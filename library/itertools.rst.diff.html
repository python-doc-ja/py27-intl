<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/itertools.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -29,60 +29,62 @@</span>
 
 These tools and their built-in counterparts also work well with the high-speed
 functions in the :mod:`operator` module.  For example, the multiplication
 operator can be mapped across two vectors to form an efficient dot-product:
 ``sum(imap(operator.mul, vector1, vector2))``.
 
 
 **Infinite Iterators:**
 
 ==================  =================       =================================================               =========================================
 Iterator            Arguments               Results                                                         Example
 ==================  =================       =================================================               =========================================
<span class="gd">-:func:`count`       start                   start, start+1, start+2, ...                                    ``count(10) --&gt; 10 11 12 13 14 ...``</span>
<span class="gi">+:func:`count`       start, [step]           start, start+step, start+2*step, ...                            ``count(10) --&gt; 10 11 12 13 14 ...``</span>
 :func:`cycle`       p                       p0, p1, ... plast, p0, p1, ...                                  ``cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D ...``
 :func:`repeat`      elem [,n]               elem, elem, elem, ... endlessly or up to n times                ``repeat(10, 3) --&gt; 10 10 10``
 ==================  =================       =================================================               =========================================
 
 **Iterators terminating on the shortest input sequence:**
 
 ====================    ============================    =================================================   =============================================================
 Iterator                Arguments                       Results                                             Example
 ====================    ============================    =================================================   =============================================================
 :func:`chain`           p, q, ...                       p0, p1, ... plast, q0, q1, ...                      ``chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F``
<span class="gi">+:func:`compress`        data, selectors                 (d[0] if s[0]), (d[1] if s[1]), ...                 ``compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F``</span>
 :func:`dropwhile`       pred, seq                       seq[n], seq[n+1], starting when pred fails          ``dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1``
 :func:`groupby`         iterable[, keyfunc]             sub-iterators grouped by value of keyfunc(v)
 :func:`ifilter`         pred, seq                       elements of seq where pred(elem) is True            ``ifilter(lambda x: x%2, range(10)) --&gt; 1 3 5 7 9``
 :func:`ifilterfalse`    pred, seq                       elements of seq where pred(elem) is False           ``ifilterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8``
 :func:`islice`          seq, [start,] stop [, step]     elements from seq[start:stop:step]                  ``islice(&#39;ABCDEFG&#39;, 2, None) --&gt; C D E F G``
 :func:`imap`            func, p, q, ...                 func(p0, q0), func(p1, q1), ...                     ``imap(pow, (2,3,10), (5,2,3)) --&gt; 32 9 1000``
 :func:`starmap`         func, seq                       func(\*seq[0]), func(\*seq[1]), ...                 ``starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000``
 :func:`tee`             it, n                           it1, it2 , ... itn  splits one iterator into n
 :func:`takewhile`       pred, seq                       seq[0], seq[1], until pred fails                    ``takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4``
 :func:`izip`            p, q, ...                       (p[0], q[0]), (p[1], q[1]), ...                     ``izip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By``
 :func:`izip_longest`    p, q, ...                       (p[0], q[0]), (p[1], q[1]), ...                     ``izip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&gt; Ax By C- D-``
 ====================    ============================    =================================================   =============================================================
 
 **Combinatoric generators:**
 
 ==============================================   ====================       =============================================================
 Iterator                                         Arguments                  Results
 ==============================================   ====================       =============================================================
 :func:`product`                                  p, q, ... [repeat=1]       cartesian product, equivalent to a nested for-loop
 :func:`permutations`                             p[, r]                     r-length tuples, all possible orderings, no repeated elements
 :func:`combinations`                             p, r                       r-length tuples, in sorted order, no repeated elements
<span class="gd">-|</span>
<span class="gi">+:func:`combinations_with_replacement`            p, r                       r-length tuples, in sorted order, with repeated elements</span>
 ``product(&#39;ABCD&#39;, repeat=2)``                                               ``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``
 ``permutations(&#39;ABCD&#39;, 2)``                                                 ``AB AC AD BA BC BD CA CB CD DA DB DC``
 ``combinations(&#39;ABCD&#39;, 2)``                                                 ``AB AC AD BC BD CD``
<span class="gi">+``combinations_with_replacement(&#39;ABCD&#39;, 2)``                                ``AA AB AC AD BB BC BD CC CD DD``</span>
 ==============================================   ====================       =============================================================
 
 
 .. _itertools-functions:
 
 Itertool functions
 ------------------
 
 The following module functions all construct and return iterators. Some provide
 streams of infinite length, so they should only be accessed by functions or
 loops that truncate the stream.
 
<span class="gu">@@ -157,37 +159,105 @@</span>
         def combinations(iterable, r):
             pool = tuple(iterable)
             n = len(pool)
             for indices in permutations(range(n), r):
                 if sorted(indices) == list(indices):
                     yield tuple(pool[i] for i in indices)
 
    The number of items returned is ``n! / r! / (n-r)!`` when ``0 &lt;= r &lt;= n``
    or zero when ``r &gt; n``.
 
    .. versionadded:: 2.6
 
<span class="gd">-.. function:: count([n])</span>
<span class="gi">+.. function:: combinations_with_replacement(iterable, r)</span>
 
<span class="gd">-   Make an iterator that returns consecutive integers starting with *n*. If not</span>
<span class="gd">-   specified *n* defaults to zero.   Often used as an argument to :func:`imap` to</span>
<span class="gd">-   generate consecutive data points. Also, used with :func:`izip` to add sequence</span>
<span class="gd">-   numbers.  Equivalent to::</span>
<span class="gi">+   Return *r* length subsequences of elements from the input *iterable*</span>
<span class="gi">+   allowing individual elements to be repeated more than once.</span>
 
<span class="gd">-      def count(n=0):</span>
<span class="gi">+   Combinations are emitted in lexicographic sort order.  So, if the</span>
<span class="gi">+   input *iterable* is sorted, the combination tuples will be produced</span>
<span class="gi">+   in sorted order.</span>
<span class="gi">+</span>
<span class="gi">+   Elements are treated as unique based on their position, not on their</span>
<span class="gi">+   value.  So if the input elements are unique, the generated combinations</span>
<span class="gi">+   will also be unique.</span>
<span class="gi">+</span>
<span class="gi">+   Equivalent to::</span>
<span class="gi">+</span>
<span class="gi">+        def combinations_with_replacement(iterable, r):</span>
<span class="gi">+            # combinations_with_replacement(&#39;ABC&#39;, 2) --&gt; AA AB AC BB BC CC</span>
<span class="gi">+            pool = tuple(iterable)</span>
<span class="gi">+            n = len(pool)</span>
<span class="gi">+            if not n and r:</span>
<span class="gi">+                return</span>
<span class="gi">+            indices = [0] * r</span>
<span class="gi">+            yield tuple(pool[i] for i in indices)</span>
<span class="gi">+            while True:</span>
<span class="gi">+                for i in reversed(range(r)):</span>
<span class="gi">+                    if indices[i] != n - 1:</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return</span>
<span class="gi">+                indices[i:] = [indices[i] + 1] * (r - i)</span>
<span class="gi">+                yield tuple(pool[i] for i in indices)</span>
<span class="gi">+</span>
<span class="gi">+   The code for :func:`combinations_with_replacement` can be also expressed as</span>
<span class="gi">+   a subsequence of :func:`product` after filtering entries where the elements</span>
<span class="gi">+   are not in sorted order (according to their position in the input pool)::</span>
<span class="gi">+</span>
<span class="gi">+        def combinations_with_replacement(iterable, r):</span>
<span class="gi">+            pool = tuple(iterable)</span>
<span class="gi">+            n = len(pool)</span>
<span class="gi">+            for indices in product(range(n), repeat=r):</span>
<span class="gi">+                if sorted(indices) == list(indices):</span>
<span class="gi">+                    yield tuple(pool[i] for i in indices)</span>
<span class="gi">+</span>
<span class="gi">+   The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n &gt; 0``.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+</span>
<span class="gi">+.. function:: compress(data, selectors)</span>
<span class="gi">+</span>
<span class="gi">+   Make an iterator that filters elements from *data* returning only those that</span>
<span class="gi">+   have a corresponding element in *selectors* that evaluates to ``True``.</span>
<span class="gi">+   Stops when either the *data* or *selectors* iterables has been exhausted.</span>
<span class="gi">+   Equivalent to::</span>
<span class="gi">+</span>
<span class="gi">+       def compress(data, selectors):</span>
<span class="gi">+           # compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F</span>
<span class="gi">+           return (d for d, s in izip(data, selectors) if s)</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. function:: count(start=0, step=1)</span>
<span class="gi">+</span>
<span class="gi">+   Make an iterator that returns evenly spaced values starting with *n*. Often</span>
<span class="gi">+   used as an argument to :func:`imap` to generate consecutive data points.</span>
<span class="gi">+   Also, used with :func:`izip` to add sequence numbers.  Equivalent to::</span>
<span class="gi">+</span>
<span class="gi">+      def count(start=0, step=1):</span>
           # count(10) --&gt; 10 11 12 13 14 ...
<span class="gi">+          # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span>
<span class="gi">+          n = start</span>
           while True:
               yield n
<span class="gd">-              n += 1</span>
<span class="gi">+              n += step</span>
 
<span class="gi">+   When counting with floating point numbers, better accuracy can sometimes be</span>
<span class="gi">+   achieved by substituting multiplicative code such as: ``(start + step * i</span>
<span class="gi">+   for i in count())``.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      added *step* argument and allowed non-integer arguments.</span>
 
 .. function:: cycle(iterable)
 
    Make an iterator returning elements from the iterable and saving a copy of each.
    When the iterable is exhausted, return elements from the saved copy.  Repeats
    indefinitely.  Equivalent to::
 
       def cycle(iterable):
           # cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D A B C D ...
           saved = []
           for element in iterable:
               yield element
<span class="gu">@@ -564,61 +634,24 @@</span>
    Once :func:`tee` has made a split, the original *iterable* should not be
    used anywhere else; otherwise, the *iterable* could get advanced without
    the tee objects being informed.
 
    This itertool may require significant auxiliary storage (depending on how
    much temporary data needs to be stored). In general, if one iterator uses
    most or all of the data before another iterator starts, it is faster to use
    :func:`list` instead of :func:`tee`.
 
    .. versionadded:: 2.4
 
 
<span class="gd">-.. _itertools-example:</span>
<span class="gd">-</span>
<span class="gd">-Examples</span>
<span class="gd">---------</span>
<span class="gd">-</span>
<span class="gd">-The following examples show common uses for each tool and demonstrate ways they</span>
<span class="gd">-can be combined.</span>
<span class="gd">-</span>
<span class="gd">-.. doctest::</span>
<span class="gd">-</span>
<span class="gd">-   &gt;&gt;&gt; # Show a dictionary sorted and grouped by value</span>
<span class="gd">-   &gt;&gt;&gt; from operator import itemgetter</span>
<span class="gd">-   &gt;&gt;&gt; d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)</span>
<span class="gd">-   &gt;&gt;&gt; di = sorted(d.iteritems(), key=itemgetter(1))</span>
<span class="gd">-   &gt;&gt;&gt; for k, g in groupby(di, key=itemgetter(1)):</span>
<span class="gd">-   ...     print k, map(itemgetter(0), g)</span>
<span class="gd">-   ...</span>
<span class="gd">-   1 [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;]</span>
<span class="gd">-   2 [&#39;b&#39;, &#39;d&#39;, &#39;f&#39;]</span>
<span class="gd">-   3 [&#39;g&#39;]</span>
<span class="gd">-</span>
<span class="gd">-   &gt;&gt;&gt; # Find runs of consecutive numbers using groupby.  The key to the solution</span>
<span class="gd">-   &gt;&gt;&gt; # is differencing with a range so that consecutive numbers all appear in</span>
<span class="gd">-   &gt;&gt;&gt; # same group.</span>
<span class="gd">-   &gt;&gt;&gt; data = [ 1,  4,5,6, 10, 15,16,17,18, 22, 25,26,27,28]</span>
<span class="gd">-   &gt;&gt;&gt; for k, g in groupby(enumerate(data), lambda (i,x):i-x):</span>
<span class="gd">-   ...     print map(itemgetter(1), g)</span>
<span class="gd">-   ...</span>
<span class="gd">-   [1]</span>
<span class="gd">-   [4, 5, 6]</span>
<span class="gd">-   [10]</span>
<span class="gd">-   [15, 16, 17, 18]</span>
<span class="gd">-   [22]</span>
<span class="gd">-   [25, 26, 27, 28]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-</span>
 .. _itertools-recipes:
 
 Recipes
 -------
 
 This section shows recipes for creating an extended toolset using the existing
 itertools as building blocks.
 
 The extended tools offer the same high performance as the underlying toolset.
 The superior memory performance is kept by processing elements one at a time
 rather than bringing the whole iterable into memory all at once. Code volume is
 kept small by linking the tools together in a functional style which helps
<span class="gu">@@ -629,30 +662,30 @@</span>
 .. testcode::
 
    def take(n, iterable):
        &quot;Return first n items of the iterable as a list&quot;
        return list(islice(iterable, n))
 
    def tabulate(function, start=0):
        &quot;Return function(0), function(1), ...&quot;
        return imap(function, count(start))
 
    def consume(iterator, n):
        &quot;Advance the iterator n-steps ahead. If n is none, consume entirely.&quot;
<span class="gd">-       # The technique uses objects that consume iterators at C speed.</span>
<span class="gi">+       # Use functions that consume iterators at C speed.</span>
        if n is None:
            # feed the entire iterator into a zero-length deque
            collections.deque(iterator, maxlen=0)
        else:
<span class="gd">-           # advance to the emtpy slice starting at position n</span>
<span class="gi">+           # advance to the empty slice starting at position n</span>
            next(islice(iterator, n, n), None)
 
    def nth(iterable, n, default=None):
        &quot;Returns the nth item or a default value&quot;
        return next(islice(iterable, n, None), default)
 
    def quantify(iterable, pred=bool):
        &quot;Count how many times the predicate is true&quot;
        return sum(imap(pred, iterable))
 
    def padnone(iterable):
        &quot;&quot;&quot;Returns the sequence elements and then returns None indefinitely.
<span class="gu">@@ -696,46 +729,24 @@</span>
        &quot;roundrobin(&#39;ABC&#39;, &#39;D&#39;, &#39;EF&#39;) --&gt; A D E B F C&quot;
        # Recipe credited to George Sakkis
        pending = len(iterables)
        nexts = cycle(iter(it).next for it in iterables)
        while pending:
            try:
                for next in nexts:
                    yield next()
            except StopIteration:
                pending -= 1
                nexts = cycle(islice(nexts, pending))
 
<span class="gd">-   def compress(data, selectors):</span>
<span class="gd">-       &quot;compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F&quot;</span>
<span class="gd">-       return (d for d, s in izip(data, selectors) if s)</span>
<span class="gd">-</span>
<span class="gd">-   def combinations_with_replacement(iterable, r):</span>
<span class="gd">-       &quot;combinations_with_replacement(&#39;ABC&#39;, 2) --&gt; AA AB AC BB BC CC&quot;</span>
<span class="gd">-       # number items returned:  (n+r-1)! / r! / (n-1)!</span>
<span class="gd">-       pool = tuple(iterable)</span>
<span class="gd">-       n = len(pool)</span>
<span class="gd">-       if not n and r:</span>
<span class="gd">-           return</span>
<span class="gd">-       indices = [0] * r</span>
<span class="gd">-       yield tuple(pool[i] for i in indices)</span>
<span class="gd">-       while True:</span>
<span class="gd">-           for i in reversed(range(r)):</span>
<span class="gd">-               if indices[i] != n - 1:</span>
<span class="gd">-                   break</span>
<span class="gd">-           else:</span>
<span class="gd">-               return</span>
<span class="gd">-           indices[i:] = [indices[i] + 1] * (r - i)</span>
<span class="gd">-           yield tuple(pool[i] for i in indices)</span>
<span class="gd">-</span>
    def powerset(iterable):
        &quot;powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)&quot;
        s = list(iterable)
        return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
 
    def unique_everseen(iterable, key=None):
        &quot;List unique elements, preserving order. Remember all elements ever seen.&quot;
        # unique_everseen(&#39;AAAABBBCCDAABBB&#39;) --&gt; A B C D
        # unique_everseen(&#39;ABBCcAD&#39;, str.lower) --&gt; A B C D
        seen = set()
        seen_add = seen.add
        if key is None:
</pre></div>

</body>
</html>
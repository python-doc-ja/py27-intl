@@ -131,24 +131,49 @@
 .. function:: get_referents(*objs)
 
    Return a list of objects directly referred to by any of the arguments. The
    referents returned are those objects visited by the arguments' C-level
    :attr:`tp_traverse` methods (if any), and may not be all objects actually
    directly reachable.  :attr:`tp_traverse` methods are supported only by objects
    that support garbage collection, and are only required to visit objects that may
    be involved in a cycle.  So, for example, if an integer is directly reachable
    from an argument, that integer object may or may not appear in the result list.
 
    .. versionadded:: 2.3
 
+.. function:: is_tracked(obj)
+
+   Returns True if the object is currently tracked by the garbage collector,
+   False otherwise.  As a general rule, instances of atomic types aren't
+   tracked and instances of non-atomic types (containers, user-defined
+   objects...) are.  However, some type-specific optimizations can be present
+   in order to suppress the garbage collector footprint of simple instances
+   (e.g. dicts containing only atomic keys and values)::
+
+      >>> gc.is_tracked(0)
+      False
+      >>> gc.is_tracked("a")
+      False
+      >>> gc.is_tracked([])
+      True
+      >>> gc.is_tracked({})
+      False
+      >>> gc.is_tracked({"a": 1})
+      False
+      >>> gc.is_tracked({"a": []})
+      True
+
+   .. versionadded:: 2.7
+
+
 The following variable is provided for read-only access (you can mutate its
 value but should not rebind it):
 
 
 .. data:: garbage
 
    A list of objects which the collector found to be unreachable but could not be
    freed (uncollectable objects).  By default, this list contains only objects with
    :meth:`__del__` methods. [#]_ Objects that have :meth:`__del__` methods and are
    part of a reference cycle cause the entire reference cycle to be uncollectable,
    including objects not necessarily in the cycle but reachable only from it.
    Python doesn't collect such cycles automatically because, in general, it isn't

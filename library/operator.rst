
:mod:`operator` --- 関数形式の標準演算子
========================================

.. module:: operator
.. sectionauthor:: Skip Montanaro <skip@automatrix.com>




:mod:`operator` モジュールは、Python 固有の各演算子に対応している C 言語で実装された関数セットを提供します。例えば、
``operator.add(x, y)`` は式 ``x+y`` と等価です。関数名は 特殊なクラスメソッドとして扱われます; 便宜上、先頭と末尾の
``__``  を取り除いたものも提供されています。

これらの関数はそれぞれ、オブジェクトの比較、論理演算、数学演算、 シーケンス操作、および抽象型テストに分類されます。

オブジェクト比較関数は全てのオブジェクトで有効で、関数の名前は サポートする大小比較演算子からとられています:


.. function:: lt(a, b)
              le(a, b)
              eq(a, b)
              ne(a, b)
              ge(a, b)
              gt(a, b)
              __lt__(a, b)
              __le__(a, b)
              __eq__(a, b)
              __ne__(a, b)
              __ge__(a, b)
              __gt__(a, b)

   これらは  *a* および *b* の大小比較を行います。 特に、 ``lt(a, b)`` は ``a < b``、 ``le(a, b)`` は ``a
   <= b``、 ``eq(a, b)`` は ``a == b``、 ``ne(a, b)`` は ``a != b``、 ``gt(a, b)`` は ``a
   > b``、 そして ``ge(a, b)`` は ``a >= b`` と等価です。

   組み込み関数 :func:`cmp` と違って、これらの関数はどのような 値を返してもよく、ブール代数値として解釈できてもできなくても
   かまいません。大小比較の詳細については Python リファレンスマニュアル (XXX reference: ../ref/ref.html)
   を参照してください。

   .. versionadded:: 2.2

論理演算もまた全てのオブジェクトに対して適用することができ、 真値テスト、同一性テストおよびブール演算をサポートします:


.. function:: not_(o)
              __not__(o)

   :keyword:`not` *o* の結果を返します。(オブジェクトのインスタンス には :meth:`__not__`
   メソッドは適用されないので注意してください; この操作を定義しているのはインタプリタコアだけです。結果は :meth:`__nonzero__` および
   :meth:`__len__` メソッドによって 影響されます。)


.. function:: truth(o)

   *o* が真の場合 ``True`` を返し、そうでない場合 ``False``
   を返します。この関数は:class:`bool`のコンストラクタ呼び出しと同等です。


.. function:: is_(a, b)

   ``a is b`` を返します。オブジェクトの同一性をテストします。


.. function:: is_not(a, b)

   ``a is not b`` を返します。オブジェクトの同一性をテストします。

演算子で最も多いのは数学演算およびビット単位の演算です:


.. function:: abs(o)
              __abs__(o)

   *o* の絶対値を返します。


.. function:: add(a, b)
              __add__(a, b)

   数値 *a* および *b* について *a* ``+`` *b* を 返します。


.. function:: and_(a, b)
              __and__(a, b)

   *a* と *b* の論理積を返します。


.. function:: div(a, b)
              __div__(a, b)

   ``__future__.division`` が有効でない場合には *a* ``/`` *b* を返します。"古い(classic)"
   除算としても知られています。


.. function:: floordiv(a, b)
              __floordiv__(a, b)

   *a* ``//`` *b* を返します。

   .. versionadded:: 2.2


.. function:: inv(o)
              invert(o)
              __inv__(o)
              __invert__(o)

   *o* のビット単位反転を返します。``~``*o* と 同じです。Python 2.0 では名前 :func:`invert` および
   :func:`__invert__` が追加されました。


.. function:: lshift(a, b)
              __lshift__(a, b)

   *a* の *b* ビット左シフトを返します。


.. function:: mod(a, b)
              __mod__(a, b)

   *a* ``%`` *b* を返します。


.. function:: mul(a, b)
              __mul__(a, b)

   数値 *a* および *b* について *a* ``*`` *b* を返します。


.. function:: neg(o)
              __neg__(o)

   *o* の符号反転を返します。


.. function:: or_(a, b)
              __or__(a, b)

   *a* と *b* の論理和を返します。


.. function:: pos(o)
              __pos__(o)

   *o* の符号非反転を返します。


.. function:: pow(a, b)
              __pow__(a, b)

   数値 *a* および *b* について *a* ``**`` *b* を返します。

   .. versionadded:: 2.3


.. function:: rshift(a, b)
              __rshift__(a, b)

   *a* の *b* ビット右シフトを返します。


.. function:: sub(a, b)
              __sub__(a, b)

   *a* ``-`` *b* を返します。


.. function:: truediv(a, b)
              __truediv__(a, b)

   ``__future__.division`` が有効な場合 *a* ``/`` *b*  を返します。"真の"除算としても知られています。

   .. versionadded:: 2.2


.. function:: xor(a, b)
              __xor__(a, b)

   *a* および *b* の排他的論理和を返します。


.. function:: index(a)
              __index__(a)

   整数に変換された *a* を返します。 *a*``.__index__()`` と同等です。

   .. versionadded:: 2.5

シーケンスを扱う演算子には以下のようなものがあります:


.. function:: concat(a, b)
              __concat__(a, b)

   シーケンス *a* および *b* について *a* ``+`` *b*  を返します。


.. function:: contains(a, b)
              __contains__(a, b)

   *b* ``in`` *a* を調べた結果を返します。 演算対象が左右反転しているので注意してください。関数名 :func:`__contains__` は
   Python 2.0 で追加されました。


.. function:: countOf(a, b)

   *a* の中に *b* が出現する回数を返します。


.. function:: delitem(a, b)
              __delitem__(a, b)

   *a* でインデクスが *b* の要素を削除します。


.. function:: delslice(a, b, c)
              __delslice__(a, b, c)

   *a* でインデクスが *b* から *c*``-1`` のスライス要素を 削除します。


.. function:: getitem(a, b)
              __getitem__(a, b)

   *a* でインデクスが *b* の要素を返します。


.. function:: getslice(a, b, c)
              __getslice__(a, b, c)

   *a* でインデクスが *b* から *c*``-1`` のスライス要素を 返します。


.. function:: indexOf(a, b)

   *a* で最初に *b* が出現する場所のインデクスを返します。


.. function:: repeat(a, b)
              __repeat__(a, b)

   シーケンス *a* と整数 *b* について *a* ``*`` *b* を返します。


.. function:: sequenceIncludes(...)

   .. deprecated:: 2.0
      :func:`contains` を使ってください。

   :func:`contains` の別名です。


.. function:: setitem(a, b, c)
              __setitem__(a, b, c)

   *a* でインデクスが *b* の要素の値を *c* に設定します。


.. function:: setslice(a, b, c, v)
              __setslice__(a, b, c, v)

   *a* でインデクスが *b* から *c*``-1`` のスライス要素の 値をシーケンス *v* に設定します。

多くの演算に「その場」バージョンがあります。 以下の関数はそうした演算子の通常の文法に比べてより素朴な呼び出し方を提供します。 たとえば、文 ``x +=
y`` は ``x = operator.iadd(x, y)`` と等価です。 別の言い方をすると、``z = operator.iadd(x, y)``
は複合文 ``z = x; z += y`` と等価です。


.. function:: iadd(a, b)
              __iadd__(a, b)

   ``a = iadd(a, b)`` は ``a += b`` と等価です。

   .. versionadded:: 2.5


.. function:: iand(a, b)
              __iand__(a, b)

   ``a = iand(a, b)`` は ``a &= b`` と等価です。

   .. versionadded:: 2.5


.. function:: iconcat(a, b)
              __iconcat__(a, b)

   ``a = iconcat(a, b)`` は二つのシーケンス *a* と *b* に対し ``a += b`` と等価です。

   .. versionadded:: 2.5


.. function:: idiv(a, b)
              __idiv__(a, b)

   ``a = idiv(a, b)`` は ``__future__.division`` が有効でないときに ``a /= b`` と等価です。

   .. versionadded:: 2.5


.. function:: ifloordiv(a, b)
              __ifloordiv__(a, b)

   ``a = ifloordiv(a, b)`` は ``a //= b`` と等価です。

   .. versionadded:: 2.5


.. function:: ilshift(a, b)
              __ilshift__(a, b)

   ``a = ilshift(a, b)`` は ``a <``\ ``<= b`` と等価です。

   .. versionadded:: 2.5


.. function:: imod(a, b)
              __imod__(a, b)

   ``a = imod(a, b)`` は ``a %= b`` と等価です。

   .. versionadded:: 2.5


.. function:: imul(a, b)
              __imul__(a, b)

   ``a = imul(a, b)`` は ``a *= b`` と等価です。

   .. versionadded:: 2.5


.. function:: ior(a, b)
              __ior__(a, b)

   ``a = ior(a, b)`` は ``a |= b`` と等価です。

   .. versionadded:: 2.5


.. function:: ipow(a, b)
              __ipow__(a, b)

   ``a = ipow(a, b)`` は ``a **= b`` と等価です。

   .. versionadded:: 2.5


.. function:: irepeat(a, b)
              __irepeat__(a, b)

   ``a = irepeat(a, b)`` は *a* がシーケンスで *b* が整数であるとき ``a *= b`` と等価です。

   .. versionadded:: 2.5


.. function:: irshift(a, b)
              __irshift__(a, b)

   ``a = irshift(a, b)`` は ``a >>= b`` と等価です。

   .. versionadded:: 2.5


.. function:: isub(a, b)
              __isub__(a, b)

   ``a = isub(a, b)`` は ``a -= b`` と等価です。

   .. versionadded:: 2.5


.. function:: itruediv(a, b)
              __itruediv__(a, b)

   ``a = itruediv(a, b)`` は ``__future__.division`` が有効なときに ``a /= b`` と等価です。

   .. versionadded:: 2.5


.. function:: ixor(a, b)
              __ixor__(a, b)

   ``a = ixor(a, b)`` は ``a ^= b`` と等価です。

   .. versionadded:: 2.5

:mod:`operator` モジュールでは、オブジェクトの型を調べるための 述語演算子も定義しています。

.. note::

   これらの関数が返す結果について 誤って理解しないよう注意してください; インスタンスオブジェクトに 対して常に信頼できる値を返すのは
   :func:`isCallable`

だけです。例えば以下のようになります::

   >>> class C:
   ...     pass
   ... 
   >>> import operator
   >>> o = C()
   >>> operator.isMappingType(o)
   True


.. function:: isCallable(o)

   .. deprecated:: 2.0
      :func:`callable` を使ってください。

   オブジェクト *o* を関数のように呼び出すことができる場合真を 返し、それ以外の場合 false を返します。関数、バインドおよび非バインド
   メソッド、クラスオブジェクト、および :meth:`__call__` メソッド をサポートするインスタンスオブジェクトは真を返します。


.. function:: isMappingType(o)

   オブジェクト *o* がマップ型インタフェースをサポートする場合に真を返します。 辞書および :meth:`__getitem__`
   メソッドが定義された全てのインスタンスオブジェクトに対しては、この値は真になります。

   .. warning::

      インタフェース自体が誤った定義になっているため、 あるインスタンスが完全なマップ型プロトコルを備えているかを調べる信頼性のある方法は
      存在しません。このため、この関数によるテストはさほど便利ではありません。


.. function:: isNumberType(o)

   オブジェクト *o* が数値を表現している場合に真を返します。 C で実装された全ての数値型対して、この値は真になります。

   .. warning::

      インタフェース自体が誤った定義になっているため、 あるインスタンスが完全な数値型のインタフェースをサポートしているかを調べる信頼性のある方法は存在
      しません。このため、この関数によるテストはさほど便利ではありません。

      .. % 


.. function:: isSequenceType(o)

   *o* がシーケンス型プロトコルをサポートする場合に真を返します。 シーケンス型メソッドを C で定義している全てのオブジェクトおよび
   :meth:`__getitem__` メソッドが定義された全てのインスタンスオブジェクト に対して、この値は真になります。

   .. warning::

      インタフェース自体が誤った定義になっているため、 あるインスタンスが完全なシーケンス型のインタフェースをサポートしているかを調べる信頼性のある方法は存在
      しません。このため、この関数によるテストはさほど便利ではありません。

      .. % 

例: ``0`` から ``255`` までの序数を文字に対応付ける 辞書を構築します。 ::

   >>> import operator
   >>> d = {}
   >>> keys = range(256)
   >>> vals = map(chr, keys)
   >>> map(operator.setitem, [d]*len(keys), keys, vals)

:mod:`operator` モジュールはアトリビュートとアイテムの汎用的な検索 のための道具も定義しています。 :func:`map`,
:func:`sorted`, :meth:`itertools.groupby`,  や関数を引数に取るその他の関数に対して高速にフィールドを抽出する際に
引数として使うと便利です。


.. function:: attrgetter(attr[, args...])

   演算対象から *attr* を取得する呼び出し可能なオブジェクトを返します。 二つ以上のアトリビュートを要求された場合には、アトリビュートのタプルを返します。
   ``f=attrgetter('name')`` とした後で、``f(b)`` を呼び出すと ``b.name`` を返します。
   ``f=attrgetter('name', 'date')`` とした後で、 ``f(b)`` を呼び出すと ``(b.name, b.date)``
   を返します。

   .. versionadded:: 2.4

   .. versionchanged:: 2.5
      複数のアトリビュートがサポートされました.


.. function:: itemgetter(item[, args...])

   演算対象から *item* を取得する呼び出し可能なオブジェクトを返します。 二つ以上のアイテムを要求された場合には、アイテムのタプルを返します。
   ``f=itemgetter(2)`` とした後で、 ``f(b)`` を呼び出すと ``b[2]`` を返します。
   ``f=itemgetter(2,5,3)`` とした後で、 ``f(b)`` を呼び出すと ``(b[2], b[5], b[3])`` を返します。

   .. versionadded:: 2.4

   .. versionchanged:: 2.5
      複数のアトリビュートがサポートされました.

例::

   >>> from operator import itemgetter
   >>> inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)]
   >>> getcount = itemgetter(1)
   >>> map(getcount, inventory)
   [3, 2, 5, 1]
   >>> sorted(inventory, key=getcount)
   [('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)]


.. _operator-map:

演算子から関数への対応表
------------------------

下のテーブルでは、個々の抽象的な操作が、どのように Python 構文上の 各演算子や :mod:`operator` モジュールの関数に対応しているか
を示しています。

+----------------------+-------------------------+----------------------------------------+
| 操作                 | 構文                    | 関数                                   |
+======================+=========================+========================================+
| 加算                 | ``a + b``               | ``add(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| 結合                 | ``seq1 + seq2``         | ``concat(seq1, seq2)``                 |
+----------------------+-------------------------+----------------------------------------+
| 包含テスト           | ``o in seq``            | ``contains(seq, o)``                   |
+----------------------+-------------------------+----------------------------------------+
| 除算                 | ``a / b``               | ``__future__.division`` が無効な場合の |
|                      |                         | ``div(a, b) #``                        |
+----------------------+-------------------------+----------------------------------------+
| 除算                 | ``a / b``               | ``__future__.division`` が有効な場合の |
|                      |                         | ``truediv(a, b) #``                    |
+----------------------+-------------------------+----------------------------------------+
| 除算                 | ``a // b``              | ``floordiv(a, b)``                     |
+----------------------+-------------------------+----------------------------------------+
| 論理積               | ``a & b``               | ``and_(a, b)``                         |
+----------------------+-------------------------+----------------------------------------+
| 排他的論理和         | ``a ^ b``               | ``xor(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| ビット反転           | ``~ a``                 | ``invert(a)``                          |
+----------------------+-------------------------+----------------------------------------+
| 論理和               | ``a | b``               | ``or_(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| べき乗               | ``a ** b``              | ``pow(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| インデクス指定の代入 | ``o[k] = v``            | ``setitem(o, k, v)``                   |
+----------------------+-------------------------+----------------------------------------+
| インデクス指定の削除 | ``del o[k]``            | ``delitem(o, k)``                      |
+----------------------+-------------------------+----------------------------------------+
| インデクス指定       | ``o[k]``                | ``getitem(o, k)``                      |
+----------------------+-------------------------+----------------------------------------+
| 左シフト             | ``a << b``              | ``lshift(a, b)``                       |
+----------------------+-------------------------+----------------------------------------+
| 剰余                 | ``a % b``               | ``mod(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| 乗算                 | ``a * b``               | ``mul(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| (算術)否             | ``- a``                 | ``neg(a)``                             |
+----------------------+-------------------------+----------------------------------------+
| (論理)否             | ``not a``               | ``not_(a)``                            |
+----------------------+-------------------------+----------------------------------------+
| 右シフト             | ``a >> b``              | ``rshift(a, b)``                       |
+----------------------+-------------------------+----------------------------------------+
| シーケンスの反復     | ``seq * i``             | ``repeat(seq, i)``                     |
+----------------------+-------------------------+----------------------------------------+
| スライス指定の代入   | ``seq[i:j]`` = *values* | ``setslice(seq, i, j, values)``        |
+----------------------+-------------------------+----------------------------------------+
| スライス指定の削除   | ``del seq[i:j]``        | ``delslice(seq, i, j)``                |
+----------------------+-------------------------+----------------------------------------+
| スライス指定         | ``seq[i:j]``            | ``getslice(seq, i, j)``                |
+----------------------+-------------------------+----------------------------------------+
| 文字列書式化         | ``s % o``               | ``mod(s, o)``                          |
+----------------------+-------------------------+----------------------------------------+
| 減算                 | ``a - b``               | ``sub(a, b)``                          |
+----------------------+-------------------------+----------------------------------------+
| 真値テスト           | ``o``                   | ``truth(o)``                           |
+----------------------+-------------------------+----------------------------------------+
| 順序付け             | ``a < b``               | ``lt(a, b)``                           |
+----------------------+-------------------------+----------------------------------------+
| 順序付け             | ``a <= b``              | ``le(a, b)``                           |
+----------------------+-------------------------+----------------------------------------+
| 等価性               | ``a == b``              | ``eq(a, b)``                           |
+----------------------+-------------------------+----------------------------------------+
| 不等性               | ``a != b``              | ``ne(a, b)``                           |
+----------------------+-------------------------+----------------------------------------+
| 順序付け             | ``a >= b``              | ``ge(a, b)``                           |
+----------------------+-------------------------+----------------------------------------+
| 順序付け             | ``a > b``               | ``gt(a, b)``                           |
+----------------------+-------------------------+----------------------------------------+


@@ -23,36 +23,46 @@
 
 This module defines the class :class:`ConfigParser`.   The :class:`ConfigParser`
 class implements a basic configuration file parser language which provides a
 structure similar to what you would find on Microsoft Windows INI files.  You
 can use this to write Python programs which can be customized by end users
 easily.
 
 .. note::
 
    This library does *not* interpret or write the value-type prefixes used in
    the Windows Registry extended version of INI syntax.
 
+.. seealso::
+
+   Module :mod:`shlex`
+      Support for a creating Unix shell-like mini-languages which can be used
+      as an alternate format for application configuration files.
+
+   Module :mod:`json`
+      The json module implements a subset of JavaScript syntax which can also
+      be used for this purpose.
+
 The configuration file consists of sections, led by a ``[section]`` header and
 followed by ``name: value`` entries, with continuations in the style of
 :rfc:`822` (see section 3.1.1, "LONG HEADER FIELDS"); ``name=value`` is also
 accepted.  Note that leading whitespace is removed from values. The optional
 values can contain format strings which refer to other values in the same
 section, or values in a special ``DEFAULT`` section.  Additional defaults can be
 provided on initialization and retrieval.  Lines beginning with ``'#'`` or
 ``';'`` are ignored and may be used to provide comments.
 
 Configuration files may include comments, prefixed by specific characters (``#``
 and ``;``).  Comments may appear on their own in an otherwise empty line, or may
-be entered in lines holding values or spection names.  In the latter case, they
+be entered in lines holding values or section names.  In the latter case, they
 need to be preceded by a whitespace character to be recognized as a comment.
 (For backwards compatibility, only ``;`` starts an inline comment, while ``#``
 does not.)
 
 On top of the core functionality, :class:`SafeConfigParser` supports
 interpolation.  This means values can contain format strings which refer to
 other values in the same section, or values in a special ``DEFAULT`` section.
 Additional defaults can be provided on initialization.
 
 For example::
 
    [My Section]
@@ -65,65 +75,91 @@
 All reference expansions are done on demand.
 
 Default values can be specified by passing them into the :class:`ConfigParser`
 constructor as a dictionary.  Additional defaults  may be passed into the
 :meth:`get` method which will override all others.
 
 Sections are normally stored in a built-in dictionary. An alternative dictionary
 type can be passed to the :class:`ConfigParser` constructor. For example, if a
 dictionary type is passed that sorts its keys, the sections will be sorted on
 write-back, as will be the keys within each section.
 
 
-.. class:: RawConfigParser([defaults[, dict_type]])
+.. class:: RawConfigParser([defaults[, dict_type[, allow_no_value]]])
 
    The basic configuration object.  When *defaults* is given, it is initialized
    into the dictionary of intrinsic defaults.  When *dict_type* is given, it will
    be used to create the dictionary objects for the list of sections, for the
-   options within a section, and for the default values. This class does not
+   options within a section, and for the default values.  When *allow_no_value*
+   is true (default: ``False``), options without values are accepted; the value
+   presented for these is ``None``.
+
+   This class does not
    support the magical interpolation behavior.
 
+   All option names are passed through the :meth:`optionxform` method.  Its
+   default implementation converts option names to lower case.
+
    .. versionadded:: 2.3
 
    .. versionchanged:: 2.6
       *dict_type* was added.
 
+   .. versionchanged:: 2.7
+      The default *dict_type* is :class:`collections.OrderedDict`.
+      *allow_no_value* was added.
 
-.. class:: ConfigParser([defaults[, dict_type]])
+
+.. class:: ConfigParser([defaults[, dict_type[, allow_no_value]]])
 
    Derived class of :class:`RawConfigParser` that implements the magical
    interpolation feature and adds optional arguments to the :meth:`get` and
    :meth:`items` methods.  The values in *defaults* must be appropriate for the
    ``%()s`` string interpolation.  Note that *__name__* is an intrinsic default;
    its value is the section name, and will override any value provided in
    *defaults*.
 
    All option names used in interpolation will be passed through the
-   :meth:`optionxform` method just like any other option name reference.  For
-   example, using the default implementation of :meth:`optionxform` (which converts
-   option names to lower case), the values ``foo %(bar)s`` and ``foo %(BAR)s`` are
-   equivalent.
+   :meth:`optionxform` method just like any other option name reference.  Using
+   the default implementation of :meth:`optionxform`, the values ``foo %(bar)s``
+   and ``foo %(BAR)s`` are equivalent.
 
+   .. versionadded:: 2.3
 
-.. class:: SafeConfigParser([defaults[, dict_type]])
+   .. versionchanged:: 2.6
+      *dict_type* was added.
+
+   .. versionchanged:: 2.7
+      The default *dict_type* is :class:`collections.OrderedDict`.
+      *allow_no_value* was added.
+
+
+.. class:: SafeConfigParser([defaults[, dict_type[, allow_no_value]]])
 
    Derived class of :class:`ConfigParser` that implements a more-sane variant of
    the magical interpolation feature.  This implementation is more predictable as
    well. New applications should prefer this version if they don't need to be
    compatible with older versions of Python.
 
    .. XXX Need to explain what's safer/more predictable about it.
 
    .. versionadded:: 2.3
 
+   .. versionchanged:: 2.6
+      *dict_type* was added.
+
+   .. versionchanged:: 2.7
+      The default *dict_type* is :class:`collections.OrderedDict`.
+      *allow_no_value* was added.
+
 
 .. exception:: Error
 
    Base class for all other configparser exceptions.
 
 
 .. exception:: NoSectionError
 
    Exception raised when a specified section is not found.
 
 
 .. exception:: DuplicateSectionError
@@ -477,12 +513,47 @@
 
 The function ``opt_move`` below can be used to move options between sections::
 
    def opt_move(config, section1, section2, option):
        try:
            config.set(section2, option, config.get(section1, option, 1))
        except ConfigParser.NoSectionError:
            # Create non-existent section
            config.add_section(section2)
            opt_move(config, section1, section2, option)
        else:
            config.remove_option(section1, option)
+
+Some configuration files are known to include settings without values, but which
+otherwise conform to the syntax supported by :mod:`ConfigParser`.  The
+*allow_no_value* parameter to the constructor can be used to indicate that such
+values should be accepted:
+
+.. doctest::
+
+   >>> import ConfigParser
+   >>> import io
+
+   >>> sample_config = """
+   ... [mysqld]
+   ... user = mysql
+   ... pid-file = /var/run/mysqld/mysqld.pid
+   ... skip-external-locking
+   ... old_passwords = 1
+   ... skip-bdb
+   ... skip-innodb
+   ... """
+   >>> config = ConfigParser.RawConfigParser(allow_no_value=True)
+   >>> config.readfp(io.BytesIO(sample_config))
+
+   >>> # Settings with values are treated as before:
+   >>> config.get("mysqld", "user")
+   'mysql'
+
+   >>> # Settings without values provide None:
+   >>> config.get("mysqld", "skip-bdb")
+
+   >>> # Settings which aren't specified still raise an error:
+   >>> config.get("mysqld", "does-not-exist")
+   Traceback (most recent call last):
+     ...
+   ConfigParser.NoOptionError: No option 'does-not-exist' in section: 'mysqld'

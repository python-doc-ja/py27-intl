<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/sqlite3.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -74,25 +74,25 @@</span>
 To retrieve data after executing a SELECT statement, you can either treat the
 cursor as an :term:`iterator`, call the cursor&#39;s :meth:`~Cursor.fetchone` method to
 retrieve a single matching row, or call :meth:`~Cursor.fetchall` to get a list of the
 matching rows.
 
 This example uses the iterator form::
 
    &gt;&gt;&gt; c = conn.cursor()
    &gt;&gt;&gt; c.execute(&#39;select * from stocks order by price&#39;)
    &gt;&gt;&gt; for row in c:
    ...    print row
    ...
<span class="gd">-   (u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100, 35.140000000000001)</span>
<span class="gi">+   (u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100, 35.14)</span>
    (u&#39;2006-03-28&#39;, u&#39;BUY&#39;, u&#39;IBM&#39;, 1000, 45.0)
    (u&#39;2006-04-06&#39;, u&#39;SELL&#39;, u&#39;IBM&#39;, 500, 53.0)
    (u&#39;2006-04-05&#39;, u&#39;BUY&#39;, u&#39;MSOFT&#39;, 1000, 72.0)
    &gt;&gt;&gt;
 
 
 .. seealso::
 
    http://code.google.com/p/pysqlite/
       The pysqlite web page -- sqlite3 is developed externally under the name
       &quot;pysqlite&quot;.
 
<span class="gu">@@ -129,25 +129,25 @@</span>
    :func:`connect` function.
 
    Setting this makes the SQLite interface parse the column name for each column it
    returns.  It will look for a string formed [mytype] in there, and then decide
    that &#39;mytype&#39; is the type of the column. It will try to find an entry of
    &#39;mytype&#39; in the converters dictionary and then use the converter function found
    there to return the value. The column name found in :attr:`Cursor.description`
    is only the first word of the column name, i.  e. if you use something like
    ``&#39;as &quot;x [datetime]&quot;&#39;`` in your SQL, then we will parse out everything until the
    first blank for the column name: the column name would simply be &quot;x&quot;.
 
 
<span class="gd">-.. function:: connect(database[, timeout, isolation_level, detect_types, factory])</span>
<span class="gi">+.. function:: connect(database[, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements])</span>
 
    Opens a connection to the SQLite database file *database*. You can use
    ``&quot;:memory:&quot;`` to open a database connection to a database that resides in RAM
    instead of on disk.
 
    When a database is accessed by multiple connections, and one of the processes
    modifies the database, the SQLite database is locked until that transaction is
    committed. The *timeout* parameter specifies how long the connection should wait
    for the lock to go away until raising an exception. The default for the timeout
    parameter is 5.0 (five seconds).
 
    For the *isolation_level* parameter, please see the
<span class="gu">@@ -249,40 +249,39 @@</span>
    This method rolls back any changes to the database since the last call to
    :meth:`commit`.
 
 .. method:: Connection.close()
 
    This closes the database connection. Note that this does not automatically
    call :meth:`commit`. If you just close your database connection without
    calling :meth:`commit` first, your changes will be lost!
 
 .. method:: Connection.execute(sql, [parameters])
 
    This is a nonstandard shortcut that creates an intermediate cursor object by
<span class="gd">-   calling the cursor method, then calls the cursor&#39;s</span>
<span class="gd">-   :meth:`execute&lt;Cursor.execute&gt;` method with the parameters given.</span>
<span class="gi">+   calling the cursor method, then calls the cursor&#39;s :meth:`execute</span>
<span class="gi">+   &lt;Cursor.execute&gt;` method with the parameters given.</span>
 
 
 .. method:: Connection.executemany(sql, [parameters])
 
    This is a nonstandard shortcut that creates an intermediate cursor object by
<span class="gd">-   calling the cursor method, then calls the cursor&#39;s</span>
<span class="gd">-   :meth:`executemany&lt;Cursor.executemany&gt;` method with the parameters given.</span>
<span class="gi">+   calling the cursor method, then calls the cursor&#39;s :meth:`executemany</span>
<span class="gi">+   &lt;Cursor.executemany&gt;` method with the parameters given.</span>
 
 .. method:: Connection.executescript(sql_script)
 
    This is a nonstandard shortcut that creates an intermediate cursor object by
<span class="gd">-   calling the cursor method, then calls the cursor&#39;s</span>
<span class="gd">-   :meth:`executescript&lt;Cursor.executescript&gt;` method with the parameters</span>
<span class="gd">-   given.</span>
<span class="gi">+   calling the cursor method, then calls the cursor&#39;s :meth:`executescript</span>
<span class="gi">+   &lt;Cursor.executescript&gt;` method with the parameters given.</span>
 
 
 .. method:: Connection.create_function(name, num_params, func)
 
    Creates a user-defined function that you can later use from within SQL
    statements under the function name *name*. *num_params* is the number of
    parameters the function accepts, and *func* is a Python callable that is called
    as the SQL function.
 
    The function can return any of the types supported by SQLite: unicode, str, int,
    long, float, buffer and None.
 
<span class="gu">@@ -359,24 +358,43 @@</span>
 
    .. versionadded:: 2.6
 
    This routine registers a callback. The callback is invoked for every *n*
    instructions of the SQLite virtual machine. This is useful if you want to
    get called from SQLite during long-running operations, for example to update
    a GUI.
 
    If you want to clear any previously installed progress handler, call the
    method with :const:`None` for *handler*.
 
 
<span class="gi">+.. method:: Connection.enable_load_extension(enabled)</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+</span>
<span class="gi">+   This routine allows/disallows the SQLite engine to load SQLite extensions</span>
<span class="gi">+   from shared libraries.  SQLite extensions can define new functions,</span>
<span class="gi">+   aggregates or whole new virtual table implementations.  One well-known</span>
<span class="gi">+   extension is the fulltext-search extension distributed with SQLite.</span>
<span class="gi">+</span>
<span class="gi">+   .. literalinclude:: ../includes/sqlite3/load_extension.py</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Connection.load_extension(path)</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+</span>
<span class="gi">+   This routine loads a SQLite extension from a shared library.  You have to</span>
<span class="gi">+   enable extension loading with :meth:`enable_load_extension` before you can</span>
<span class="gi">+   use this routine.</span>
<span class="gi">+</span>
 .. attribute:: Connection.row_factory
 
    You can change this attribute to a callable that accepts the cursor and the
    original row as a tuple and will return the real result row.  This way, you can
    implement more advanced ways of returning results, such  as returning an object
    that can also access columns by name.
 
    Example:
 
    .. literalinclude:: ../includes/sqlite3/row_factory.py
 
    If returning a tuple doesn&#39;t suffice and you want name-based access to
<span class="gu">@@ -432,25 +450,25 @@</span>
       with open(&#39;dump.sql&#39;, &#39;w&#39;) as f:
           for line in con.iterdump():
               f.write(&#39;%s\n&#39; % line)
 
 
 .. _sqlite3-cursor-objects:
 
 Cursor Objects
 --------------
 
 .. class:: Cursor
 
<span class="gd">-   A SQLite database cursor has the following attributes and methods:</span>
<span class="gi">+   A :class:`Cursor` instance has the following attributes and methods.</span>
 
 .. method:: Cursor.execute(sql, [parameters])
 
    Executes an SQL statement. The SQL statement may be parametrized (i. e.
    placeholders instead of SQL literals). The :mod:`sqlite3` module supports two
    kinds of placeholders: question marks (qmark style) and named placeholders
    (named style).
 
    This example shows how to use parameters with qmark style:
 
    .. literalinclude:: ../includes/sqlite3/execute_1.py
 
<span class="gu">@@ -593,25 +611,25 @@</span>
     c.close()
 
 Now we plug :class:`Row` in::
 
     &gt;&gt;&gt; conn.row_factory = sqlite3.Row
     &gt;&gt;&gt; c = conn.cursor()
     &gt;&gt;&gt; c.execute(&#39;select * from stocks&#39;)
     &lt;sqlite3.Cursor object at 0x7f4e7dd8fa80&gt;
     &gt;&gt;&gt; r = c.fetchone()
     &gt;&gt;&gt; type(r)
     &lt;type &#39;sqlite3.Row&#39;&gt;
     &gt;&gt;&gt; r
<span class="gd">-    (u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100.0, 35.140000000000001)</span>
<span class="gi">+    (u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100.0, 35.14)</span>
     &gt;&gt;&gt; len(r)
     5
     &gt;&gt;&gt; r[2]
     u&#39;RHAT&#39;
     &gt;&gt;&gt; r.keys()
     [&#39;date&#39;, &#39;trans&#39;, &#39;symbol&#39;, &#39;qty&#39;, &#39;price&#39;]
     &gt;&gt;&gt; r[&#39;qty&#39;]
     100.0
     &gt;&gt;&gt; for member in r: print member
     ...
     2006-01-05
     BUY
<span class="gu">@@ -852,12 +870,26 @@</span>
 
 Using the connection as a context manager
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 .. versionadded:: 2.6
 
 Connection objects can be used as context managers
 that automatically commit or rollback transactions.  In the event of an
 exception, the transaction is rolled back; otherwise, the transaction is
 committed:
 
 .. literalinclude:: ../includes/sqlite3/ctx_manager.py
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Common issues</span>
<span class="gi">+-------------</span>
<span class="gi">+</span>
<span class="gi">+Multithreading</span>
<span class="gi">+^^^^^^^^^^^^^^</span>
<span class="gi">+</span>
<span class="gi">+Older SQLite versions had issues with sharing connections between threads.</span>
<span class="gi">+That&#39;s why the Python module disallows sharing connections and cursors between</span>
<span class="gi">+threads. If you still try to do so, you will get an exception at runtime.</span>
<span class="gi">+</span>
<span class="gi">+The only exception is calling the :meth:`~Connection.interrupt` method, which</span>
<span class="gi">+only makes sense to call from a different thread.</span>
</pre></div>

</body>
</html>
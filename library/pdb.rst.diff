@@ -1,13 +1,12 @@
-
 .. _debugger:
 
 :mod:`pdb` --- The Python Debugger
 ==================================
 
 .. module:: pdb
    :synopsis: The Python debugger for interactive interpreters.
 
 
 .. index:: single: debugging
 
 The module :mod:`pdb` defines an interactive source code debugger for Python
@@ -70,28 +69,28 @@
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
      File "./mymodule.py", line 4, in test
        test2()
      File "./mymodule.py", line 3, in test2
        print spam
    NameError: spam
    >>> pdb.pm()
    > ./mymodule.py(3)test2()
    -> print spam
    (Pdb)
 
+
 The module defines the following functions; each enters the debugger in a
 slightly different way:
 
-
 .. function:: run(statement[, globals[, locals]])
 
    Execute the *statement* (given as a string) under debugger control.  The
    debugger prompt appears before any code is executed; you can set breakpoints and
    type ``continue``, or you can step through the statement using ``step`` or
    ``next`` (all these commands are explained below).  The optional *globals* and
    *locals* arguments specify the environment in which the code is executed; by
    default the dictionary of the module :mod:`__main__` is used.  (See the
    explanation of the :keyword:`exec` statement or the :func:`eval` built-in
    function.)
 
 
@@ -117,25 +116,56 @@
 
 
 .. function:: post_mortem([traceback])
 
    Enter post-mortem debugging of the given *traceback* object.  If no
    *traceback* is given, it uses the one of the exception that is currently
    being handled (an exception must be being handled if the default is to be
    used).
 
 
 .. function:: pm()
 
-   Enter post-mortem debugging of the traceback found in ``sys.last_traceback``.
+   Enter post-mortem debugging of the traceback found in
+   :data:`sys.last_traceback`.
+
+
+The ``run*`` functions and :func:`set_trace` are aliases for instantiating the
+:class:`Pdb` class and calling the method of the same name.  If you want to
+access further features, you have to do this yourself:
+
+.. class:: Pdb(completekey='tab', stdin=None, stdout=None, skip=None)
+
+   :class:`Pdb` is the debugger class.
+
+   The *completekey*, *stdin* and *stdout* arguments are passed to the
+   underlying :class:`cmd.Cmd` class; see the description there.
+
+   The *skip* argument, if given, must be an iterable of glob-style module name
+   patterns.  The debugger will not step into frames that originate in a module
+   that matches one of these patterns. [1]_
+
+   Example call to enable tracing with *skip*::
+
+      import pdb; pdb.Pdb(skip=['django.*']).set_trace()
+
+   .. versionadded:: 2.7
+      The *skip* argument.
+
+   .. method:: run(statement[, globals[, locals]])
+               runeval(expression[, globals[, locals]])
+               runcall(function[, argument, ...])
+               set_trace()
+
+      See the documentation for the functions explained above.
 
 
 .. _debugger-commands:
 
 Debugger Commands
 =================
 
 The debugger recognizes the following commands.  Most commands can be
 abbreviated to one or two letters; e.g. ``h(elp)`` means that either ``h`` or
 ``help`` can be used to enter the help command (but not ``he`` or ``hel``, nor
 ``H`` or ``Help`` or ``HELP``).  Arguments to commands must be separated by
 whitespace (spaces or tabs).  Optional arguments are enclosed in square brackets
@@ -200,25 +230,26 @@
 
    If a second argument is present, it is an expression which must evaluate to true
    before the breakpoint is honored.
 
    Without argument, list all breaks, including for each breakpoint, the number of
    times that breakpoint has been hit, the current ignore count, and the associated
    condition if any.
 
 tbreak [[*filename*:]\ *lineno* | *function*\ [, *condition*]]
    Temporary breakpoint, which is removed automatically when it is first hit.  The
    arguments are the same as break.
 
-cl(ear) [*bpnumber* [*bpnumber ...*]]
+cl(ear) [*filename:lineno* | *bpnumber* [*bpnumber ...*]]
+   With a *filename:lineno* argument, clear all the breakpoints at this line.
    With a space separated list of breakpoint numbers, clear those breakpoints.
    Without argument, clear all breaks (but first ask confirmation).
 
 disable [*bpnumber* [*bpnumber ...*]]
    Disables the breakpoints given as a space separated list of breakpoint numbers.
    Disabling a breakpoint means it cannot cause the program to stop execution, but
    unlike clearing a breakpoint, it remains in the list of breakpoints and can be
    (re-)enabled.
 
 enable [*bpnumber* [*bpnumber ...*]]
    Enables the breakpoints specified.
 
@@ -351,12 +382,18 @@
       (Pdb) global list_options; list_options = ['-l']
       (Pdb)
 
 run [*args* ...]
    Restart the debugged Python program. If an argument is supplied, it is split
    with "shlex" and the result is used as the new sys.argv. History, breakpoints,
    actions and debugger options are preserved. "restart" is an alias for "run".
 
    .. versionadded:: 2.6
 
 q(uit)
    Quit from the debugger. The program being executed is aborted.
+
+
+.. rubric:: Footnotes
+
+.. [1] Whether a frame is considered to originate in a certain module
+       is determined by the ``__name__`` in the frame globals.

@@ -28,29 +28,34 @@
    find the longest contiguous matching subsequence that contains no "junk"
    elements (the Ratcliff and Obershelp algorithm doesn't address junk).  The same
    idea is then applied recursively to the pieces of the sequences to the left and
    to the right of the matching subsequence.  This does not yield minimal edit
    sequences, but does tend to yield matches that "look right" to people.
 
    **Timing:** The basic Ratcliff-Obershelp algorithm is cubic time in the worst
    case and quadratic time in the expected case. :class:`SequenceMatcher` is
    quadratic time for the worst case and has expected-case behavior dependent in a
    complicated way on how many elements the sequences have in common; best case
    time is linear.
 
-   **Heuristic:** To speed-up matching, items that appear more than 1% of the
-   time in sequences of at least 200 items are treated as junk.  This has the
-   unfortunate side-effect of giving bad results for sequences constructed from
-   a small set of items.  An option to turn off the heuristic will be added to a
-   future version.
+   **Automatic junk heuristic:** :class:`SequenceMatcher` supports a heuristic that
+   automatically treats certain sequence items as junk. The heuristic counts how many
+   times each individual item appears in the sequence. If an item's duplicates (after
+   the first one) account for more than 1% of the sequence and the sequence is at least
+   200 items long, this item is marked as "popular" and is treated as junk for
+   the purpose of sequence matching. This heuristic can be turned off by setting
+   the ``autojunk`` argument to ``False`` when creating the :class:`SequenceMatcher`.
+
+   .. versionadded:: 2.7.1
+      The *autojunk* parameter.
 
 .. class:: Differ
 
    This is a class for comparing sequences of lines of text, and producing
    human-readable differences or deltas.  Differ uses :class:`SequenceMatcher`
    both to compare sequences of lines, and to compare sequences of characters
    within similar (near-matching) lines.
 
    Each line of a :class:`Differ` delta begins with a two-letter code:
 
    +----------+-------------------------------------------+
    | Code     | Meaning                                   |
@@ -142,26 +147,26 @@
 
    By default, the diff control lines (those with ``***`` or ``---``) are created
    with a trailing newline.  This is helpful so that inputs created from
    :func:`file.readlines` result in diffs that are suitable for use with
    :func:`file.writelines` since both the inputs and outputs have trailing
    newlines.
 
    For inputs that do not have trailing newlines, set the *lineterm* argument to
    ``""`` so that the output will be uniformly newline free.
 
    The context diff format normally has a header for filenames and modification
    times.  Any or all of these may be specified using strings for *fromfile*,
-   *tofile*, *fromfiledate*, and *tofiledate*. The modification times are normally
-   expressed in the format returned by :func:`time.ctime`.  If not specified, the
+   *tofile*, *fromfiledate*, and *tofiledate*.  The modification times are normally
+   expressed in the ISO 8601 format. If not specified, the
    strings default to blanks.
 
       >>> s1 = ['bacon\n', 'eggs\n', 'ham\n', 'guido\n']
       >>> s2 = ['python\n', 'eggy\n', 'hamster\n', 'guido\n']
       >>> for line in context_diff(s1, s2, fromfile='before.py', tofile='after.py'):
       ...     sys.stdout.write(line)  # doctest: +NORMALIZE_WHITESPACE
       *** before.py
       --- after.py
       ***************
       *** 1,4 ****
       ! bacon
       ! eggs
@@ -277,26 +282,26 @@
 
    By default, the diff control lines (those with ``---``, ``+++``, or ``@@``) are
    created with a trailing newline.  This is helpful so that inputs created from
    :func:`file.readlines` result in diffs that are suitable for use with
    :func:`file.writelines` since both the inputs and outputs have trailing
    newlines.
 
    For inputs that do not have trailing newlines, set the *lineterm* argument to
    ``""`` so that the output will be uniformly newline free.
 
    The context diff format normally has a header for filenames and modification
    times.  Any or all of these may be specified using strings for *fromfile*,
-   *tofile*, *fromfiledate*, and *tofiledate*. The modification times are normally
-   expressed in the format returned by :func:`time.ctime`.  If not specified, the
+   *tofile*, *fromfiledate*, and *tofiledate*.  The modification times are normally
+   expressed in the ISO 8601 format. If not specified, the
    strings default to blanks.
 
       >>> s1 = ['bacon\n', 'eggs\n', 'ham\n', 'guido\n']
       >>> s2 = ['python\n', 'eggy\n', 'hamster\n', 'guido\n']
       >>> for line in unified_diff(s1, s2, fromfile='before.py', tofile='after.py'):
       ...     sys.stdout.write(line)   # doctest: +NORMALIZE_WHITESPACE
       --- before.py
       +++ after.py
       @@ -1,4 +1,4 @@
       -bacon
       -eggs
       -ham
@@ -330,43 +335,48 @@
       Discussion of a similar algorithm by John W. Ratcliff and D. E. Metzener. This
       was published in `Dr. Dobb's Journal <http://www.ddj.com/>`_ in July, 1988.
 
 
 .. _sequence-matcher:
 
 SequenceMatcher Objects
 -----------------------
 
 The :class:`SequenceMatcher` class has this constructor:
 
 
-.. class:: SequenceMatcher([isjunk[, a[, b]]])
+.. class:: SequenceMatcher([isjunk[, a[, b[, autojunk=True]]]])
 
    Optional argument *isjunk* must be ``None`` (the default) or a one-argument
    function that takes a sequence element and returns true if and only if the
    element is "junk" and should be ignored. Passing ``None`` for *isjunk* is
    equivalent to passing ``lambda x: 0``; in other words, no elements are ignored.
    For example, pass::
 
       lambda x: x in " \t"
 
    if you're comparing lines as sequences of characters, and don't want to synch up
    on blanks or hard tabs.
 
    The optional arguments *a* and *b* are sequences to be compared; both default to
    empty strings.  The elements of both sequences must be :term:`hashable`.
 
+   The optional argument *autojunk* can be used to disable the automatic junk
+   heuristic.
+
+   .. versionadded:: 2.7.1
+      The *autojunk* parameter.
+
    :class:`SequenceMatcher` objects have the following methods:
 
-
    .. method:: set_seqs(a, b)
 
       Set the two sequences to be compared.
 
    :class:`SequenceMatcher` computes and caches detailed information about the
    second sequence, so if you want to compare one sequence against many
    sequences, use :meth:`set_seq2` to set the commonly used sequence once and
    call :meth:`set_seq1` repeatedly, once for each of the other sequences.
 
 
    .. method:: set_seq1(a)
 
@@ -508,34 +518,29 @@
       sequences are identical, and ``0.0`` if they have nothing in common.
 
       This is expensive to compute if :meth:`get_matching_blocks` or
       :meth:`get_opcodes` hasn't already been called, in which case you may want
       to try :meth:`quick_ratio` or :meth:`real_quick_ratio` first to get an
       upper bound.
 
 
    .. method:: quick_ratio()
 
       Return an upper bound on :meth:`ratio` relatively quickly.
 
-      This isn't defined beyond that it is an upper bound on :meth:`ratio`, and
-      is faster to compute.
-
 
    .. method:: real_quick_ratio()
 
       Return an upper bound on :meth:`ratio` very quickly.
 
-      This isn't defined beyond that it is an upper bound on :meth:`ratio`, and
-      is faster to compute than either :meth:`ratio` or :meth:`quick_ratio`.
 
 The three methods that return the ratio of matching to total characters can give
 different results due to differing levels of approximation, although
 :meth:`quick_ratio` and :meth:`real_quick_ratio` are always at least as large as
 :meth:`ratio`:
 
    >>> s = SequenceMatcher(None, "abcd", "bcde")
    >>> s.ratio()
    0.75
    >>> s.quick_ratio()
    0.75
    >>> s.real_quick_ratio()

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/optparse.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -1,20 +1,25 @@</span>
<span class="gd">-:mod:`optparse` --- More powerful command line option parser</span>
<span class="gd">-============================================================</span>
<span class="gi">+:mod:`optparse` --- Parser for command line options</span>
<span class="gi">+===================================================</span>
 
 .. module:: optparse
<span class="gd">-   :synopsis: More convenient, flexible, and powerful command-line parsing library.</span>
<span class="gi">+   :synopsis: Command-line option parsing library.</span>
<span class="gi">+   :deprecated:</span>
<span class="gi">+</span>
<span class="gi">+.. deprecated:: 2.7</span>
<span class="gi">+   The :mod:`optparse` module is deprecated and will not be developed further;</span>
<span class="gi">+   development will continue with the :mod:`argparse` module.</span>
<span class="gi">+</span>
 .. moduleauthor:: Greg Ward &lt;gward@python.net&gt;
 
<span class="gd">-</span>
 .. versionadded:: 2.3
 
 .. sectionauthor:: Greg Ward &lt;gward@python.net&gt;
 
 
 :mod:`optparse` is a more convenient, flexible, and powerful library for parsing
 command-line options than the old :mod:`getopt` module.  :mod:`optparse` uses a
 more declarative style of command-line parsing: you create an instance of
 :class:`OptionParser`, populate it with options, and parse the command
 line. :mod:`optparse` allows users to specify options in the conventional
 GNU/POSIX syntax, and additionally generates usage and help messages for you.
 
<span class="gu">@@ -50,27 +55,27 @@</span>
    &lt;yourscript&gt; -q -foutfile
    &lt;yourscript&gt; -qfoutfile
 
 Additionally, users can run one of  ::
 
    &lt;yourscript&gt; -h
    &lt;yourscript&gt; --help
 
 and :mod:`optparse` will print out a brief summary of your script&#39;s options:
 
 .. code-block:: text
 
<span class="gd">-   usage: &lt;yourscript&gt; [options]</span>
<span class="gd">-</span>
<span class="gd">-   options:</span>
<span class="gi">+   Usage: &lt;yourscript&gt; [options]</span>
<span class="gi">+</span>
<span class="gi">+   Options:</span>
      -h, --help            show this help message and exit
      -f FILE, --file=FILE  write report to FILE
      -q, --quiet           don&#39;t print status messages to stdout
 
 where the value of *yourscript* is determined at runtime (normally from
 ``sys.argv[0]``).
 
 
 .. _optparse-background:
 
 Background
 ----------
<span class="gu">@@ -93,44 +98,44 @@</span>
    (``sys.argv[0]`` is the name of the program being executed).  Unix shells
    also use the term &quot;word&quot;.
 
    It is occasionally desirable to substitute an argument list other than
    ``sys.argv[1:]``, so you should read &quot;argument&quot; as &quot;an element of
    ``sys.argv[1:]``, or of some other list provided as a substitute for
    ``sys.argv[1:]``&quot;.
 
 option
    an argument used to supply extra information to guide or customize the
    execution of a program.  There are many different syntaxes for options; the
    traditional Unix syntax is a hyphen (&quot;-&quot;) followed by a single letter,
<span class="gd">-   e.g. ``&quot;-x&quot;`` or ``&quot;-F&quot;``.  Also, traditional Unix syntax allows multiple</span>
<span class="gd">-   options to be merged into a single argument, e.g.  ``&quot;-x -F&quot;`` is equivalent</span>
<span class="gd">-   to ``&quot;-xF&quot;``.  The GNU project introduced ``&quot;--&quot;`` followed by a series of</span>
<span class="gd">-   hyphen-separated words, e.g.  ``&quot;--file&quot;`` or ``&quot;--dry-run&quot;``.  These are the</span>
<span class="gi">+   e.g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple</span>
<span class="gi">+   options to be merged into a single argument, e.g. ``-x -F`` is equivalent</span>
<span class="gi">+   to ``-xF``.  The GNU project introduced ``--`` followed by a series of</span>
<span class="gi">+   hyphen-separated words, e.g. ``--file`` or ``--dry-run``.  These are the</span>
    only two option syntaxes provided by :mod:`optparse`.
 
    Some other option syntaxes that the world has seen include:
 
<span class="gd">-   * a hyphen followed by a few letters, e.g. ``&quot;-pf&quot;`` (this is *not* the same</span>
<span class="gi">+   * a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same</span>
      as multiple options merged into a single argument)
 
<span class="gd">-   * a hyphen followed by a whole word, e.g. ``&quot;-file&quot;`` (this is technically</span>
<span class="gi">+   * a hyphen followed by a whole word, e.g. ``-file`` (this is technically</span>
      equivalent to the previous syntax, but they aren&#39;t usually seen in the same
      program)
 
    * a plus sign followed by a single letter, or a few letters, or a word, e.g.
<span class="gd">-     ``&quot;+f&quot;``, ``&quot;+rgb&quot;``</span>
<span class="gd">-</span>
<span class="gd">-   * a slash followed by a letter, or a few letters, or a word, e.g. ``&quot;/f&quot;``,</span>
<span class="gd">-     ``&quot;/file&quot;``</span>
<span class="gi">+     ``+f``, ``+rgb``</span>
<span class="gi">+</span>
<span class="gi">+   * a slash followed by a letter, or a few letters, or a word, e.g. ``/f``,</span>
<span class="gi">+     ``/file``</span>
 
    These option syntaxes are not supported by :mod:`optparse`, and they never
    will be.  This is deliberate: the first three are non-standard on any
    environment, and the last only makes sense if you&#39;re exclusively targeting
    VMS, MS-DOS, and/or Windows.
 
 option argument
    an argument that follows an option, is closely associated with that option,
    and is consumed from the argument list when that option is. With
    :mod:`optparse`, option arguments may either be in a separate argument from
    their option:
 
<span class="gu">@@ -140,47 +145,47 @@</span>
       --file foo
 
    or included in the same argument:
 
    .. code-block:: text
 
       -ffoo
       --file=foo
 
    Typically, a given option either takes an argument or it doesn&#39;t. Lots of
    people want an &quot;optional option arguments&quot; feature, meaning that some options
    will take an argument if they see it, and won&#39;t if they don&#39;t.  This is
<span class="gd">-   somewhat controversial, because it makes parsing ambiguous: if ``&quot;-a&quot;`` takes</span>
<span class="gd">-   an optional argument and ``&quot;-b&quot;`` is another option entirely, how do we</span>
<span class="gd">-   interpret ``&quot;-ab&quot;``?  Because of this ambiguity, :mod:`optparse` does not</span>
<span class="gi">+   somewhat controversial, because it makes parsing ambiguous: if ``-a`` takes</span>
<span class="gi">+   an optional argument and ``-b`` is another option entirely, how do we</span>
<span class="gi">+   interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` does not</span>
    support this feature.
 
 positional argument
    something leftover in the argument list after options have been parsed, i.e.
    after options and their arguments have been parsed and removed from the
    argument list.
 
 required option
    an option that must be supplied on the command-line; note that the phrase
    &quot;required option&quot; is self-contradictory in English.  :mod:`optparse` doesn&#39;t
    prevent you from implementing required options, but doesn&#39;t give you much
    help at it either.
 
 For example, consider this hypothetical command-line::
 
    prog -v --report /tmp/report.txt foo bar
 
<span class="gd">-``&quot;-v&quot;`` and ``&quot;--report&quot;`` are both options.  Assuming that :option:`--report`</span>
<span class="gd">-takes one argument, ``&quot;/tmp/report.txt&quot;`` is an option argument.  ``&quot;foo&quot;`` and</span>
<span class="gd">-``&quot;bar&quot;`` are positional arguments.</span>
<span class="gi">+``-v`` and ``--report`` are both options.  Assuming that ``--report``</span>
<span class="gi">+takes one argument, ``/tmp/report.txt`` is an option argument.  ``foo`` and</span>
<span class="gi">+``bar`` are positional arguments.</span>
 
 
 .. _optparse-what-options-for:
 
 What are options for?
 ^^^^^^^^^^^^^^^^^^^^^
 
 Options are used to provide extra information to tune or customize the execution
 of a program.  In case it wasn&#39;t clear, options are usually *optional*.  A
 program should be able to run just fine with no options whatsoever.  (Pick a
 random program from the Unix or GNU toolsets.  Can it run without any options at
 all and still make sense?  The main exceptions are ``find``, ``tar``, and
<span class="gu">@@ -247,25 +252,25 @@</span>
 First, you need to import the OptionParser class; then, early in the main
 program, create an OptionParser instance::
 
    from optparse import OptionParser
    [...]
    parser = OptionParser()
 
 Then you can start defining options.  The basic syntax is::
 
    parser.add_option(opt_str, ...,
                      attr=value, ...)
 
<span class="gd">-Each option has one or more option strings, such as ``&quot;-f&quot;`` or ``&quot;--file&quot;``,</span>
<span class="gi">+Each option has one or more option strings, such as ``-f`` or ``--file``,</span>
 and several option attributes that tell :mod:`optparse` what to expect and what
 to do when it encounters that option on the command line.
 
 Typically, each option will have one short option string and one long option
 string, e.g.::
 
    parser.add_option(&quot;-f&quot;, &quot;--file&quot;, ...)
 
 You&#39;re free to define as many short option strings and as many long option
 strings as you like (including zero), as long as there is at least one option
 string overall.
 
<span class="gu">@@ -276,25 +281,25 @@</span>
 
 Once all of your options are defined, instruct :mod:`optparse` to parse your
 program&#39;s command line::
 
    (options, args) = parser.parse_args()
 
 (If you like, you can pass a custom argument list to :meth:`parse_args`, but
 that&#39;s rarely necessary: by default it uses ``sys.argv[1:]``.)
 
 :meth:`parse_args` returns two values:
 
 * ``options``, an object containing values for all of your options---e.g. if
<span class="gd">-  ``&quot;--file&quot;`` takes a single string argument, then ``options.file`` will be the</span>
<span class="gi">+  ``--file`` takes a single string argument, then ``options.file`` will be the</span>
   filename supplied by the user, or ``None`` if the user did not supply that
   option
 
 * ``args``, the list of positional arguments leftover after parsing options
 
 This tutorial section only covers the four most important option attributes:
 :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option.dest`
 (destination), and :attr:`~Option.help`. Of these, :attr:`~Option.action` is the
 most fundamental.
 
 
 .. _optparse-understanding-option-actions:
<span class="gu">@@ -322,80 +327,80 @@</span>
 of the correct type, and store it to your chosen destination.
 
 For example::
 
    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      action=&quot;store&quot;, type=&quot;string&quot;, dest=&quot;filename&quot;)
 
 Now let&#39;s make up a fake command line and ask :mod:`optparse` to parse it::
 
    args = [&quot;-f&quot;, &quot;foo.txt&quot;]
    (options, args) = parser.parse_args(args)
 
<span class="gd">-When :mod:`optparse` sees the option string ``&quot;-f&quot;``, it consumes the next</span>
<span class="gd">-argument, ``&quot;foo.txt&quot;``, and stores it in ``options.filename``.  So, after this</span>
<span class="gi">+When :mod:`optparse` sees the option string ``-f``, it consumes the next</span>
<span class="gi">+argument, ``foo.txt``, and stores it in ``options.filename``.  So, after this</span>
 call to :meth:`parse_args`, ``options.filename`` is ``&quot;foo.txt&quot;``.
 
 Some other option types supported by :mod:`optparse` are ``int`` and ``float``.
 Here&#39;s an option that expects an integer argument::
 
    parser.add_option(&quot;-n&quot;, type=&quot;int&quot;, dest=&quot;num&quot;)
 
 Note that this option has no long option string, which is perfectly acceptable.
 Also, there&#39;s no explicit action, since the default is ``store``.
 
 Let&#39;s parse another fake command-line.  This time, we&#39;ll jam the option argument
<span class="gd">-right up against the option: since ``&quot;-n42&quot;`` (one argument) is equivalent to</span>
<span class="gd">-``&quot;-n 42&quot;`` (two arguments), the code ::</span>
<span class="gi">+right up against the option: since ``-n42`` (one argument) is equivalent to</span>
<span class="gi">+``-n 42`` (two arguments), the code ::</span>
 
    (options, args) = parser.parse_args([&quot;-n42&quot;])
    print options.num
 
<span class="gd">-will print ``&quot;42&quot;``.</span>
<span class="gi">+will print ``42``.</span>
 
 If you don&#39;t specify a type, :mod:`optparse` assumes ``string``.  Combined with
 the fact that the default action is ``store``, that means our first example can
 be a lot shorter::
 
    parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;)
 
 If you don&#39;t supply a destination, :mod:`optparse` figures out a sensible
 default from the option strings: if the first long option string is
<span class="gd">-``&quot;--foo-bar&quot;``, then the default destination is ``foo_bar``.  If there are no</span>
<span class="gi">+``--foo-bar``, then the default destination is ``foo_bar``.  If there are no</span>
 long option strings, :mod:`optparse` looks at the first short option string: the
<span class="gd">-default destination for ``&quot;-f&quot;`` is ``f``.</span>
<span class="gi">+default destination for ``-f`` is ``f``.</span>
 
 :mod:`optparse` also includes built-in ``long`` and ``complex`` types.  Adding
 types is covered in section :ref:`optparse-extending-optparse`.
 
 
 .. _optparse-handling-boolean-options:
 
 Handling boolean (flag) options
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 Flag options---set a variable to true or false when a particular option is seen
 ---are quite common.  :mod:`optparse` supports them with two separate actions,
 ``store_true`` and ``store_false``.  For example, you might have a ``verbose``
<span class="gd">-flag that is turned on with ``&quot;-v&quot;`` and off with ``&quot;-q&quot;``::</span>
<span class="gi">+flag that is turned on with ``-v`` and off with ``-q``::</span>
 
    parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;)
    parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;)
 
 Here we have two different options with the same destination, which is perfectly
 OK.  (It just means you have to be a bit careful when setting default values---
 see below.)
 
<span class="gd">-When :mod:`optparse` encounters ``&quot;-v&quot;`` on the command line, it sets</span>
<span class="gd">-``options.verbose`` to ``True``; when it encounters ``&quot;-q&quot;``,</span>
<span class="gi">+When :mod:`optparse` encounters ``-v`` on the command line, it sets</span>
<span class="gi">+``options.verbose`` to ``True``; when it encounters ``-q``,</span>
 ``options.verbose`` is set to ``False``.
 
 
 .. _optparse-other-actions:
 
 Other actions
 ^^^^^^^^^^^^^
 
 Some other actions supported by :mod:`optparse` are:
 
 ``&quot;store_const&quot;``
    store a constant value
<span class="gu">@@ -417,25 +422,25 @@</span>
 
 Default values
 ^^^^^^^^^^^^^^
 
 All of the above examples involve setting some variable (the &quot;destination&quot;) when
 certain command-line options are seen.  What happens if those options are never
 seen?  Since we didn&#39;t supply any defaults, they are all set to ``None``.  This
 is usually fine, but sometimes you want more control.  :mod:`optparse` lets you
 supply a default value for each destination, which is assigned before the
 command line is parsed.
 
 First, consider the verbose/quiet example.  If we want :mod:`optparse` to set
<span class="gd">-``verbose`` to ``True`` unless ``&quot;-q&quot;`` is seen, then we can do this::</span>
<span class="gi">+``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::</span>
 
    parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;, default=True)
    parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;)
 
 Since default values apply to the *destination* rather than to any particular
 option, and these two options happen to have the same destination, this is
 exactly equivalent::
 
    parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;)
    parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=True)
 
 Consider this::
<span class="gu">@@ -475,199 +480,273 @@</span>
                      action=&quot;store_true&quot;, dest=&quot;verbose&quot;, default=True,
                      help=&quot;make lots of noise [default]&quot;)
    parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;,
                      action=&quot;store_false&quot;, dest=&quot;verbose&quot;,
                      help=&quot;be vewwy quiet (I&#39;m hunting wabbits)&quot;)
    parser.add_option(&quot;-f&quot;, &quot;--filename&quot;,
                      metavar=&quot;FILE&quot;, help=&quot;write output to FILE&quot;)
    parser.add_option(&quot;-m&quot;, &quot;--mode&quot;,
                      default=&quot;intermediate&quot;,
                      help=&quot;interaction mode: novice, intermediate, &quot;
                           &quot;or expert [default: %default]&quot;)
 
<span class="gd">-If :mod:`optparse` encounters either ``&quot;-h&quot;`` or ``&quot;--help&quot;`` on the</span>
<span class="gi">+If :mod:`optparse` encounters either ``-h`` or ``--help`` on the</span>
 command-line, or if you just call :meth:`parser.print_help`, it prints the
 following to standard output:
 
 .. code-block:: text
 
<span class="gd">-   usage: &lt;yourscript&gt; [options] arg1 arg2</span>
<span class="gd">-</span>
<span class="gd">-   options:</span>
<span class="gi">+   Usage: &lt;yourscript&gt; [options] arg1 arg2</span>
<span class="gi">+</span>
<span class="gi">+   Options:</span>
      -h, --help            show this help message and exit
      -v, --verbose         make lots of noise [default]
      -q, --quiet           be vewwy quiet (I&#39;m hunting wabbits)
      -f FILE, --filename=FILE
                            write output to FILE
      -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                            expert [default: intermediate]
 
 (If the help output is triggered by a help option, :mod:`optparse` exits after
 printing the help text.)
 
 There&#39;s a lot going on here to help :mod:`optparse` generate the best possible
 help message:
 
 * the script defines its own usage message::
 
      usage = &quot;usage: %prog [options] arg1 arg2&quot;
 
<span class="gd">-  :mod:`optparse` expands ``&quot;%prog&quot;`` in the usage string to the name of the</span>
<span class="gi">+  :mod:`optparse` expands ``%prog`` in the usage string to the name of the</span>
   current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded string
   is then printed before the detailed option help.
 
   If you don&#39;t supply a usage string, :mod:`optparse` uses a bland but sensible
<span class="gd">-  default: ``&quot;usage: %prog [options]&quot;``, which is fine if your script doesn&#39;t</span>
<span class="gi">+  default: ``&quot;Usage: %prog [options]&quot;``, which is fine if your script doesn&#39;t</span>
   take any positional arguments.
 
 * every option defines a help string, and doesn&#39;t worry about line-wrapping---
   :mod:`optparse` takes care of wrapping lines and making the help output look
   good.
 
 * options that take a value indicate this fact in their automatically-generated
   help message, e.g. for the &quot;mode&quot; option::
 
      -m MODE, --mode=MODE
 
   Here, &quot;MODE&quot; is called the meta-variable: it stands for the argument that the
<span class="gd">-  user is expected to supply to :option:`-m`/:option:`--mode`.  By default,</span>
<span class="gi">+  user is expected to supply to ``-m``/``--mode``.  By default,</span>
   :mod:`optparse` converts the destination variable name to uppercase and uses
   that for the meta-variable.  Sometimes, that&#39;s not what you want---for
<span class="gd">-  example, the :option:`--filename` option explicitly sets ``metavar=&quot;FILE&quot;``,</span>
<span class="gi">+  example, the ``--filename`` option explicitly sets ``metavar=&quot;FILE&quot;``,</span>
   resulting in this automatically-generated option description::
 
      -f FILE, --filename=FILE
 
   This is important for more than just saving space, though: the manually
<span class="gd">-  written help text uses the meta-variable &quot;FILE&quot; to clue the user in that</span>
<span class="gd">-  there&#39;s a connection between the semi-formal syntax &quot;-f FILE&quot; and the informal</span>
<span class="gi">+  written help text uses the meta-variable ``FILE`` to clue the user in that</span>
<span class="gi">+  there&#39;s a connection between the semi-formal syntax ``-f FILE`` and the informal</span>
   semantic description &quot;write output to FILE&quot;. This is a simple but effective
   way to make your help text a lot clearer and more useful for end users.
 
 .. versionadded:: 2.4
    Options that have a default value can include ``%default`` in the help
    string---\ :mod:`optparse` will replace it with :func:`str` of the option&#39;s
    default value.  If an option has no default value (or the default value is
    ``None``), ``%default`` expands to ``none``.
 
<span class="gi">+Grouping Options</span>
<span class="gi">+++++++++++++++++</span>
<span class="gi">+</span>
 When dealing with many options, it is convenient to group these options for
 better help output.  An :class:`OptionParser` can contain several option groups,
 each of which can contain several options.
 
<span class="gd">-Continuing with the parser defined above, adding an :class:`OptionGroup` to a</span>
<span class="gd">-parser is easy::</span>
<span class="gi">+An option group is obtained using the class :class:`OptionGroup`:</span>
<span class="gi">+</span>
<span class="gi">+.. class:: OptionGroup(parser, title, description=None)</span>
<span class="gi">+</span>
<span class="gi">+   where</span>
<span class="gi">+</span>
<span class="gi">+   * parser is the :class:`OptionParser` instance the group will be insterted in</span>
<span class="gi">+     to</span>
<span class="gi">+   * title is the group title</span>
<span class="gi">+   * description, optional, is a long description of the group</span>
<span class="gi">+</span>
<span class="gi">+:class:`OptionGroup` inherits from :class:`OptionContainer` (like</span>
<span class="gi">+:class:`OptionParser`) and so the :meth:`add_option` method can be used to add</span>
<span class="gi">+an option to the group.</span>
<span class="gi">+</span>
<span class="gi">+Once all the options are declared, using the :class:`OptionParser` method</span>
<span class="gi">+:meth:`add_option_group` the group is added to the previously defined parser.</span>
<span class="gi">+</span>
<span class="gi">+Continuing with the parser defined in the previous section, adding an</span>
<span class="gi">+:class:`OptionGroup` to a parser is easy::</span>
 
     group = OptionGroup(parser, &quot;Dangerous Options&quot;,
                         &quot;Caution: use these options at your own risk.  &quot;
                         &quot;It is believed that some of them bite.&quot;)
     group.add_option(&quot;-g&quot;, action=&quot;store_true&quot;, help=&quot;Group option.&quot;)
     parser.add_option_group(group)
 
 This would result in the following help output:
 
 .. code-block:: text
 
<span class="gd">-    usage:  [options] arg1 arg2</span>
<span class="gd">-</span>
<span class="gd">-    options:</span>
<span class="gd">-      -h, --help           show this help message and exit</span>
<span class="gd">-      -v, --verbose        make lots of noise [default]</span>
<span class="gd">-      -q, --quiet          be vewwy quiet (I&#39;m hunting wabbits)</span>
<span class="gd">-      -fFILE, --file=FILE  write output to FILE</span>
<span class="gd">-      -mMODE, --mode=MODE  interaction mode: one of &#39;novice&#39;, &#39;intermediate&#39;</span>
<span class="gd">-                           [default], &#39;expert&#39;</span>
<span class="gd">-</span>
<span class="gd">-      Dangerous Options:</span>
<span class="gd">-      Caution: use of these options is at your own risk.  It is believed that</span>
<span class="gd">-      some of them bite.</span>
<span class="gd">-      -g                 Group option.</span>
<span class="gi">+   Usage: &lt;yourscript&gt; [options] arg1 arg2</span>
<span class="gi">+</span>
<span class="gi">+   Options:</span>
<span class="gi">+     -h, --help            show this help message and exit</span>
<span class="gi">+     -v, --verbose         make lots of noise [default]</span>
<span class="gi">+     -q, --quiet           be vewwy quiet (I&#39;m hunting wabbits)</span>
<span class="gi">+     -f FILE, --filename=FILE</span>
<span class="gi">+                           write output to FILE</span>
<span class="gi">+     -m MODE, --mode=MODE  interaction mode: novice, intermediate, or</span>
<span class="gi">+                           expert [default: intermediate]</span>
<span class="gi">+</span>
<span class="gi">+     Dangerous Options:</span>
<span class="gi">+       Caution: use these options at your own risk.  It is believed that some</span>
<span class="gi">+       of them bite.</span>
<span class="gi">+</span>
<span class="gi">+       -g                  Group option.</span>
<span class="gi">+</span>
<span class="gi">+A bit more complete example might invole using more than one group: still</span>
<span class="gi">+extendind the previous example::</span>
<span class="gi">+</span>
<span class="gi">+    group = OptionGroup(parser, &quot;Dangerous Options&quot;,</span>
<span class="gi">+                        &quot;Caution: use these options at your own risk.  &quot;</span>
<span class="gi">+                        &quot;It is believed that some of them bite.&quot;)</span>
<span class="gi">+    group.add_option(&quot;-g&quot;, action=&quot;store_true&quot;, help=&quot;Group option.&quot;)</span>
<span class="gi">+    parser.add_option_group(group)</span>
<span class="gi">+</span>
<span class="gi">+    group = OptionGroup(parser, &quot;Debug Options&quot;)</span>
<span class="gi">+    group.add_option(&quot;-d&quot;, &quot;--debug&quot;, action=&quot;store_true&quot;,</span>
<span class="gi">+                     help=&quot;Print debug information&quot;)</span>
<span class="gi">+    group.add_option(&quot;-s&quot;, &quot;--sql&quot;, action=&quot;store_true&quot;,</span>
<span class="gi">+                     help=&quot;Print all SQL statements executed&quot;)</span>
<span class="gi">+    group.add_option(&quot;-e&quot;, action=&quot;store_true&quot;, help=&quot;Print every action done&quot;)</span>
<span class="gi">+    parser.add_option_group(group)</span>
<span class="gi">+</span>
<span class="gi">+that results in the following output:</span>
<span class="gi">+</span>
<span class="gi">+.. code-block:: text</span>
<span class="gi">+</span>
<span class="gi">+   Usage: &lt;yourscript&gt; [options] arg1 arg2</span>
<span class="gi">+</span>
<span class="gi">+   Options:</span>
<span class="gi">+     -h, --help            show this help message and exit</span>
<span class="gi">+     -v, --verbose         make lots of noise [default]</span>
<span class="gi">+     -q, --quiet           be vewwy quiet (I&#39;m hunting wabbits)</span>
<span class="gi">+     -f FILE, --filename=FILE</span>
<span class="gi">+                           write output to FILE</span>
<span class="gi">+     -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert</span>
<span class="gi">+                           [default: intermediate]</span>
<span class="gi">+</span>
<span class="gi">+     Dangerous Options:</span>
<span class="gi">+       Caution: use these options at your own risk.  It is believed that some</span>
<span class="gi">+       of them bite.</span>
<span class="gi">+</span>
<span class="gi">+       -g                  Group option.</span>
<span class="gi">+</span>
<span class="gi">+     Debug Options:</span>
<span class="gi">+       -d, --debug         Print debug information</span>
<span class="gi">+       -s, --sql           Print all SQL statements executed</span>
<span class="gi">+       -e                  Print every action done</span>
<span class="gi">+</span>
<span class="gi">+Another interesting method, in particular when working programmatically with</span>
<span class="gi">+option groups is:</span>
<span class="gi">+</span>
<span class="gi">+.. method:: OptionParser.get_option_group(opt_str)</span>
<span class="gi">+</span>
<span class="gi">+   Return, if defined, the :class:`OptionGroup` that has the title or the long</span>
<span class="gi">+   description equals to *opt_str*</span>
 
 .. _optparse-printing-version-string:
 
 Printing a version string
 ^^^^^^^^^^^^^^^^^^^^^^^^^
 
 Similar to the brief usage string, :mod:`optparse` can also print a version
 string for your program.  You have to supply the string as the ``version``
 argument to OptionParser::
 
    parser = OptionParser(usage=&quot;%prog [-f] [-q]&quot;, version=&quot;%prog 1.0&quot;)
 
<span class="gd">-``&quot;%prog&quot;`` is expanded just like it is in ``usage``.  Apart from that,</span>
<span class="gi">+``%prog`` is expanded just like it is in ``usage``.  Apart from that,</span>
 ``version`` can contain anything you like.  When you supply it, :mod:`optparse`
<span class="gd">-automatically adds a ``&quot;--version&quot;`` option to your parser. If it encounters</span>
<span class="gi">+automatically adds a ``--version`` option to your parser. If it encounters</span>
 this option on the command line, it expands your ``version`` string (by
<span class="gd">-replacing ``&quot;%prog&quot;``), prints it to stdout, and exits.</span>
<span class="gi">+replacing ``%prog``), prints it to stdout, and exits.</span>
 
 For example, if your script is called ``/usr/bin/foo``::
 
    $ /usr/bin/foo --version
    foo 1.0
 
 The following two methods can be used to print and get the ``version`` string:
 
 .. method:: OptionParser.print_version(file=None)
 
    Print the version message for the current program (``self.version``) to
    *file* (default stdout).  As with :meth:`print_usage`, any occurrence
<span class="gd">-   of ``&quot;%prog&quot;`` in ``self.version`` is replaced with the name of the current</span>
<span class="gi">+   of ``%prog`` in ``self.version`` is replaced with the name of the current</span>
    program.  Does nothing if ``self.version`` is empty or undefined.
 
 .. method:: OptionParser.get_version()
 
    Same as :meth:`print_version` but returns the version string instead of
    printing it.
 
 
 .. _optparse-how-optparse-handles-errors:
 
 How :mod:`optparse` handles errors
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 There are two broad classes of errors that :mod:`optparse` has to worry about:
 programmer errors and user errors.  Programmer errors are usually erroneous
 calls to :func:`OptionParser.add_option`, e.g. invalid option strings, unknown
 option attributes, missing option attributes, etc.  These are dealt with in the
 usual way: raise an exception (either :exc:`optparse.OptionError` or
 :exc:`TypeError`) and let the program crash.
 
 Handling user errors is much more important, since they are guaranteed to happen
 no matter how stable your code is.  :mod:`optparse` can automatically detect
<span class="gd">-some user errors, such as bad option arguments (passing ``&quot;-n 4x&quot;`` where</span>
<span class="gd">-:option:`-n` takes an integer argument), missing arguments (``&quot;-n&quot;`` at the end</span>
<span class="gd">-of the command line, where :option:`-n` takes an argument of any type).  Also,</span>
<span class="gi">+some user errors, such as bad option arguments (passing ``-n 4x`` where</span>
<span class="gi">+``-n`` takes an integer argument), missing arguments (``-n`` at the end</span>
<span class="gi">+of the command line, where ``-n`` takes an argument of any type).  Also,</span>
 you can call :func:`OptionParser.error` to signal an application-defined error
 condition::
 
    (options, args) = parser.parse_args()
    [...]
    if options.a and options.b:
        parser.error(&quot;options -a and -b are mutually exclusive&quot;)
 
 In either case, :mod:`optparse` handles the error the same way: it prints the
 program&#39;s usage message and an error message to standard error and exits with
 error status 2.
 
<span class="gd">-Consider the first example above, where the user passes ``&quot;4x&quot;`` to an option</span>
<span class="gi">+Consider the first example above, where the user passes ``4x`` to an option</span>
 that takes an integer::
 
    $ /usr/bin/foo -n 4x
<span class="gd">-   usage: foo [options]</span>
<span class="gi">+   Usage: foo [options]</span>
 
    foo: error: option -n: invalid integer value: &#39;4x&#39;
 
 Or, where the user fails to pass a value at all::
 
    $ /usr/bin/foo -n
<span class="gd">-   usage: foo [options]</span>
<span class="gi">+   Usage: foo [options]</span>
 
    foo: error: -n option requires an argument
 
 :mod:`optparse`\ -generated error messages take care always to mention the
 option involved in the error; be sure to do the same when calling
 :func:`OptionParser.error` from your application code.
 
 If :mod:`optparse`&#39;s default error-handling behaviour does not suit your needs,
 you&#39;ll need to subclass OptionParser and override its :meth:`~OptionParser.exit`
 and/or :meth:`~OptionParser.error` methods.
 
 
<span class="gu">@@ -731,49 +810,49 @@</span>
       A list of Option objects to populate the parser with.  The options in
       ``option_list`` are added after any options in ``standard_option_list`` (a
       class attribute that may be set by OptionParser subclasses), but before
       any version or help options. Deprecated; use :meth:`add_option` after
       creating the parser instead.
 
    ``option_class`` (default: optparse.Option)
       Class to use when adding options to the parser in :meth:`add_option`.
 
    ``version`` (default: ``None``)
       A version string to print when the user supplies a version option. If you
       supply a true value for ``version``, :mod:`optparse` automatically adds a
<span class="gd">-      version option with the single option string ``&quot;--version&quot;``.  The</span>
<span class="gd">-      substring ``&quot;%prog&quot;`` is expanded the same as for ``usage``.</span>
<span class="gi">+      version option with the single option string ``--version``.  The</span>
<span class="gi">+      substring ``%prog`` is expanded the same as for ``usage``.</span>
 
    ``conflict_handler`` (default: ``&quot;error&quot;``)
       Specifies what to do when options with conflicting option strings are
       added to the parser; see section
       :ref:`optparse-conflicts-between-options`.
 
    ``description`` (default: ``None``)
       A paragraph of text giving a brief overview of your program.
       :mod:`optparse` reformats this paragraph to fit the current terminal width
       and prints it when the user requests help (after ``usage``, but before the
       list of options).
 
    ``formatter`` (default: a new :class:`IndentedHelpFormatter`)
       An instance of optparse.HelpFormatter that will be used for printing help
       text.  :mod:`optparse` provides two concrete classes for this purpose:
       IndentedHelpFormatter and TitledHelpFormatter.
 
    ``add_help_option`` (default: ``True``)
<span class="gd">-      If true, :mod:`optparse` will add a help option (with option strings ``&quot;-h&quot;``</span>
<span class="gd">-      and ``&quot;--help&quot;``) to the parser.</span>
<span class="gi">+      If true, :mod:`optparse` will add a help option (with option strings ``-h``</span>
<span class="gi">+      and ``--help``) to the parser.</span>
 
    ``prog``
<span class="gd">-      The string to use when expanding ``&quot;%prog&quot;`` in ``usage`` and ``version``</span>
<span class="gi">+      The string to use when expanding ``%prog`` in ``usage`` and ``version``</span>
       instead of ``os.path.basename(sys.argv[0])``.
 
    ``epilog`` (default: ``None``)
       A paragraph of help text to print after the option help.
 
 .. _optparse-populating-parser:
 
 Populating the parser
 ^^^^^^^^^^^^^^^^^^^^^
 
 There are several ways to populate the parser with options.  The preferred way
 is by using :meth:`OptionParser.add_option`, as shown in section
<span class="gu">@@ -799,25 +878,25 @@</span>
 (:func:`make_option` is a factory function for creating Option instances;
 currently it is an alias for the Option constructor.  A future version of
 :mod:`optparse` may split Option into several classes, and :func:`make_option`
 will pick the right class to instantiate.  Do not instantiate Option directly.)
 
 
 .. _optparse-defining-options:
 
 Defining options
 ^^^^^^^^^^^^^^^^
 
 Each Option instance represents a set of synonymous command-line option strings,
<span class="gd">-e.g. :option:`-f` and :option:`--file`.  You can specify any number of short or</span>
<span class="gi">+e.g. ``-f`` and ``--file``.  You can specify any number of short or</span>
 long option strings, but you must specify at least one overall option string.
 
 The canonical way to create an :class:`Option` instance is with the
 :meth:`add_option` method of :class:`OptionParser`.
 
 .. method:: OptionParser.add_option(opt_str[, ...], attr=value, ...)
 
    To define an option with only a short option string::
 
       parser.add_option(&quot;-f&quot;, attr=value, ...)
 
    And to define an option with only a long option string::
<span class="gu">@@ -962,25 +1041,25 @@</span>
    is seen.  See section :ref:`optparse-option-callbacks` for detail on the
    arguments passed to the callable.
 
 .. attribute:: Option.callback_args
                Option.callback_kwargs
 
    Additional positional and keyword arguments to pass to ``callback`` after the
    four standard callback arguments.
 
 .. attribute:: Option.help
 
    Help text to print for this option when listing all available options after
<span class="gd">-   the user supplies a :attr:`~Option.help` option (such as ``&quot;--help&quot;``).  If</span>
<span class="gi">+   the user supplies a :attr:`~Option.help` option (such as ``--help``).  If</span>
    no help text is supplied, the option will be listed without help text.  To
    hide this option, use the special value :data:`optparse.SUPPRESS_HELP`.
 
 .. attribute:: Option.metavar
 
    (default: derived from option strings)
 
    Stand-in for the option argument(s) to use when printing help text.  See
    section :ref:`optparse-tutorial` for an example.
 
 
 .. _optparse-standard-option-actions:
<span class="gu">@@ -1000,27 +1079,27 @@</span>
   according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If
   :attr:`~Option.nargs` &gt; 1, multiple arguments will be consumed from the
   command line; all will be converted according to :attr:`~Option.type` and
   stored to :attr:`~Option.dest` as a tuple.  See the
   :ref:`optparse-standard-option-types` section.
 
   If :attr:`~Option.choices` is supplied (a list or tuple of strings), the type
   defaults to ``&quot;choice&quot;``.
 
   If :attr:`~Option.type` is not supplied, it defaults to ``&quot;string&quot;``.
 
   If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a destination
<span class="gd">-  from the first long option string (e.g., ``&quot;--foo-bar&quot;`` implies</span>
<span class="gi">+  from the first long option string (e.g., ``--foo-bar`` implies</span>
   ``foo_bar``). If there are no long option strings, :mod:`optparse` derives a
<span class="gd">-  destination from the first short option string (e.g., ``&quot;-f&quot;`` implies ``f``).</span>
<span class="gi">+  destination from the first short option string (e.g., ``-f`` implies ``f``).</span>
 
   Example::
 
      parser.add_option(&quot;-f&quot;)
      parser.add_option(&quot;-p&quot;, type=&quot;float&quot;, nargs=3, dest=&quot;point&quot;)
 
   As it parses the command line ::
 
      -f foo.txt -p 1 -3.5 4 -fbar.txt
 
   :mod:`optparse` will set ::
 
<span class="gu">@@ -1033,25 +1112,25 @@</span>
 
   The value :attr:`~Option.const` is stored in :attr:`~Option.dest`.
 
   Example::
 
      parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;,
                        action=&quot;store_const&quot;, const=0, dest=&quot;verbose&quot;)
      parser.add_option(&quot;-v&quot;, &quot;--verbose&quot;,
                        action=&quot;store_const&quot;, const=1, dest=&quot;verbose&quot;)
      parser.add_option(&quot;--noisy&quot;,
                        action=&quot;store_const&quot;, const=2, dest=&quot;verbose&quot;)
 
<span class="gd">-  If ``&quot;--noisy&quot;`` is seen, :mod:`optparse` will set  ::</span>
<span class="gi">+  If ``--noisy`` is seen, :mod:`optparse` will set  ::</span>
 
      options.verbose = 2
 
 * ``&quot;store_true&quot;`` [relevant: :attr:`~Option.dest`]
 
   A special case of ``&quot;store_const&quot;`` that stores a true value to
   :attr:`~Option.dest`.
 
 * ``&quot;store_false&quot;`` [relevant: :attr:`~Option.dest`]
 
   Like ``&quot;store_true&quot;``, but stores a false value.
 
<span class="gu">@@ -1068,59 +1147,59 @@</span>
   supplied, an empty list is automatically created when :mod:`optparse` first
   encounters this option on the command-line.  If :attr:`~Option.nargs` &gt; 1,
   multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs`
   is appended to :attr:`~Option.dest`.
 
   The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same as
   for the ``&quot;store&quot;`` action.
 
   Example::
 
      parser.add_option(&quot;-t&quot;, &quot;--tracks&quot;, action=&quot;append&quot;, type=&quot;int&quot;)
 
<span class="gd">-  If ``&quot;-t3&quot;`` is seen on the command-line, :mod:`optparse` does the equivalent</span>
<span class="gi">+  If ``-t3`` is seen on the command-line, :mod:`optparse` does the equivalent</span>
   of::
 
      options.tracks = []
      options.tracks.append(int(&quot;3&quot;))
 
<span class="gd">-  If, a little later on, ``&quot;--tracks=4&quot;`` is seen, it does::</span>
<span class="gi">+  If, a little later on, ``--tracks=4`` is seen, it does::</span>
 
      options.tracks.append(int(&quot;4&quot;))
 
 * ``&quot;append_const&quot;`` [required: :attr:`~Option.const`; relevant:
   :attr:`~Option.dest`]
 
   Like ``&quot;store_const&quot;``, but the value :attr:`~Option.const` is appended to
   :attr:`~Option.dest`; as with ``&quot;append&quot;``, :attr:`~Option.dest` defaults to
   ``None``, and an empty list is automatically created the first time the option
   is encountered.
 
 * ``&quot;count&quot;`` [relevant: :attr:`~Option.dest`]
 
   Increment the integer stored at :attr:`~Option.dest`.  If no default value is
   supplied, :attr:`~Option.dest` is set to zero before being incremented the
   first time.
 
   Example::
 
      parser.add_option(&quot;-v&quot;, action=&quot;count&quot;, dest=&quot;verbosity&quot;)
 
<span class="gd">-  The first time ``&quot;-v&quot;`` is seen on the command line, :mod:`optparse` does the</span>
<span class="gi">+  The first time ``-v`` is seen on the command line, :mod:`optparse` does the</span>
   equivalent of::
 
      options.verbosity = 0
      options.verbosity += 1
 
<span class="gd">-  Every subsequent occurrence of ``&quot;-v&quot;`` results in  ::</span>
<span class="gi">+  Every subsequent occurrence of ``-v`` results in  ::</span>
 
      options.verbosity += 1
 
 * ``&quot;callback&quot;`` [required: :attr:`~Option.callback`; relevant:
   :attr:`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`,
   :attr:`~Option.callback_kwargs`]
 
   Call the function specified by :attr:`~Option.callback`, which is called as ::
 
      func(option, opt_str, value, parser, *args, **kwargs)
 
   See section :ref:`optparse-option-callbacks` for more detail.
<span class="gu">@@ -1145,33 +1224,33 @@</span>
 
      # usually, a help option is added automatically, but that can
      # be suppressed using the add_help_option argument
      parser = OptionParser(add_help_option=False)
 
      parser.add_option(&quot;-h&quot;, &quot;--help&quot;, action=&quot;help&quot;)
      parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;,
                        help=&quot;Be moderately verbose&quot;)
      parser.add_option(&quot;--file&quot;, dest=&quot;filename&quot;,
                        help=&quot;Input file to read data from&quot;)
      parser.add_option(&quot;--secret&quot;, help=SUPPRESS_HELP)
 
<span class="gd">-  If :mod:`optparse` sees either ``&quot;-h&quot;`` or ``&quot;--help&quot;`` on the command line,</span>
<span class="gi">+  If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line,</span>
   it will print something like the following help message to stdout (assuming
   ``sys.argv[0]`` is ``&quot;foo.py&quot;``):
 
   .. code-block:: text
 
<span class="gd">-     usage: foo.py [options]</span>
<span class="gd">-</span>
<span class="gd">-     options:</span>
<span class="gi">+     Usage: foo.py [options]</span>
<span class="gi">+</span>
<span class="gi">+     Options:</span>
        -h, --help        Show this help message and exit
        -v                Be moderately verbose
        --file=FILENAME   Input file to read data from
 
   After printing the help message, :mod:`optparse` terminates your process with
   ``sys.exit(0)``.
 
 * ``&quot;version&quot;``
 
   Prints the version number supplied to the OptionParser to stdout and exits.
   The version number is actually formatted and printed by the
   ``print_version()`` method of OptionParser.  Generally only relevant if the
<span class="gu">@@ -1202,25 +1281,25 @@</span>
 
 * otherwise, the number is parsed as a decimal number
 
 
 The conversion is done by calling either :func:`int` or :func:`long` with the
 appropriate base (2, 8, 10, or 16).  If this fails, so will :mod:`optparse`,
 although with a more useful error message.
 
 ``&quot;float&quot;`` and ``&quot;complex&quot;`` option arguments are converted directly with
 :func:`float` and :func:`complex`, with similar error-handling.
 
 ``&quot;choice&quot;`` options are a subtype of ``&quot;string&quot;`` options.  The
<span class="gd">-:attr:`~Option.choices`` option attribute (a sequence of strings) defines the</span>
<span class="gi">+:attr:`~Option.choices` option attribute (a sequence of strings) defines the</span>
 set of allowed option arguments.  :func:`optparse.check_choice` compares
 user-supplied option arguments against this master list and raises
 :exc:`OptionValueError` if an invalid string is given.
 
 
 .. _optparse-parsing-arguments:
 
 Parsing arguments
 ^^^^^^^^^^^^^^^^^
 
 The whole point of creating and populating an OptionParser is to call its
 :meth:`parse_args` method::
<span class="gu">@@ -1259,26 +1338,26 @@</span>
 
 .. _optparse-querying-manipulating-option-parser:
 
 Querying and manipulating your option parser
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 The default behavior of the option parser can be customized slightly, and you
 can also poke around your option parser and see what&#39;s there.  OptionParser
 provides several methods to help you out:
 
 .. method:: OptionParser.disable_interspersed_args()
 
<span class="gd">-   Set parsing to stop on the first non-option.  For example, if ``&quot;-a&quot;`` and</span>
<span class="gd">-   ``&quot;-b&quot;`` are both simple options that take no arguments, :mod:`optparse`</span>
<span class="gi">+   Set parsing to stop on the first non-option.  For example, if ``-a`` and</span>
<span class="gi">+   ``-b`` are both simple options that take no arguments, :mod:`optparse`</span>
    normally accepts this syntax::
 
       prog -a arg1 -b arg2
 
    and treats it as equivalent to  ::
 
       prog -a -b arg1 arg2
 
    To disable this feature, call :meth:`disable_interspersed_args`.  This
    restores traditional Unix syntax, where option parsing stops with the first
    non-option argument.
 
<span class="gu">@@ -1290,25 +1369,25 @@</span>
 
    Set parsing to not stop on the first non-option, allowing interspersing
    switches with command arguments.  This is the default behavior.
 
 .. method:: OptionParser.get_option(opt_str)
 
    Returns the Option instance with the option string *opt_str*, or ``None`` if
    no options have that option string.
 
 .. method:: OptionParser.has_option(opt_str)
 
    Return true if the OptionParser has an option with option string *opt_str*
<span class="gd">-   (e.g., ``&quot;-q&quot;`` or ``&quot;--verbose&quot;``).</span>
<span class="gi">+   (e.g., ``-q`` or ``--verbose``).</span>
 
 .. method:: OptionParser.remove_option(opt_str)
 
    If the :class:`OptionParser` has an option corresponding to *opt_str*, that
    option is removed.  If that option provided any other option strings, all of
    those option strings become invalid. If *opt_str* does not occur in any
    option belonging to this :class:`OptionParser`, raises :exc:`ValueError`.
 
 
 .. _optparse-conflicts-between-options:
 
 Conflicts between options
<span class="gu">@@ -1343,46 +1422,46 @@</span>
    ``&quot;resolve&quot;``
       resolve option conflicts intelligently (see below)
 
 
 As an example, let&#39;s define an :class:`OptionParser` that resolves conflicts
 intelligently and add conflicting options to it::
 
    parser = OptionParser(conflict_handler=&quot;resolve&quot;)
    parser.add_option(&quot;-n&quot;, &quot;--dry-run&quot;, ..., help=&quot;do no harm&quot;)
    parser.add_option(&quot;-n&quot;, &quot;--noisy&quot;, ..., help=&quot;be noisy&quot;)
 
 At this point, :mod:`optparse` detects that a previously-added option is already
<span class="gd">-using the ``&quot;-n&quot;`` option string.  Since ``conflict_handler`` is ``&quot;resolve&quot;``,</span>
<span class="gd">-it resolves the situation by removing ``&quot;-n&quot;`` from the earlier option&#39;s list of</span>
<span class="gd">-option strings.  Now ``&quot;--dry-run&quot;`` is the only way for the user to activate</span>
<span class="gi">+using the ``-n`` option string.  Since ``conflict_handler`` is ``&quot;resolve&quot;``,</span>
<span class="gi">+it resolves the situation by removing ``-n`` from the earlier option&#39;s list of</span>
<span class="gi">+option strings.  Now ``--dry-run`` is the only way for the user to activate</span>
 that option.  If the user asks for help, the help message will reflect that::
 
<span class="gd">-   options:</span>
<span class="gi">+   Options:</span>
      --dry-run     do no harm
      [...]
      -n, --noisy   be noisy
 
 It&#39;s possible to whittle away the option strings for a previously-added option
 until there are none left, and the user has no way of invoking that option from
 the command-line.  In that case, :mod:`optparse` removes that option completely,
 so it doesn&#39;t show up in help text or anywhere else. Carrying on with our
 existing OptionParser::
 
    parser.add_option(&quot;--dry-run&quot;, ..., help=&quot;new dry-run option&quot;)
 
<span class="gd">-At this point, the original :option:`-n/--dry-run` option is no longer</span>
<span class="gi">+At this point, the original ``-n``/``--dry-run`` option is no longer</span>
 accessible, so :mod:`optparse` removes it, leaving this help text::
 
<span class="gd">-   options:</span>
<span class="gi">+   Options:</span>
      [...]
      -n, --noisy   be noisy
      --dry-run     new dry-run option
 
 
 .. _optparse-cleanup:
 
 Cleanup
 ^^^^^^^
 
 OptionParser instances have several cyclic references.  This should not be a
 problem for Python&#39;s garbage collector, but you may wish to break the cyclic
<span class="gu">@@ -1399,25 +1478,25 @@</span>
 
 OptionParser supports several other public methods:
 
 .. method:: OptionParser.set_usage(usage)
 
    Set the usage string according to the rules described above for the ``usage``
    constructor keyword argument.  Passing ``None`` sets the default usage
    string; use :data:`optparse.SUPPRESS_USAGE` to suppress a usage message.
 
 .. method:: OptionParser.print_usage(file=None)
 
    Print the usage message for the current program (``self.usage``) to *file*
<span class="gd">-   (default stdout).  Any occurrence of the string ``&quot;%prog&quot;`` in ``self.usage``</span>
<span class="gi">+   (default stdout).  Any occurrence of the string ``%prog`` in ``self.usage``</span>
    is replaced with the name of the current program.  Does nothing if
    ``self.usage`` is empty or not defined.
 
 .. method:: OptionParser.get_usage()
 
    Same as :meth:`print_usage` but returns the usage string instead of
    printing it.
 
 .. method:: OptionParser.set_defaults(dest=value, ...)
 
    Set default values for several option destinations at once.  Using
    :meth:`set_defaults` is the preferred way to set default values for options,
<span class="gu">@@ -1463,27 +1542,27 @@</span>
 
 Defining a callback option
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 As always, the easiest way to define a callback option is by using the
 :meth:`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, the
 only option attribute you must specify is ``callback``, the function to call::
 
    parser.add_option(&quot;-c&quot;, action=&quot;callback&quot;, callback=my_callback)
 
 ``callback`` is a function (or other callable object), so you must have already
 defined ``my_callback()`` when you create this callback option. In this simple
<span class="gd">-case, :mod:`optparse` doesn&#39;t even know if :option:`-c` takes any arguments,</span>
<span class="gi">+case, :mod:`optparse` doesn&#39;t even know if ``-c`` takes any arguments,</span>
 which usually means that the option takes no arguments---the mere presence of
<span class="gd">-:option:`-c` on the command-line is all it needs to know.  In some</span>
<span class="gi">+``-c`` on the command-line is all it needs to know.  In some</span>
 circumstances, though, you might want your callback to consume an arbitrary
 number of command-line arguments.  This is where writing callbacks gets tricky;
 it&#39;s covered later in this section.
 
 :mod:`optparse` always passes four particular arguments to your callback, and it
 will only pass additional arguments if you specify them via
 :attr:`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, the
 minimal callback function signature is::
 
    def my_callback(option, opt, value, parser):
 
 The four arguments to a callback are described below.
<span class="gu">@@ -1518,26 +1597,26 @@</span>
 All callbacks are called as follows::
 
    func(option, opt_str, value, parser, *args, **kwargs)
 
 where
 
 ``option``
    is the Option instance that&#39;s calling the callback
 
 ``opt_str``
    is the option string seen on the command-line that&#39;s triggering the callback.
    (If an abbreviated long option was used, ``opt_str`` will be the full,
<span class="gd">-   canonical option string---e.g. if the user puts ``&quot;--foo&quot;`` on the</span>
<span class="gd">-   command-line as an abbreviation for ``&quot;--foobar&quot;``, then ``opt_str`` will be</span>
<span class="gi">+   canonical option string---e.g. if the user puts ``--foo`` on the</span>
<span class="gi">+   command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be</span>
    ``&quot;--foobar&quot;``.)
 
 ``value``
    is the argument to this option seen on the command-line.  :mod:`optparse` will
    only expect an argument if :attr:`~Option.type` is set; the type of ``value`` will be
    the type implied by the option&#39;s type.  If :attr:`~Option.type` for this option is
    ``None`` (no argument expected), then ``value`` will be ``None``.  If :attr:`~Option.nargs`
    &gt; 1, ``value`` will be a tuple of values of the appropriate type.
 
 ``parser``
    is the OptionParser instance driving the whole thing, mainly useful because
    you can access some other interesting data through its instance attributes:
<span class="gu">@@ -1594,43 +1673,43 @@</span>
        parser.values.saw_foo = True
 
    parser.add_option(&quot;--foo&quot;, action=&quot;callback&quot;, callback=record_foo_seen)
 
 Of course, you could do that with the ``&quot;store_true&quot;`` action.
 
 
 .. _optparse-callback-example-2:
 
 Callback example 2: check option order
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
<span class="gd">-Here&#39;s a slightly more interesting example: record the fact that ``&quot;-a&quot;`` is</span>
<span class="gd">-seen, but blow up if it comes after ``&quot;-b&quot;`` in the command-line.  ::</span>
<span class="gi">+Here&#39;s a slightly more interesting example: record the fact that ``-a`` is</span>
<span class="gi">+seen, but blow up if it comes after ``-b`` in the command-line.  ::</span>
 
    def check_order(option, opt_str, value, parser):
        if parser.values.b:
            raise OptionValueError(&quot;can&#39;t use -a after -b&quot;)
        parser.values.a = 1
    [...]
    parser.add_option(&quot;-a&quot;, action=&quot;callback&quot;, callback=check_order)
    parser.add_option(&quot;-b&quot;, action=&quot;store_true&quot;, dest=&quot;b&quot;)
 
 
 .. _optparse-callback-example-3:
 
 Callback example 3: check option order (generalized)
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 If you want to re-use this callback for several similar options (set a flag, but
<span class="gd">-blow up if ``&quot;-b&quot;`` has already been seen), it needs a bit of work: the error</span>
<span class="gi">+blow up if ``-b`` has already been seen), it needs a bit of work: the error</span>
 message and the flag that it sets must be generalized.  ::
 
    def check_order(option, opt_str, value, parser):
        if parser.values.b:
            raise OptionValueError(&quot;can&#39;t use %s after -b&quot; % opt_str)
        setattr(parser.values, option.dest, 1)
    [...]
    parser.add_option(&quot;-a&quot;, action=&quot;callback&quot;, callback=check_order, dest=&#39;a&#39;)
    parser.add_option(&quot;-b&quot;, action=&quot;store_true&quot;, dest=&quot;b&quot;)
    parser.add_option(&quot;-c&quot;, action=&quot;callback&quot;, callback=check_order, dest=&#39;c&#39;)
 
 
<span class="gu">@@ -1682,33 +1761,33 @@</span>
 
 
 .. _optparse-callback-example-6:
 
 Callback example 6: variable arguments
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 Things get hairy when you want an option to take a variable number of arguments.
 For this case, you must write a callback, as :mod:`optparse` doesn&#39;t provide any
 built-in capabilities for it.  And you have to deal with certain intricacies of
 conventional Unix command-line parsing that :mod:`optparse` normally handles for
 you.  In particular, callbacks should implement the conventional rules for bare
<span class="gd">-``&quot;--&quot;`` and ``&quot;-&quot;`` arguments:</span>
<span class="gd">-</span>
<span class="gd">-* either ``&quot;--&quot;`` or ``&quot;-&quot;`` can be option arguments</span>
<span class="gd">-</span>
<span class="gd">-* bare ``&quot;--&quot;`` (if not the argument to some option): halt command-line</span>
<span class="gd">-  processing and discard the ``&quot;--&quot;``</span>
<span class="gd">-</span>
<span class="gd">-* bare ``&quot;-&quot;`` (if not the argument to some option): halt command-line</span>
<span class="gd">-  processing but keep the ``&quot;-&quot;`` (append it to ``parser.largs``)</span>
<span class="gi">+``--`` and ``-`` arguments:</span>
<span class="gi">+</span>
<span class="gi">+* either ``--`` or ``-`` can be option arguments</span>
<span class="gi">+</span>
<span class="gi">+* bare ``--`` (if not the argument to some option): halt command-line</span>
<span class="gi">+  processing and discard the ``--``</span>
<span class="gi">+</span>
<span class="gi">+* bare ``-`` (if not the argument to some option): halt command-line</span>
<span class="gi">+  processing but keep the ``-`` (append it to ``parser.largs``)</span>
 
 If you want an option that takes a variable number of arguments, there are
 several subtle, tricky issues to worry about.  The exact implementation you
 choose will be based on which trade-offs you&#39;re willing to make for your
 application (which is why :mod:`optparse` doesn&#39;t support this sort of thing
 directly).
 
 Nevertheless, here&#39;s a stab at a callback for an option with variable
 arguments::
 
     def vararg_callback(option, opt_str, value, parser):
         assert value is None
<span class="gu">@@ -1761,25 +1840,25 @@</span>
 
    A tuple of type names; in your subclass, simply define a new tuple
    :attr:`TYPES` that builds on the standard one.
 
 .. attribute:: Option.TYPE_CHECKER
 
    A dictionary mapping type names to type-checking functions.  A type-checking
    function has the following signature::
 
       def check_mytype(option, opt, value)
 
    where ``option`` is an :class:`Option` instance, ``opt`` is an option string
<span class="gd">-   (e.g., ``&quot;-f&quot;``), and ``value`` is the string from the command line that must</span>
<span class="gi">+   (e.g., ``-f``), and ``value`` is the string from the command line that must</span>
    be checked and converted to your desired type.  ``check_mytype()`` should
    return an object of the hypothetical type ``mytype``.  The value returned by
    a type-checking function will wind up in the OptionValues instance returned
    by :meth:`OptionParser.parse_args`, or be passed to a callback as the
    ``value`` parameter.
 
    Your type-checking function should raise :exc:`OptionValueError` if it
    encounters any problems.  :exc:`OptionValueError` takes a single string
    argument, which is passed as-is to :class:`OptionParser`&#39;s :meth:`error`
    method, which in turn prepends the program name and the string ``&quot;error:&quot;``
    and prints everything to stderr before terminating the process.
 
<span class="gu">@@ -1873,25 +1952,25 @@</span>
    Actions that always take a type (i.e. whose options always take a value) are
    additionally listed here.  The only effect of this is that :mod:`optparse`
    assigns the default type, ``&quot;string&quot;``, to options with no explicit type
    whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`.
 
 In order to actually implement your new action, you must override Option&#39;s
 :meth:`take_action` method and add a case that recognizes your action.
 
 For example, let&#39;s add an ``&quot;extend&quot;`` action.  This is similar to the standard
 ``&quot;append&quot;`` action, but instead of taking a single value from the command-line
 and appending it to an existing list, ``&quot;extend&quot;`` will take multiple values in
 a single comma-delimited string, and extend an existing list with them.  That
<span class="gd">-is, if ``&quot;--names&quot;`` is an ``&quot;extend&quot;`` option of type ``&quot;string&quot;``, the command</span>
<span class="gi">+is, if ``--names`` is an ``&quot;extend&quot;`` option of type ``&quot;string&quot;``, the command</span>
 line ::
 
    --names=foo,bar --names blah --names ding,dong
 
 would result in a list  ::
 
    [&quot;foo&quot;, &quot;bar&quot;, &quot;blah&quot;, &quot;ding&quot;, &quot;dong&quot;]
 
 Again we define a subclass of Option::
 
    class MyOption(Option):
 
</pre></div>

</body>
</html>
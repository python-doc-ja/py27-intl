
:mod:`cgi` --- CGI (ゲートウェイインタフェース規格) のサポート
==============================================================

.. module:: cgi




.. index::
   pair: WWW; server
   pair: CGI; protocol
   pair: HTTP; protocol
   pair: MIME; headers
   single: URL

ゲートウェイインタフェース規格 (CGI) に準拠したスクリプトを サポートするためのモジュールです。

.. index:: single: Common Gateway Interface

このモジュールでは、 Python で CGI スクリプトを書く際に使える 様々なユーティリティを定義しています。


はじめに
--------

.. _cgi-intro:

CGI スクリプトは、HTTP サーバによって起動され、 通常は HTML の``<FORM>`` または ``<ISINDEX>`` エレメントを
通じてユーザが入力した内容を処理します。

ほとんどの場合、CGI スクリプトはサーバ上の特殊なディレクトリ :file:`cgi-bin` の下に置きます。HTTP サーバは、まずスクリプトを
駆動するためのシェルの環境変数に、リクエストの全ての情報  (クライアントのホスト名、リクエストされている URL、クエリ文字列、 その他諸々)
を設定し、スクリプトを実行した後、スクリプトの出力を クライアントに送信します。

スクリプトの入力端もクライアントに接続されていて、この経路を通じて フォームデータを読み込むこともあります。それ以外の場合には、 フォームデータは URL
の一部分である 「クエリ文字列」を介して 渡されます。このモジュールでは、上記のケースの違いに注意しつつ、 Python
スクリプトに対しては単純なインタフェースを提供しています。 このモジュールではまた、スクリプトをデバッグするための
ユーティリティも多数提供しています。また、最近はフォームを 経由したファイルのアップロードをサポートしています (ブラウザ側 がサポートしていればです)。

CGI スクリプトの出力は 2 つのセクションからなり、空行で分割 されています。最初のセクションは複数のヘッダからなり、
後続するデータがどのようなものかをクライアントに通知します。 最小のヘッダセクションを生成するための Python のコードは 以下のようなものです::

   print "Content-Type: text/html"     # 以降のデータが HTML であることを示す行
   print                               # ヘッダ部の終了を示す空行

二つ目のセクションは通常、ヘッダやインラインイメージ等の付属した テキストをうまくフォーマットして表示できるようにした HTML です。 以下に単純な HTML
を出力する Python コードを示します::

   print "<TITLE>CGI script output</TITLE>"
   print "<H1>This is my first CGI script</H1>"
   print "Hello, world!"


cgi モジュールを使う
--------------------

.. _using the cgi module:

先頭には ``import cgi`` と書いてください。``from cgi import *`` と書いてはなりません ---
このモジュールでは、以前のバージョンとの 互換性を持たせるため、内部で呼び出す名前を多数定義しており、それらを ユーザの名前空間に存在させる必要はないからです。

新たにスクリプトを書く際には、以下の一行を付加するかどうか検討してください::

   import cgitb; cgitb.enable()

これによって、特別な例外処理が有効にされ、エラーが発生した際にブラウザ 上に詳細なレポートを出力するようになります。ユーザにスクリプトの内部を
見せたくないのなら、以下のようにしてレポートをファイルに保存できます::

   import cgitb; cgitb.enable(display=0, logdir="/tmp")

スクリプトを開発する際には、この機能はとても役に立ちます。 :mod:`cgitb` が生成する報告はバグを追跡するためにかかる
時間を大幅に減らせるような情報を提供してくれます。スクリプトを テストし終わり、正確に動作することを確認したら、いつでも ``cgitb``
の行を削除できます。

入力されたフォームデータを取得するには、 :class:`FieldStorage` クラス
を使うのが最良の方法です。このモジュールで定義されている他のクラスの ほとんどは以前のバージョンとの互換性のためのものです。 インスタンス生成は引数なしで必ず
1 度だけ行います。これにより、 標準入力または環境変数からフォームの内容を読み出します (どちらから読み出すかは、複数の環境変数の値が CGI 標準に従って
どう設定されているかで決まります)。インスタンスが標準入力を 使うかもしれないので、インスタンス生成を行うのは一度だけにしなければ なりません。

:class:`FieldStorage` のインスタンスは Python の辞書のようにインデクス を使って参照でき、標準の辞書に対するメソッド
:meth:`has_key` と :meth:`keys` をサポートしています。組み込みの関数 :func:`len`
もサポートしています。空の文字列を含むフォームのフィールドは 無視され、辞書には入りません; そういった値を保持するには、
:class:`FieldStorage` のインスタンスを生成する時にオプションの  *keep_blank_values* キーワード引数を true
に設定してください。

例えば、以下のコード (:mailheader:`Content-Type` ヘッダと空行は すでに出力された後とします) は ``name`` および
``addr``  フィールドが両方とも空の文字列に設定されていないか調べます::

   form = cgi.FieldStorage()
   if not (form.has_key("name") and form.has_key("addr")):
       print "<H1>Error</H1>"
       print "Please fill in the name and addr fields."
       return
   print "<p>name:", form["name"].value
   print "<p>addr:", form["addr"].value
   ...further form processing here...

ここで、``form[key]`` で参照される各フィールドは それ自体が :class:`FieldStorage` (または
:class:`MiniFieldStorage`　。 フォームのエンコードによって変わります) のインスタンスです。 インスタンスの属性
:attr:`value` の内容は対応するフィールドの値で、 文字列になります。 :meth:`getvalue` メソッドはこの文字列値を直接返します。
:meth:`getvalue` の 2 つめの引数にオプションの値を与えると、 リクエストされたキーが存在しない場合に返すデフォルトの値になります。

入力されたフォームデータに同じ名前のフィールドが二つ以上あれば、 ``form[key]`` で得られるオブジェクトは
:class:`FieldStorage` や :class:`MiniFieldStorage` のインスタンスではなく、そうしたインスタンスの
リストになります。この場合、``form.getvalue(key)`` も同様に、 文字列からなるリストを返します。 もしこうした状況が起きうると思うなら
(HTML のフォームに同じ名前をもったフィールドが複数含まれているのなら) 、 組み込み関数 :func:`isinstance`
を使って、返された値が単一のインスタンスかインスタンスのリストかどうか 調べてください。例えば、以下のコードは任意の数のユーザ名フィールドを
結合し、コンマで分割された文字列にします::

   value = form.getvalue("username", "")
   if isinstance(value, list):
       # Multiple username fields specified
       usernames = ",".join(value)
   else:
       # Single or no username field specified
       usernames = value

フィールドがアップロードされたファイルを表している場合、:attr:`value` 属性や :func:`getvalue`
メソッドを使ってフィールドの値にアクセス すると、ファイルの内容を全て文字列としてメモリ上に読み込んでしまいます。
これは望ましくない機能かもしれません。アップロードされたファイルが あるかどうかは :attr:`filename` 属性および :attr:`file`
属性の いずれかで調べられます。その後、以下のようにして:attr:`file` 属性から 落ち着いてデータを読み出せます::

   fileitem = form["userfile"]
   if fileitem.file:
       # It's an uploaded file; count lines
       linecount = 0
       while 1:
           line = fileitem.file.readline()
           if not line: break
           linecount = linecount + 1

現在ドラフトとなっているファイルアップロードの標準仕様では、一つの フィールドから (再帰的な :mimetype:`multipart/\*`
エンコーディングを 使って) 複数のファイルがアップロードされる可能性を受け入れています。 この場合、アイテムは辞書形式の
:class:`FieldStorage` アイテムと なります。複数ファイルかどうかは :attr:`type` 属性が
:mimetype:`multipart/form-data` (または :mimetype:`multipart/\*` に マッチする他の MIME 型)
になっているかどうかを調べれば判別できます。 この場合、トップレベルのフォームオブジェクトと同様にして再帰的に 個別処理できます。

フォームが 「古い」 形式で入力された場合 (クエリ文字列または 単一の:mimetype:`application/x-www-form-
urlencoded` データで入力 された場合)、データ要素の実体は :class:`MiniFieldStorage` クラスの
インスタンスになります。この場合、:attr:`list` 、:attr:`file` 、および :attr:`filename` 属性は常に ``None``
になります。


高水準インタフェース
--------------------

.. versionadded:: 2.2

前節では CGI フォームデータを :class:`FieldStorage` クラスを使って 読み出す方法について解説しました。この節では、フォームデータを
分かりやすく直感的な方法で読み出せるようにするために追加された、 より高水準のインタフェースについて記述します。
このインタフェースは前節で説明した技術を撤廃するものでは ありません --- 例えば、前節の技術は依然としてファイルのアップロードを 効率的に行う上で便利です。

.. % XXX: Is this true ?

このインタフェースは 2 つの単純なメソッドからなります。このメソッドを 使えば、一般的な方法でフォームデータを処理でき、ある名前のフィールドに
入力された値が一つなのかそれ以上なのかを心配する必要がなくなります。

前節では、一つのフィールド名に対して二つ以上の値が入力される かもしれない場合には、常に以下のようなコードを書くよう学びました::

   item = form.getvalue("item")
   if isinstance(item, list):
       # The user is requesting more than one item.
   else:
       # The user is requesting only one item.

こういった状況は、例えば以下のように、同じ名前を持った複数の チェックボックスからなるグループがフォームに入っているような場合に よく起きます::

   <input type="checkbox" name="item" value="1" />
   <input type="checkbox" name="item" value="2" />

しかしながら、ほとんどの場合、あるフォーム中で特定の名前を持った コントロールはただ一つしかないので、その名前に関連付けられた値は
ただ一つしかないはずだと考えるでしょう。そこで、スクリプトには例えば 以下のようなコードを書くでしょう::

   user = form.getvalue("user").upper()

このコードの問題点は、クライアント側がスクリプトにとって常に有効な 入力を提供するとは期待できないところにあります。 例えば、もし好奇心旺盛なユーザがもう一つの
``user=foo`` ペア をクエリ文字列に追加したら、``getvalue(``'user')`` メソッドは
文字列ではなくリストを返すため、このスクリプトはクラッシュするでしょう。 リストに対して :meth:`\ upper\ `メソッドを呼び出すと、引数が
有効でない (リスト型はその名前のメソッドを持っていない) ため、例外 :exc:`\ AttributeError` を送出します。

従って、フォームデータの値を読み出しには、得られた値が 単一の値なのか値のリストなのかを常に調べるコードを使うのが適切
でした。これでは煩わしく、より読みにくいスクリプトになってしまいます。

ここで述べる高水準のインタフェースで提供している :meth:`getfirst`  や :meth:`getlist`
メソッドを使うと、もっと便利にアプローチできます。


.. method:: FieldStorage.getfirst(name[, default])

   フォームフィールド *name* に関連付けられた値をつねに一つだけ 返す軽量メソッドです。同じ名前で 1 つ以上の値がポストされている場合、
   このメソッドは最初の値だけを返します。フォームから値を受信する 際の値の並び順はブラウザ間で異なる可能性があり、特定の順番であるとは
   期待できないので注意してください。  [#]_

   指定したフォームフィールドや値がない場合、このメソッドはオプションの引数 *default* を返します。このパラメタを指定しない場合、標準の 値は
   ``None`` に設定されます。


.. method:: FieldStorage.getlist(name)

   このメソッドはフォームフィールド *name* に関連付けられた値を 常にリストにして返します。*name* に指定したフォームフィールドや値が
   存在しない場合、このメソッドは空のリストを返します。値が一つだけ 存在する場合、要素を一つだけ含むリストを返します。

これらのメソッドを使うことで、以下のようにナイスでコンパクトに コードを書けます::

   import cgi
   form = cgi.FieldStorage()
   user = form.getfirst("user", "").upper()    # This way it's safe.
   for item in form.getlist("item"):
       do_something(item)


古いクラス群
------------

これらのクラスは、:mod:`cgi` モジュールの以前のバージョンに入って おり、以前のバージョンとの互換性のために現在もサポートされています。
新しいアプリケーションでは :class:`FieldStorage` クラスを使うべきです。

:class:`SvFormContentDict` は単一の値しか持たないフォームデータの内容 を辞書として記憶します;
このクラスでは、各フィールド名はフォーム中に 一度しか現れないと仮定しています。

:class:`FormContentDict` は複数の値を持つフォームデータの内容 を辞書として記憶します (フォーム要素は値のリストです);
フォームが同じ名前を持ったフィールドを複数含む場合に便利です。

他のクラス (:class:`FormContent`、:class:`InterpFormContentDict`) は
非常に古いアプリケーションとの後方互換性のために存在します。 これらのクラスをいまだに使っていて、このモジュールの次のバージョンで
消えてしまったら非常に不便な場合は、作者まで連絡を下さい。


関数
----

.. _functions in cgi module:

より細かく CGI をコントロールしたり、このモジュールで実装されている アルゴリズムを他の状況で利用したい場合には、以下の関数が便利です。


.. function:: parse(fp[, keep_blank_values[, strict_parsing]])

   環境変数、またはファイルからからクエリを解釈します (ファイルは 標準で ``sys.stdin`` になります) *keep_blank_values*
   および *strict_parsing* パラメタはそのまま :func:`parse_qs` に 渡されます。


.. function:: parse_qs(qs[, keep_blank_values[, strict_parsing]])

   文字列引数として渡されたクエリ文字列  (:mimetype:`application/x-www-form-urlencoded` 型のデータ) を
   解釈します。解釈されたデータを辞書として返します。 辞書のキーは一意なクエリ変数名で、値は各変数名に対する値からなる リストです。

   オプションの引数 *keep_blank_values* は、 URL エンコード されたクエリ中で値の入っていないものを空文字列と見なすかどうか
   を示すフラグです。値が真であれば、値の入っていないフィールド は空文字列のままになります。標準では偽で、値の入っていない
   フィールドを無視し、そのフィールドはクエリに含まれていない ものとして扱います。

   オプションの引数 *strict_pasing* はパース時のエラーをどう 扱うかを決めるフラグです。値が偽なら (標準の設定です)、
   エラーは暗黙のうちに無視します。値が真なら:exc:`ValueError`  例外を送出します。

   辞書等をクエリ文字列に変換する場合は:func:`urllib. urlencode`関数を使用してください。


.. function:: parse_qsl(qs[, keep_blank_values[, strict_parsing]])

   文字列引数として渡されたクエリ文字列  (:mimetype:`application/x-www-form-urlencoded` 型のデータ) を
   解釈します。解釈されたデータは名前と値のペアからなるリストです。

   オプションの引数 *keep_blank_values* は、 URL エンコード されたクエリ中で値の入っていないものを空文字列と見なすかどうか
   を示すフラグです。値が真であれば、値の入っていないフィールド は空文字列のままになります。標準では偽で、値の入っていない
   フィールドを無視し、そのフィールドはクエリに含まれていない ものとして扱います。

   オプションの引数 *strict_pasing* はパース時のエラーをどう 扱うかを決めるフラグです。値が偽なら (標準の設定です)、
   エラーは暗黙のうちに無視します。値が真なら:exc:`ValueError`  例外を送出します。

   ペアのリストからクエリ文字列を生成する場合には :mod:`urllib`.urlencode() 関数を使用します。


.. function:: parse_multipart(fp, pdict)

   (ファイル入力のための) :mimetype:`multipart/form-data` 型の入力を 解釈します。引数は入力ファイルを示す *fp* と
   :mailheader:`Content-Type` ヘッダ内の他のパラメタを含む辞書 *pdict* です。

   :func:`parse_qs` と同じく辞書を返します。辞書のキーは フィールド名で、対応する値は各フィールドの値でできたリストです。
   この関数は簡単に使えますが、数メガバイトのデータがアップロードされる と考えられる場合にはあまり適していません --- その場合、 より柔軟性のある
   :class:`FieldStorage` を代りに使ってください。

   マルチパートデータがネストしている場合、各パートを解釈できないので 注意してください --- 代りに :class:`FieldStorage`
   を使ってください。


.. function:: parse_header(string)

   (:mailheader:`Content-Type` のような) MIME ヘッダを解釈し、ヘッダの 主要値と各パラメタからなる辞書にします。


.. function:: test()

   メインプログラムから利用できる堅牢性テストを行う CGI スクリプトです。 最小の HTTP ヘッダと、HTML フォームからスクリプトに供給された全ての
   情報を書式化して出力します。


.. function:: print_environ()

   シェル変数を HTML に書式化して出力します。


.. function:: print_form(form)

   フォームを HTML に初期化して出力します。


.. function:: print_directory()

   現在のディレクトリを HTML に書式化して出力します。 Format the current directory in HTML.


.. function:: print_environ_usage()

   意味のある (CGI の使う) 環境変数を HTML で出力します。


.. function:: escape(s[, quote])

   文字列 *s* 中の文字 ``'&'``、 ``'<'``、 および  ``'>'`` を HTML で正しく表示できる文字列に変換します。
   それらの文字が中に入っているかもしれないようなテキストを出力 する必要があるときに使ってください。 オプションの引数 *quote*
   の値が真であれば、二重引用符文字 (``'"'``) も変換します; この機能は、例えば  ``<A HREF="...">`` といったような HTML
   の属性値を出力に含めるのに 役立ちます。クオートされる値が単引用符か二重引用符、またはその両方 を含む可能性がある場合は、代りに
   :mod:`xml.sax.saxutils` の :func:`quoteattr` 関数を検討してください。


.. _cgi-security:

セキュリティへの配慮
--------------------

.. index:: pair: CGI; security

重要なルールが一つあります: ( 関数 :func:`os.system`  または :func:`os.popen` 、またはその他の同様の機能によって )
外部プログラムを呼び出すなら、クライアントから受信した任意の 文字列をシェルに渡していないことをよく確かめてください。
これはよく知られているセキュリティホールであり、これによって Web  のどこかにいる悪賢いハッカーが、だまされやすい CGI スクリプトに任意の
シェルコマンドを実行させてしまえます。URL の一部や フィールド名でさえも信用してはいけません。CGI へのリクエストは
あなたの作ったフォームから送信されるとは限らないからです！

安全な方法をとるために、フォームから入力された文字をシェルに 渡す場合、文字列に入っているのが英数文字、ダッシュ、アンダースコア、
およびピリオドだけかどうかを確認してください。


CGI スクリプトを Unix システムにインストールする
------------------------------------------------

あなたの使っている HTTP サーバのドキュメントを読んでください。そして ローカルシステムの管理者と一緒にどのディレクトリに CGI スクリプト
をインストールすべきかを調べてください; 通常これはサーバのファイル システムツリー内の :file:`cgi-bin` ディレクトリです。

あなたのスクリプトが "others" によって読み取り可能および実行可能 であることを確認してください; Unix ファイルモードは 8 進表記で
``0755`` です (``chmod 0755 filename`` を使ってください)。 スクリプトの最初の行の 1 カラム目が、 ``#!``
で開始し、その後に Python インタプリタへのパス名が続いていることを確認してください。 例えば::

   #!/usr/local/bin/python

Python インタプリタが存在し、"others" によって実行可能であることを 確かめてください。

あなたのスクリプトが読み書きしなければならないファイルが全て "others" によって読み出しや書き込み可能である ことを確かめてください ---
読み出し可能のファイルモードは ``0644`` で、書き込み可能のファイルモードは ``0666`` になるはずです。これは、セキュリティ上の理由から、
HTTP サーバが あなたのスクリプトを特権を全く持たないユーザ "nobody" の権限で 実行するからです。この権限下では、誰でもが読める
(書ける、実行できる) ファイルしか読み出し (書き込み、実行) できません。 スクリプト実行時のディレクトリや環境変数のセットもあなたがログイン
したときの設定と異なります。特に、実行ファイルに対するシェルの 検索パス (:envvar:`PATH`) や Python のモジュール検索パス
(:envvar:`PYTHONPATH`)が何らかの値に設定されていると期待しては いけません。

モジュールを Python の標準設定におけるモジュール検索パス上にない ディレクトリからロードする必要がある場合、他のモジュールを取り込む
前にスクリプト内で検索パスを変更できます。例えば::

   import sys
   sys.path.insert(0, "/usr/home/joe/lib/python")
   sys.path.insert(0, "/usr/local/lib/python")

(この方法では、最後に挿入されたディレクトリが最初に検索されます！)

非 Unix システムにおける説明は変わるでしょう; あなたの使っている HTTP サーバのドキュメントを調べてください (普通は CGI スクリプトに
関する節があります)。


CGI スクリプトをテストする
--------------------------

残念ながら、 CGI スクリプトは普通、コマンドラインから起動しよう としても動きません。また、コマンドラインから起動した場合には完璧に
動作するスクリプトが、不思議なことにサーバからの起動では失敗することが あります。しかし、スクリプトをコマンドラインから実行してみなければ
ならない理由が一つあります: もしスクリプトが文法エラーを含んで いれば、Python インタプリタはそのプログラムを全く実行しないため、 HTTP
サーバはほとんどの場合クライアントに謎めいたエラーを送信 するからです。

スクリプトが構文エラーを含まないのにうまく動作しないなら、次の 節に読み進むしかありません。


CGI スクリプトをデバッグする
----------------------------

.. index:: pair: CGI; debugging

何よりもまず、些細なインストール関連のエラーでないか確認してください --- 上の CGI スクリプトのインストールに関する節を注意深く読めば
時間を大いに節約できます。もしインストールの手続きを正しく理解 しているか不安なら、このモジュールのファイル (:file:`cgi.py`)
をコピーして、CGI スクリプトとしてインストールしてみてください。 このファイルはスクリプトとして呼び出すと、スクリプトの実行環境と フォームの内容を
HTML フォームに出力します。 正しいモードなどをフォームに与えて、リクエストを送ってみてください。 標準的な :file:`cgi-bin`
ディレクトリにインストールされていれば、 以下のような URL をブラウザに入力してリクエストを送信できるはずです::

   http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&addr=At+Home

もしタイプ 404 のエラーになるなら、サーバはスクリプトを発見 できないでいます -- おそらくあなたはスクリプトを別のディレクトリ
に入れる必要があるのでしょう。他のエラーになるなら、先に進む前に 解決しなければならないインストール上の問題があります。 もし実行環境の情報とフォーム内容
(この例では、 各フィールドはフィールド名 "addr" に対して値 "At Home"、および フィールド名 "name" に対して "Joe Blow" )
が綺麗にフォーマット されて表示されるなら、 :file:`cgi.py` スクリプトは正しくインストールされています。
同じ操作をあなたの自作スクリプトに対して行えば、スクリプトをデバッグ できるようになるはずです。

次のステップでは :mod:`cgi` モジュールの :func:`test` 関数を 呼び出すことになります: メインプログラムコードを以下の 1 行、 ::

   cgi.test()

と置き換えてください。この操作で :file:`cgi.py` ファイル自体を インストールした時と同じ結果を出力するはずです。

通常の Python スクリプトが例外を処理しきれずに送出した場合 (様々な理由: モジュール名のタイプミス、ファイルが開けなかった、など)、 Python
インタプリタはナイスなトレースバックを出力して終了します。 Python インタプリタはあなたの CGI スクリプトが例外を送出した場合
にも同様に振舞うので、トレースバックは大抵HTTP サーバのいずれかの ログファイルに残るかまったく無視されるかです。

幸運なことに、あなたが自作のスクリプトで *何らかの* コードを 実行できるようになったら、:mod:`cgitb` モジュールを使って
簡単にトレースバックをブラウザに送信できます。まだそうでないなら、 以下の一行::

   import cgitb; cgitb.enable()

をスクリプトの先頭に追加してください。そしてスクリプトを再度 走らせます; 問題が発生すれば、クラッシュの原因を見出せるような 詳細な報告を読めます。

:mod:`cgitb` モジュールのインポートに問題がありそうだと 思うなら、(組み込みモジュールだけを使った) もっと堅牢なアプローチを 取れます::

   import sys
   sys.stderr = sys.stdout
   print "Content-Type: text/plain"
   print
   ...your code here...

このコードは Python インタプリタがトレースバックを出力することに 依存しています。出力のコンテント型はプレーンテキストに設定されて おり、全ての
HTML 処理を無効にしています。スクリプトがうまく動作 する場合、生の HTML コードがクライアントに表示されます。スクリプト が例外を送出する場合、最初の
2 行が出力された後、トレースバックが 表示されます。HTML の解釈は行われないので、トレースバックを 読めるはずです。


よくある問題と解決法
--------------------

* ほとんどの HTTP サーバはスクリプトの実行が完了するまで CGI からの 出力をバッファします。このことは、スクリプトの実行中にクライアントが
  進捗状況報告を表示できないことを意味します。

* 上のインストールに関する説明を調べましょう。

* HTTP サーバのログファイルを調べましょう。(別のウィンドウで  ``tail -f logfile`` を実行すると便利かもしれません！)

* 常に ``python script.py`` などとして、スクリプトが構文エラーで ないか調べましょう。

* スクリプトに構文エラーがないなら、``import cgitb; cgitb.enable()`` をスクリプトの先頭に追加してみましょう。

* 外部プログラムを起動するときには、スクリプトがそのプログラムを 見つけられるようにしましょう。これは通常、絶対パス名を使うことを 意味します ---
  :envvar:`PATH` は普通、あまり CGI スクリプトにとって 便利でない値に設定されています。

* 外部のファイルを読み書きする際には、CGI スクリプトを動作 させるときに使われる userid でファイルを読み書きできるように
  なっているか確認しましょう: userid は通常、Web サーバを動作させて いる userid か、Web サーバの ``suexec``
  機能で明示的に指定 している userid になります。

* CGI スクリプトを set-uid モードにしてはいけません。これはほとんど のシステムで動作せず、セキュリティ上の信頼性もありません。

.. rubric:: Footnotes

.. [#] 最近のバージョンの HTML 仕様ではフィールドの値を供給する 順番を取り決めてはいますが、ある HTTP リクエストがその取り決めに
   準拠したブラウザから受信したものかどうか、そもそもブラウザから送信 されたものかどうかの判別は退屈で間違いやすいので注意してください。


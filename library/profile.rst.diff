@@ -611,25 +611,25 @@
    that you choose.  For most machines, a timer that returns a lone integer value
    will provide the best results in terms of low overhead during profiling.
    (:func:`os.times` is *pretty* bad, as it returns a tuple of floating point
    values).  If you want to substitute a better timer in the cleanest fashion,
    derive a class and hardwire a replacement dispatch method that best handles your
    timer call, along with the appropriate calibration constant.
 
 :class:`cProfile.Profile`
    :func:`your_time_func` should return a single number.  If it returns plain
    integers, you can also invoke the class constructor with a second argument
    specifying the real duration of one unit of time.  For example, if
    :func:`your_integer_time_func` returns times measured in thousands of seconds,
-   you would constuct the :class:`Profile` instance as follows::
+   you would construct the :class:`Profile` instance as follows::
 
       pr = profile.Profile(your_integer_time_func, 0.001)
 
    As the :mod:`cProfile.Profile` class cannot be calibrated, custom timer
    functions should be used with care and should be as fast as possible.  For the
    best results with a custom timer, it might be necessary to hard-code it in the C
    source of the internal :mod:`_lsprof` module.
 
 .. rubric:: Footnotes
 
 .. [#] Updated and converted to LaTeX by Guido van Rossum. Further updated by Armin
    Rigo to integrate the documentation for the new :mod:`cProfile` module of Python

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/pickle.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -16,47 +16,53 @@</span>
 
 The :mod:`pickle` module implements a fundamental, but powerful algorithm for
 serializing and de-serializing a Python object structure.  &quot;Pickling&quot; is the
 process whereby a Python object hierarchy is converted into a byte stream, and
 &quot;unpickling&quot; is the inverse operation, whereby a byte stream is converted back
 into an object hierarchy.  Pickling (and unpickling) is alternatively known as
 &quot;serialization&quot;, &quot;marshalling,&quot; [#]_ or &quot;flattening&quot;, however, to avoid
 confusion, the terms used here are &quot;pickling&quot; and &quot;unpickling&quot;.
 
 This documentation describes both the :mod:`pickle` module and the
 :mod:`cPickle` module.
 
<span class="gi">+.. warning::</span>
<span class="gi">+</span>
<span class="gi">+   The :mod:`pickle` module is not intended to be secure against erroneous or</span>
<span class="gi">+   maliciously constructed data.  Never unpickle data received from an untrusted</span>
<span class="gi">+   or unauthenticated source.</span>
<span class="gi">+</span>
 
 Relationship to other Python modules
 ------------------------------------
 
 The :mod:`pickle` module has an optimized cousin called the :mod:`cPickle`
 module.  As its name implies, :mod:`cPickle` is written in C, so it can be up to
 1000 times faster than :mod:`pickle`.  However it does not support subclassing
 of the :func:`Pickler` and :func:`Unpickler` classes, because in :mod:`cPickle`
 these are functions, not classes.  Most applications have no need for this
 functionality, and can benefit from the improved performance of :mod:`cPickle`.
 Other than that, the interfaces of the two modules are nearly identical; the
 common interface is described in this manual and differences are pointed out
 where necessary.  In the following discussions, we use the term &quot;pickle&quot; to
 collectively describe the :mod:`pickle` and :mod:`cPickle` modules.
 
 The data streams the two modules produce are guaranteed to be interchangeable.
 
 Python has a more primitive serialization module called :mod:`marshal`, but in
 general :mod:`pickle` should always be the preferred way to serialize Python
 objects.  :mod:`marshal` exists primarily to support Python&#39;s :file:`.pyc`
 files.
 
<span class="gd">-The :mod:`pickle` module differs from :mod:`marshal` several significant ways:</span>
<span class="gi">+The :mod:`pickle` module differs from :mod:`marshal` in several significant ways:</span>
 
 * The :mod:`pickle` module keeps track of the objects it has already serialized,
   so that later references to the same object won&#39;t be serialized again.
   :mod:`marshal` doesn&#39;t do this.
 
   This has implications both for recursive objects and object sharing.  Recursive
   objects are objects that contain references to themselves.  These are not
   handled by marshal, and in fact, attempting to marshal recursive objects will
   crash your Python interpreter.  Object sharing happens when there are multiple
   references to the same object in different places in the object hierarchy being
   serialized.  :mod:`pickle` stores such objects only once, and ensures that all
   other references point to the master copy.  Shared objects remain shared, which
<span class="gu">@@ -65,30 +71,24 @@</span>
 * :mod:`marshal` cannot be used to serialize user-defined classes and their
   instances.  :mod:`pickle` can save and restore class instances transparently,
   however the class definition must be importable and live in the same module as
   when the object was stored.
 
 * The :mod:`marshal` serialization format is not guaranteed to be portable
   across Python versions.  Because its primary job in life is to support
   :file:`.pyc` files, the Python implementers reserve the right to change the
   serialization format in non-backwards compatible ways should the need arise.
   The :mod:`pickle` serialization format is guaranteed to be backwards compatible
   across Python releases.
 
<span class="gd">-.. warning::</span>
<span class="gd">-</span>
<span class="gd">-   The :mod:`pickle` module is not intended to be secure against erroneous or</span>
<span class="gd">-   maliciously constructed data.  Never unpickle data received from an untrusted</span>
<span class="gd">-   or unauthenticated source.</span>
<span class="gd">-</span>
 Note that serialization is a more primitive notion than persistence; although
 :mod:`pickle` reads and writes file objects, it does not handle the issue of
 naming persistent objects, nor the (even more complicated) issue of concurrent
 access to persistent objects.  The :mod:`pickle` module can transform a complex
 object into a byte stream and it can transform the byte stream into an object
 with the same internal structure.  Perhaps the most obvious thing to do with
 these byte streams is to write them onto a file, but it is also conceivable to
 send them across a network or store them in a database.  The module
 :mod:`shelve` provides a simple interface to pickle and unpickle objects on
 DBM-style database files.
 
 
<span class="gu">@@ -435,25 +435,25 @@</span>
 
    where *args* is the result of calling :meth:`__getnewargs__` on the original
    object; if there is no :meth:`__getnewargs__`, an empty tuple is assumed.
 
 .. method:: object.__getstate__()
 
    Classes can further influence how their instances are pickled; if the class
    defines the method :meth:`__getstate__`, it is called and the return state is
    pickled as the contents for the instance, instead of the contents of the
    instance&#39;s dictionary.  If there is no :meth:`__getstate__` method, the
    instance&#39;s :attr:`__dict__` is pickled.
 
<span class="gd">-.. method:: object.__setstate__()</span>
<span class="gi">+.. method:: object.__setstate__(state)</span>
 
    Upon unpickling, if the class also defines the method :meth:`__setstate__`,
    it is called with the unpickled state. [#]_ If there is no
    :meth:`__setstate__` method, the pickled state must be a dictionary and its
    items are assigned to the new instance&#39;s dictionary.  If a class defines both
    :meth:`__getstate__` and :meth:`__setstate__`, the state object needn&#39;t be a
    dictionary and these methods can do what they want. [#]_
 
    .. note::
 
       For :term:`new-style class`\es, if :meth:`__getstate__` returns a false
       value, the :meth:`__setstate__` method will not be called.
</pre></div>

</body>
</html>
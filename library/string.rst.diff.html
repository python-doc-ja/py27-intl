<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/string.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -8,24 +8,29 @@</span>
 .. index:: module: re
 
 The :mod:`string` module contains a number of useful constants and
 classes, as well as some deprecated legacy functions that are also
 available as methods on strings. In addition, Python&#39;s built-in string
 classes support the sequence type methods described in the
 :ref:`typesseq` section, and also the string-specific methods described
 in the :ref:`string-methods` section. To output formatted strings use
 template strings or the ``%`` operator described in the
 :ref:`string-formatting` section. Also, see the :mod:`re` module for
 string functions based on regular expressions.
 
<span class="gi">+.. seealso::</span>
<span class="gi">+</span>
<span class="gi">+   Latest version of the `string module Python source code</span>
<span class="gi">+   &lt;http://svn.python.org/view/python/branches/release27-maint/Lib/string.py?view=markup&gt;`_</span>
<span class="gi">+</span>
 
 String constants
 ----------------
 
 The constants defined in this module are:
 
 
 .. data:: ascii_letters
 
    The concatenation of the :const:`ascii_lowercase` and :const:`ascii_uppercase`
    constants described below.  This value is not locale-dependent.
 
<span class="gu">@@ -109,48 +114,48 @@</span>
 
 The built-in str and unicode classes provide the ability
 to do complex variable substitutions and value formatting via the
 :meth:`str.format` method described in :pep:`3101`.  The :class:`Formatter`
 class in the :mod:`string` module allows you to create and customize your own
 string formatting behaviors using the same implementation as the built-in
 :meth:`format` method.
 
 .. class:: Formatter
 
    The :class:`Formatter` class has the following public methods:
 
<span class="gd">-   .. method:: format(format_string, *args, *kwargs)</span>
<span class="gi">+   .. method:: format(format_string, *args, **kwargs)</span>
 
       :meth:`format` is the primary API method.  It takes a format template
       string, and an arbitrary set of positional and keyword argument.
       :meth:`format` is just a wrapper that calls :meth:`vformat`.
 
    .. method:: vformat(format_string, args, kwargs)
 
       This function does the actual work of formatting.  It is exposed as a
       separate function for cases where you want to pass in a predefined
       dictionary of arguments, rather than unpacking and repacking the
       dictionary as individual arguments using the ``*args`` and ``**kwds``
       syntax.  :meth:`vformat` does the work of breaking up the format template
       string into character data and replacement fields.  It calls the various
       methods described below.
 
    In addition, the :class:`Formatter` defines a number of methods that are
    intended to be replaced by subclasses:
 
    .. method:: parse(format_string)
 
       Loop over the format_string and return an iterable of tuples
       (*literal_text*, *field_name*, *format_spec*, *conversion*).  This is used
<span class="gd">-      by :meth:`vformat` to break the string in to either literal text, or</span>
<span class="gi">+      by :meth:`vformat` to break the string into either literal text, or</span>
       replacement fields.
 
       The values in the tuple conceptually represent a span of literal text
       followed by a single replacement field.  If there is no literal text
       (which can happen if two replacement fields occur consecutively), then
       *literal_text* will be a zero-length string.  If there is no replacement
       field, then the values of *field_name*, *format_spec* and *conversion*
       will be ``None``.
 
    .. method:: get_field(field_name, args, kwargs)
 
       Given *field_name* as returned by :meth:`parse` (see above), convert it to
<span class="gu">@@ -181,25 +186,25 @@</span>
       built-in :func:`getattr` function.
 
       If the index or keyword refers to an item that does not exist, then an
       :exc:`IndexError` or :exc:`KeyError` should be raised.
 
    .. method:: check_unused_args(used_args, args, kwargs)
 
       Implement checking for unused arguments if desired.  The arguments to this
       function is the set of all argument keys that were actually referred to in
       the format string (integers for positional arguments, and strings for
       named arguments), and a reference to the *args* and *kwargs* that was
       passed to vformat.  The set of unused args can be calculated from these
<span class="gd">-      parameters.  :meth:`check_unused_args` is assumed to throw an exception if</span>
<span class="gi">+      parameters.  :meth:`check_unused_args` is assumed to raise an exception if</span>
       the check fails.
 
    .. method:: format_field(value, format_spec)
 
       :meth:`format_field` simply calls the global :func:`format` built-in.  The
       method is provided so that subclasses can override it.
 
    .. method:: convert_field(value, conversion)
 
       Converts the value (returned by :meth:`get_field`) given a conversion type
       (as in the tuple returned by the :meth:`parse` method).  The default
       version understands &#39;r&#39; (repr) and &#39;s&#39; (str) conversion types.
<span class="gu">@@ -213,50 +218,61 @@</span>
 The :meth:`str.format` method and the :class:`Formatter` class share the same
 syntax for format strings (although in the case of :class:`Formatter`,
 subclasses can define their own format string syntax).
 
 Format strings contain &quot;replacement fields&quot; surrounded by curly braces ``{}``.
 Anything that is not contained in braces is considered literal text, which is
 copied unchanged to the output.  If you need to include a brace character in the
 literal text, it can be escaped by doubling: ``{{`` and ``}}``.
 
 The grammar for a replacement field is as follows:
 
    .. productionlist:: sf
<span class="gd">-      replacement_field: &quot;{&quot; `field_name` [&quot;!&quot; `conversion`] [&quot;:&quot; `format_spec`] &quot;}&quot;</span>
<span class="gd">-      field_name: (`identifier` | `integer`) (&quot;.&quot; `attribute_name` | &quot;[&quot; `element_index` &quot;]&quot;)*</span>
<span class="gi">+      replacement_field: &quot;{&quot; [`field_name`] [&quot;!&quot; `conversion`] [&quot;:&quot; `format_spec`] &quot;}&quot;</span>
<span class="gi">+      field_name: arg_name (&quot;.&quot; `attribute_name` | &quot;[&quot; `element_index` &quot;]&quot;)*</span>
<span class="gi">+      arg_name: [`identifier` | `integer`]</span>
       attribute_name: `identifier`
       element_index: `integer` | `index_string`
       index_string: &lt;any source character except &quot;]&quot;&gt; +
       conversion: &quot;r&quot; | &quot;s&quot;
       format_spec: &lt;described in the next section&gt;
 
<span class="gd">-In less formal terms, the replacement field starts with a *field_name*, which</span>
<span class="gd">-can either be a number (for a positional argument), or an identifier (for</span>
<span class="gd">-keyword arguments).  Following this is an optional *conversion* field, which is</span>
<span class="gi">+In less formal terms, the replacement field can start with a *field_name* that specifies</span>
<span class="gi">+the object whose value is to be formatted and inserted</span>
<span class="gi">+into the output instead of the replacement field.</span>
<span class="gi">+The *field_name* is optionally followed by a  *conversion* field, which is</span>
 preceded by an exclamation point ``&#39;!&#39;``, and a *format_spec*, which is preceded
<span class="gd">-by a colon ``&#39;:&#39;``.</span>
<span class="gi">+by a colon ``&#39;:&#39;``.  These specify a non-default format for the replacement value.</span>
 
 See also the :ref:`formatspec` section.
 
<span class="gd">-The *field_name* itself begins with either a number or a keyword.  If it&#39;s a</span>
<span class="gd">-number, it refers to a positional argument, and if it&#39;s a keyword it refers to a</span>
<span class="gd">-named keyword argument.  This can be followed by any number of index or</span>
<span class="gi">+The *field_name* itself begins with an *arg_name* that is either either a number or a</span>
<span class="gi">+keyword.  If it&#39;s a number, it refers to a positional argument, and if it&#39;s a keyword,</span>
<span class="gi">+it refers to a named keyword argument.  If the numerical arg_names in a format string</span>
<span class="gi">+are 0, 1, 2, ... in sequence, they can all be omitted (not just some)</span>
<span class="gi">+and the numbers 0, 1, 2, ... will be automatically inserted in that order.</span>
<span class="gi">+The *arg_name* can be followed by any number of index or</span>
 attribute expressions. An expression of the form ``&#39;.name&#39;`` selects the named
 attribute using :func:`getattr`, while an expression of the form ``&#39;[index]&#39;``
 does an index lookup using :func:`__getitem__`.
 
<span class="gi">+.. versionchanged:: 2.7</span>
<span class="gi">+   The positional argument specifiers can be omitted, so ``&#39;{} {}&#39;`` is</span>
<span class="gi">+   equivalent to ``&#39;{0} {1}&#39;``.</span>
<span class="gi">+</span>
 Some simple format string examples::
 
    &quot;First, thou shalt count to {0}&quot; # References first positional argument
<span class="gi">+   &quot;Bring me a {}&quot;                  # Implicitly references the first positional argument</span>
<span class="gi">+   &quot;From {} to {}&quot;                  # Same as &quot;From {0} to {1}&quot;</span>
    &quot;My quest is {name}&quot;             # References keyword argument &#39;name&#39;
    &quot;Weight in tons {0.weight}&quot;      # &#39;weight&#39; attribute of first positional arg
    &quot;Units destroyed: {players[0]}&quot;  # First element of keyword argument &#39;players&#39;.
 
 The *conversion* field causes a type coercion before formatting.  Normally, the
 job of formatting a value is done by the :meth:`__format__` method of the value
 itself.  However, in some cases it is desirable to force a type to be formatted
 as a string, overriding its own definition of formatting.  By converting the
 value to a string before calling :meth:`__format__`, the normal formatting logic
 is bypassed.
 
 Two conversion flags are currently supported: ``&#39;!s&#39;`` which calls :func:`str`
<span class="gu">@@ -296,48 +312,48 @@</span>
 specification is to be interpreted.
 
 Most built-in types implement the following options for format specifications,
 although some of the formatting options are only supported by the numeric types.
 
 A general convention is that an empty format string (``&quot;&quot;``) produces
 the same result as if you had called :func:`str` on the value. A
 non-empty format string typically modifies the result.
 
 The general form of a *standard format specifier* is:
 
 .. productionlist:: sf
<span class="gd">-   format_spec: [[`fill`]`align`][`sign`][#][0][`width`][.`precision`][`type`]</span>
<span class="gi">+   format_spec: [[`fill`]`align`][`sign`][#][0][`width`][,][.`precision`][`type`]</span>
    fill: &lt;a character other than &#39;}&#39;&gt;
    align: &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;
    sign: &quot;+&quot; | &quot;-&quot; | &quot; &quot;
    width: `integer`
    precision: `integer`
    type: &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;
 
<span class="gd">-The *fill* character can be any character other than &#39;}&#39; (which signifies the</span>
<span class="gd">-end of the field).  The presence of a fill character is signaled by the *next*</span>
<span class="gd">-character, which must be one of the alignment options. If the second character</span>
<span class="gd">-of *format_spec* is not a valid alignment option, then it is assumed that both</span>
<span class="gd">-the fill character and the alignment option are absent.</span>
<span class="gi">+The *fill* character can be any character other than &#39;{&#39; or &#39;}&#39;.  The presence</span>
<span class="gi">+of a fill character is signaled by the character following it, which must be</span>
<span class="gi">+one of the alignment options.  If the second character of *format_spec* is not</span>
<span class="gi">+a valid alignment option, then it is assumed that both the fill character and</span>
<span class="gi">+the alignment option are absent.</span>
 
 The meaning of the various alignment options is as follows:
 
    +---------+----------------------------------------------------------+
    | Option  | Meaning                                                  |
    +=========+==========================================================+
    | ``&#39;&lt;&#39;`` | Forces the field to be left-aligned within the available |
<span class="gd">-   |         | space (this is the default).                             |</span>
<span class="gi">+   |         | space (this is the default for most objects).            |</span>
    +---------+----------------------------------------------------------+
    | ``&#39;&gt;&#39;`` | Forces the field to be right-aligned within the          |
<span class="gd">-   |         | available space.                                         |</span>
<span class="gi">+   |         | available space (this is the default for numbers).       |</span>
    +---------+----------------------------------------------------------+
    | ``&#39;=&#39;`` | Forces the padding to be placed after the sign (if any)  |
    |         | but before the digits.  This is used for printing fields |
    |         | in the form &#39;+000000120&#39;. This alignment option is only  |
    |         | valid for numeric types.                                 |
    +---------+----------------------------------------------------------+
    | ``&#39;^&#39;`` | Forces the field to be centered within the available     |
    |         | space.                                                   |
    +---------+----------------------------------------------------------+
 
 Note that unless a minimum field width is defined, the field width will always
 be the same size as the data to fill it, so that the alignment option has no
<span class="gu">@@ -354,24 +370,31 @@</span>
    +---------+----------------------------------------------------------+
    | ``&#39;-&#39;`` | indicates that a sign should be used only for negative   |
    |         | numbers (this is the default behavior).                  |
    +---------+----------------------------------------------------------+
    | space   | indicates that a leading space should be used on         |
    |         | positive numbers, and a minus sign on negative numbers.  |
    +---------+----------------------------------------------------------+
 
 The ``&#39;#&#39;`` option is only valid for integers, and only for binary, octal, or
 hexadecimal output.  If present, it specifies that the output will be prefixed
 by ``&#39;0b&#39;``, ``&#39;0o&#39;``, or ``&#39;0x&#39;``, respectively.
 
<span class="gi">+The ``&#39;,&#39;`` option signals the use of a comma for a thousands separator.</span>
<span class="gi">+For a locale aware separator, use the ``&#39;n&#39;`` integer presentation type</span>
<span class="gi">+instead.</span>
<span class="gi">+</span>
<span class="gi">+.. versionchanged:: 2.7</span>
<span class="gi">+   Added the ``&#39;,&#39;`` option (see also :pep:`378`).</span>
<span class="gi">+</span>
 *width* is a decimal integer defining the minimum field width.  If not
 specified, then the field width will be determined by the content.
 
 If the *width* field is preceded by a zero (``&#39;0&#39;``) character, this enables
 zero-padding.  This is equivalent to an *alignment* type of ``&#39;=&#39;`` and a *fill*
 character of ``&#39;0&#39;``.
 
 The *precision* is a decimal number indicating how many digits should be
 displayed after the decimal point for a floating point value formatted with
 ``&#39;f&#39;`` and ``&#39;F&#39;``, or before and after the decimal point for a floating point
 value formatted with ``&#39;g&#39;`` or ``&#39;G&#39;``.  For non-number types the field
 indicates the maximum field size - in other words, how many characters will be
<span class="gu">@@ -445,25 +468,25 @@</span>
    |         |                                                          |
    |         | The precise rules are as follows: suppose that the       |
    |         | result formatted with presentation type ``&#39;e&#39;`` and      |
    |         | precision ``p-1`` would have exponent ``exp``.  Then     |
    |         | if ``-4 &lt;= exp &lt; p``, the number is formatted            |
    |         | with presentation type ``&#39;f&#39;`` and precision             |
    |         | ``p-1-exp``.  Otherwise, the number is formatted         |
    |         | with presentation type ``&#39;e&#39;`` and precision ``p-1``.    |
    |         | In both cases insignificant trailing zeros are removed   |
    |         | from the significand, and the decimal point is also      |
    |         | removed if there are no remaining digits following it.   |
    |         |                                                          |
<span class="gd">-   |         | Postive and negative infinity, positive and negative     |</span>
<span class="gi">+   |         | Positive and negative infinity, positive and negative    |</span>
    |         | zero, and nans, are formatted as ``inf``, ``-inf``,      |
    |         | ``0``, ``-0`` and ``nan`` respectively, regardless of    |
    |         | the precision.                                           |
    |         |                                                          |
    |         | A precision of ``0`` is treated as equivalent to a       |
    |         | precision of ``1``.                                      |
    +---------+----------------------------------------------------------+
    | ``&#39;G&#39;`` | General format. Same as ``&#39;g&#39;`` except switches to       |
    |         | ``&#39;E&#39;`` if the number gets too large. The                |
    |         | representations of infinity and NaN are uppercased, too. |
    +---------+----------------------------------------------------------+
    | ``&#39;n&#39;`` | Number. This is the same as ``&#39;g&#39;``, except that it uses |
<span class="gu">@@ -479,33 +502,35 @@</span>
 
 
 .. _formatexamples:
 
 Format examples
 ^^^^^^^^^^^^^^^
 
 This section contains examples of the new format syntax and comparison with
 the old ``%``-formatting.
 
 In most of the cases the syntax is similar to the old ``%``-formatting, with the
 addition of the ``{}`` and with ``:`` used instead of ``%``.
<span class="gd">-For example, ``&#39;%03.2f&#39;`` can be translated to ``&#39;{0:03.2f}&#39;``.</span>
<span class="gi">+For example, ``&#39;%03.2f&#39;`` can be translated to ``&#39;{:03.2f}&#39;``.</span>
 
 The new format syntax also supports new and different options, shown in the
 follow examples.
 
 Accessing arguments by position::
 
    &gt;&gt;&gt; &#39;{0}, {1}, {2}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
    &#39;a, b, c&#39;
<span class="gi">+   &gt;&gt;&gt; &#39;{}, {}, {}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)  # 2.7+ only</span>
<span class="gi">+   &#39;a, b, c&#39;</span>
    &gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
    &#39;c, b, a&#39;
    &gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(*&#39;abc&#39;)      # unpacking argument sequence
    &#39;c, b, a&#39;
    &gt;&gt;&gt; &#39;{0}{1}{0}&#39;.format(&#39;abra&#39;, &#39;cad&#39;)   # arguments&#39; indices can be repeated
    &#39;abracadabra&#39;
 
 Accessing arguments by name::
 
    &gt;&gt;&gt; &#39;Coordinates: {latitude}, {longitude}&#39;.format(latitude=&#39;37.24N&#39;, longitude=&#39;-115.81W&#39;)
    &#39;Coordinates: 37.24N, -115.81W&#39;
    &gt;&gt;&gt; coord = {&#39;latitude&#39;: &#39;37.24N&#39;, &#39;longitude&#39;: &#39;-115.81W&#39;}
<span class="gu">@@ -527,81 +552,86 @@</span>
    &gt;&gt;&gt; str(Point(4, 2))
    &#39;Point(4, 2)&#39;
 
 
 Accessing arguments&#39; items::
 
    &gt;&gt;&gt; coord = (3, 5)
    &gt;&gt;&gt; &#39;X: {0[0]};  Y: {0[1]}&#39;.format(coord)
    &#39;X: 3;  Y: 5&#39;
 
 Replacing ``%s`` and ``%r``::
 
<span class="gd">-   &gt;&gt;&gt; &quot;repr() shows quotes: {0!r}; str() doesn&#39;t: {1!s}&quot;.format(&#39;test1&#39;, &#39;test2&#39;)</span>
<span class="gi">+   &gt;&gt;&gt; &quot;repr() shows quotes: {!r}; str() doesn&#39;t: {!s}&quot;.format(&#39;test1&#39;, &#39;test2&#39;)</span>
    &quot;repr() shows quotes: &#39;test1&#39;; str() doesn&#39;t: test2&quot;
 
 Aligning the text and specifying a width::
 
<span class="gd">-   &gt;&gt;&gt; &#39;{0:&lt;30}&#39;.format(&#39;left aligned&#39;)</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:&lt;30}&#39;.format(&#39;left aligned&#39;)</span>
    &#39;left aligned                  &#39;
<span class="gd">-   &gt;&gt;&gt; &#39;{0:&gt;30}&#39;.format(&#39;right aligned&#39;)</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:&gt;30}&#39;.format(&#39;right aligned&#39;)</span>
    &#39;                 right aligned&#39;
<span class="gd">-   &gt;&gt;&gt; &#39;{0:^30}&#39;.format(&#39;centered&#39;)</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:^30}&#39;.format(&#39;centered&#39;)</span>
    &#39;           centered           &#39;
<span class="gd">-   &gt;&gt;&gt; &#39;{0:*^30}&#39;.format(&#39;centered&#39;)  # use &#39;*&#39; as a fill char</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:*^30}&#39;.format(&#39;centered&#39;)  # use &#39;*&#39; as a fill char</span>
    &#39;***********centered***********&#39;
 
 Replacing ``%+f``, ``%-f``, and ``% f`` and specifying a sign::
 
<span class="gd">-   &gt;&gt;&gt; &#39;{0:+f}; {0:+f}&#39;.format(3.14, -3.14)  # show it always</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:+f}; {:+f}&#39;.format(3.14, -3.14)  # show it always</span>
    &#39;+3.140000; -3.140000&#39;
<span class="gd">-   &gt;&gt;&gt; &#39;{0: f}; {0: f}&#39;.format(3.14, -3.14)  # show a space for positive numbers</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{: f}; {: f}&#39;.format(3.14, -3.14)  # show a space for positive numbers</span>
    &#39; 3.140000; -3.140000&#39;
<span class="gd">-   &gt;&gt;&gt; &#39;{0:-f}; {0:-f}&#39;.format(3.14, -3.14)  # show only the minus -- same as &#39;{0:f}; {0:f}&#39;</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:-f}; {:-f}&#39;.format(3.14, -3.14)  # show only the minus -- same as &#39;{:f}; {:f}&#39;</span>
    &#39;3.140000; -3.140000&#39;
 
 Replacing ``%x`` and ``%o`` and converting the value to different bases::
 
    &gt;&gt;&gt; # format also supports binary numbers
    &gt;&gt;&gt; &quot;int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}&quot;.format(42)
    &#39;int: 42;  hex: 2a;  oct: 52;  bin: 101010&#39;
    &gt;&gt;&gt; # with 0x, 0o, or 0b as prefix:
    &gt;&gt;&gt; &quot;int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}&quot;.format(42)
    &#39;int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010&#39;
 
<span class="gi">+Using the comma as a thousands separator::</span>
<span class="gi">+</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:,}&#39;.format(1234567890)</span>
<span class="gi">+   &#39;1,234,567,890&#39;</span>
<span class="gi">+</span>
 Expressing a percentage::
 
    &gt;&gt;&gt; points = 19.5
    &gt;&gt;&gt; total = 22
<span class="gd">-   &gt;&gt;&gt; &#39;Correct answers: {0:.2%}.&#39;.format(points/total)</span>
<span class="gi">+   &gt;&gt;&gt; &#39;Correct answers: {:.2%}.&#39;.format(points/total)</span>
    &#39;Correct answers: 88.64%&#39;
 
 Using type-specific formatting::
 
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; d = datetime.datetime(2010, 7, 4, 12, 15, 58)
<span class="gd">-   &gt;&gt;&gt; &#39;{0:%Y-%m-%d %H:%M:%S}&#39;.format(d)</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:%Y-%m-%d %H:%M:%S}&#39;.format(d)</span>
    &#39;2010-07-04 12:15:58&#39;
 
 Nesting arguments and more complex examples::
 
    &gt;&gt;&gt; for align, text in zip(&#39;&lt;^&gt;&#39;, [&#39;left&#39;, &#39;center&#39;, &#39;right&#39;]):
<span class="gd">-   ...     &#39;{0:{align}{fill}16}&#39;.format(text, fill=align, align=align)</span>
<span class="gi">+   ...     &#39;{0:{fill}{align}16}&#39;.format(text, fill=align, align=align)</span>
    ...
    &#39;left&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;
    &#39;^^^^^center^^^^^&#39;
    &#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;right&#39;
    &gt;&gt;&gt;
    &gt;&gt;&gt; octets = [192, 168, 0, 1]
<span class="gd">-   &gt;&gt;&gt; &#39;{0:02X}{1:02X}{2:02X}{3:02X}&#39;.format(*octets)</span>
<span class="gi">+   &gt;&gt;&gt; &#39;{:02X}{:02X}{:02X}{:02X}&#39;.format(*octets)</span>
    &#39;C0A80001&#39;
    &gt;&gt;&gt; int(_, 16)
    3232235521
    &gt;&gt;&gt;
    &gt;&gt;&gt; width = 5
    &gt;&gt;&gt; for num in range(5,12):
    ...     for base in &#39;dXob&#39;:
    ...         print &#39;{0:{width}{base}}&#39;.format(num, base=base, width=width),
    ...     print
    ...
        5     5     5   101
        6     6     6   110
</pre></div>

</body>
</html>
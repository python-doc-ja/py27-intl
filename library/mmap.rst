
:mod:`mmap` --- メモリマップファイル
====================================

.. module:: mmap
   :synopsis: Unix とWindowsのメモリマップファイルへのインターフェース


メモリにマップされたファイルオブジェクトは、 文字列とファイルオブジェクトの両方のように振舞います。
しかし通常の文字列オブジェクトとは異なり、これらは可変です。 文字列が期待されるほとんどの場所でmmapオブジェクトを利用できます。
例えば、メモリマップファイルを探索するために :mod:`re`モジュールを使うことができます。 それらは可変なので、 ``obj[index] = 'a'``
のように文字を 変換できますし、スライスを使うことで  ``obj[i1:i2] = '...'`` のように 部分文字列を変換することができます。
現在のファイル位置をデータの始めとする読込みや書込み、 ファイルの異なる位置へ:meth:`seek`することもできます。

メモリマップファイルはUnix上とWindows上とでは異なる :func:`mmap`関数によって作られます。
いずれの場合も、開いたファイルのディスクリプタを、 更新のために提供しなければなりません。 すでに存在するPythonファイルオブジェクトをマップしたい場合は、
*fileno*パラメータのための現在値を手に入れるために、 :meth:`fileno`メソッドを使用して下さい。
そうでなければ、ファイル・ディスクリプタを直接返す:func:`os.open`関数 (呼び出すときにはまだファイルが閉じている必要があります)を使って、
ファイルを開くことができます。

関数のUnixバージョンとWindowsバージョンのために、 オプションのキーワード・パラメータとして*access*を指定する ことになるかもしれません。
*access*は3つの値の内の1つを受け入れます。 :const:`ACCESS_READ`は読み込み専用、
:const:`ACCESS_WRITE`は書き込み可能、 :const:`ACCESS_COPY`はコピーした上での書き込みです。
*access*はUnixとWindowsの両方で使用することができます。
*access*が指定されない場合、Windowsのmmapは書き込み可能マップを返します。 3つのアクセス型すべてに対する初期メモリ値は、
指定されたファイルから得られます。 :const:`ACCESS_READ`を割り当てたメモリマップは :exc:`TypeError`例外を送出します。
:const:`ACCESS_WRITE`を割り当てたメモリマップは メモリと元のファイルの両方に影響を与えます。
:const:`ACCESS_COPY`を割り当てたメモリマップは メモリに影響を与えますが、元のファイルを更新することはありません。

.. versionchanged:: 2.5
   無名メモリ(anonymous memory)をマップするためにはfilenoとして -1 を渡して長さを与えてください.


.. function:: mmap(fileno, length[, tagname[, access]])

   **(Windows)**バージョンはファイルハンドル*fileno*によって 指定されたファイルから*length*バイトをマップして、
   mmapオブジェクトを返します。 *length*が現在のファイルサイズより大きな場合、ファイルサイズは *length*を含む大きさにまで拡張されます。
   *length*が``0``の場合、マップの最大の長さは Windowsが空ファイルで例外を起こす(Windowsでは空のマップを作成すること
   ができません。)ことを除いては、 :func:`mmap`が呼ばれたときのファイルサイズになります。

   *tagname*は、``None``以外で指定された場合、 マップのタグ名を与える文字列となります。
   Windowsは同じファイルに対する様々なマップを持つことを可能にします。 既存のタグの名前を指定すればそのタグがオープンされ、
   そうでなければこの名前の新しいタグが作成されます。 もしこのパラメータを省略したり``None``を与えたりしたならば、 マップは名前なしで作成されます。
   タグ・パラメータの使用の回避は、あなたのコードをUnixとWindowsの間で 移植可能にしておくのを助けてくれるでしょう。


.. function:: mmap(fileno, length[, flags[, prot[, access]]])
   :noindex:

   **(Unix)**バージョンは、ファイル・ディスクリプタ *fileno*に よって指定されたファイルから*length*バイトをマップし、
   mmapオブジェクトを返します。*length*が``0``の場合、 そのマップの最大長が現在のファイルサイズになります。

   *flags*はマップの種類を指定します。 :const:`MAP_PRIVATE`はプライベートなcopy-on-write(書込み時コピー)
   のマップを作成します。 従って、mmapオブジェクトの内容への変更はこのプロセス内にのみ有効です。
   :const:`MAP_SHARED`はファイルの同じ領域をマップする他のすべてのプロセス と共有されたマップを作成します。
   デフォルトは:const:`MAP_SHARED`です。

   *prot*が指定された場合、希望のメモリ保護を与えます。
   2つの最も有用な値は、:const:`PROT_READ`と:const:`PROT_WRITE`です。 これは、読込み可能または書込み可能を指定するものです。
   *prot*のデフォルトは:const:`PROT_READ \| PROT_WRITE`です。

   *access*はオプションのキーワード・パラメータとして、 *flags*と*prot*の代わりに指定してもかまいません。
   *flags*,*prot*と*access*の両方を指定することは間違っています。 このパラメーターを使用法についての情報は、
   *access*の記述を参照してください。

メモリマップフィイルオブジェクトは以下のメソッドをサポートしています:


.. method:: mmap.close()

   ファイルを閉じます。 この呼出しの後にオブジェクトの他のメソッドの呼出すことは、 例外の送出を引き起こすでしょう。


.. method:: mmap.find(string[, start])

   オブジェクト内で部分文字列*string*が見つかった場所の最も小さい インデックスを返します。 失敗したとき``-1``を返します。
   *start*は探索を始めたい場所のインデックスで、デフォルトは0です。


.. method:: mmap.flush([offset, size])

   ファイルのメモリコピー内での変更をディスクへフラッシュします。 この呼出しを使わなかった場合、オブジェクトが破壊される前に 変更が書き込まれる保証はありません。
   もし*offset*と*size*が指定された場合、与えられたバイトの範囲の 変更だけがディスクにフラッシュされます。
   指定されない場合、マップ全体がフラッシュされます。


.. method:: mmap.move(dest, src, count)

   オフセット*src*からインデックス*dest*へ*count*バイトだけ コピーします。
   もしmmapが:const:`ACCESS_READ`で作成されていた場合、 :exc:`TypeError`例外を送出します。


.. method:: mmap.read(num)

   現在のファイル位置から*num*バイトの文字列を返します。 ファイル位置は返したバイトの分だけ後ろの位置へ更新されます。


.. method:: mmap.read_byte()

   現在のファイル位置から長さ1の文字列を返します。 ファイル位置は1だけ進みます。


.. method:: mmap.readline()

   現在のファイル位置から次の新しい行までの、1行を返します。


.. method:: mmap.resize(newsize)

   マップと元ファイルのサイズを変更します。 もしmmapが:const:`ACCESS_READ`または:const:`ACCESS_COPY`で
   作成されたならば、マップのリサイズは:exc:`TypeError`例外を送出します。


.. method:: mmap.seek(pos[, whence])

   ファイルの現在位置をセットします。 *whence*引数はオプションであり、デフォルトは``0``\ (絶対位置)です。 その他の値として、``1``\
   (現在位置からの相対位置)と ``2``\ (ファイルの終わりからの相対位置)があります。


.. method:: mmap.size()

   ファイルの長さを返します。 メモリマップ領域のサイズより大きいかもしれません。


.. method:: mmap.tell()

   ファイル・ポインタの現在位置を返します。


.. method:: mmap.write(string)

   メモリ内のファイル・ポインタの現在位置から*string*のバイト列を 書き込みます。 ファイル位置はバイト列が書き込まれた後の位置へ更新されます。
   もしmmapが:const:`ACCESS_READ`で作成されていた場合、 書き込み時に:exc:`TypeError`例外が送出されるでしょう。


.. method:: mmap.write_byte(byte)

   メモリ内のファイル・ポインタの現在位置から 単一文字の文字列*byte*を書き込みます。 ファイル位置は``1``だけ進みます。
   もしmmapが:const:`ACCESS_READ`で作成されていた場合、 書き込み時に:exc:`TypeError`例外が送出されるでしょう。


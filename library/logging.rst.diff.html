<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/logging.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -1,609 +1,664 @@</span>
 :mod:`logging` --- Logging facility for Python
 ==============================================
 
 .. module:: logging
<span class="gd">-   :synopsis: Flexible error logging system for applications.</span>
<span class="gi">+   :synopsis: Flexible event logging system for applications.</span>
 
 
 .. moduleauthor:: Vinay Sajip &lt;vinay_sajip@red-dove.com&gt;
 .. sectionauthor:: Vinay Sajip &lt;vinay_sajip@red-dove.com&gt;
 
 
 .. index:: pair: Errors; logging
 
<span class="gi">+.. sidebar:: Important</span>
<span class="gi">+</span>
<span class="gi">+   This page contains the API reference information. For tutorial</span>
<span class="gi">+   information and discussion of more advanced topics, see</span>
<span class="gi">+</span>
<span class="gi">+   * :ref:`Basic Tutorial &lt;logging-basic-tutorial&gt;`</span>
<span class="gi">+   * :ref:`Advanced Tutorial &lt;logging-advanced-tutorial&gt;`</span>
<span class="gi">+   * :ref:`Logging Cookbook &lt;logging-cookbook&gt;`</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. versionadded:: 2.3
 
<span class="gd">-This module defines functions and classes which implement a flexible error</span>
<span class="gd">-logging system for applications.</span>
<span class="gd">-</span>
<span class="gd">-Logging is performed by calling methods on instances of the :class:`Logger`</span>
<span class="gd">-class (hereafter called :dfn:`loggers`). Each instance has a name, and they are</span>
<span class="gd">-conceptually arranged in a namespace hierarchy using dots (periods) as</span>
<span class="gd">-separators. For example, a logger named &quot;scan&quot; is the parent of loggers</span>
<span class="gd">-&quot;scan.text&quot;, &quot;scan.html&quot; and &quot;scan.pdf&quot;. Logger names can be anything you want,</span>
<span class="gd">-and indicate the area of an application in which a logged message originates.</span>
<span class="gd">-</span>
<span class="gd">-Logged messages also have levels of importance associated with them. The default</span>
<span class="gd">-levels provided are :const:`DEBUG`, :const:`INFO`, :const:`WARNING`,</span>
<span class="gd">-:const:`ERROR` and :const:`CRITICAL`. As a convenience, you indicate the</span>
<span class="gd">-importance of a logged message by calling an appropriate method of</span>
<span class="gd">-:class:`Logger`. The methods are :meth:`debug`, :meth:`info`, :meth:`warning`,</span>
<span class="gd">-:meth:`error` and :meth:`critical`, which mirror the default levels. You are not</span>
<span class="gd">-constrained to use these levels: you can specify your own and use a more general</span>
<span class="gd">-:class:`Logger` method, :meth:`log`, which takes an explicit level argument.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Logging tutorial</span>
<span class="gd">-----------------</span>
<span class="gi">+This module defines functions and classes which implement a flexible event</span>
<span class="gi">+logging system for applications and libraries.</span>
 
 The key benefit of having the logging API provided by a standard library module
 is that all Python modules can participate in logging, so your application log
<span class="gd">-can include messages from third-party modules.</span>
<span class="gi">+can include your own messages integrated with messages from third-party</span>
<span class="gi">+modules.</span>
 
<span class="gd">-It is, of course, possible to log messages with different verbosity levels or to</span>
<span class="gd">-different destinations.  Support for writing log messages to files, HTTP</span>
<span class="gd">-GET/POST locations, email via SMTP, generic sockets, or OS-specific logging</span>
<span class="gd">-mechanisms are all supported by the standard module.  You can also create your</span>
<span class="gd">-own log destination class if you have special requirements not met by any of the</span>
<span class="gd">-built-in classes.</span>
<span class="gi">+The module provides a lot of functionality and flexibility.  If you are</span>
<span class="gi">+unfamiliar with logging, the best way to get to grips with it is to see the</span>
<span class="gi">+tutorials (see the links on the right).</span>
 
<span class="gd">-Simple examples</span>
<span class="gd">-^^^^^^^^^^^^^^^</span>
<span class="gi">+The basic classes defined by the module, together with their functions, are</span>
<span class="gi">+listed below.</span>
 
<span class="gd">-.. sectionauthor:: Doug Hellmann</span>
<span class="gd">-.. (see &lt;http://blog.doughellmann.com/2007/05/pymotw-logging.html&gt;)</span>
<span class="gi">+* Loggers expose the interface that application code directly uses.</span>
<span class="gi">+* Handlers send the log records (created by loggers) to the appropriate</span>
<span class="gi">+  destination.</span>
<span class="gi">+* Filters provide a finer grained facility for determining which log records</span>
<span class="gi">+  to output.</span>
<span class="gi">+* Formatters specify the layout of log records in the final output.</span>
 
<span class="gd">-Most applications are probably going to want to log to a file, so let&#39;s start</span>
<span class="gd">-with that case. Using the :func:`basicConfig` function, we can set up the</span>
<span class="gd">-default handler so that debug messages are written to a file (in the example,</span>
<span class="gd">-we assume that you have the appropriate permissions to create a file called</span>
<span class="gd">-*example.log* in the current directory)::</span>
 
<span class="gd">-   import logging</span>
<span class="gd">-   LOG_FILENAME = &#39;example.log&#39;</span>
<span class="gd">-   logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)</span>
<span class="gi">+.. _logger:</span>
 
<span class="gd">-   logging.debug(&#39;This message should go to the log file&#39;)</span>
<span class="gd">-</span>
<span class="gd">-And now if we open the file and look at what we have, we should find the log</span>
<span class="gd">-message::</span>
<span class="gd">-</span>
<span class="gd">-   DEBUG:root:This message should go to the log file</span>
<span class="gd">-</span>
<span class="gd">-If you run the script repeatedly, the additional log messages are appended to</span>
<span class="gd">-the file.  To create a new file each time, you can pass a *filemode* argument to</span>
<span class="gd">-:func:`basicConfig` with a value of ``&#39;w&#39;``.  Rather than managing the file size</span>
<span class="gd">-yourself, though, it is simpler to use a :class:`RotatingFileHandler`::</span>
<span class="gd">-</span>
<span class="gd">-   import glob</span>
<span class="gd">-   import logging</span>
<span class="gd">-   import logging.handlers</span>
<span class="gd">-</span>
<span class="gd">-   LOG_FILENAME = &#39;logging_rotatingfile_example.out&#39;</span>
<span class="gd">-</span>
<span class="gd">-   # Set up a specific logger with our desired output level</span>
<span class="gd">-   my_logger = logging.getLogger(&#39;MyLogger&#39;)</span>
<span class="gd">-   my_logger.setLevel(logging.DEBUG)</span>
<span class="gd">-</span>
<span class="gd">-   # Add the log message handler to the logger</span>
<span class="gd">-   handler = logging.handlers.RotatingFileHandler(</span>
<span class="gd">-                 LOG_FILENAME, maxBytes=20, backupCount=5)</span>
<span class="gd">-</span>
<span class="gd">-   my_logger.addHandler(handler)</span>
<span class="gd">-</span>
<span class="gd">-   # Log some messages</span>
<span class="gd">-   for i in range(20):</span>
<span class="gd">-       my_logger.debug(&#39;i = %d&#39; % i)</span>
<span class="gd">-</span>
<span class="gd">-   # See what files are created</span>
<span class="gd">-   logfiles = glob.glob(&#39;%s*&#39; % LOG_FILENAME)</span>
<span class="gd">-</span>
<span class="gd">-   for filename in logfiles:</span>
<span class="gd">-       print filename</span>
<span class="gd">-</span>
<span class="gd">-The result should be 6 separate files, each with part of the log history for the</span>
<span class="gd">-application::</span>
<span class="gd">-</span>
<span class="gd">-   logging_rotatingfile_example.out</span>
<span class="gd">-   logging_rotatingfile_example.out.1</span>
<span class="gd">-   logging_rotatingfile_example.out.2</span>
<span class="gd">-   logging_rotatingfile_example.out.3</span>
<span class="gd">-   logging_rotatingfile_example.out.4</span>
<span class="gd">-   logging_rotatingfile_example.out.5</span>
<span class="gd">-</span>
<span class="gd">-The most current file is always :file:`logging_rotatingfile_example.out`,</span>
<span class="gd">-and each time it reaches the size limit it is renamed with the suffix</span>
<span class="gd">-``.1``. Each of the existing backup files is renamed to increment the suffix</span>
<span class="gd">-(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased.</span>
<span class="gd">-</span>
<span class="gd">-Obviously this example sets the log length much much too small as an extreme</span>
<span class="gd">-example.  You would want to set *maxBytes* to an appropriate value.</span>
<span class="gd">-</span>
<span class="gd">-Another useful feature of the logging API is the ability to produce different</span>
<span class="gd">-messages at different log levels.  This allows you to instrument your code with</span>
<span class="gd">-debug messages, for example, but turning the log level down so that those debug</span>
<span class="gd">-messages are not written for your production system.  The default levels are</span>
<span class="gd">-``NOTSET``, ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` and ``CRITICAL``.</span>
<span class="gd">-</span>
<span class="gd">-The logger, handler, and log message call each specify a level.  The log message</span>
<span class="gd">-is only emitted if the handler and logger are configured to emit messages of</span>
<span class="gd">-that level or lower.  For example, if a message is ``CRITICAL``, and the logger</span>
<span class="gd">-is set to ``ERROR``, the message is emitted.  If a message is a ``WARNING``, and</span>
<span class="gd">-the logger is set to produce only ``ERROR``\s, the message is not emitted::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-   import sys</span>
<span class="gd">-</span>
<span class="gd">-   LEVELS = {&#39;debug&#39;: logging.DEBUG,</span>
<span class="gd">-             &#39;info&#39;: logging.INFO,</span>
<span class="gd">-             &#39;warning&#39;: logging.WARNING,</span>
<span class="gd">-             &#39;error&#39;: logging.ERROR,</span>
<span class="gd">-             &#39;critical&#39;: logging.CRITICAL}</span>
<span class="gd">-</span>
<span class="gd">-   if len(sys.argv) &gt; 1:</span>
<span class="gd">-       level_name = sys.argv[1]</span>
<span class="gd">-       level = LEVELS.get(level_name, logging.NOTSET)</span>
<span class="gd">-       logging.basicConfig(level=level)</span>
<span class="gd">-</span>
<span class="gd">-   logging.debug(&#39;This is a debug message&#39;)</span>
<span class="gd">-   logging.info(&#39;This is an info message&#39;)</span>
<span class="gd">-   logging.warning(&#39;This is a warning message&#39;)</span>
<span class="gd">-   logging.error(&#39;This is an error message&#39;)</span>
<span class="gd">-   logging.critical(&#39;This is a critical error message&#39;)</span>
<span class="gd">-</span>
<span class="gd">-Run the script with an argument like &#39;debug&#39; or &#39;warning&#39; to see which messages</span>
<span class="gd">-show up at different levels::</span>
<span class="gd">-</span>
<span class="gd">-   $ python logging_level_example.py debug</span>
<span class="gd">-   DEBUG:root:This is a debug message</span>
<span class="gd">-   INFO:root:This is an info message</span>
<span class="gd">-   WARNING:root:This is a warning message</span>
<span class="gd">-   ERROR:root:This is an error message</span>
<span class="gd">-   CRITICAL:root:This is a critical error message</span>
<span class="gd">-</span>
<span class="gd">-   $ python logging_level_example.py info</span>
<span class="gd">-   INFO:root:This is an info message</span>
<span class="gd">-   WARNING:root:This is a warning message</span>
<span class="gd">-   ERROR:root:This is an error message</span>
<span class="gd">-   CRITICAL:root:This is a critical error message</span>
<span class="gd">-</span>
<span class="gd">-You will notice that these log messages all have ``root`` embedded in them.  The</span>
<span class="gd">-logging module supports a hierarchy of loggers with different names.  An easy</span>
<span class="gd">-way to tell where a specific log message comes from is to use a separate logger</span>
<span class="gd">-object for each of your modules.  Each new logger &quot;inherits&quot; the configuration</span>
<span class="gd">-of its parent, and log messages sent to a logger include the name of that</span>
<span class="gd">-logger.  Optionally, each logger can be configured differently, so that messages</span>
<span class="gd">-from different modules are handled in different ways.  Let&#39;s look at a simple</span>
<span class="gd">-example of how to log from different modules so it is easy to trace the source</span>
<span class="gd">-of the message::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   logging.basicConfig(level=logging.WARNING)</span>
<span class="gd">-</span>
<span class="gd">-   logger1 = logging.getLogger(&#39;package1.module1&#39;)</span>
<span class="gd">-   logger2 = logging.getLogger(&#39;package2.module2&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   logger1.warning(&#39;This message comes from one module&#39;)</span>
<span class="gd">-   logger2.warning(&#39;And this message comes from another module&#39;)</span>
<span class="gd">-</span>
<span class="gd">-And the output::</span>
<span class="gd">-</span>
<span class="gd">-   $ python logging_modules_example.py</span>
<span class="gd">-   WARNING:package1.module1:This message comes from one module</span>
<span class="gd">-   WARNING:package2.module2:And this message comes from another module</span>
<span class="gd">-</span>
<span class="gd">-There are many more options for configuring logging, including different log</span>
<span class="gd">-message formatting options, having messages delivered to multiple destinations,</span>
<span class="gd">-and changing the configuration of a long-running application on the fly using a</span>
<span class="gd">-socket interface.  All of these options are covered in depth in the library</span>
<span class="gd">-module documentation.</span>
<span class="gd">-</span>
<span class="gd">-Loggers</span>
<span class="gd">-^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The logging library takes a modular approach and offers the several categories</span>
<span class="gd">-of components: loggers, handlers, filters, and formatters.  Loggers expose the</span>
<span class="gd">-interface that application code directly uses.  Handlers send the log records to</span>
<span class="gd">-the appropriate destination. Filters provide a finer grained facility for</span>
<span class="gd">-determining which log records to send on to a handler.  Formatters specify the</span>
<span class="gd">-layout of the resultant log record.</span>
<span class="gd">-</span>
<span class="gd">-:class:`Logger` objects have a threefold job.  First, they expose several</span>
<span class="gd">-methods to application code so that applications can log messages at runtime.</span>
<span class="gd">-Second, logger objects determine which log messages to act upon based upon</span>
<span class="gd">-severity (the default filtering facility) or filter objects.  Third, logger</span>
<span class="gd">-objects pass along relevant log messages to all interested log handlers.</span>
<span class="gd">-</span>
<span class="gd">-The most widely used methods on logger objects fall into two categories:</span>
<span class="gd">-configuration and message sending.</span>
<span class="gd">-</span>
<span class="gd">-* :meth:`Logger.setLevel` specifies the lowest-severity log message a logger</span>
<span class="gd">-  will handle, where debug is the lowest built-in severity level and critical is</span>
<span class="gd">-  the highest built-in severity.  For example, if the severity level is info,</span>
<span class="gd">-  the logger will handle only info, warning, error, and critical messages and</span>
<span class="gd">-  will ignore debug messages.</span>
<span class="gd">-</span>
<span class="gd">-* :meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove filter</span>
<span class="gd">-  objects from the logger object.  This tutorial does not address filters.</span>
<span class="gd">-</span>
<span class="gd">-With the logger object configured, the following methods create log messages:</span>
<span class="gd">-</span>
<span class="gd">-* :meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`,</span>
<span class="gd">-  :meth:`Logger.error`, and :meth:`Logger.critical` all create log records with</span>
<span class="gd">-  a message and a level that corresponds to their respective method names. The</span>
<span class="gd">-  message is actually a format string, which may contain the standard string</span>
<span class="gd">-  substitution syntax of :const:`%s`, :const:`%d`, :const:`%f`, and so on.  The</span>
<span class="gd">-  rest of their arguments is a list of objects that correspond with the</span>
<span class="gd">-  substitution fields in the message.  With regard to :const:`**kwargs`, the</span>
<span class="gd">-  logging methods care only about a keyword of :const:`exc_info` and use it to</span>
<span class="gd">-  determine whether to log exception information.</span>
<span class="gd">-</span>
<span class="gd">-* :meth:`Logger.exception` creates a log message similar to</span>
<span class="gd">-  :meth:`Logger.error`.  The difference is that :meth:`Logger.exception` dumps a</span>
<span class="gd">-  stack trace along with it.  Call this method only from an exception handler.</span>
<span class="gd">-</span>
<span class="gd">-* :meth:`Logger.log` takes a log level as an explicit argument.  This is a</span>
<span class="gd">-  little more verbose for logging messages than using the log level convenience</span>
<span class="gd">-  methods listed above, but this is how to log at custom log levels.</span>
<span class="gd">-</span>
<span class="gd">-:func:`getLogger` returns a reference to a logger instance with the specified</span>
<span class="gd">-name if it is provided, or ``root`` if not.  The names are period-separated</span>
<span class="gd">-hierarchical structures.  Multiple calls to :func:`getLogger` with the same name</span>
<span class="gd">-will return a reference to the same logger object.  Loggers that are further</span>
<span class="gd">-down in the hierarchical list are children of loggers higher up in the list.</span>
<span class="gd">-For example, given a logger with a name of ``foo``, loggers with names of</span>
<span class="gd">-``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all descendants of ``foo``.</span>
<span class="gd">-Child loggers propagate messages up to the handlers associated with their</span>
<span class="gd">-ancestor loggers.  Because of this, it is unnecessary to define and configure</span>
<span class="gd">-handlers for all the loggers an application uses. It is sufficient to</span>
<span class="gd">-configure handlers for a top-level logger and create child loggers as needed.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Handlers</span>
<span class="gd">-^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-:class:`Handler` objects are responsible for dispatching the appropriate log</span>
<span class="gd">-messages (based on the log messages&#39; severity) to the handler&#39;s specified</span>
<span class="gd">-destination.  Logger objects can add zero or more handler objects to themselves</span>
<span class="gd">-with an :func:`addHandler` method.  As an example scenario, an application may</span>
<span class="gd">-want to send all log messages to a log file, all log messages of error or higher</span>
<span class="gd">-to stdout, and all messages of critical to an email address.  This scenario</span>
<span class="gd">-requires three individual handlers where each handler is responsible for sending</span>
<span class="gd">-messages of a specific severity to a specific location.</span>
<span class="gd">-</span>
<span class="gd">-The standard library includes quite a few handler types; this tutorial uses only</span>
<span class="gd">-:class:`StreamHandler` and :class:`FileHandler` in its examples.</span>
<span class="gd">-</span>
<span class="gd">-There are very few methods in a handler for application developers to concern</span>
<span class="gd">-themselves with.  The only handler methods that seem relevant for application</span>
<span class="gd">-developers who are using the built-in handler objects (that is, not creating</span>
<span class="gd">-custom handlers) are the following configuration methods:</span>
<span class="gd">-</span>
<span class="gd">-* The :meth:`Handler.setLevel` method, just as in logger objects, specifies the</span>
<span class="gd">-  lowest severity that will be dispatched to the appropriate destination.  Why</span>
<span class="gd">-  are there two :func:`setLevel` methods?  The level set in the logger</span>
<span class="gd">-  determines which severity of messages it will pass to its handlers.  The level</span>
<span class="gd">-  set in each handler determines which messages that handler will send on.</span>
<span class="gd">-</span>
<span class="gd">-* :func:`setFormatter` selects a Formatter object for this handler to use.</span>
<span class="gd">-</span>
<span class="gd">-* :func:`addFilter` and :func:`removeFilter` respectively configure and</span>
<span class="gd">-  deconfigure filter objects on handlers.</span>
<span class="gd">-</span>
<span class="gd">-Application code should not directly instantiate and use instances of</span>
<span class="gd">-:class:`Handler`.  Instead, the :class:`Handler` class is a base class that</span>
<span class="gd">-defines the interface that all handlers should have and establishes some</span>
<span class="gd">-default behavior that child classes can use (or override).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Formatters</span>
<span class="gd">-^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-Formatter objects configure the final order, structure, and contents of the log</span>
<span class="gd">-message.  Unlike the base :class:`logging.Handler` class, application code may</span>
<span class="gd">-instantiate formatter classes, although you could likely subclass the formatter</span>
<span class="gd">-if your application needs special behavior.  The constructor takes two optional</span>
<span class="gd">-arguments: a message format string and a date format string.  If there is no</span>
<span class="gd">-message format string, the default is to use the raw message.  If there is no</span>
<span class="gd">-date format string, the default date format is::</span>
<span class="gd">-</span>
<span class="gd">-    %Y-%m-%d %H:%M:%S</span>
<span class="gd">-</span>
<span class="gd">-with the milliseconds tacked on at the end.</span>
<span class="gd">-</span>
<span class="gd">-The message format string uses ``%(&lt;dictionary key&gt;)s`` styled string</span>
<span class="gd">-substitution; the possible keys are documented in :ref:`formatter`.</span>
<span class="gd">-</span>
<span class="gd">-The following message format string will log the time in a human-readable</span>
<span class="gd">-format, the severity of the message, and the contents of the message, in that</span>
<span class="gd">-order::</span>
<span class="gd">-</span>
<span class="gd">-    &quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Configuring Logging</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-Programmers can configure logging either by creating loggers, handlers, and</span>
<span class="gd">-formatters explicitly in a main module with the configuration methods listed</span>
<span class="gd">-above (using Python code), or by creating a logging config file.  The following</span>
<span class="gd">-code is an example of configuring a very simple logger, a console handler, and a</span>
<span class="gd">-simple formatter in a Python module::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-</span>
<span class="gd">-    # create logger</span>
<span class="gd">-    logger = logging.getLogger(&quot;simple_example&quot;)</span>
<span class="gd">-    logger.setLevel(logging.DEBUG)</span>
<span class="gd">-    # create console handler and set level to debug</span>
<span class="gd">-    ch = logging.StreamHandler()</span>
<span class="gd">-    ch.setLevel(logging.DEBUG)</span>
<span class="gd">-    # create formatter</span>
<span class="gd">-    formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)</span>
<span class="gd">-    # add formatter to ch</span>
<span class="gd">-    ch.setFormatter(formatter)</span>
<span class="gd">-    # add ch to logger</span>
<span class="gd">-    logger.addHandler(ch)</span>
<span class="gd">-</span>
<span class="gd">-    # &quot;application&quot; code</span>
<span class="gd">-    logger.debug(&quot;debug message&quot;)</span>
<span class="gd">-    logger.info(&quot;info message&quot;)</span>
<span class="gd">-    logger.warn(&quot;warn message&quot;)</span>
<span class="gd">-    logger.error(&quot;error message&quot;)</span>
<span class="gd">-    logger.critical(&quot;critical message&quot;)</span>
<span class="gd">-</span>
<span class="gd">-Running this module from the command line produces the following output::</span>
<span class="gd">-</span>
<span class="gd">-    $ python simple_logging_module.py</span>
<span class="gd">-    2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message</span>
<span class="gd">-    2005-03-19 15:10:26,620 - simple_example - INFO - info message</span>
<span class="gd">-    2005-03-19 15:10:26,695 - simple_example - WARNING - warn message</span>
<span class="gd">-    2005-03-19 15:10:26,697 - simple_example - ERROR - error message</span>
<span class="gd">-    2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message</span>
<span class="gd">-</span>
<span class="gd">-The following Python module creates a logger, handler, and formatter nearly</span>
<span class="gd">-identical to those in the example listed above, with the only difference being</span>
<span class="gd">-the names of the objects::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-    import logging.config</span>
<span class="gd">-</span>
<span class="gd">-    logging.config.fileConfig(&quot;logging.conf&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    # create logger</span>
<span class="gd">-    logger = logging.getLogger(&quot;simpleExample&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    # &quot;application&quot; code</span>
<span class="gd">-    logger.debug(&quot;debug message&quot;)</span>
<span class="gd">-    logger.info(&quot;info message&quot;)</span>
<span class="gd">-    logger.warn(&quot;warn message&quot;)</span>
<span class="gd">-    logger.error(&quot;error message&quot;)</span>
<span class="gd">-    logger.critical(&quot;critical message&quot;)</span>
<span class="gd">-</span>
<span class="gd">-Here is the logging.conf file::</span>
<span class="gd">-</span>
<span class="gd">-    [loggers]</span>
<span class="gd">-    keys=root,simpleExample</span>
<span class="gd">-</span>
<span class="gd">-    [handlers]</span>
<span class="gd">-    keys=consoleHandler</span>
<span class="gd">-</span>
<span class="gd">-    [formatters]</span>
<span class="gd">-    keys=simpleFormatter</span>
<span class="gd">-</span>
<span class="gd">-    [logger_root]</span>
<span class="gd">-    level=DEBUG</span>
<span class="gd">-    handlers=consoleHandler</span>
<span class="gd">-</span>
<span class="gd">-    [logger_simpleExample]</span>
<span class="gd">-    level=DEBUG</span>
<span class="gd">-    handlers=consoleHandler</span>
<span class="gd">-    qualname=simpleExample</span>
<span class="gd">-    propagate=0</span>
<span class="gd">-</span>
<span class="gd">-    [handler_consoleHandler]</span>
<span class="gd">-    class=StreamHandler</span>
<span class="gd">-    level=DEBUG</span>
<span class="gd">-    formatter=simpleFormatter</span>
<span class="gd">-    args=(sys.stdout,)</span>
<span class="gd">-</span>
<span class="gd">-    [formatter_simpleFormatter]</span>
<span class="gd">-    format=%(asctime)s - %(name)s - %(levelname)s - %(message)s</span>
<span class="gd">-    datefmt=</span>
<span class="gd">-</span>
<span class="gd">-The output is nearly identical to that of the non-config-file-based example::</span>
<span class="gd">-</span>
<span class="gd">-    $ python simple_logging_config.py</span>
<span class="gd">-    2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message</span>
<span class="gd">-    2005-03-19 15:38:55,979 - simpleExample - INFO - info message</span>
<span class="gd">-    2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message</span>
<span class="gd">-    2005-03-19 15:38:56,055 - simpleExample - ERROR - error message</span>
<span class="gd">-    2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message</span>
<span class="gd">-</span>
<span class="gd">-You can see that the config file approach has a few advantages over the Python</span>
<span class="gd">-code approach, mainly separation of configuration and code and the ability of</span>
<span class="gd">-noncoders to easily modify the logging properties.</span>
<span class="gd">-</span>
<span class="gd">-.. _library-config:</span>
<span class="gd">-</span>
<span class="gd">-Configuring Logging for a Library</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-When developing a library which uses logging, some consideration needs to be</span>
<span class="gd">-given to its configuration. If the using application does not use logging, and</span>
<span class="gd">-library code makes logging calls, then a one-off message &quot;No handlers could be</span>
<span class="gd">-found for logger X.Y.Z&quot; is printed to the console. This message is intended</span>
<span class="gd">-to catch mistakes in logging configuration, but will confuse an application</span>
<span class="gd">-developer who is not aware of logging by the library.</span>
<span class="gd">-</span>
<span class="gd">-In addition to documenting how a library uses logging, a good way to configure</span>
<span class="gd">-library logging so that it does not cause a spurious message is to add a</span>
<span class="gd">-handler which does nothing. This avoids the message being printed, since a</span>
<span class="gd">-handler will be found: it just doesn&#39;t produce any output. If the library user</span>
<span class="gd">-configures logging for application use, presumably that configuration will add</span>
<span class="gd">-some handlers, and if levels are suitably configured then logging calls made</span>
<span class="gd">-in library code will send output to those handlers, as normal.</span>
<span class="gd">-</span>
<span class="gd">-A do-nothing handler can be simply defined as follows::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-</span>
<span class="gd">-    class NullHandler(logging.Handler):</span>
<span class="gd">-        def emit(self, record):</span>
<span class="gd">-            pass</span>
<span class="gd">-</span>
<span class="gd">-An instance of this handler should be added to the top-level logger of the</span>
<span class="gd">-logging namespace used by the library. If all logging by a library *foo* is</span>
<span class="gd">-done using loggers with names matching &quot;foo.x.y&quot;, then the code::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-</span>
<span class="gd">-    h = NullHandler()</span>
<span class="gd">-    logging.getLogger(&quot;foo&quot;).addHandler(h)</span>
<span class="gd">-</span>
<span class="gd">-should have the desired effect. If an organisation produces a number of</span>
<span class="gd">-libraries, then the logger name specified can be &quot;orgname.foo&quot; rather than</span>
<span class="gd">-just &quot;foo&quot;.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Logging Levels</span>
<span class="gi">+Logger Objects</span>
 --------------
 
<span class="gd">-The numeric values of logging levels are given in the following table. These are</span>
<span class="gd">-primarily of interest if you want to define your own levels, and need them to</span>
<span class="gd">-have specific values relative to the predefined levels. If you define a level</span>
<span class="gd">-with the same numeric value, it overwrites the predefined value; the predefined</span>
<span class="gd">-name is lost.</span>
<span class="gi">+Loggers have the following attributes and methods. Note that Loggers are never</span>
<span class="gi">+instantiated directly, but always through the module-level function</span>
<span class="gi">+``logging.getLogger(name)``.</span>
 
<span class="gd">-+--------------+---------------+</span>
<span class="gd">-| Level        | Numeric value |</span>
<span class="gd">-+==============+===============+</span>
<span class="gd">-| ``CRITICAL`` | 50            |</span>
<span class="gd">-+--------------+---------------+</span>
<span class="gd">-| ``ERROR``    | 40            |</span>
<span class="gd">-+--------------+---------------+</span>
<span class="gd">-| ``WARNING``  | 30            |</span>
<span class="gd">-+--------------+---------------+</span>
<span class="gd">-| ``INFO``     | 20            |</span>
<span class="gd">-+--------------+---------------+</span>
<span class="gd">-| ``DEBUG``    | 10            |</span>
<span class="gd">-+--------------+---------------+</span>
<span class="gd">-| ``NOTSET``   | 0             |</span>
<span class="gd">-+--------------+---------------+</span>
<span class="gi">+.. class:: Logger</span>
 
<span class="gd">-Levels can also be associated with loggers, being set either by the developer or</span>
<span class="gd">-through loading a saved logging configuration. When a logging method is called</span>
<span class="gd">-on a logger, the logger compares its own level with the level associated with</span>
<span class="gd">-the method call. If the logger&#39;s level is higher than the method call&#39;s, no</span>
<span class="gd">-logging message is actually generated. This is the basic mechanism controlling</span>
<span class="gd">-the verbosity of logging output.</span>
<span class="gi">+.. attribute:: Logger.propagate</span>
 
<span class="gd">-Logging messages are encoded as instances of the :class:`LogRecord` class. When</span>
<span class="gd">-a logger decides to actually log an event, a :class:`LogRecord` instance is</span>
<span class="gd">-created from the logging message.</span>
<span class="gi">+   If this evaluates to false, logging messages are not passed by this logger or by</span>
<span class="gi">+   its child loggers to the handlers of higher level (ancestor) loggers. The</span>
<span class="gi">+   constructor sets this attribute to 1.</span>
 
<span class="gd">-Logging messages are subjected to a dispatch mechanism through the use of</span>
<span class="gd">-:dfn:`handlers`, which are instances of subclasses of the :class:`Handler`</span>
<span class="gd">-class. Handlers are responsible for ensuring that a logged message (in the form</span>
<span class="gd">-of a :class:`LogRecord`) ends up in a particular location (or set of locations)</span>
<span class="gd">-which is useful for the target audience for that message (such as end users,</span>
<span class="gd">-support desk staff, system administrators, developers). Handlers are passed</span>
<span class="gd">-:class:`LogRecord` instances intended for particular destinations. Each logger</span>
<span class="gd">-can have zero, one or more handlers associated with it (via the</span>
<span class="gd">-:meth:`addHandler` method of :class:`Logger`). In addition to any handlers</span>
<span class="gd">-directly associated with a logger, *all handlers associated with all ancestors</span>
<span class="gd">-of the logger* are called to dispatch the message (unless the *propagate* flag</span>
<span class="gd">-for a logger is set to a false value, at which point the passing to ancestor</span>
<span class="gd">-handlers stops).</span>
 
<span class="gd">-Just as for loggers, handlers can have levels associated with them. A handler&#39;s</span>
<span class="gd">-level acts as a filter in the same way as a logger&#39;s level does. If a handler</span>
<span class="gd">-decides to actually dispatch an event, the :meth:`emit` method is used to send</span>
<span class="gd">-the message to its destination. Most user-defined subclasses of :class:`Handler`</span>
<span class="gd">-will need to override this :meth:`emit`.</span>
<span class="gi">+.. method:: Logger.setLevel(lvl)</span>
 
<span class="gd">-Useful Handlers</span>
<span class="gi">+   Sets the threshold for this logger to *lvl*. Logging messages which are less</span>
<span class="gi">+   severe than *lvl* will be ignored. When a logger is created, the level is set to</span>
<span class="gi">+   :const:`NOTSET` (which causes all messages to be processed when the logger is</span>
<span class="gi">+   the root logger, or delegation to the parent when the logger is a non-root</span>
<span class="gi">+   logger). Note that the root logger is created with level :const:`WARNING`.</span>
<span class="gi">+</span>
<span class="gi">+   The term &#39;delegation to the parent&#39; means that if a logger has a level of</span>
<span class="gi">+   NOTSET, its chain of ancestor loggers is traversed until either an ancestor with</span>
<span class="gi">+   a level other than NOTSET is found, or the root is reached.</span>
<span class="gi">+</span>
<span class="gi">+   If an ancestor is found with a level other than NOTSET, then that ancestor&#39;s</span>
<span class="gi">+   level is treated as the effective level of the logger where the ancestor search</span>
<span class="gi">+   began, and is used to determine how a logging event is handled.</span>
<span class="gi">+</span>
<span class="gi">+   If the root is reached, and it has a level of NOTSET, then all messages will be</span>
<span class="gi">+   processed. Otherwise, the root&#39;s level will be used as the effective level.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.isEnabledFor(lvl)</span>
<span class="gi">+</span>
<span class="gi">+   Indicates if a message of severity *lvl* would be processed by this logger.</span>
<span class="gi">+   This method checks first the module-level level set by</span>
<span class="gi">+   ``logging.disable(lvl)`` and then the logger&#39;s effective level as determined</span>
<span class="gi">+   by :meth:`getEffectiveLevel`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.getEffectiveLevel()</span>
<span class="gi">+</span>
<span class="gi">+   Indicates the effective level for this logger. If a value other than</span>
<span class="gi">+   :const:`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise,</span>
<span class="gi">+   the hierarchy is traversed towards the root until a value other than</span>
<span class="gi">+   :const:`NOTSET` is found, and that value is returned.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.getChild(suffix)</span>
<span class="gi">+</span>
<span class="gi">+   Returns a logger which is a descendant to this logger, as determined by the suffix.</span>
<span class="gi">+   Thus, ``logging.getLogger(&#39;abc&#39;).getChild(&#39;def.ghi&#39;)`` would return the same</span>
<span class="gi">+   logger as would be returned by ``logging.getLogger(&#39;abc.def.ghi&#39;)``. This is a</span>
<span class="gi">+   convenience method, useful when the parent logger is named using e.g. ``__name__``</span>
<span class="gi">+   rather than a literal string.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.debug(msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with level :const:`DEBUG` on this logger. The *msg* is the</span>
<span class="gi">+   message format string, and the *args* are the arguments which are merged into</span>
<span class="gi">+   *msg* using the string formatting operator. (Note that this means that you can</span>
<span class="gi">+   use keywords in the format string, together with a single dictionary argument.)</span>
<span class="gi">+</span>
<span class="gi">+   There are two keyword arguments in *kwargs* which are inspected: *exc_info*</span>
<span class="gi">+   which, if it does not evaluate as false, causes exception information to be</span>
<span class="gi">+   added to the logging message. If an exception tuple (in the format returned by</span>
<span class="gi">+   :func:`sys.exc_info`) is provided, it is used; otherwise, :func:`sys.exc_info`</span>
<span class="gi">+   is called to get the exception information.</span>
<span class="gi">+</span>
<span class="gi">+   The second keyword argument is *extra* which can be used to pass a</span>
<span class="gi">+   dictionary which is used to populate the __dict__ of the LogRecord created for</span>
<span class="gi">+   the logging event with user-defined attributes. These custom attributes can then</span>
<span class="gi">+   be used as you like. For example, they could be incorporated into logged</span>
<span class="gi">+   messages. For example::</span>
<span class="gi">+</span>
<span class="gi">+      FORMAT = &#39;%(asctime)-15s %(clientip)s %(user)-8s %(message)s&#39;</span>
<span class="gi">+      logging.basicConfig(format=FORMAT)</span>
<span class="gi">+      d = { &#39;clientip&#39; : &#39;192.168.0.1&#39;, &#39;user&#39; : &#39;fbloggs&#39; }</span>
<span class="gi">+      logger = logging.getLogger(&#39;tcpserver&#39;)</span>
<span class="gi">+      logger.warning(&#39;Protocol problem: %s&#39;, &#39;connection reset&#39;, extra=d)</span>
<span class="gi">+</span>
<span class="gi">+   would print something like  ::</span>
<span class="gi">+</span>
<span class="gi">+      2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset</span>
<span class="gi">+</span>
<span class="gi">+   The keys in the dictionary passed in *extra* should not clash with the keys used</span>
<span class="gi">+   by the logging system. (See the :class:`Formatter` documentation for more</span>
<span class="gi">+   information on which keys are used by the logging system.)</span>
<span class="gi">+</span>
<span class="gi">+   If you choose to use these attributes in logged messages, you need to exercise</span>
<span class="gi">+   some care. In the above example, for instance, the :class:`Formatter` has been</span>
<span class="gi">+   set up with a format string which expects &#39;clientip&#39; and &#39;user&#39; in the attribute</span>
<span class="gi">+   dictionary of the LogRecord. If these are missing, the message will not be</span>
<span class="gi">+   logged because a string formatting exception will occur. So in this case, you</span>
<span class="gi">+   always need to pass the *extra* dictionary with these keys.</span>
<span class="gi">+</span>
<span class="gi">+   While this might be annoying, this feature is intended for use in specialized</span>
<span class="gi">+   circumstances, such as multi-threaded servers where the same code executes in</span>
<span class="gi">+   many contexts, and interesting conditions which arise are dependent on this</span>
<span class="gi">+   context (such as remote client IP address and authenticated user name, in the</span>
<span class="gi">+   above example). In such circumstances, it is likely that specialized</span>
<span class="gi">+   :class:`Formatter`\ s would be used with particular :class:`Handler`\ s.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.info(msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with level :const:`INFO` on this logger. The arguments are</span>
<span class="gi">+   interpreted as for :meth:`debug`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.warning(msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with level :const:`WARNING` on this logger. The arguments are</span>
<span class="gi">+   interpreted as for :meth:`debug`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.error(msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with level :const:`ERROR` on this logger. The arguments are</span>
<span class="gi">+   interpreted as for :meth:`debug`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.critical(msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with level :const:`CRITICAL` on this logger. The arguments are</span>
<span class="gi">+   interpreted as for :meth:`debug`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.log(lvl, msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with integer level *lvl* on this logger. The other arguments are</span>
<span class="gi">+   interpreted as for :meth:`debug`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.exception(msg, *args)</span>
<span class="gi">+</span>
<span class="gi">+   Logs a message with level :const:`ERROR` on this logger. The arguments are</span>
<span class="gi">+   interpreted as for :meth:`debug`. Exception info is added to the logging</span>
<span class="gi">+   message. This method should only be called from an exception handler.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.addFilter(filt)</span>
<span class="gi">+</span>
<span class="gi">+   Adds the specified filter *filt* to this logger.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.removeFilter(filt)</span>
<span class="gi">+</span>
<span class="gi">+   Removes the specified filter *filt* from this logger.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.filter(record)</span>
<span class="gi">+</span>
<span class="gi">+   Applies this logger&#39;s filters to the record and returns a true value if the</span>
<span class="gi">+   record is to be processed.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.addHandler(hdlr)</span>
<span class="gi">+</span>
<span class="gi">+   Adds the specified handler *hdlr* to this logger.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.removeHandler(hdlr)</span>
<span class="gi">+</span>
<span class="gi">+   Removes the specified handler *hdlr* from this logger.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.findCaller()</span>
<span class="gi">+</span>
<span class="gi">+   Finds the caller&#39;s source filename and line number. Returns the filename, line</span>
<span class="gi">+   number and function name as a 3-element tuple.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionchanged:: 2.4</span>
<span class="gi">+      The function name was added. In earlier versions, the filename and line</span>
<span class="gi">+      number were returned as a 2-element tuple.</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.handle(record)</span>
<span class="gi">+</span>
<span class="gi">+   Handles a record by passing it to all handlers associated with this logger and</span>
<span class="gi">+   its ancestors (until a false value of *propagate* is found). This method is used</span>
<span class="gi">+   for unpickled records received from a socket, as well as those created locally.</span>
<span class="gi">+   Logger-level filtering is applied using :meth:`~Logger.filter`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Logger.makeRecord(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None)</span>
<span class="gi">+</span>
<span class="gi">+   This is a factory method which can be overridden in subclasses to create</span>
<span class="gi">+   specialized :class:`LogRecord` instances.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionchanged:: 2.5</span>
<span class="gi">+      *func* and *extra* were added.</span>
<span class="gi">+</span>
<span class="gi">+.. _handler:</span>
<span class="gi">+</span>
<span class="gi">+Handler Objects</span>
 ---------------
 
<span class="gd">-In addition to the base :class:`Handler` class, many useful subclasses are</span>
<span class="gd">-provided:</span>
<span class="gi">+Handlers have the following attributes and methods. Note that :class:`Handler`</span>
<span class="gi">+is never instantiated directly; this class acts as a base for more useful</span>
<span class="gi">+subclasses. However, the :meth:`__init__` method in subclasses needs to call</span>
<span class="gi">+:meth:`Handler.__init__`.</span>
 
<span class="gd">-#. :ref:`stream-handler` instances send error messages to streams (file-like</span>
<span class="gd">-   objects).</span>
 
<span class="gd">-#. :ref:`file-handler` instances send error messages to disk files.</span>
<span class="gi">+.. method:: Handler.__init__(level=NOTSET)</span>
 
<span class="gd">-#. :class:`BaseRotatingHandler` is the base class for handlers that</span>
<span class="gd">-   rotate log files at a certain point. It is not meant to be  instantiated</span>
<span class="gd">-   directly. Instead, use :ref:`rotating-file-handler` or</span>
<span class="gd">-   :ref:`timed-rotating-file-handler`.</span>
<span class="gi">+   Initializes the :class:`Handler` instance by setting its level, setting the list</span>
<span class="gi">+   of filters to the empty list and creating a lock (using :meth:`createLock`) for</span>
<span class="gi">+   serializing access to an I/O mechanism.</span>
 
<span class="gd">-#. :ref:`rotating-file-handler` instances send error messages to disk</span>
<span class="gd">-   files, with support for maximum log file sizes and log file rotation.</span>
 
<span class="gd">-#. :ref:`timed-rotating-file-handler` instances send error messages to</span>
<span class="gd">-   disk files, rotating the log file at certain timed intervals.</span>
<span class="gi">+.. method:: Handler.createLock()</span>
 
<span class="gd">-#. :ref:`socket-handler` instances send error messages to TCP/IP</span>
<span class="gd">-   sockets.</span>
<span class="gi">+   Initializes a thread lock which can be used to serialize access to underlying</span>
<span class="gi">+   I/O functionality which may not be threadsafe.</span>
 
<span class="gd">-#. :ref:`datagram-handler` instances send error messages to UDP</span>
<span class="gd">-   sockets.</span>
 
<span class="gd">-#. :ref:`smtp-handler` instances send error messages to a designated</span>
<span class="gd">-   email address.</span>
<span class="gi">+.. method:: Handler.acquire()</span>
 
<span class="gd">-#. :ref:`syslog-handler` instances send error messages to a Unix</span>
<span class="gd">-   syslog daemon, possibly on a remote machine.</span>
<span class="gi">+   Acquires the thread lock created with :meth:`createLock`.</span>
 
<span class="gd">-#. :ref:`nt-eventlog-handler` instances send error messages to a</span>
<span class="gd">-   Windows NT/2000/XP event log.</span>
 
<span class="gd">-#. :ref:`memory-handler` instances send error messages to a buffer</span>
<span class="gd">-   in memory, which is flushed whenever specific criteria are met.</span>
<span class="gi">+.. method:: Handler.release()</span>
 
<span class="gd">-#. :ref:`http-handler` instances send error messages to an HTTP</span>
<span class="gd">-   server using either ``GET`` or ``POST`` semantics.</span>
<span class="gi">+   Releases the thread lock acquired with :meth:`acquire`.</span>
 
<span class="gd">-#. :ref:`watched-file-handler` instances watch the file they are</span>
<span class="gd">-   logging to. If the file changes, it is closed and reopened using the file</span>
<span class="gd">-   name. This handler is only useful on Unix-like systems; Windows does not</span>
<span class="gd">-   support the underlying mechanism used.</span>
 
<span class="gd">-The :class:`StreamHandler` and :class:`FileHandler`</span>
<span class="gd">-classes are defined in the core logging package. The other handlers are</span>
<span class="gd">-defined in a sub- module, :mod:`logging.handlers`. (There is also another</span>
<span class="gd">-sub-module, :mod:`logging.config`, for configuration functionality.)</span>
<span class="gi">+.. method:: Handler.setLevel(lvl)</span>
 
<span class="gd">-Logged messages are formatted for presentation through instances of the</span>
<span class="gd">-:class:`Formatter` class. They are initialized with a format string suitable for</span>
<span class="gd">-use with the % operator and a dictionary.</span>
<span class="gi">+   Sets the threshold for this handler to *lvl*. Logging messages which are less</span>
<span class="gi">+   severe than *lvl* will be ignored. When a handler is created, the level is set</span>
<span class="gi">+   to :const:`NOTSET` (which causes all messages to be processed).</span>
 
<span class="gd">-For formatting multiple messages in a batch, instances of</span>
<span class="gd">-:class:`BufferingFormatter` can be used. In addition to the format string (which</span>
<span class="gd">-is applied to each message in the batch), there is provision for header and</span>
<span class="gd">-trailer format strings.</span>
 
<span class="gd">-When filtering based on logger level and/or handler level is not enough,</span>
<span class="gd">-instances of :class:`Filter` can be added to both :class:`Logger` and</span>
<span class="gd">-:class:`Handler` instances (through their :meth:`addFilter` method). Before</span>
<span class="gd">-deciding to process a message further, both loggers and handlers consult all</span>
<span class="gd">-their filters for permission. If any filter returns a false value, the message</span>
<span class="gd">-is not processed further.</span>
<span class="gi">+.. method:: Handler.setFormatter(form)</span>
 
<span class="gd">-The basic :class:`Filter` functionality allows filtering by specific logger</span>
<span class="gd">-name. If this feature is used, messages sent to the named logger and its</span>
<span class="gd">-children are allowed through the filter, and all others dropped.</span>
<span class="gi">+   Sets the :class:`Formatter` for this handler to *form*.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.addFilter(filt)</span>
<span class="gi">+</span>
<span class="gi">+   Adds the specified filter *filt* to this handler.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.removeFilter(filt)</span>
<span class="gi">+</span>
<span class="gi">+   Removes the specified filter *filt* from this handler.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.filter(record)</span>
<span class="gi">+</span>
<span class="gi">+   Applies this handler&#39;s filters to the record and returns a true value if the</span>
<span class="gi">+   record is to be processed.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.flush()</span>
<span class="gi">+</span>
<span class="gi">+   Ensure all logging output has been flushed. This version does nothing and is</span>
<span class="gi">+   intended to be implemented by subclasses.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.close()</span>
<span class="gi">+</span>
<span class="gi">+   Tidy up any resources used by the handler. This version does no output but</span>
<span class="gi">+   removes the handler from an internal list of handlers which is closed when</span>
<span class="gi">+   :func:`shutdown` is called. Subclasses should ensure that this gets called</span>
<span class="gi">+   from overridden :meth:`close` methods.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.handle(record)</span>
<span class="gi">+</span>
<span class="gi">+   Conditionally emits the specified logging record, depending on filters which may</span>
<span class="gi">+   have been added to the handler. Wraps the actual emission of the record with</span>
<span class="gi">+   acquisition/release of the I/O thread lock.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.handleError(record)</span>
<span class="gi">+</span>
<span class="gi">+   This method should be called from handlers when an exception is encountered</span>
<span class="gi">+   during an :meth:`emit` call. By default it does nothing, which means that</span>
<span class="gi">+   exceptions get silently ignored. This is what is mostly wanted for a logging</span>
<span class="gi">+   system - most users will not care about errors in the logging system, they are</span>
<span class="gi">+   more interested in application errors. You could, however, replace this with a</span>
<span class="gi">+   custom handler if you wish. The specified record is the one which was being</span>
<span class="gi">+   processed when the exception occurred.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.format(record)</span>
<span class="gi">+</span>
<span class="gi">+   Do formatting for a record - if a formatter is set, use it. Otherwise, use the</span>
<span class="gi">+   default formatter for the module.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. method:: Handler.emit(record)</span>
<span class="gi">+</span>
<span class="gi">+   Do whatever it takes to actually log the specified logging record. This version</span>
<span class="gi">+   is intended to be implemented by subclasses and so raises a</span>
<span class="gi">+   :exc:`NotImplementedError`.</span>
<span class="gi">+</span>
<span class="gi">+For a list of handlers included as standard, see :mod:`logging.handlers`.</span>
<span class="gi">+</span>
<span class="gi">+.. _formatter-objects:</span>
<span class="gi">+</span>
<span class="gi">+Formatter Objects</span>
<span class="gi">+-----------------</span>
<span class="gi">+</span>
<span class="gi">+.. currentmodule:: logging</span>
<span class="gi">+</span>
<span class="gi">+:class:`Formatter` objects have the following attributes and methods. They are</span>
<span class="gi">+responsible for converting a :class:`LogRecord` to (usually) a string which can</span>
<span class="gi">+be interpreted by either a human or an external system. The base</span>
<span class="gi">+:class:`Formatter` allows a formatting string to be specified. If none is</span>
<span class="gi">+supplied, the default value of ``&#39;%(message)s&#39;`` is used.</span>
<span class="gi">+</span>
<span class="gi">+A Formatter can be initialized with a format string which makes use of knowledge</span>
<span class="gi">+of the :class:`LogRecord` attributes - such as the default value mentioned above</span>
<span class="gi">+making use of the fact that the user&#39;s message and arguments are pre-formatted</span>
<span class="gi">+into a :class:`LogRecord`&#39;s *message* attribute.  This format string contains</span>
<span class="gi">+standard Python %-style mapping keys. See section :ref:`string-formatting`</span>
<span class="gi">+for more information on string formatting.</span>
<span class="gi">+</span>
<span class="gi">+The useful mapping keys in a :class:`LogRecord` are given in the section on</span>
<span class="gi">+:ref:`logrecord-attributes`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. class:: Formatter(fmt=None, datefmt=None)</span>
<span class="gi">+</span>
<span class="gi">+   Returns a new instance of the :class:`Formatter` class.  The instance is</span>
<span class="gi">+   initialized with a format string for the message as a whole, as well as a</span>
<span class="gi">+   format string for the date/time portion of a message.  If no *fmt* is</span>
<span class="gi">+   specified, ``&#39;%(message)s&#39;`` is used.  If no *datefmt* is specified, the</span>
<span class="gi">+   ISO8601 date format is used.</span>
<span class="gi">+</span>
<span class="gi">+   .. method:: format(record)</span>
<span class="gi">+</span>
<span class="gi">+      The record&#39;s attribute dictionary is used as the operand to a string</span>
<span class="gi">+      formatting operation. Returns the resulting string. Before formatting the</span>
<span class="gi">+      dictionary, a couple of preparatory steps are carried out. The *message*</span>
<span class="gi">+      attribute of the record is computed using *msg* % *args*. If the</span>
<span class="gi">+      formatting string contains ``&#39;(asctime)&#39;``, :meth:`formatTime` is called</span>
<span class="gi">+      to format the event time. If there is exception information, it is</span>
<span class="gi">+      formatted using :meth:`formatException` and appended to the message. Note</span>
<span class="gi">+      that the formatted exception information is cached in attribute</span>
<span class="gi">+      *exc_text*. This is useful because the exception information can be</span>
<span class="gi">+      pickled and sent across the wire, but you should be careful if you have</span>
<span class="gi">+      more than one :class:`Formatter` subclass which customizes the formatting</span>
<span class="gi">+      of exception information. In this case, you will have to clear the cached</span>
<span class="gi">+      value after a formatter has done its formatting, so that the next</span>
<span class="gi">+      formatter to handle the event doesn&#39;t use the cached value but</span>
<span class="gi">+      recalculates it afresh.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+   .. method:: formatTime(record, datefmt=None)</span>
<span class="gi">+</span>
<span class="gi">+      This method should be called from :meth:`format` by a formatter which</span>
<span class="gi">+      wants to make use of a formatted time. This method can be overridden in</span>
<span class="gi">+      formatters to provide for any specific requirement, but the basic behavior</span>
<span class="gi">+      is as follows: if *datefmt* (a string) is specified, it is used with</span>
<span class="gi">+      :func:`time.strftime` to format the creation time of the</span>
<span class="gi">+      record. Otherwise, the ISO8601 format is used.  The resulting string is</span>
<span class="gi">+      returned.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+   .. method:: formatException(exc_info)</span>
<span class="gi">+</span>
<span class="gi">+      Formats the specified exception information (a standard exception tuple as</span>
<span class="gi">+      returned by :func:`sys.exc_info`) as a string. This default implementation</span>
<span class="gi">+      just uses :func:`traceback.print_exception`. The resulting string is</span>
<span class="gi">+      returned.</span>
<span class="gi">+</span>
<span class="gi">+.. _filter:</span>
<span class="gi">+</span>
<span class="gi">+Filter Objects</span>
<span class="gi">+--------------</span>
<span class="gi">+</span>
<span class="gi">+``Filters`` can be used by ``Handlers`` and ``Loggers`` for more sophisticated</span>
<span class="gi">+filtering than is provided by levels. The base filter class only allows events</span>
<span class="gi">+which are below a certain point in the logger hierarchy. For example, a filter</span>
<span class="gi">+initialized with &#39;A.B&#39; will allow events logged by loggers &#39;A.B&#39;, &#39;A.B.C&#39;,</span>
<span class="gi">+&#39;A.B.C.D&#39;, &#39;A.B.D&#39; etc. but not &#39;A.BB&#39;, &#39;B.A.B&#39; etc. If initialized with the</span>
<span class="gi">+empty string, all events are passed.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. class:: Filter(name=&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+   Returns an instance of the :class:`Filter` class. If *name* is specified, it</span>
<span class="gi">+   names a logger which, together with its children, will have its events allowed</span>
<span class="gi">+   through the filter. If *name* is the empty string, allows every event.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+   .. method:: filter(record)</span>
<span class="gi">+</span>
<span class="gi">+      Is the specified record to be logged? Returns zero for no, nonzero for</span>
<span class="gi">+      yes. If deemed appropriate, the record may be modified in-place by this</span>
<span class="gi">+      method.</span>
<span class="gi">+</span>
<span class="gi">+Note that filters attached to handlers are consulted whenever an event is</span>
<span class="gi">+emitted by the handler, whereas filters attached to loggers are consulted</span>
<span class="gi">+whenever an event is logged to the handler (using :meth:`debug`, :meth:`info`,</span>
<span class="gi">+etc.) This means that events which have been generated by descendant loggers</span>
<span class="gi">+will not be filtered by a logger&#39;s filter setting, unless the filter has also</span>
<span class="gi">+been applied to those descendant loggers.</span>
<span class="gi">+</span>
<span class="gi">+You don&#39;t actually need to subclass ``Filter``: you can pass any instance</span>
<span class="gi">+which has a ``filter`` method with the same semantics.</span>
<span class="gi">+</span>
<span class="gi">+Although filters are used primarily to filter records based on more</span>
<span class="gi">+sophisticated criteria than levels, they get to see every record which is</span>
<span class="gi">+processed by the handler or logger they&#39;re attached to: this can be useful if</span>
<span class="gi">+you want to do things like counting how many records were processed by a</span>
<span class="gi">+particular logger or handler, or adding, changing or removing attributes in</span>
<span class="gi">+the LogRecord being processed. Obviously changing the LogRecord needs to be</span>
<span class="gi">+done with some care, but it does allow the injection of contextual information</span>
<span class="gi">+into logs (see :ref:`filters-contextual`).</span>
<span class="gi">+</span>
<span class="gi">+.. _log-record:</span>
<span class="gi">+</span>
<span class="gi">+LogRecord Objects</span>
<span class="gi">+-----------------</span>
<span class="gi">+</span>
<span class="gi">+:class:`LogRecord` instances are created automatically by the :class:`Logger`</span>
<span class="gi">+every time something is logged, and can be created manually via</span>
<span class="gi">+:func:`makeLogRecord` (for example, from a pickled event received over the</span>
<span class="gi">+wire).</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. class:: LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None)</span>
<span class="gi">+</span>
<span class="gi">+   Contains all the information pertinent to the event being logged.</span>
<span class="gi">+</span>
<span class="gi">+   The primary information is passed in :attr:`msg` and :attr:`args`, which</span>
<span class="gi">+   are combined using ``msg % args`` to create the :attr:`message` field of the</span>
<span class="gi">+   record.</span>
<span class="gi">+</span>
<span class="gi">+   :param name:  The name of the logger used to log the event represented by</span>
<span class="gi">+                 this LogRecord.</span>
<span class="gi">+   :param level: The numeric level of the logging event (one of DEBUG, INFO etc.)</span>
<span class="gi">+   :param pathname: The full pathname of the source file where the logging call</span>
<span class="gi">+                    was made.</span>
<span class="gi">+   :param lineno: The line number in the source file where the logging call was</span>
<span class="gi">+                  made.</span>
<span class="gi">+   :param msg: The event description message, possibly a format string with</span>
<span class="gi">+               placeholders for variable data.</span>
<span class="gi">+   :param args: Variable data to merge into the *msg* argument to obtain the</span>
<span class="gi">+                event description.</span>
<span class="gi">+   :param exc_info: An exception tuple with the current exception information,</span>
<span class="gi">+                    or *None* if no exception information is available.</span>
<span class="gi">+   :param func: The name of the function or method from which the logging call</span>
<span class="gi">+                was invoked.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionchanged:: 2.5</span>
<span class="gi">+      *func* was added.</span>
<span class="gi">+</span>
<span class="gi">+   .. method:: getMessage()</span>
<span class="gi">+</span>
<span class="gi">+      Returns the message for this :class:`LogRecord` instance after merging any</span>
<span class="gi">+      user-supplied arguments with the message. If the user-supplied message</span>
<span class="gi">+      argument to the logging call is not a string, :func:`str` is called on it to</span>
<span class="gi">+      convert it to a string. This allows use of user-defined classes as</span>
<span class="gi">+      messages, whose ``__str__`` method can return the actual format string to</span>
<span class="gi">+      be used.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. _logrecord-attributes:</span>
<span class="gi">+</span>
<span class="gi">+LogRecord attributes</span>
<span class="gi">+--------------------</span>
<span class="gi">+</span>
<span class="gi">+The LogRecord has a number of attributes, most of which are derived from the</span>
<span class="gi">+parameters to the constructor. (Note that the names do not always correspond</span>
<span class="gi">+exactly between the LogRecord constructor parameters and the LogRecord</span>
<span class="gi">+attributes.) These attributes can be used to merge data from the record into</span>
<span class="gi">+the format string. The following table lists (in alphabetical order) the</span>
<span class="gi">+attribute names, their meanings and the corresponding placeholder in a %-style</span>
<span class="gi">+format string.</span>
<span class="gi">+</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| Attribute name | Format                  | Description                                   |</span>
<span class="gi">++================+=========================+===============================================+</span>
<span class="gi">+| args           | You shouldn&#39;t need to   | The tuple of arguments merged into ``msg`` to |</span>
<span class="gi">+|                | format this yourself.   | produce ``message``.                          |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| asctime        | ``%(asctime)s``         | Human-readable time when the                  |</span>
<span class="gi">+|                |                         | :class:`LogRecord` was created.  By default   |</span>
<span class="gi">+|                |                         | this is of the form &#39;2003-07-08 16:49:45,896&#39; |</span>
<span class="gi">+|                |                         | (the numbers after the comma are millisecond  |</span>
<span class="gi">+|                |                         | portion of the time).                         |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| created        | ``%(created)f``         | Time when the :class:`LogRecord` was created  |</span>
<span class="gi">+|                |                         | (as returned by :func:`time.time`).           |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| exc_info       | You shouldn&#39;t need to   | Exception tuple (à la ``sys.exc_info``) or,   |</span>
<span class="gi">+|                | format this yourself.   | if no exception has occurred, *None*.         |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| filename       | ``%(filename)s``        | Filename portion of ``pathname``.             |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| funcName       | ``%(funcName)s``        | Name of function containing the logging call. |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| levelname      | ``%(levelname)s``       | Text logging level for the message            |</span>
<span class="gi">+|                |                         | (``&#39;DEBUG&#39;``, ``&#39;INFO&#39;``, ``&#39;WARNING&#39;``,      |</span>
<span class="gi">+|                |                         | ``&#39;ERROR&#39;``, ``&#39;CRITICAL&#39;``).                 |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| levelno        | ``%(levelno)s``         | Numeric logging level for the message         |</span>
<span class="gi">+|                |                         | (:const:`DEBUG`, :const:`INFO`,               |</span>
<span class="gi">+|                |                         | :const:`WARNING`, :const:`ERROR`,             |</span>
<span class="gi">+|                |                         | :const:`CRITICAL`).                           |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| lineno         | ``%(lineno)d``          | Source line number where the logging call was |</span>
<span class="gi">+|                |                         | issued (if available).                        |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| module         | ``%(module)s``          | Module (name portion of ``filename``).        |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| msecs          | ``%(msecs)d``           | Millisecond portion of the time when the      |</span>
<span class="gi">+|                |                         | :class:`LogRecord` was created.               |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| message        | ``%(message)s``         | The logged message, computed as ``msg %       |</span>
<span class="gi">+|                |                         | args``. This is set when                      |</span>
<span class="gi">+|                |                         | :meth:`Formatter.format` is invoked.          |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| msg            | You shouldn&#39;t need to   | The format string passed in the original      |</span>
<span class="gi">+|                | format this yourself.   | logging call. Merged with ``args`` to         |</span>
<span class="gi">+|                |                         | produce ``message``, or an arbitrary object   |</span>
<span class="gi">+|                |                         | (see :ref:`arbitrary-object-messages`).       |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| name           | ``%(name)s``            | Name of the logger used to log the call.      |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| pathname       | ``%(pathname)s``        | Full pathname of the source file where the    |</span>
<span class="gi">+|                |                         | logging call was issued (if available).       |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| process        | ``%(process)d``         | Process ID (if available).                    |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| processName    | ``%(processName)s``     | Process name (if available).                  |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| relativeCreated| ``%(relativeCreated)d`` | Time in milliseconds when the LogRecord was   |</span>
<span class="gi">+|                |                         | created, relative to the time the logging     |</span>
<span class="gi">+|                |                         | module was loaded.                            |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| thread         | ``%(thread)d``          | Thread ID (if available).                     |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+| threadName     | ``%(threadName)s``      | Thread name (if available).                   |</span>
<span class="gi">++----------------+-------------------------+-----------------------------------------------+</span>
<span class="gi">+</span>
<span class="gi">+.. versionchanged:: 2.5</span>
<span class="gi">+   *funcName* was added.</span>
<span class="gi">+</span>
<span class="gi">+.. _logger-adapter:</span>
<span class="gi">+</span>
<span class="gi">+LoggerAdapter Objects</span>
<span class="gi">+---------------------</span>
<span class="gi">+</span>
<span class="gi">+:class:`LoggerAdapter` instances are used to conveniently pass contextual</span>
<span class="gi">+information into logging calls. For a usage example , see the section on</span>
<span class="gi">+:ref:`adding contextual information to your logging output &lt;context-info&gt;`.</span>
<span class="gi">+</span>
<span class="gi">+.. versionadded:: 2.6</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. class:: LoggerAdapter(logger, extra)</span>
<span class="gi">+</span>
<span class="gi">+   Returns an instance of :class:`LoggerAdapter` initialized with an</span>
<span class="gi">+   underlying :class:`Logger` instance and a dict-like object.</span>
<span class="gi">+</span>
<span class="gi">+   .. method:: process(msg, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+      Modifies the message and/or keyword arguments passed to a logging call in</span>
<span class="gi">+      order to insert contextual information. This implementation takes the object</span>
<span class="gi">+      passed as *extra* to the constructor and adds it to *kwargs* using key</span>
<span class="gi">+      &#39;extra&#39;. The return value is a (*msg*, *kwargs*) tuple which has the</span>
<span class="gi">+      (possibly modified) versions of the arguments passed in.</span>
<span class="gi">+</span>
<span class="gi">+In addition to the above, :class:`LoggerAdapter` supports the following</span>
<span class="gi">+methods of :class:`Logger`, i.e. :meth:`debug`, :meth:`info`, :meth:`warning`,</span>
<span class="gi">+:meth:`error`, :meth:`exception`, :meth:`critical`, :meth:`log`,</span>
<span class="gi">+:meth:`isEnabledFor`, :meth:`getEffectiveLevel`, :meth:`setLevel`,</span>
<span class="gi">+:meth:`hasHandlers`. These methods have the same signatures as their</span>
<span class="gi">+counterparts in :class:`Logger`, so you can use the two types of instances</span>
<span class="gi">+interchangeably.</span>
<span class="gi">+</span>
<span class="gi">+.. versionchanged:: 2.7</span>
<span class="gi">+   The :meth:`isEnabledFor` method was added to :class:`LoggerAdapter`.  This</span>
<span class="gi">+   method delegates to the underlying logger.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Thread Safety</span>
<span class="gi">+-------------</span>
<span class="gi">+</span>
<span class="gi">+The logging module is intended to be thread-safe without any special work</span>
<span class="gi">+needing to be done by its clients. It achieves this though using threading</span>
<span class="gi">+locks; there is one lock to serialize access to the module&#39;s shared data, and</span>
<span class="gi">+each handler also creates a lock to serialize access to its underlying I/O.</span>
<span class="gi">+</span>
<span class="gi">+If you are implementing asynchronous signal handlers using the :mod:`signal`</span>
<span class="gi">+module, you may not be able to use logging from within such handlers. This is</span>
<span class="gi">+because lock implementations in the :mod:`threading` module are not always</span>
<span class="gi">+re-entrant, and so cannot be invoked from such signal handlers.</span>
<span class="gi">+</span>
 
 Module-Level Functions
 ----------------------
 
 In addition to the classes described above, there are a number of module- level
 functions.
 
 
 .. function:: getLogger([name])
 
    Return a logger with the specified name or, if no name is specified, return a
    logger which is the root logger of the hierarchy. If specified, the name is
<span class="gu">@@ -641,25 +696,25 @@</span>
 
    The other optional keyword argument is *extra* which can be used to pass a
    dictionary which is used to populate the __dict__ of the LogRecord created for
    the logging event with user-defined attributes. These custom attributes can then
    be used as you like. For example, they could be incorporated into logged
    messages. For example::
 
       FORMAT = &quot;%(asctime)-15s %(clientip)s %(user)-8s %(message)s&quot;
       logging.basicConfig(format=FORMAT)
       d = {&#39;clientip&#39;: &#39;192.168.0.1&#39;, &#39;user&#39;: &#39;fbloggs&#39;}
       logging.warning(&quot;Protocol problem: %s&quot;, &quot;connection reset&quot;, extra=d)
 
<span class="gd">-   would print something like  ::</span>
<span class="gi">+   would print something like::</span>
 
       2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
 
    The keys in the dictionary passed in *extra* should not clash with the keys used
    by the logging system. (See the :class:`Formatter` documentation for more
    information on which keys are used by the logging system.)
 
    If you choose to use these attributes in logged messages, you need to exercise
    some care. In the above example, for instance, the :class:`Formatter` has been
    set up with a format string which expects &#39;clientip&#39; and &#39;user&#39; in the attribute
    dictionary of the LogRecord. If these are missing, the message will not be
    logged because a string formatting exception will occur. So in this case, you
<span class="gu">@@ -703,45 +758,55 @@</span>
 .. function:: exception(msg[, *args])
 
    Logs a message with level :const:`ERROR` on the root logger. The arguments are
    interpreted as for :func:`debug`. Exception info is added to the logging
    message. This function should only be called from an exception handler.
 
 
 .. function:: log(level, msg[, *args[, **kwargs]])
 
    Logs a message with level *level* on the root logger. The other arguments are
    interpreted as for :func:`debug`.
 
<span class="gi">+   PLEASE NOTE: The above module-level functions which delegate to the root</span>
<span class="gi">+   logger should *not* be used in threads, in versions of Python earlier than</span>
<span class="gi">+   2.7.1 and 3.2, unless at least one handler has been added to the root</span>
<span class="gi">+   logger *before* the threads are started. These convenience functions call</span>
<span class="gi">+   :func:`basicConfig` to ensure that at least one handler is available; in</span>
<span class="gi">+   earlier versions of Python, this can (under rare circumstances) lead to</span>
<span class="gi">+   handlers being added multiple times to the root logger, which can in turn</span>
<span class="gi">+   lead to multiple messages for the same event.</span>
 
 .. function:: disable(lvl)
 
    Provides an overriding level *lvl* for all loggers which takes precedence over
    the logger&#39;s own level. When the need arises to temporarily throttle logging
    output down across the whole application, this function can be useful. Its
    effect is to disable all logging calls of severity *lvl* and below, so that
    if you call it with a value of INFO, then all INFO and DEBUG events would be
    discarded, whereas those of severity WARNING and above would be processed
    according to the logger&#39;s effective level.
 
 
 .. function:: addLevelName(lvl, levelName)
 
    Associates level *lvl* with text *levelName* in an internal dictionary, which is
    used to map numeric levels to a textual representation, for example when a
    :class:`Formatter` formats a message. This function can also be used to define
    your own levels. The only constraints are that all levels used must be
    registered using this function, levels should be positive integers and they
    should increase in increasing order of severity.
 
<span class="gi">+   NOTE: If you are thinking of defining your own levels, please see the section</span>
<span class="gi">+   on :ref:`custom-levels`.</span>
 
 .. function:: getLevelName(lvl)
 
    Returns the textual representation of logging level *lvl*. If the level is one
    of the predefined levels :const:`CRITICAL`, :const:`ERROR`, :const:`WARNING`,
    :const:`INFO` or :const:`DEBUG` then you get the corresponding string. If you
    have associated levels with names using :func:`addLevelName` then the name you
    have associated with *lvl* is returned. If a numeric value corresponding to one
    of the defined levels is passed in, the corresponding string representation is
    returned. Otherwise, the string &quot;Level %s&quot; % lvl is returned.
 
 
<span class="gu">@@ -758,24 +823,31 @@</span>
    Does basic configuration for the logging system by creating a
    :class:`StreamHandler` with a default :class:`Formatter` and adding it to the
    root logger. The functions :func:`debug`, :func:`info`, :func:`warning`,
    :func:`error` and :func:`critical` will call :func:`basicConfig` automatically
    if no handlers are defined for the root logger.
 
    This function does nothing if the root logger already has handlers
    configured for it.
 
    .. versionchanged:: 2.4
       Formerly, :func:`basicConfig` did not take any keyword arguments.
 
<span class="gi">+   PLEASE NOTE: This function should be called from the main thread</span>
<span class="gi">+   before other threads are started. In versions of Python prior to</span>
<span class="gi">+   2.7.1 and 3.2, if this function is called from multiple threads,</span>
<span class="gi">+   it is possible (in rare circumstances) that a handler will be added</span>
<span class="gi">+   to the root logger more than once, leading to unexpected results</span>
<span class="gi">+   such as messages being duplicated in the log.</span>
<span class="gi">+</span>
    The following keyword arguments are supported.
 
    +--------------+---------------------------------------------+
    | Format       | Description                                 |
    +==============+=============================================+
    | ``filename`` | Specifies that a FileHandler be created,    |
    |              | using the specified filename, rather than a |
    |              | StreamHandler.                              |
    +--------------+---------------------------------------------+
    | ``filemode`` | Specifies the mode to open the file, if     |
    |              | filename is specified (if filemode is       |
    |              | unspecified, it defaults to &#39;a&#39;).           |
<span class="gu">@@ -802,2130 +874,52 @@</span>
    further use of the logging system should be made after this call.
 
 
 .. function:: setLoggerClass(klass)
 
    Tells the logging system to use the class *klass* when instantiating a logger.
    The class should define :meth:`__init__` such that only a name argument is
    required, and the :meth:`__init__` should call :meth:`Logger.__init__`. This
    function is typically called before any loggers are instantiated by applications
    which need to use custom logger behavior.
 
 
<span class="gi">+Integration with the warnings module</span>
<span class="gi">+------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+The :func:`captureWarnings` function can be used to integrate :mod:`logging`</span>
<span class="gi">+with the :mod:`warnings` module.</span>
<span class="gi">+</span>
<span class="gi">+.. function:: captureWarnings(capture)</span>
<span class="gi">+</span>
<span class="gi">+   This function is used to turn the capture of warnings by logging on and</span>
<span class="gi">+   off.</span>
<span class="gi">+</span>
<span class="gi">+   If *capture* is ``True``, warnings issued by the :mod:`warnings` module will</span>
<span class="gi">+   be redirected to the logging system. Specifically, a warning will be</span>
<span class="gi">+   formatted using :func:`warnings.formatwarning` and the resulting string</span>
<span class="gi">+   logged to a logger named &#39;py.warnings&#39; with a severity of `WARNING`.</span>
<span class="gi">+</span>
<span class="gi">+   If *capture* is ``False``, the redirection of warnings to the logging system</span>
<span class="gi">+   will stop, and warnings will be redirected to their original destinations</span>
<span class="gi">+   (i.e. those in effect before `captureWarnings(True)` was called).</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. seealso::
 
<span class="gi">+   Module :mod:`logging.config`</span>
<span class="gi">+      Configuration API for the logging module.</span>
<span class="gi">+</span>
<span class="gi">+   Module :mod:`logging.handlers`</span>
<span class="gi">+      Useful handlers included with the logging module.</span>
<span class="gi">+</span>
    :pep:`282` - A Logging System
       The proposal which described this feature for inclusion in the Python standard
       library.
 
    `Original Python logging package &lt;http://www.red-dove.com/python_logging.html&gt;`_
       This is the original source for the :mod:`logging` package.  The version of the
       package available from this site is suitable for use with Python 1.5.2, 2.1.x
       and 2.2.x, which do not include the :mod:`logging` package in the standard
       library.
 
<span class="gd">-.. _logger:</span>
<span class="gd">-</span>
<span class="gd">-Logger Objects</span>
<span class="gd">---------------</span>
<span class="gd">-</span>
<span class="gd">-Loggers have the following attributes and methods. Note that Loggers are never</span>
<span class="gd">-instantiated directly, but always through the module-level function</span>
<span class="gd">-``logging.getLogger(name)``.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. attribute:: Logger.propagate</span>
<span class="gd">-</span>
<span class="gd">-   If this evaluates to false, logging messages are not passed by this logger or by</span>
<span class="gd">-   its child loggers to the handlers of higher level (ancestor) loggers. The</span>
<span class="gd">-   constructor sets this attribute to 1.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.setLevel(lvl)</span>
<span class="gd">-</span>
<span class="gd">-   Sets the threshold for this logger to *lvl*. Logging messages which are less</span>
<span class="gd">-   severe than *lvl* will be ignored. When a logger is created, the level is set to</span>
<span class="gd">-   :const:`NOTSET` (which causes all messages to be processed when the logger is</span>
<span class="gd">-   the root logger, or delegation to the parent when the logger is a non-root</span>
<span class="gd">-   logger). Note that the root logger is created with level :const:`WARNING`.</span>
<span class="gd">-</span>
<span class="gd">-   The term &quot;delegation to the parent&quot; means that if a logger has a level of</span>
<span class="gd">-   NOTSET, its chain of ancestor loggers is traversed until either an ancestor with</span>
<span class="gd">-   a level other than NOTSET is found, or the root is reached.</span>
<span class="gd">-</span>
<span class="gd">-   If an ancestor is found with a level other than NOTSET, then that ancestor&#39;s</span>
<span class="gd">-   level is treated as the effective level of the logger where the ancestor search</span>
<span class="gd">-   began, and is used to determine how a logging event is handled.</span>
<span class="gd">-</span>
<span class="gd">-   If the root is reached, and it has a level of NOTSET, then all messages will be</span>
<span class="gd">-   processed. Otherwise, the root&#39;s level will be used as the effective level.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.isEnabledFor(lvl)</span>
<span class="gd">-</span>
<span class="gd">-   Indicates if a message of severity *lvl* would be processed by this logger.</span>
<span class="gd">-   This method checks first the module-level level set by</span>
<span class="gd">-   ``logging.disable(lvl)`` and then the logger&#39;s effective level as determined</span>
<span class="gd">-   by :meth:`getEffectiveLevel`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.getEffectiveLevel()</span>
<span class="gd">-</span>
<span class="gd">-   Indicates the effective level for this logger. If a value other than</span>
<span class="gd">-   :const:`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise,</span>
<span class="gd">-   the hierarchy is traversed towards the root until a value other than</span>
<span class="gd">-   :const:`NOTSET` is found, and that value is returned.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.debug(msg[, *args[, **kwargs]])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with level :const:`DEBUG` on this logger. The *msg* is the</span>
<span class="gd">-   message format string, and the *args* are the arguments which are merged into</span>
<span class="gd">-   *msg* using the string formatting operator. (Note that this means that you can</span>
<span class="gd">-   use keywords in the format string, together with a single dictionary argument.)</span>
<span class="gd">-</span>
<span class="gd">-   There are two keyword arguments in *kwargs* which are inspected: *exc_info*</span>
<span class="gd">-   which, if it does not evaluate as false, causes exception information to be</span>
<span class="gd">-   added to the logging message. If an exception tuple (in the format returned by</span>
<span class="gd">-   :func:`sys.exc_info`) is provided, it is used; otherwise, :func:`sys.exc_info`</span>
<span class="gd">-   is called to get the exception information.</span>
<span class="gd">-</span>
<span class="gd">-   The other optional keyword argument is *extra* which can be used to pass a</span>
<span class="gd">-   dictionary which is used to populate the __dict__ of the LogRecord created for</span>
<span class="gd">-   the logging event with user-defined attributes. These custom attributes can then</span>
<span class="gd">-   be used as you like. For example, they could be incorporated into logged</span>
<span class="gd">-   messages. For example::</span>
<span class="gd">-</span>
<span class="gd">-      FORMAT = &quot;%(asctime)-15s %(clientip)s %(user)-8s %(message)s&quot;</span>
<span class="gd">-      logging.basicConfig(format=FORMAT)</span>
<span class="gd">-      d = { &#39;clientip&#39; : &#39;192.168.0.1&#39;, &#39;user&#39; : &#39;fbloggs&#39; }</span>
<span class="gd">-      logger = logging.getLogger(&quot;tcpserver&quot;)</span>
<span class="gd">-      logger.warning(&quot;Protocol problem: %s&quot;, &quot;connection reset&quot;, extra=d)</span>
<span class="gd">-</span>
<span class="gd">-   would print something like  ::</span>
<span class="gd">-</span>
<span class="gd">-      2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset</span>
<span class="gd">-</span>
<span class="gd">-   The keys in the dictionary passed in *extra* should not clash with the keys used</span>
<span class="gd">-   by the logging system. (See the :class:`Formatter` documentation for more</span>
<span class="gd">-   information on which keys are used by the logging system.)</span>
<span class="gd">-</span>
<span class="gd">-   If you choose to use these attributes in logged messages, you need to exercise</span>
<span class="gd">-   some care. In the above example, for instance, the :class:`Formatter` has been</span>
<span class="gd">-   set up with a format string which expects &#39;clientip&#39; and &#39;user&#39; in the attribute</span>
<span class="gd">-   dictionary of the LogRecord. If these are missing, the message will not be</span>
<span class="gd">-   logged because a string formatting exception will occur. So in this case, you</span>
<span class="gd">-   always need to pass the *extra* dictionary with these keys.</span>
<span class="gd">-</span>
<span class="gd">-   While this might be annoying, this feature is intended for use in specialized</span>
<span class="gd">-   circumstances, such as multi-threaded servers where the same code executes in</span>
<span class="gd">-   many contexts, and interesting conditions which arise are dependent on this</span>
<span class="gd">-   context (such as remote client IP address and authenticated user name, in the</span>
<span class="gd">-   above example). In such circumstances, it is likely that specialized</span>
<span class="gd">-   :class:`Formatter`\ s would be used with particular :class:`Handler`\ s.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.5</span>
<span class="gd">-      *extra* was added.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.info(msg[, *args[, **kwargs]])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with level :const:`INFO` on this logger. The arguments are</span>
<span class="gd">-   interpreted as for :meth:`debug`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.warning(msg[, *args[, **kwargs]])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with level :const:`WARNING` on this logger. The arguments are</span>
<span class="gd">-   interpreted as for :meth:`debug`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.error(msg[, *args[, **kwargs]])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with level :const:`ERROR` on this logger. The arguments are</span>
<span class="gd">-   interpreted as for :meth:`debug`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.critical(msg[, *args[, **kwargs]])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with level :const:`CRITICAL` on this logger. The arguments are</span>
<span class="gd">-   interpreted as for :meth:`debug`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.log(lvl, msg[, *args[, **kwargs]])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with integer level *lvl* on this logger. The other arguments are</span>
<span class="gd">-   interpreted as for :meth:`debug`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.exception(msg[, *args])</span>
<span class="gd">-</span>
<span class="gd">-   Logs a message with level :const:`ERROR` on this logger. The arguments are</span>
<span class="gd">-   interpreted as for :meth:`debug`. Exception info is added to the logging</span>
<span class="gd">-   message. This method should only be called from an exception handler.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.addFilter(filt)</span>
<span class="gd">-</span>
<span class="gd">-   Adds the specified filter *filt* to this logger.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.removeFilter(filt)</span>
<span class="gd">-</span>
<span class="gd">-   Removes the specified filter *filt* from this logger.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.filter(record)</span>
<span class="gd">-</span>
<span class="gd">-   Applies this logger&#39;s filters to the record and returns a true value if the</span>
<span class="gd">-   record is to be processed.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.addHandler(hdlr)</span>
<span class="gd">-</span>
<span class="gd">-   Adds the specified handler *hdlr* to this logger.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.removeHandler(hdlr)</span>
<span class="gd">-</span>
<span class="gd">-   Removes the specified handler *hdlr* from this logger.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.findCaller()</span>
<span class="gd">-</span>
<span class="gd">-   Finds the caller&#39;s source filename and line number. Returns the filename, line</span>
<span class="gd">-   number and function name as a 3-element tuple.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.4</span>
<span class="gd">-      The function name was added. In earlier versions, the filename and line number</span>
<span class="gd">-      were returned as a 2-element tuple..</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.handle(record)</span>
<span class="gd">-</span>
<span class="gd">-   Handles a record by passing it to all handlers associated with this logger and</span>
<span class="gd">-   its ancestors (until a false value of *propagate* is found). This method is used</span>
<span class="gd">-   for unpickled records received from a socket, as well as those created locally.</span>
<span class="gd">-   Logger-level filtering is applied using :meth:`~Logger.filter`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Logger.makeRecord(name, lvl, fn, lno, msg, args, exc_info [, func, extra])</span>
<span class="gd">-</span>
<span class="gd">-   This is a factory method which can be overridden in subclasses to create</span>
<span class="gd">-   specialized :class:`LogRecord` instances.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.5</span>
<span class="gd">-      *func* and *extra* were added.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _minimal-example:</span>
<span class="gd">-</span>
<span class="gd">-Basic example</span>
<span class="gd">--------------</span>
<span class="gd">-</span>
<span class="gd">-.. versionchanged:: 2.4</span>
<span class="gd">-   formerly :func:`basicConfig` did not take any keyword arguments.</span>
<span class="gd">-</span>
<span class="gd">-The :mod:`logging` package provides a lot of flexibility, and its configuration</span>
<span class="gd">-can appear daunting.  This section demonstrates that simple use of the logging</span>
<span class="gd">-package is possible.</span>
<span class="gd">-</span>
<span class="gd">-The simplest example shows logging to the console::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   logging.debug(&#39;A debug message&#39;)</span>
<span class="gd">-   logging.info(&#39;Some information&#39;)</span>
<span class="gd">-   logging.warning(&#39;A shot across the bows&#39;)</span>
<span class="gd">-</span>
<span class="gd">-If you run the above script, you&#39;ll see this::</span>
<span class="gd">-</span>
<span class="gd">-   WARNING:root:A shot across the bows</span>
<span class="gd">-</span>
<span class="gd">-Because no particular logger was specified, the system used the root logger. The</span>
<span class="gd">-debug and info messages didn&#39;t appear because by default, the root logger is</span>
<span class="gd">-configured to only handle messages with a severity of WARNING or above. The</span>
<span class="gd">-message format is also a configuration default, as is the output destination of</span>
<span class="gd">-the messages - ``sys.stderr``. The severity level, the message format and</span>
<span class="gd">-destination can be easily changed, as shown in the example below::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   logging.basicConfig(level=logging.DEBUG,</span>
<span class="gd">-                       format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,</span>
<span class="gd">-                       filename=&#39;myapp.log&#39;,</span>
<span class="gd">-                       filemode=&#39;w&#39;)</span>
<span class="gd">-   logging.debug(&#39;A debug message&#39;)</span>
<span class="gd">-   logging.info(&#39;Some information&#39;)</span>
<span class="gd">-   logging.warning(&#39;A shot across the bows&#39;)</span>
<span class="gd">-</span>
<span class="gd">-The :meth:`basicConfig` method is used to change the configuration defaults,</span>
<span class="gd">-which results in output (written to ``myapp.log``) which should look</span>
<span class="gd">-something like the following::</span>
<span class="gd">-</span>
<span class="gd">-   2004-07-02 13:00:08,743 DEBUG A debug message</span>
<span class="gd">-   2004-07-02 13:00:08,743 INFO Some information</span>
<span class="gd">-   2004-07-02 13:00:08,743 WARNING A shot across the bows</span>
<span class="gd">-</span>
<span class="gd">-This time, all messages with a severity of DEBUG or above were handled, and the</span>
<span class="gd">-format of the messages was also changed, and output went to the specified file</span>
<span class="gd">-rather than the console.</span>
<span class="gd">-</span>
<span class="gd">-Formatting uses standard Python string formatting - see section</span>
<span class="gd">-:ref:`string-formatting`. The format string takes the following common</span>
<span class="gd">-specifiers. For a complete list of specifiers, consult the :class:`Formatter`</span>
<span class="gd">-documentation.</span>
<span class="gd">-</span>
<span class="gd">-+-------------------+-----------------------------------------------+</span>
<span class="gd">-| Format            | Description                                   |</span>
<span class="gd">-+===================+===============================================+</span>
<span class="gd">-| ``%(name)s``      | Name of the logger (logging channel).         |</span>
<span class="gd">-+-------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(levelname)s`` | Text logging level for the message            |</span>
<span class="gd">-|                   | (``&#39;DEBUG&#39;``, ``&#39;INFO&#39;``, ``&#39;WARNING&#39;``,      |</span>
<span class="gd">-|                   | ``&#39;ERROR&#39;``, ``&#39;CRITICAL&#39;``).                 |</span>
<span class="gd">-+-------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(asctime)s``   | Human-readable time when the                  |</span>
<span class="gd">-|                   | :class:`LogRecord` was created.  By default   |</span>
<span class="gd">-|                   | this is of the form &quot;2003-07-08 16:49:45,896&quot; |</span>
<span class="gd">-|                   | (the numbers after the comma are millisecond  |</span>
<span class="gd">-|                   | portion of the time).                         |</span>
<span class="gd">-+-------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(message)s``   | The logged message.                           |</span>
<span class="gd">-+-------------------+-----------------------------------------------+</span>
<span class="gd">-</span>
<span class="gd">-To change the date/time format, you can pass an additional keyword parameter,</span>
<span class="gd">-*datefmt*, as in the following::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   logging.basicConfig(level=logging.DEBUG,</span>
<span class="gd">-                       format=&#39;%(asctime)s %(levelname)-8s %(message)s&#39;,</span>
<span class="gd">-                       datefmt=&#39;%a, %d %b %Y %H:%M:%S&#39;,</span>
<span class="gd">-                       filename=&#39;/temp/myapp.log&#39;,</span>
<span class="gd">-                       filemode=&#39;w&#39;)</span>
<span class="gd">-   logging.debug(&#39;A debug message&#39;)</span>
<span class="gd">-   logging.info(&#39;Some information&#39;)</span>
<span class="gd">-   logging.warning(&#39;A shot across the bows&#39;)</span>
<span class="gd">-</span>
<span class="gd">-which would result in output like ::</span>
<span class="gd">-</span>
<span class="gd">-   Fri, 02 Jul 2004 13:06:18 DEBUG    A debug message</span>
<span class="gd">-   Fri, 02 Jul 2004 13:06:18 INFO     Some information</span>
<span class="gd">-   Fri, 02 Jul 2004 13:06:18 WARNING  A shot across the bows</span>
<span class="gd">-</span>
<span class="gd">-The date format string follows the requirements of :func:`strftime` - see the</span>
<span class="gd">-documentation for the :mod:`time` module.</span>
<span class="gd">-</span>
<span class="gd">-If, instead of sending logging output to the console or a file, you&#39;d rather use</span>
<span class="gd">-a file-like object which you have created separately, you can pass it to</span>
<span class="gd">-:func:`basicConfig` using the *stream* keyword argument. Note that if both</span>
<span class="gd">-*stream* and *filename* keyword arguments are passed, the *stream* argument is</span>
<span class="gd">-ignored.</span>
<span class="gd">-</span>
<span class="gd">-Of course, you can put variable information in your output. To do this, simply</span>
<span class="gd">-have the message be a format string and pass in additional arguments containing</span>
<span class="gd">-the variable information, as in the following example::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   logging.basicConfig(level=logging.DEBUG,</span>
<span class="gd">-                       format=&#39;%(asctime)s %(levelname)-8s %(message)s&#39;,</span>
<span class="gd">-                       datefmt=&#39;%a, %d %b %Y %H:%M:%S&#39;,</span>
<span class="gd">-                       filename=&#39;/temp/myapp.log&#39;,</span>
<span class="gd">-                       filemode=&#39;w&#39;)</span>
<span class="gd">-   logging.error(&#39;Pack my box with %d dozen %s&#39;, 5, &#39;liquor jugs&#39;)</span>
<span class="gd">-</span>
<span class="gd">-which would result in ::</span>
<span class="gd">-</span>
<span class="gd">-   Wed, 21 Jul 2004 15:35:16 ERROR    Pack my box with 5 dozen liquor jugs</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _multiple-destinations:</span>
<span class="gd">-</span>
<span class="gd">-Logging to multiple destinations</span>
<span class="gd">---------------------------------</span>
<span class="gd">-</span>
<span class="gd">-Let&#39;s say you want to log to console and file with different message formats and</span>
<span class="gd">-in differing circumstances. Say you want to log messages with levels of DEBUG</span>
<span class="gd">-and higher to file, and those messages at level INFO and higher to the console.</span>
<span class="gd">-Let&#39;s also assume that the file should contain timestamps, but the console</span>
<span class="gd">-messages should not. Here&#39;s how you can achieve this::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   # set up logging to file - see previous section for more details</span>
<span class="gd">-   logging.basicConfig(level=logging.DEBUG,</span>
<span class="gd">-                       format=&#39;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&#39;,</span>
<span class="gd">-                       datefmt=&#39;%m-%d %H:%M&#39;,</span>
<span class="gd">-                       filename=&#39;/temp/myapp.log&#39;,</span>
<span class="gd">-                       filemode=&#39;w&#39;)</span>
<span class="gd">-   # define a Handler which writes INFO messages or higher to the sys.stderr</span>
<span class="gd">-   console = logging.StreamHandler()</span>
<span class="gd">-   console.setLevel(logging.INFO)</span>
<span class="gd">-   # set a format which is simpler for console use</span>
<span class="gd">-   formatter = logging.Formatter(&#39;%(name)-12s: %(levelname)-8s %(message)s&#39;)</span>
<span class="gd">-   # tell the handler to use this format</span>
<span class="gd">-   console.setFormatter(formatter)</span>
<span class="gd">-   # add the handler to the root logger</span>
<span class="gd">-   logging.getLogger(&#39;&#39;).addHandler(console)</span>
<span class="gd">-</span>
<span class="gd">-   # Now, we can log to the root logger, or any other logger. First the root...</span>
<span class="gd">-   logging.info(&#39;Jackdaws love my big sphinx of quartz.&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   # Now, define a couple of other loggers which might represent areas in your</span>
<span class="gd">-   # application:</span>
<span class="gd">-</span>
<span class="gd">-   logger1 = logging.getLogger(&#39;myapp.area1&#39;)</span>
<span class="gd">-   logger2 = logging.getLogger(&#39;myapp.area2&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   logger1.debug(&#39;Quick zephyrs blow, vexing daft Jim.&#39;)</span>
<span class="gd">-   logger1.info(&#39;How quickly daft jumping zebras vex.&#39;)</span>
<span class="gd">-   logger2.warning(&#39;Jail zesty vixen who grabbed pay from quack.&#39;)</span>
<span class="gd">-   logger2.error(&#39;The five boxing wizards jump quickly.&#39;)</span>
<span class="gd">-</span>
<span class="gd">-When you run this, on the console you will see ::</span>
<span class="gd">-</span>
<span class="gd">-   root        : INFO     Jackdaws love my big sphinx of quartz.</span>
<span class="gd">-   myapp.area1 : INFO     How quickly daft jumping zebras vex.</span>
<span class="gd">-   myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.</span>
<span class="gd">-   myapp.area2 : ERROR    The five boxing wizards jump quickly.</span>
<span class="gd">-</span>
<span class="gd">-and in the file you will see something like ::</span>
<span class="gd">-</span>
<span class="gd">-   10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.</span>
<span class="gd">-   10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.</span>
<span class="gd">-   10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.</span>
<span class="gd">-   10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.</span>
<span class="gd">-   10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly.</span>
<span class="gd">-</span>
<span class="gd">-As you can see, the DEBUG message only shows up in the file. The other messages</span>
<span class="gd">-are sent to both destinations.</span>
<span class="gd">-</span>
<span class="gd">-This example uses console and file handlers, but you can use any number and</span>
<span class="gd">-combination of handlers you choose.</span>
<span class="gd">-</span>
<span class="gd">-.. _logging-exceptions:</span>
<span class="gd">-</span>
<span class="gd">-Exceptions raised during logging</span>
<span class="gd">---------------------------------</span>
<span class="gd">-</span>
<span class="gd">-The logging package is designed to swallow exceptions which occur while logging</span>
<span class="gd">-in production. This is so that errors which occur while handling logging events</span>
<span class="gd">-- such as logging misconfiguration, network or other similar errors - do not</span>
<span class="gd">-cause the application using logging to terminate prematurely.</span>
<span class="gd">-</span>
<span class="gd">-:class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never</span>
<span class="gd">-swallowed. Other exceptions which occur during the :meth:`emit` method of a</span>
<span class="gd">-:class:`Handler` subclass are passed to its :meth:`handleError` method.</span>
<span class="gd">-</span>
<span class="gd">-The default implementation of :meth:`handleError` in :class:`Handler` checks</span>
<span class="gd">-to see if a module-level variable, :data:`raiseExceptions`, is set. If set, a</span>
<span class="gd">-traceback is printed to :data:`sys.stderr`. If not set, the exception is swallowed.</span>
<span class="gd">-</span>
<span class="gd">-**Note:** The default value of :data:`raiseExceptions` is ``True``. This is because</span>
<span class="gd">-during development, you typically want to be notified of any exceptions that</span>
<span class="gd">-occur. It&#39;s advised that you set :data:`raiseExceptions` to ``False`` for production</span>
<span class="gd">-usage.</span>
<span class="gd">-</span>
<span class="gd">-.. _context-info:</span>
<span class="gd">-</span>
<span class="gd">-Adding contextual information to your logging output</span>
<span class="gd">-----------------------------------------------------</span>
<span class="gd">-</span>
<span class="gd">-Sometimes you want logging output to contain contextual information in</span>
<span class="gd">-addition to the parameters passed to the logging call. For example, in a</span>
<span class="gd">-networked application, it may be desirable to log client-specific information</span>
<span class="gd">-in the log (e.g. remote client&#39;s username, or IP address). Although you could</span>
<span class="gd">-use the *extra* parameter to achieve this, it&#39;s not always convenient to pass</span>
<span class="gd">-the information in this way. While it might be tempting to create</span>
<span class="gd">-:class:`Logger` instances on a per-connection basis, this is not a good idea</span>
<span class="gd">-because these instances are not garbage collected. While this is not a problem</span>
<span class="gd">-in practice, when the number of :class:`Logger` instances is dependent on the</span>
<span class="gd">-level of granularity you want to use in logging an application, it could</span>
<span class="gd">-be hard to manage if the number of :class:`Logger` instances becomes</span>
<span class="gd">-effectively unbounded.</span>
<span class="gd">-</span>
<span class="gd">-An easy way in which you can pass contextual information to be output along</span>
<span class="gd">-with logging event information is to use the :class:`LoggerAdapter` class.</span>
<span class="gd">-This class is designed to look like a :class:`Logger`, so that you can call</span>
<span class="gd">-:meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`,</span>
<span class="gd">-:meth:`exception`, :meth:`critical` and :meth:`log`. These methods have the</span>
<span class="gd">-same signatures as their counterparts in :class:`Logger`, so you can use the</span>
<span class="gd">-two types of instances interchangeably.</span>
<span class="gd">-</span>
<span class="gd">-When you create an instance of :class:`LoggerAdapter`, you pass it a</span>
<span class="gd">-:class:`Logger` instance and a dict-like object which contains your contextual</span>
<span class="gd">-information. When you call one of the logging methods on an instance of</span>
<span class="gd">-:class:`LoggerAdapter`, it delegates the call to the underlying instance of</span>
<span class="gd">-:class:`Logger` passed to its constructor, and arranges to pass the contextual</span>
<span class="gd">-information in the delegated call. Here&#39;s a snippet from the code of</span>
<span class="gd">-:class:`LoggerAdapter`::</span>
<span class="gd">-</span>
<span class="gd">-    def debug(self, msg, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        Delegate a debug call to the underlying logger, after adding</span>
<span class="gd">-        contextual information from this adapter instance.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        msg, kwargs = self.process(msg, kwargs)</span>
<span class="gd">-        self.logger.debug(msg, *args, **kwargs)</span>
<span class="gd">-</span>
<span class="gd">-The :meth:`process` method of :class:`LoggerAdapter` is where the contextual</span>
<span class="gd">-information is added to the logging output. It&#39;s passed the message and</span>
<span class="gd">-keyword arguments of the logging call, and it passes back (potentially)</span>
<span class="gd">-modified versions of these to use in the call to the underlying logger. The</span>
<span class="gd">-default implementation of this method leaves the message alone, but inserts</span>
<span class="gd">-an &quot;extra&quot; key in the keyword argument whose value is the dict-like object</span>
<span class="gd">-passed to the constructor. Of course, if you had passed an &quot;extra&quot; keyword</span>
<span class="gd">-argument in the call to the adapter, it will be silently overwritten.</span>
<span class="gd">-</span>
<span class="gd">-The advantage of using &quot;extra&quot; is that the values in the dict-like object are</span>
<span class="gd">-merged into the :class:`LogRecord` instance&#39;s __dict__, allowing you to use</span>
<span class="gd">-customized strings with your :class:`Formatter` instances which know about</span>
<span class="gd">-the keys of the dict-like object. If you need a different method, e.g. if you</span>
<span class="gd">-want to prepend or append the contextual information to the message string,</span>
<span class="gd">-you just need to subclass :class:`LoggerAdapter` and override :meth:`process`</span>
<span class="gd">-to do what you need. Here&#39;s an example script which uses this class, which</span>
<span class="gd">-also illustrates what dict-like behaviour is needed from an arbitrary</span>
<span class="gd">-&quot;dict-like&quot; object for use in the constructor::</span>
<span class="gd">-</span>
<span class="gd">-   import logging</span>
<span class="gd">-</span>
<span class="gd">-   class ConnInfo:</span>
<span class="gd">-       &quot;&quot;&quot;</span>
<span class="gd">-       An example class which shows how an arbitrary class can be used as</span>
<span class="gd">-       the &#39;extra&#39; context information repository passed to a LoggerAdapter.</span>
<span class="gd">-       &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-       def __getitem__(self, name):</span>
<span class="gd">-           &quot;&quot;&quot;</span>
<span class="gd">-           To allow this instance to look like a dict.</span>
<span class="gd">-           &quot;&quot;&quot;</span>
<span class="gd">-           from random import choice</span>
<span class="gd">-           if name == &quot;ip&quot;:</span>
<span class="gd">-               result = choice([&quot;127.0.0.1&quot;, &quot;192.168.0.1&quot;])</span>
<span class="gd">-           elif name == &quot;user&quot;:</span>
<span class="gd">-               result = choice([&quot;jim&quot;, &quot;fred&quot;, &quot;sheila&quot;])</span>
<span class="gd">-           else:</span>
<span class="gd">-               result = self.__dict__.get(name, &quot;?&quot;)</span>
<span class="gd">-           return result</span>
<span class="gd">-</span>
<span class="gd">-       def __iter__(self):</span>
<span class="gd">-           &quot;&quot;&quot;</span>
<span class="gd">-           To allow iteration over keys, which will be merged into</span>
<span class="gd">-           the LogRecord dict before formatting and output.</span>
<span class="gd">-           &quot;&quot;&quot;</span>
<span class="gd">-           keys = [&quot;ip&quot;, &quot;user&quot;]</span>
<span class="gd">-           keys.extend(self.__dict__.keys())</span>
<span class="gd">-           return keys.__iter__()</span>
<span class="gd">-</span>
<span class="gd">-   if __name__ == &quot;__main__&quot;:</span>
<span class="gd">-       from random import choice</span>
<span class="gd">-       levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL)</span>
<span class="gd">-       a1 = logging.LoggerAdapter(logging.getLogger(&quot;a.b.c&quot;),</span>
<span class="gd">-                                  { &quot;ip&quot; : &quot;123.231.231.123&quot;, &quot;user&quot; : &quot;sheila&quot; })</span>
<span class="gd">-       logging.basicConfig(level=logging.DEBUG,</span>
<span class="gd">-                           format=&quot;%(asctime)-15s %(name)-5s %(levelname)-8s IP: %(ip)-15s User: %(user)-8s %(message)s&quot;)</span>
<span class="gd">-       a1.debug(&quot;A debug message&quot;)</span>
<span class="gd">-       a1.info(&quot;An info message with %s&quot;, &quot;some parameters&quot;)</span>
<span class="gd">-       a2 = logging.LoggerAdapter(logging.getLogger(&quot;d.e.f&quot;), ConnInfo())</span>
<span class="gd">-       for x in range(10):</span>
<span class="gd">-           lvl = choice(levels)</span>
<span class="gd">-           lvlname = logging.getLevelName(lvl)</span>
<span class="gd">-           a2.log(lvl, &quot;A message at %s level with %d %s&quot;, lvlname, 2, &quot;parameters&quot;)</span>
<span class="gd">-</span>
<span class="gd">-When this script is run, the output should look something like this::</span>
<span class="gd">-</span>
<span class="gd">-   2008-01-18 14:49:54,023 a.b.c DEBUG    IP: 123.231.231.123 User: sheila   A debug message</span>
<span class="gd">-   2008-01-18 14:49:54,023 a.b.c INFO     IP: 123.231.231.123 User: sheila   An info message with some parameters</span>
<span class="gd">-   2008-01-18 14:49:54,023 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A message at CRITICAL level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f INFO     IP: 192.168.0.1     User: jim      A message at INFO level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f ERROR    IP: 127.0.0.1       User: fred     A message at ERROR level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A message at ERROR level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: jim      A message at WARNING level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f INFO     IP: 192.168.0.1     User: fred     A message at INFO level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters</span>
<span class="gd">-   2008-01-18 14:49:54,033 d.e.f WARNING  IP: 127.0.0.1       User: jim      A message at WARNING level with 2 parameters</span>
<span class="gd">-</span>
<span class="gd">-.. versionadded:: 2.6</span>
<span class="gd">-</span>
<span class="gd">-The :class:`LoggerAdapter` class was not present in previous versions.</span>
<span class="gd">-</span>
<span class="gd">-.. _multiple-processes:</span>
<span class="gd">-</span>
<span class="gd">-Logging to a single file from multiple processes</span>
<span class="gd">-------------------------------------------------</span>
<span class="gd">-</span>
<span class="gd">-Although logging is thread-safe, and logging to a single file from multiple</span>
<span class="gd">-threads in a single process *is* supported, logging to a single file from</span>
<span class="gd">-*multiple processes* is *not* supported, because there is no standard way to</span>
<span class="gd">-serialize access to a single file across multiple processes in Python. If you</span>
<span class="gd">-need to log to a single file from multiple processes, the best way of doing</span>
<span class="gd">-this is to have all the processes log to a :class:`SocketHandler`, and have a</span>
<span class="gd">-separate process which implements a socket server which reads from the socket</span>
<span class="gd">-and logs to file. (If you prefer, you can dedicate one thread in one of the</span>
<span class="gd">-existing processes to perform this function.) The following section documents</span>
<span class="gd">-this approach in more detail and includes a working socket receiver which can</span>
<span class="gd">-be used as a starting point for you to adapt in your own applications.</span>
<span class="gd">-</span>
<span class="gd">-If you are using a recent version of Python which includes the</span>
<span class="gd">-:mod:`multiprocessing` module, you can write your own handler which uses the</span>
<span class="gd">-:class:`Lock` class from this module to serialize access to the file from</span>
<span class="gd">-your processes. The existing :class:`FileHandler` and subclasses do not make</span>
<span class="gd">-use of :mod:`multiprocessing` at present, though they may do so in the future.</span>
<span class="gd">-Note that at present, the :mod:`multiprocessing` module does not provide</span>
<span class="gd">-working lock functionality on all platforms (see</span>
<span class="gd">-http://bugs.python.org/issue3770).</span>
<span class="gd">-</span>
<span class="gd">-.. _network-logging:</span>
<span class="gd">-</span>
<span class="gd">-Sending and receiving logging events across a network</span>
<span class="gd">------------------------------------------------------</span>
<span class="gd">-</span>
<span class="gd">-Let&#39;s say you want to send logging events across a network, and handle them at</span>
<span class="gd">-the receiving end. A simple way of doing this is attaching a</span>
<span class="gd">-:class:`SocketHandler` instance to the root logger at the sending end::</span>
<span class="gd">-</span>
<span class="gd">-   import logging, logging.handlers</span>
<span class="gd">-</span>
<span class="gd">-   rootLogger = logging.getLogger(&#39;&#39;)</span>
<span class="gd">-   rootLogger.setLevel(logging.DEBUG)</span>
<span class="gd">-   socketHandler = logging.handlers.SocketHandler(&#39;localhost&#39;,</span>
<span class="gd">-                       logging.handlers.DEFAULT_TCP_LOGGING_PORT)</span>
<span class="gd">-   # don&#39;t bother with a formatter, since a socket handler sends the event as</span>
<span class="gd">-   # an unformatted pickle</span>
<span class="gd">-   rootLogger.addHandler(socketHandler)</span>
<span class="gd">-</span>
<span class="gd">-   # Now, we can log to the root logger, or any other logger. First the root...</span>
<span class="gd">-   logging.info(&#39;Jackdaws love my big sphinx of quartz.&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   # Now, define a couple of other loggers which might represent areas in your</span>
<span class="gd">-   # application:</span>
<span class="gd">-</span>
<span class="gd">-   logger1 = logging.getLogger(&#39;myapp.area1&#39;)</span>
<span class="gd">-   logger2 = logging.getLogger(&#39;myapp.area2&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   logger1.debug(&#39;Quick zephyrs blow, vexing daft Jim.&#39;)</span>
<span class="gd">-   logger1.info(&#39;How quickly daft jumping zebras vex.&#39;)</span>
<span class="gd">-   logger2.warning(&#39;Jail zesty vixen who grabbed pay from quack.&#39;)</span>
<span class="gd">-   logger2.error(&#39;The five boxing wizards jump quickly.&#39;)</span>
<span class="gd">-</span>
<span class="gd">-At the receiving end, you can set up a receiver using the :mod:`SocketServer`</span>
<span class="gd">-module. Here is a basic working example::</span>
<span class="gd">-</span>
<span class="gd">-   import cPickle</span>
<span class="gd">-   import logging</span>
<span class="gd">-   import logging.handlers</span>
<span class="gd">-   import SocketServer</span>
<span class="gd">-   import struct</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   class LogRecordStreamHandler(SocketServer.StreamRequestHandler):</span>
<span class="gd">-       &quot;&quot;&quot;Handler for a streaming logging request.</span>
<span class="gd">-</span>
<span class="gd">-       This basically logs the record using whatever logging policy is</span>
<span class="gd">-       configured locally.</span>
<span class="gd">-       &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-       def handle(self):</span>
<span class="gd">-           &quot;&quot;&quot;</span>
<span class="gd">-           Handle multiple requests - each expected to be a 4-byte length,</span>
<span class="gd">-           followed by the LogRecord in pickle format. Logs the record</span>
<span class="gd">-           according to whatever policy is configured locally.</span>
<span class="gd">-           &quot;&quot;&quot;</span>
<span class="gd">-           while 1:</span>
<span class="gd">-               chunk = self.connection.recv(4)</span>
<span class="gd">-               if len(chunk) &lt; 4:</span>
<span class="gd">-                   break</span>
<span class="gd">-               slen = struct.unpack(&quot;&gt;L&quot;, chunk)[0]</span>
<span class="gd">-               chunk = self.connection.recv(slen)</span>
<span class="gd">-               while len(chunk) &lt; slen:</span>
<span class="gd">-                   chunk = chunk + self.connection.recv(slen - len(chunk))</span>
<span class="gd">-               obj = self.unPickle(chunk)</span>
<span class="gd">-               record = logging.makeLogRecord(obj)</span>
<span class="gd">-               self.handleLogRecord(record)</span>
<span class="gd">-</span>
<span class="gd">-       def unPickle(self, data):</span>
<span class="gd">-           return cPickle.loads(data)</span>
<span class="gd">-</span>
<span class="gd">-       def handleLogRecord(self, record):</span>
<span class="gd">-           # if a name is specified, we use the named logger rather than the one</span>
<span class="gd">-           # implied by the record.</span>
<span class="gd">-           if self.server.logname is not None:</span>
<span class="gd">-               name = self.server.logname</span>
<span class="gd">-           else:</span>
<span class="gd">-               name = record.name</span>
<span class="gd">-           logger = logging.getLogger(name)</span>
<span class="gd">-           # N.B. EVERY record gets logged. This is because Logger.handle</span>
<span class="gd">-           # is normally called AFTER logger-level filtering. If you want</span>
<span class="gd">-           # to do filtering, do it at the client end to save wasting</span>
<span class="gd">-           # cycles and network bandwidth!</span>
<span class="gd">-           logger.handle(record)</span>
<span class="gd">-</span>
<span class="gd">-   class LogRecordSocketReceiver(SocketServer.ThreadingTCPServer):</span>
<span class="gd">-       &quot;&quot;&quot;simple TCP socket-based logging receiver suitable for testing.</span>
<span class="gd">-       &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-       allow_reuse_address = 1</span>
<span class="gd">-</span>
<span class="gd">-       def __init__(self, host=&#39;localhost&#39;,</span>
<span class="gd">-                    port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,</span>
<span class="gd">-                    handler=LogRecordStreamHandler):</span>
<span class="gd">-           SocketServer.ThreadingTCPServer.__init__(self, (host, port), handler)</span>
<span class="gd">-           self.abort = 0</span>
<span class="gd">-           self.timeout = 1</span>
<span class="gd">-           self.logname = None</span>
<span class="gd">-</span>
<span class="gd">-       def serve_until_stopped(self):</span>
<span class="gd">-           import select</span>
<span class="gd">-           abort = 0</span>
<span class="gd">-           while not abort:</span>
<span class="gd">-               rd, wr, ex = select.select([self.socket.fileno()],</span>
<span class="gd">-                                          [], [],</span>
<span class="gd">-                                          self.timeout)</span>
<span class="gd">-               if rd:</span>
<span class="gd">-                   self.handle_request()</span>
<span class="gd">-               abort = self.abort</span>
<span class="gd">-</span>
<span class="gd">-   def main():</span>
<span class="gd">-       logging.basicConfig(</span>
<span class="gd">-           format=&quot;%(relativeCreated)5d %(name)-15s %(levelname)-8s %(message)s&quot;)</span>
<span class="gd">-       tcpserver = LogRecordSocketReceiver()</span>
<span class="gd">-       print &quot;About to start TCP server...&quot;</span>
<span class="gd">-       tcpserver.serve_until_stopped()</span>
<span class="gd">-</span>
<span class="gd">-   if __name__ == &quot;__main__&quot;:</span>
<span class="gd">-       main()</span>
<span class="gd">-</span>
<span class="gd">-First run the server, and then the client. On the client side, nothing is</span>
<span class="gd">-printed on the console; on the server side, you should see something like::</span>
<span class="gd">-</span>
<span class="gd">-   About to start TCP server...</span>
<span class="gd">-      59 root            INFO     Jackdaws love my big sphinx of quartz.</span>
<span class="gd">-      59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.</span>
<span class="gd">-      69 myapp.area1     INFO     How quickly daft jumping zebras vex.</span>
<span class="gd">-      69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.</span>
<span class="gd">-      69 myapp.area2     ERROR    The five boxing wizards jump quickly.</span>
<span class="gd">-</span>
<span class="gd">-Note that there are some security issues with pickle in some scenarios. If</span>
<span class="gd">-these affect you, you can use an alternative serialization scheme by overriding</span>
<span class="gd">-the :meth:`makePickle` method and implementing your alternative there, as</span>
<span class="gd">-well as adapting the above script to use your alternative serialization.</span>
<span class="gd">-</span>
<span class="gd">-Using arbitrary objects as messages</span>
<span class="gd">------------------------------------</span>
<span class="gd">-</span>
<span class="gd">-In the preceding sections and examples, it has been assumed that the message</span>
<span class="gd">-passed when logging the event is a string. However, this is not the only</span>
<span class="gd">-possibility. You can pass an arbitrary object as a message, and its</span>
<span class="gd">-:meth:`__str__` method will be called when the logging system needs to convert</span>
<span class="gd">-it to a string representation. In fact, if you want to, you can avoid</span>
<span class="gd">-computing a string representation altogether - for example, the</span>
<span class="gd">-:class:`SocketHandler` emits an event by pickling it and sending it over the</span>
<span class="gd">-wire.</span>
<span class="gd">-</span>
<span class="gd">-Optimization</span>
<span class="gd">-------------</span>
<span class="gd">-</span>
<span class="gd">-Formatting of message arguments is deferred until it cannot be avoided.</span>
<span class="gd">-However, computing the arguments passed to the logging method can also be</span>
<span class="gd">-expensive, and you may want to avoid doing it if the logger will just throw</span>
<span class="gd">-away your event. To decide what to do, you can call the :meth:`isEnabledFor`</span>
<span class="gd">-method which takes a level argument and returns true if the event would be</span>
<span class="gd">-created by the Logger for that level of call. You can write code like this::</span>
<span class="gd">-</span>
<span class="gd">-    if logger.isEnabledFor(logging.DEBUG):</span>
<span class="gd">-        logger.debug(&quot;Message with %s, %s&quot;, expensive_func1(),</span>
<span class="gd">-                                            expensive_func2())</span>
<span class="gd">-</span>
<span class="gd">-so that if the logger&#39;s threshold is set above ``DEBUG``, the calls to</span>
<span class="gd">-:func:`expensive_func1` and :func:`expensive_func2` are never made.</span>
<span class="gd">-</span>
<span class="gd">-There are other optimizations which can be made for specific applications which</span>
<span class="gd">-need more precise control over what logging information is collected. Here&#39;s a</span>
<span class="gd">-list of things you can do to avoid processing during logging which you don&#39;t</span>
<span class="gd">-need:</span>
<span class="gd">-</span>
<span class="gd">-+-----------------------------------------------+----------------------------------------+</span>
<span class="gd">-| What you don&#39;t want to collect                | How to avoid collecting it             |</span>
<span class="gd">-+===============================================+========================================+</span>
<span class="gd">-| Information about where calls were made from. | Set ``logging._srcfile`` to ``None``.  |</span>
<span class="gd">-+-----------------------------------------------+----------------------------------------+</span>
<span class="gd">-| Threading information.                        | Set ``logging.logThreads`` to ``0``.   |</span>
<span class="gd">-+-----------------------------------------------+----------------------------------------+</span>
<span class="gd">-| Process information.                          | Set ``logging.logProcesses`` to ``0``. |</span>
<span class="gd">-+-----------------------------------------------+----------------------------------------+</span>
<span class="gd">-</span>
<span class="gd">-Also note that the core logging module only includes the basic handlers. If</span>
<span class="gd">-you don&#39;t import :mod:`logging.handlers` and :mod:`logging.config`, they won&#39;t</span>
<span class="gd">-take up any memory.</span>
<span class="gd">-</span>
<span class="gd">-.. _handler:</span>
<span class="gd">-</span>
<span class="gd">-Handler Objects</span>
<span class="gd">----------------</span>
<span class="gd">-</span>
<span class="gd">-Handlers have the following attributes and methods. Note that :class:`Handler`</span>
<span class="gd">-is never instantiated directly; this class acts as a base for more useful</span>
<span class="gd">-subclasses. However, the :meth:`__init__` method in subclasses needs to call</span>
<span class="gd">-:meth:`Handler.__init__`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.__init__(level=NOTSET)</span>
<span class="gd">-</span>
<span class="gd">-   Initializes the :class:`Handler` instance by setting its level, setting the list</span>
<span class="gd">-   of filters to the empty list and creating a lock (using :meth:`createLock`) for</span>
<span class="gd">-   serializing access to an I/O mechanism.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.createLock()</span>
<span class="gd">-</span>
<span class="gd">-   Initializes a thread lock which can be used to serialize access to underlying</span>
<span class="gd">-   I/O functionality which may not be threadsafe.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.acquire()</span>
<span class="gd">-</span>
<span class="gd">-   Acquires the thread lock created with :meth:`createLock`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.release()</span>
<span class="gd">-</span>
<span class="gd">-   Releases the thread lock acquired with :meth:`acquire`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.setLevel(lvl)</span>
<span class="gd">-</span>
<span class="gd">-   Sets the threshold for this handler to *lvl*. Logging messages which are less</span>
<span class="gd">-   severe than *lvl* will be ignored. When a handler is created, the level is set</span>
<span class="gd">-   to :const:`NOTSET` (which causes all messages to be processed).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.setFormatter(form)</span>
<span class="gd">-</span>
<span class="gd">-   Sets the :class:`Formatter` for this handler to *form*.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.addFilter(filt)</span>
<span class="gd">-</span>
<span class="gd">-   Adds the specified filter *filt* to this handler.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.removeFilter(filt)</span>
<span class="gd">-</span>
<span class="gd">-   Removes the specified filter *filt* from this handler.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.filter(record)</span>
<span class="gd">-</span>
<span class="gd">-   Applies this handler&#39;s filters to the record and returns a true value if the</span>
<span class="gd">-   record is to be processed.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.flush()</span>
<span class="gd">-</span>
<span class="gd">-   Ensure all logging output has been flushed. This version does nothing and is</span>
<span class="gd">-   intended to be implemented by subclasses.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.close()</span>
<span class="gd">-</span>
<span class="gd">-   Tidy up any resources used by the handler. This version does no output but</span>
<span class="gd">-   removes the handler from an internal list of handlers which is closed when</span>
<span class="gd">-   :func:`shutdown` is called. Subclasses should ensure that this gets called</span>
<span class="gd">-   from overridden :meth:`close` methods.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.handle(record)</span>
<span class="gd">-</span>
<span class="gd">-   Conditionally emits the specified logging record, depending on filters which may</span>
<span class="gd">-   have been added to the handler. Wraps the actual emission of the record with</span>
<span class="gd">-   acquisition/release of the I/O thread lock.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.handleError(record)</span>
<span class="gd">-</span>
<span class="gd">-   This method should be called from handlers when an exception is encountered</span>
<span class="gd">-   during an :meth:`emit` call. By default it does nothing, which means that</span>
<span class="gd">-   exceptions get silently ignored. This is what is mostly wanted for a logging</span>
<span class="gd">-   system - most users will not care about errors in the logging system, they are</span>
<span class="gd">-   more interested in application errors. You could, however, replace this with a</span>
<span class="gd">-   custom handler if you wish. The specified record is the one which was being</span>
<span class="gd">-   processed when the exception occurred.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.format(record)</span>
<span class="gd">-</span>
<span class="gd">-   Do formatting for a record - if a formatter is set, use it. Otherwise, use the</span>
<span class="gd">-   default formatter for the module.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. method:: Handler.emit(record)</span>
<span class="gd">-</span>
<span class="gd">-   Do whatever it takes to actually log the specified logging record. This version</span>
<span class="gd">-   is intended to be implemented by subclasses and so raises a</span>
<span class="gd">-   :exc:`NotImplementedError`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _stream-handler:</span>
<span class="gd">-</span>
<span class="gd">-StreamHandler</span>
<span class="gd">-^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`StreamHandler` class, located in the core :mod:`logging` package,</span>
<span class="gd">-sends logging output to streams such as *sys.stdout*, *sys.stderr* or any</span>
<span class="gd">-file-like object (or, more precisely, any object which supports :meth:`write`</span>
<span class="gd">-and :meth:`flush` methods).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. currentmodule:: logging</span>
<span class="gd">-</span>
<span class="gd">-.. class:: StreamHandler([strm])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`StreamHandler` class. If *strm* is</span>
<span class="gd">-   specified, the instance will use it for logging output; otherwise, *sys.stderr*</span>
<span class="gd">-   will be used.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      If a formatter is specified, it is used to format the record. The record</span>
<span class="gd">-      is then written to the stream with a trailing newline. If exception</span>
<span class="gd">-      information is present, it is formatted using</span>
<span class="gd">-      :func:`traceback.print_exception` and appended to the stream.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: flush()</span>
<span class="gd">-</span>
<span class="gd">-      Flushes the stream by calling its :meth:`flush` method. Note that the</span>
<span class="gd">-      :meth:`close` method is inherited from :class:`Handler` and so does</span>
<span class="gd">-      no output, so an explicit :meth:`flush` call may be needed at times.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _file-handler:</span>
<span class="gd">-</span>
<span class="gd">-FileHandler</span>
<span class="gd">-^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`FileHandler` class, located in the core :mod:`logging` package,</span>
<span class="gd">-sends logging output to a disk file.  It inherits the output functionality from</span>
<span class="gd">-:class:`StreamHandler`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: FileHandler(filename[, mode[, encoding[, delay]]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`FileHandler` class. The specified file is</span>
<span class="gd">-   opened and used as the stream for logging. If *mode* is not specified,</span>
<span class="gd">-   :const:`&#39;a&#39;` is used.  If *encoding* is not *None*, it is used to open the file</span>
<span class="gd">-   with that encoding.  If *delay* is true, then file opening is deferred until the</span>
<span class="gd">-   first call to :meth:`emit`. By default, the file grows indefinitely.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.6</span>
<span class="gd">-      *delay* was added.</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: close()</span>
<span class="gd">-</span>
<span class="gd">-      Closes the file.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Outputs the record to the file.</span>
<span class="gd">-</span>
<span class="gd">-.. _null-handler:</span>
<span class="gd">-</span>
<span class="gd">-See :ref:`library-config` for more information on how to use</span>
<span class="gd">-:class:`NullHandler`.</span>
<span class="gd">-</span>
<span class="gd">-.. _watched-file-handler:</span>
<span class="gd">-</span>
<span class="gd">-WatchedFileHandler</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-.. versionadded:: 2.6</span>
<span class="gd">-</span>
<span class="gd">-The :class:`WatchedFileHandler` class, located in the :mod:`logging.handlers`</span>
<span class="gd">-module, is a :class:`FileHandler` which watches the file it is logging to. If</span>
<span class="gd">-the file changes, it is closed and reopened using the file name.</span>
<span class="gd">-</span>
<span class="gd">-A file change can happen because of usage of programs such as *newsyslog* and</span>
<span class="gd">-*logrotate* which perform log file rotation. This handler, intended for use</span>
<span class="gd">-under Unix/Linux, watches the file to see if it has changed since the last emit.</span>
<span class="gd">-(A file is deemed to have changed if its device or inode have changed.) If the</span>
<span class="gd">-file has changed, the old file stream is closed, and the file opened to get a</span>
<span class="gd">-new stream.</span>
<span class="gd">-</span>
<span class="gd">-This handler is not appropriate for use under Windows, because under Windows</span>
<span class="gd">-open log files cannot be moved or renamed - logging opens the files with</span>
<span class="gd">-exclusive locks - and so there is no need for such a handler. Furthermore,</span>
<span class="gd">-*ST_INO* is not supported under Windows; :func:`stat` always returns zero for</span>
<span class="gd">-this value.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: WatchedFileHandler(filename[,mode[, encoding[, delay]]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`WatchedFileHandler` class. The specified</span>
<span class="gd">-   file is opened and used as the stream for logging. If *mode* is not specified,</span>
<span class="gd">-   :const:`&#39;a&#39;` is used.  If *encoding* is not *None*, it is used to open the file</span>
<span class="gd">-   with that encoding.  If *delay* is true, then file opening is deferred until the</span>
<span class="gd">-   first call to :meth:`emit`.  By default, the file grows indefinitely.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.6</span>
<span class="gd">-      *delay* was added.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Outputs the record to the file, but first checks to see if the file has</span>
<span class="gd">-      changed.  If it has, the existing stream is flushed and closed and the</span>
<span class="gd">-      file opened again, before outputting the record to the file.</span>
<span class="gd">-</span>
<span class="gd">-.. _rotating-file-handler:</span>
<span class="gd">-</span>
<span class="gd">-RotatingFileHandler</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`RotatingFileHandler` class, located in the :mod:`logging.handlers`</span>
<span class="gd">-module, supports rotation of disk log files.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: RotatingFileHandler(filename[, mode[, maxBytes[, backupCount[, encoding[, delay]]]]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`RotatingFileHandler` class. The specified</span>
<span class="gd">-   file is opened and used as the stream for logging. If *mode* is not specified,</span>
<span class="gd">-   ``&#39;a&#39;`` is used.  If *encoding* is not *None*, it is used to open the file</span>
<span class="gd">-   with that encoding.  If *delay* is true, then file opening is deferred until the</span>
<span class="gd">-   first call to :meth:`emit`.  By default, the file grows indefinitely.</span>
<span class="gd">-</span>
<span class="gd">-   You can use the *maxBytes* and *backupCount* values to allow the file to</span>
<span class="gd">-   :dfn:`rollover` at a predetermined size. When the size is about to be exceeded,</span>
<span class="gd">-   the file is closed and a new file is silently opened for output. Rollover occurs</span>
<span class="gd">-   whenever the current log file is nearly *maxBytes* in length; if *maxBytes* is</span>
<span class="gd">-   zero, rollover never occurs.  If *backupCount* is non-zero, the system will save</span>
<span class="gd">-   old log files by appending the extensions &quot;.1&quot;, &quot;.2&quot; etc., to the filename. For</span>
<span class="gd">-   example, with a *backupCount* of 5 and a base file name of :file:`app.log`, you</span>
<span class="gd">-   would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, up to</span>
<span class="gd">-   :file:`app.log.5`. The file being written to is always :file:`app.log`.  When</span>
<span class="gd">-   this file is filled, it is closed and renamed to :file:`app.log.1`, and if files</span>
<span class="gd">-   :file:`app.log.1`, :file:`app.log.2`, etc.  exist, then they are renamed to</span>
<span class="gd">-   :file:`app.log.2`, :file:`app.log.3` etc.  respectively.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.6</span>
<span class="gd">-      *delay* was added.</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: doRollover()</span>
<span class="gd">-</span>
<span class="gd">-      Does a rollover, as described above.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Outputs the record to the file, catering for rollover as described</span>
<span class="gd">-      previously.</span>
<span class="gd">-</span>
<span class="gd">-.. _timed-rotating-file-handler:</span>
<span class="gd">-</span>
<span class="gd">-TimedRotatingFileHandler</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`TimedRotatingFileHandler` class, located in the</span>
<span class="gd">-:mod:`logging.handlers` module, supports rotation of disk log files at certain</span>
<span class="gd">-timed intervals.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: TimedRotatingFileHandler(filename [,when [,interval [,backupCount[, encoding[, delay[, utc]]]]]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`TimedRotatingFileHandler` class. The</span>
<span class="gd">-   specified file is opened and used as the stream for logging. On rotating it also</span>
<span class="gd">-   sets the filename suffix. Rotating happens based on the product of *when* and</span>
<span class="gd">-   *interval*.</span>
<span class="gd">-</span>
<span class="gd">-   You can use the *when* to specify the type of *interval*. The list of possible</span>
<span class="gd">-   values is below.  Note that they are not case sensitive.</span>
<span class="gd">-</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-   | Value          | Type of interval      |</span>
<span class="gd">-   +================+=======================+</span>
<span class="gd">-   | ``&#39;S&#39;``        | Seconds               |</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-   | ``&#39;M&#39;``        | Minutes               |</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-   | ``&#39;H&#39;``        | Hours                 |</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-   | ``&#39;D&#39;``        | Days                  |</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-   | ``&#39;W&#39;``        | Week day (0=Monday)   |</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-   | ``&#39;midnight&#39;`` | Roll over at midnight |</span>
<span class="gd">-   +----------------+-----------------------+</span>
<span class="gd">-</span>
<span class="gd">-   The system will save old log files by appending extensions to the filename.</span>
<span class="gd">-   The extensions are date-and-time based, using the strftime format</span>
<span class="gd">-   ``%Y-%m-%d_%H-%M-%S`` or a leading portion thereof, depending on the</span>
<span class="gd">-   rollover interval.</span>
<span class="gd">-</span>
<span class="gd">-   When computing the next rollover time for the first time (when the handler</span>
<span class="gd">-   is created), the last modification time of an existing log file, or else</span>
<span class="gd">-   the current time, is used to compute when the next rotation will occur.</span>
<span class="gd">-</span>
<span class="gd">-   If the *utc* argument is true, times in UTC will be used; otherwise</span>
<span class="gd">-   local time is used.</span>
<span class="gd">-</span>
<span class="gd">-   If *backupCount* is nonzero, at most *backupCount* files</span>
<span class="gd">-   will be kept, and if more would be created when rollover occurs, the oldest</span>
<span class="gd">-   one is deleted. The deletion logic uses the interval to determine which</span>
<span class="gd">-   files to delete, so changing the interval may leave old files lying around.</span>
<span class="gd">-</span>
<span class="gd">-   If *delay* is true, then file opening is deferred until the first call to</span>
<span class="gd">-   :meth:`emit`.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.6</span>
<span class="gd">-      *delay* was added.</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: doRollover()</span>
<span class="gd">-</span>
<span class="gd">-      Does a rollover, as described above.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Outputs the record to the file, catering for rollover as described above.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _socket-handler:</span>
<span class="gd">-</span>
<span class="gd">-SocketHandler</span>
<span class="gd">-^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`SocketHandler` class, located in the :mod:`logging.handlers` module,</span>
<span class="gd">-sends logging output to a network socket. The base class uses a TCP socket.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: SocketHandler(host, port)</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`SocketHandler` class intended to</span>
<span class="gd">-   communicate with a remote machine whose address is given by *host* and *port*.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: close()</span>
<span class="gd">-</span>
<span class="gd">-      Closes the socket.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit()</span>
<span class="gd">-</span>
<span class="gd">-      Pickles the record&#39;s attribute dictionary and writes it to the socket in</span>
<span class="gd">-      binary format. If there is an error with the socket, silently drops the</span>
<span class="gd">-      packet. If the connection was previously lost, re-establishes the</span>
<span class="gd">-      connection. To unpickle the record at the receiving end into a</span>
<span class="gd">-      :class:`LogRecord`, use the :func:`makeLogRecord` function.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: handleError()</span>
<span class="gd">-</span>
<span class="gd">-      Handles an error which has occurred during :meth:`emit`. The most likely</span>
<span class="gd">-      cause is a lost connection. Closes the socket so that we can retry on the</span>
<span class="gd">-      next event.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: makeSocket()</span>
<span class="gd">-</span>
<span class="gd">-      This is a factory method which allows subclasses to define the precise</span>
<span class="gd">-      type of socket they want. The default implementation creates a TCP socket</span>
<span class="gd">-      (:const:`socket.SOCK_STREAM`).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: makePickle(record)</span>
<span class="gd">-</span>
<span class="gd">-      Pickles the record&#39;s attribute dictionary in binary format with a length</span>
<span class="gd">-      prefix, and returns it ready for transmission across the socket.</span>
<span class="gd">-</span>
<span class="gd">-      Note that pickles aren&#39;t completely secure. If you are concerned about</span>
<span class="gd">-      security, you may want to override this method to implement a more secure</span>
<span class="gd">-      mechanism. For example, you can sign pickles using HMAC and then verify</span>
<span class="gd">-      them on the receiving end, or alternatively you can disable unpickling of</span>
<span class="gd">-      global objects on the receiving end.</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: send(packet)</span>
<span class="gd">-</span>
<span class="gd">-      Send a pickled string *packet* to the socket. This function allows for</span>
<span class="gd">-      partial sends which can happen when the network is busy.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _datagram-handler:</span>
<span class="gd">-</span>
<span class="gd">-DatagramHandler</span>
<span class="gd">-^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`DatagramHandler` class, located in the :mod:`logging.handlers`</span>
<span class="gd">-module, inherits from :class:`SocketHandler` to support sending logging messages</span>
<span class="gd">-over UDP sockets.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: DatagramHandler(host, port)</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`DatagramHandler` class intended to</span>
<span class="gd">-   communicate with a remote machine whose address is given by *host* and *port*.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit()</span>
<span class="gd">-</span>
<span class="gd">-      Pickles the record&#39;s attribute dictionary and writes it to the socket in</span>
<span class="gd">-      binary format. If there is an error with the socket, silently drops the</span>
<span class="gd">-      packet. To unpickle the record at the receiving end into a</span>
<span class="gd">-      :class:`LogRecord`, use the :func:`makeLogRecord` function.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: makeSocket()</span>
<span class="gd">-</span>
<span class="gd">-      The factory method of :class:`SocketHandler` is here overridden to create</span>
<span class="gd">-      a UDP socket (:const:`socket.SOCK_DGRAM`).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: send(s)</span>
<span class="gd">-</span>
<span class="gd">-      Send a pickled string to a socket.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _syslog-handler:</span>
<span class="gd">-</span>
<span class="gd">-SysLogHandler</span>
<span class="gd">-^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` module,</span>
<span class="gd">-supports sending logging messages to a remote or local Unix syslog.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: SysLogHandler([address[, facility]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`SysLogHandler` class intended to</span>
<span class="gd">-   communicate with a remote Unix machine whose address is given by *address* in</span>
<span class="gd">-   the form of a ``(host, port)`` tuple.  If *address* is not specified,</span>
<span class="gd">-   ``(&#39;localhost&#39;, 514)`` is used.  The address is used to open a UDP socket.  An</span>
<span class="gd">-   alternative to providing a ``(host, port)`` tuple is providing an address as a</span>
<span class="gd">-   string, for example &quot;/dev/log&quot;. In this case, a Unix domain socket is used to</span>
<span class="gd">-   send the message to the syslog. If *facility* is not specified,</span>
<span class="gd">-   :const:`LOG_USER` is used.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: close()</span>
<span class="gd">-</span>
<span class="gd">-      Closes the socket to the remote host.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      The record is formatted, and then sent to the syslog server. If exception</span>
<span class="gd">-      information is present, it is *not* sent to the server.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: encodePriority(facility, priority)</span>
<span class="gd">-</span>
<span class="gd">-      Encodes the facility and priority into an integer. You can pass in strings</span>
<span class="gd">-      or integers - if strings are passed, internal mapping dictionaries are</span>
<span class="gd">-      used to convert them to integers.</span>
<span class="gd">-</span>
<span class="gd">-      The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and</span>
<span class="gd">-      mirror the values defined in the ``sys/syslog.h`` header file.</span>
<span class="gd">-</span>
<span class="gd">-      **Priorities**</span>
<span class="gd">-</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | Name (string)            | Symbolic value|</span>
<span class="gd">-      +==========================+===============+</span>
<span class="gd">-      | ``alert``                | LOG_ALERT     |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``crit`` or ``critical`` | LOG_CRIT      |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``debug``                | LOG_DEBUG     |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``emerg`` or ``panic``   | LOG_EMERG     |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``err`` or ``error``     | LOG_ERR       |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``info``                 | LOG_INFO      |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``notice``               | LOG_NOTICE    |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-      | ``warn`` or ``warning``  | LOG_WARNING   |</span>
<span class="gd">-      +--------------------------+---------------+</span>
<span class="gd">-</span>
<span class="gd">-      **Facilities**</span>
<span class="gd">-</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | Name (string) | Symbolic value|</span>
<span class="gd">-      +===============+===============+</span>
<span class="gd">-      | ``auth``      | LOG_AUTH      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``authpriv``  | LOG_AUTHPRIV  |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``cron``      | LOG_CRON      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``daemon``    | LOG_DAEMON    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``ftp``       | LOG_FTP       |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``kern``      | LOG_KERN      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``lpr``       | LOG_LPR       |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``mail``      | LOG_MAIL      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``news``      | LOG_NEWS      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``syslog``    | LOG_SYSLOG    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``user``      | LOG_USER      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``uucp``      | LOG_UUCP      |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local0``    | LOG_LOCAL0    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local1``    | LOG_LOCAL1    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local2``    | LOG_LOCAL2    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local3``    | LOG_LOCAL3    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local4``    | LOG_LOCAL4    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local5``    | LOG_LOCAL5    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local6``    | LOG_LOCAL6    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-      | ``local7``    | LOG_LOCAL7    |</span>
<span class="gd">-      +---------------+---------------+</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: mapPriority(levelname)</span>
<span class="gd">-</span>
<span class="gd">-      Maps a logging level name to a syslog priority name.</span>
<span class="gd">-      You may need to override this if you are using custom levels, or</span>
<span class="gd">-      if the default algorithm is not suitable for your needs. The</span>
<span class="gd">-      default algorithm maps ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` and</span>
<span class="gd">-      ``CRITICAL`` to the equivalent syslog names, and all other level</span>
<span class="gd">-      names to &quot;warning&quot;.</span>
<span class="gd">-</span>
<span class="gd">-.. _nt-eventlog-handler:</span>
<span class="gd">-</span>
<span class="gd">-NTEventLogHandler</span>
<span class="gd">-^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers`</span>
<span class="gd">-module, supports sending logging messages to a local Windows NT, Windows 2000 or</span>
<span class="gd">-Windows XP event log. Before you can use it, you need Mark Hammond&#39;s Win32</span>
<span class="gd">-extensions for Python installed.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: NTEventLogHandler(appname[, dllname[, logtype]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`NTEventLogHandler` class. The *appname* is</span>
<span class="gd">-   used to define the application name as it appears in the event log. An</span>
<span class="gd">-   appropriate registry entry is created using this name. The *dllname* should give</span>
<span class="gd">-   the fully qualified pathname of a .dll or .exe which contains message</span>
<span class="gd">-   definitions to hold in the log (if not specified, ``&#39;win32service.pyd&#39;`` is used</span>
<span class="gd">-   - this is installed with the Win32 extensions and contains some basic</span>
<span class="gd">-   placeholder message definitions. Note that use of these placeholders will make</span>
<span class="gd">-   your event logs big, as the entire message source is held in the log. If you</span>
<span class="gd">-   want slimmer logs, you have to pass in the name of your own .dll or .exe which</span>
<span class="gd">-   contains the message definitions you want to use in the event log). The</span>
<span class="gd">-   *logtype* is one of ``&#39;Application&#39;``, ``&#39;System&#39;`` or ``&#39;Security&#39;``, and</span>
<span class="gd">-   defaults to ``&#39;Application&#39;``.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: close()</span>
<span class="gd">-</span>
<span class="gd">-      At this point, you can remove the application name from the registry as a</span>
<span class="gd">-      source of event log entries. However, if you do this, you will not be able</span>
<span class="gd">-      to see the events as you intended in the Event Log Viewer - it needs to be</span>
<span class="gd">-      able to access the registry to get the .dll name. The current version does</span>
<span class="gd">-      not do this.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Determines the message ID, event category and event type, and then logs</span>
<span class="gd">-      the message in the NT event log.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: getEventCategory(record)</span>
<span class="gd">-</span>
<span class="gd">-      Returns the event category for the record. Override this if you want to</span>
<span class="gd">-      specify your own categories. This version returns 0.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: getEventType(record)</span>
<span class="gd">-</span>
<span class="gd">-      Returns the event type for the record. Override this if you want to</span>
<span class="gd">-      specify your own types. This version does a mapping using the handler&#39;s</span>
<span class="gd">-      typemap attribute, which is set up in :meth:`__init__` to a dictionary</span>
<span class="gd">-      which contains mappings for :const:`DEBUG`, :const:`INFO`,</span>
<span class="gd">-      :const:`WARNING`, :const:`ERROR` and :const:`CRITICAL`. If you are using</span>
<span class="gd">-      your own levels, you will either need to override this method or place a</span>
<span class="gd">-      suitable dictionary in the handler&#39;s *typemap* attribute.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: getMessageID(record)</span>
<span class="gd">-</span>
<span class="gd">-      Returns the message ID for the record. If you are using your own messages,</span>
<span class="gd">-      you could do this by having the *msg* passed to the logger being an ID</span>
<span class="gd">-      rather than a format string. Then, in here, you could use a dictionary</span>
<span class="gd">-      lookup to get the message ID. This version returns 1, which is the base</span>
<span class="gd">-      message ID in :file:`win32service.pyd`.</span>
<span class="gd">-</span>
<span class="gd">-.. _smtp-handler:</span>
<span class="gd">-</span>
<span class="gd">-SMTPHandler</span>
<span class="gd">-^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` module,</span>
<span class="gd">-supports sending logging messages to an email address via SMTP.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: SMTPHandler(mailhost, fromaddr, toaddrs, subject[, credentials])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`SMTPHandler` class. The instance is</span>
<span class="gd">-   initialized with the from and to addresses and subject line of the email. The</span>
<span class="gd">-   *toaddrs* should be a list of strings. To specify a non-standard SMTP port, use</span>
<span class="gd">-   the (host, port) tuple format for the *mailhost* argument. If you use a string,</span>
<span class="gd">-   the standard SMTP port is used. If your SMTP server requires authentication, you</span>
<span class="gd">-   can specify a (username, password) tuple for the *credentials* argument.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.6</span>
<span class="gd">-      *credentials* was added.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Formats the record and sends it to the specified addressees.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: getSubject(record)</span>
<span class="gd">-</span>
<span class="gd">-      If you want to specify a subject line which is record-dependent, override</span>
<span class="gd">-      this method.</span>
<span class="gd">-</span>
<span class="gd">-.. _memory-handler:</span>
<span class="gd">-</span>
<span class="gd">-MemoryHandler</span>
<span class="gd">-^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` module,</span>
<span class="gd">-supports buffering of logging records in memory, periodically flushing them to a</span>
<span class="gd">-:dfn:`target` handler. Flushing occurs whenever the buffer is full, or when an</span>
<span class="gd">-event of a certain severity or greater is seen.</span>
<span class="gd">-</span>
<span class="gd">-:class:`MemoryHandler` is a subclass of the more general</span>
<span class="gd">-:class:`BufferingHandler`, which is an abstract class. This buffers logging</span>
<span class="gd">-records in memory. Whenever each record is added to the buffer, a check is made</span>
<span class="gd">-by calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it</span>
<span class="gd">-should, then :meth:`flush` is expected to do the needful.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: BufferingHandler(capacity)</span>
<span class="gd">-</span>
<span class="gd">-   Initializes the handler with a buffer of the specified capacity.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Appends the record to the buffer. If :meth:`shouldFlush` returns true,</span>
<span class="gd">-      calls :meth:`flush` to process the buffer.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: flush()</span>
<span class="gd">-</span>
<span class="gd">-      You can override this to implement custom flushing behavior. This version</span>
<span class="gd">-      just zaps the buffer to empty.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: shouldFlush(record)</span>
<span class="gd">-</span>
<span class="gd">-      Returns true if the buffer is up to capacity. This method can be</span>
<span class="gd">-      overridden to implement custom flushing strategies.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: MemoryHandler(capacity[, flushLevel [, target]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`MemoryHandler` class. The instance is</span>
<span class="gd">-   initialized with a buffer size of *capacity*. If *flushLevel* is not specified,</span>
<span class="gd">-   :const:`ERROR` is used. If no *target* is specified, the target will need to be</span>
<span class="gd">-   set using :meth:`setTarget` before this handler does anything useful.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: close()</span>
<span class="gd">-</span>
<span class="gd">-      Calls :meth:`flush`, sets the target to :const:`None` and clears the</span>
<span class="gd">-      buffer.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: flush()</span>
<span class="gd">-</span>
<span class="gd">-      For a :class:`MemoryHandler`, flushing means just sending the buffered</span>
<span class="gd">-      records to the target, if there is one. Override if you want different</span>
<span class="gd">-      behavior.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: setTarget(target)</span>
<span class="gd">-</span>
<span class="gd">-      Sets the target handler for this handler.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: shouldFlush(record)</span>
<span class="gd">-</span>
<span class="gd">-      Checks for buffer full or a record at the *flushLevel* or higher.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _http-handler:</span>
<span class="gd">-</span>
<span class="gd">-HTTPHandler</span>
<span class="gd">-^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` module,</span>
<span class="gd">-supports sending logging messages to a Web server, using either ``GET`` or</span>
<span class="gd">-``POST`` semantics.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: HTTPHandler(host, url[, method])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`HTTPHandler` class. The instance is</span>
<span class="gd">-   initialized with a host address, url and HTTP method. The *host* can be of the</span>
<span class="gd">-   form ``host:port``, should you need to use a specific port number. If no</span>
<span class="gd">-   *method* is specified, ``GET`` is used.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: emit(record)</span>
<span class="gd">-</span>
<span class="gd">-      Sends the record to the Web server as an URL-encoded dictionary.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _formatter:</span>
<span class="gd">-</span>
<span class="gd">-Formatter Objects</span>
<span class="gd">------------------</span>
<span class="gd">-</span>
<span class="gd">-.. currentmodule:: logging</span>
<span class="gd">-</span>
<span class="gd">-:class:`Formatter`\ s have the following attributes and methods. They are</span>
<span class="gd">-responsible for converting a :class:`LogRecord` to (usually) a string which can</span>
<span class="gd">-be interpreted by either a human or an external system. The base</span>
<span class="gd">-:class:`Formatter` allows a formatting string to be specified. If none is</span>
<span class="gd">-supplied, the default value of ``&#39;%(message)s&#39;`` is used.</span>
<span class="gd">-</span>
<span class="gd">-A Formatter can be initialized with a format string which makes use of knowledge</span>
<span class="gd">-of the :class:`LogRecord` attributes - such as the default value mentioned above</span>
<span class="gd">-making use of the fact that the user&#39;s message and arguments are pre-formatted</span>
<span class="gd">-into a :class:`LogRecord`&#39;s *message* attribute.  This format string contains</span>
<span class="gd">-standard Python %-style mapping keys. See section :ref:`string-formatting`</span>
<span class="gd">-for more information on string formatting.</span>
<span class="gd">-</span>
<span class="gd">-Currently, the useful mapping keys in a :class:`LogRecord` are:</span>
<span class="gd">-</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| Format                  | Description                                   |</span>
<span class="gd">-+=========================+===============================================+</span>
<span class="gd">-| ``%(name)s``            | Name of the logger (logging channel).         |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(levelno)s``         | Numeric logging level for the message         |</span>
<span class="gd">-|                         | (:const:`DEBUG`, :const:`INFO`,               |</span>
<span class="gd">-|                         | :const:`WARNING`, :const:`ERROR`,             |</span>
<span class="gd">-|                         | :const:`CRITICAL`).                           |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(levelname)s``       | Text logging level for the message            |</span>
<span class="gd">-|                         | (``&#39;DEBUG&#39;``, ``&#39;INFO&#39;``, ``&#39;WARNING&#39;``,      |</span>
<span class="gd">-|                         | ``&#39;ERROR&#39;``, ``&#39;CRITICAL&#39;``).                 |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(pathname)s``        | Full pathname of the source file where the    |</span>
<span class="gd">-|                         | logging call was issued (if available).       |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(filename)s``        | Filename portion of pathname.                 |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(module)s``          | Module (name portion of filename).            |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(funcName)s``        | Name of function containing the logging call. |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(lineno)d``          | Source line number where the logging call was |</span>
<span class="gd">-|                         | issued (if available).                        |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(created)f``         | Time when the :class:`LogRecord` was created  |</span>
<span class="gd">-|                         | (as returned by :func:`time.time`).           |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(relativeCreated)d`` | Time in milliseconds when the LogRecord was   |</span>
<span class="gd">-|                         | created, relative to the time the logging     |</span>
<span class="gd">-|                         | module was loaded.                            |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(asctime)s``         | Human-readable time when the                  |</span>
<span class="gd">-|                         | :class:`LogRecord` was created.  By default   |</span>
<span class="gd">-|                         | this is of the form &quot;2003-07-08 16:49:45,896&quot; |</span>
<span class="gd">-|                         | (the numbers after the comma are millisecond  |</span>
<span class="gd">-|                         | portion of the time).                         |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(msecs)d``           | Millisecond portion of the time when the      |</span>
<span class="gd">-|                         | :class:`LogRecord` was created.               |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(thread)d``          | Thread ID (if available).                     |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(threadName)s``      | Thread name (if available).                   |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(process)d``         | Process ID (if available).                    |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-| ``%(message)s``         | The logged message, computed as ``msg %       |</span>
<span class="gd">-|                         | args``.                                       |</span>
<span class="gd">-+-------------------------+-----------------------------------------------+</span>
<span class="gd">-</span>
<span class="gd">-.. versionchanged:: 2.5</span>
<span class="gd">-   *funcName* was added.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: Formatter([fmt[, datefmt]])</span>
<span class="gd">-</span>
<span class="gd">-   Returns a new instance of the :class:`Formatter` class. The instance is</span>
<span class="gd">-   initialized with a format string for the message as a whole, as well as a format</span>
<span class="gd">-   string for the date/time portion of a message. If no *fmt* is specified,</span>
<span class="gd">-   ``&#39;%(message)s&#39;`` is used. If no *datefmt* is specified, the ISO8601 date format</span>
<span class="gd">-   is used.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: format(record)</span>
<span class="gd">-</span>
<span class="gd">-      The record&#39;s attribute dictionary is used as the operand to a string</span>
<span class="gd">-      formatting operation. Returns the resulting string. Before formatting the</span>
<span class="gd">-      dictionary, a couple of preparatory steps are carried out. The *message*</span>
<span class="gd">-      attribute of the record is computed using *msg* % *args*. If the</span>
<span class="gd">-      formatting string contains ``&#39;(asctime)&#39;``, :meth:`formatTime` is called</span>
<span class="gd">-      to format the event time. If there is exception information, it is</span>
<span class="gd">-      formatted using :meth:`formatException` and appended to the message. Note</span>
<span class="gd">-      that the formatted exception information is cached in attribute</span>
<span class="gd">-      *exc_text*. This is useful because the exception information can be</span>
<span class="gd">-      pickled and sent across the wire, but you should be careful if you have</span>
<span class="gd">-      more than one :class:`Formatter` subclass which customizes the formatting</span>
<span class="gd">-      of exception information. In this case, you will have to clear the cached</span>
<span class="gd">-      value after a formatter has done its formatting, so that the next</span>
<span class="gd">-      formatter to handle the event doesn&#39;t use the cached value but</span>
<span class="gd">-      recalculates it afresh.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: formatTime(record[, datefmt])</span>
<span class="gd">-</span>
<span class="gd">-      This method should be called from :meth:`format` by a formatter which</span>
<span class="gd">-      wants to make use of a formatted time. This method can be overridden in</span>
<span class="gd">-      formatters to provide for any specific requirement, but the basic behavior</span>
<span class="gd">-      is as follows: if *datefmt* (a string) is specified, it is used with</span>
<span class="gd">-      :func:`time.strftime` to format the creation time of the</span>
<span class="gd">-      record. Otherwise, the ISO8601 format is used.  The resulting string is</span>
<span class="gd">-      returned.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: formatException(exc_info)</span>
<span class="gd">-</span>
<span class="gd">-      Formats the specified exception information (a standard exception tuple as</span>
<span class="gd">-      returned by :func:`sys.exc_info`) as a string. This default implementation</span>
<span class="gd">-      just uses :func:`traceback.print_exception`. The resulting string is</span>
<span class="gd">-      returned.</span>
<span class="gd">-</span>
<span class="gd">-.. _filter:</span>
<span class="gd">-</span>
<span class="gd">-Filter Objects</span>
<span class="gd">---------------</span>
<span class="gd">-</span>
<span class="gd">-Filters can be used by :class:`Handler`\ s and :class:`Logger`\ s for</span>
<span class="gd">-more sophisticated filtering than is provided by levels. The base filter class</span>
<span class="gd">-only allows events which are below a certain point in the logger hierarchy. For</span>
<span class="gd">-example, a filter initialized with &quot;A.B&quot; will allow events logged by loggers</span>
<span class="gd">-&quot;A.B&quot;, &quot;A.B.C&quot;, &quot;A.B.C.D&quot;, &quot;A.B.D&quot; etc. but not &quot;A.BB&quot;, &quot;B.A.B&quot; etc. If</span>
<span class="gd">-initialized with the empty string, all events are passed.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: Filter([name])</span>
<span class="gd">-</span>
<span class="gd">-   Returns an instance of the :class:`Filter` class. If *name* is specified, it</span>
<span class="gd">-   names a logger which, together with its children, will have its events allowed</span>
<span class="gd">-   through the filter. If no name is specified, allows every event.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: filter(record)</span>
<span class="gd">-</span>
<span class="gd">-      Is the specified record to be logged? Returns zero for no, nonzero for</span>
<span class="gd">-      yes. If deemed appropriate, the record may be modified in-place by this</span>
<span class="gd">-      method.</span>
<span class="gd">-</span>
<span class="gd">-.. _log-record:</span>
<span class="gd">-</span>
<span class="gd">-LogRecord Objects</span>
<span class="gd">------------------</span>
<span class="gd">-</span>
<span class="gd">-:class:`LogRecord` instances are created every time something is logged. They</span>
<span class="gd">-contain all the information pertinent to the event being logged. The main</span>
<span class="gd">-information passed in is in msg and args, which are combined using msg % args to</span>
<span class="gd">-create the message field of the record. The record also includes information</span>
<span class="gd">-such as when the record was created, the source line where the logging call was</span>
<span class="gd">-made, and any exception information to be logged.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. class:: LogRecord(name, lvl, pathname, lineno, msg, args, exc_info [, func])</span>
<span class="gd">-</span>
<span class="gd">-   Returns an instance of :class:`LogRecord` initialized with interesting</span>
<span class="gd">-   information. The *name* is the logger name; *lvl* is the numeric level;</span>
<span class="gd">-   *pathname* is the absolute pathname of the source file in which the logging</span>
<span class="gd">-   call was made; *lineno* is the line number in that file where the logging</span>
<span class="gd">-   call is found; *msg* is the user-supplied message (a format string); *args*</span>
<span class="gd">-   is the tuple which, together with *msg*, makes up the user message; and</span>
<span class="gd">-   *exc_info* is the exception tuple obtained by calling :func:`sys.exc_info`</span>
<span class="gd">-   (or :const:`None`, if no exception information is available). The *func* is</span>
<span class="gd">-   the name of the function from which the logging call was made. If not</span>
<span class="gd">-   specified, it defaults to ``None``.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.5</span>
<span class="gd">-      *func* was added.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-   .. method:: getMessage()</span>
<span class="gd">-</span>
<span class="gd">-      Returns the message for this :class:`LogRecord` instance after merging any</span>
<span class="gd">-      user-supplied arguments with the message.</span>
<span class="gd">-</span>
<span class="gd">-.. _logger-adapter:</span>
<span class="gd">-</span>
<span class="gd">-LoggerAdapter Objects</span>
<span class="gd">----------------------</span>
<span class="gd">-</span>
<span class="gd">-.. versionadded:: 2.6</span>
<span class="gd">-</span>
<span class="gd">-:class:`LoggerAdapter` instances are used to conveniently pass contextual</span>
<span class="gd">-information into logging calls. For a usage example , see the section on</span>
<span class="gd">-`adding contextual information to your logging output`__.</span>
<span class="gd">-</span>
<span class="gd">-__ context-info_</span>
<span class="gd">-</span>
<span class="gd">-.. class:: LoggerAdapter(logger, extra)</span>
<span class="gd">-</span>
<span class="gd">-  Returns an instance of :class:`LoggerAdapter` initialized with an</span>
<span class="gd">-  underlying :class:`Logger` instance and a dict-like object.</span>
<span class="gd">-</span>
<span class="gd">-  .. method:: process(msg, kwargs)</span>
<span class="gd">-</span>
<span class="gd">-    Modifies the message and/or keyword arguments passed to a logging call in</span>
<span class="gd">-    order to insert contextual information. This implementation takes the object</span>
<span class="gd">-    passed as *extra* to the constructor and adds it to *kwargs* using key</span>
<span class="gd">-    &#39;extra&#39;. The return value is a (*msg*, *kwargs*) tuple which has the</span>
<span class="gd">-    (possibly modified) versions of the arguments passed in.</span>
<span class="gd">-</span>
<span class="gd">-In addition to the above, :class:`LoggerAdapter` supports all the logging</span>
<span class="gd">-methods of :class:`Logger`, i.e. :meth:`debug`, :meth:`info`, :meth:`warning`,</span>
<span class="gd">-:meth:`error`, :meth:`exception`, :meth:`critical` and :meth:`log`. These</span>
<span class="gd">-methods have the same signatures as their counterparts in :class:`Logger`, so</span>
<span class="gd">-you can use the two types of instances interchangeably.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Thread Safety</span>
<span class="gd">--------------</span>
<span class="gd">-</span>
<span class="gd">-The logging module is intended to be thread-safe without any special work</span>
<span class="gd">-needing to be done by its clients. It achieves this though using threading</span>
<span class="gd">-locks; there is one lock to serialize access to the module&#39;s shared data, and</span>
<span class="gd">-each handler also creates a lock to serialize access to its underlying I/O.</span>
<span class="gd">-</span>
<span class="gd">-If you are implementing asynchronous signal handlers using the :mod:`signal`</span>
<span class="gd">-module, you may not be able to use logging from within such handlers. This is</span>
<span class="gd">-because lock implementations in the :mod:`threading` module are not always</span>
<span class="gd">-re-entrant, and so cannot be invoked from such signal handlers.</span>
<span class="gd">-</span>
<span class="gd">-Configuration</span>
<span class="gd">--------------</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _logging-config-api:</span>
<span class="gd">-</span>
<span class="gd">-Configuration functions</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The following functions configure the logging module. They are located in the</span>
<span class="gd">-:mod:`logging.config` module.  Their use is optional --- you can configure the</span>
<span class="gd">-logging module using these functions or by making calls to the main API (defined</span>
<span class="gd">-in :mod:`logging` itself) and defining handlers which are declared either in</span>
<span class="gd">-:mod:`logging` or :mod:`logging.handlers`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. function:: fileConfig(fname[, defaults])</span>
<span class="gd">-</span>
<span class="gd">-   Reads the logging configuration from a ConfigParser-format file named *fname*.</span>
<span class="gd">-   This function can be called several times from an application, allowing an end</span>
<span class="gd">-   user the ability to select from various pre-canned configurations (if the</span>
<span class="gd">-   developer provides a mechanism to present the choices and load the chosen</span>
<span class="gd">-   configuration). Defaults to be passed to ConfigParser can be specified in the</span>
<span class="gd">-   *defaults* argument.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. function:: listen([port])</span>
<span class="gd">-</span>
<span class="gd">-   Starts up a socket server on the specified port, and listens for new</span>
<span class="gd">-   configurations. If no port is specified, the module&#39;s default</span>
<span class="gd">-   :const:`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be</span>
<span class="gd">-   sent as a file suitable for processing by :func:`fileConfig`. Returns a</span>
<span class="gd">-   :class:`Thread` instance on which you can call :meth:`start` to start the</span>
<span class="gd">-   server, and which you can :meth:`join` when appropriate. To stop the server,</span>
<span class="gd">-   call :func:`stopListening`.</span>
<span class="gd">-</span>
<span class="gd">-   To send a configuration to the socket, read in the configuration file and</span>
<span class="gd">-   send it to the socket as a string of bytes preceded by a four-byte length</span>
<span class="gd">-   string packed in binary using ``struct.pack(&#39;&gt;L&#39;, n)``.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. function:: stopListening()</span>
<span class="gd">-</span>
<span class="gd">-   Stops the listening server which was created with a call to :func:`listen`.</span>
<span class="gd">-   This is typically called before calling :meth:`join` on the return value from</span>
<span class="gd">-   :func:`listen`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. _logging-config-fileformat:</span>
<span class="gd">-</span>
<span class="gd">-Configuration file format</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-The configuration file format understood by :func:`fileConfig` is based on</span>
<span class="gd">-:mod:`ConfigParser` functionality. The file must contain sections called</span>
<span class="gd">-``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name the</span>
<span class="gd">-entities of each type which are defined in the file. For each such entity,</span>
<span class="gd">-there is a separate section which identifies how that entity is configured.</span>
<span class="gd">-Thus, for a logger named ``log01`` in the ``[loggers]`` section, the relevant</span>
<span class="gd">-configuration details are held in a section ``[logger_log01]``. Similarly, a</span>
<span class="gd">-handler called ``hand01`` in the ``[handlers]`` section will have its</span>
<span class="gd">-configuration held in a section called ``[handler_hand01]``, while a formatter</span>
<span class="gd">-called ``form01`` in the ``[formatters]`` section will have its configuration</span>
<span class="gd">-specified in a section called ``[formatter_form01]``. The root logger</span>
<span class="gd">-configuration must be specified in a section called ``[logger_root]``.</span>
<span class="gd">-</span>
<span class="gd">-Examples of these sections in the file are given below. ::</span>
<span class="gd">-</span>
<span class="gd">-   [loggers]</span>
<span class="gd">-   keys=root,log02,log03,log04,log05,log06,log07</span>
<span class="gd">-</span>
<span class="gd">-   [handlers]</span>
<span class="gd">-   keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09</span>
<span class="gd">-</span>
<span class="gd">-   [formatters]</span>
<span class="gd">-   keys=form01,form02,form03,form04,form05,form06,form07,form08,form09</span>
<span class="gd">-</span>
<span class="gd">-The root logger must specify a level and a list of handlers. An example of a</span>
<span class="gd">-root logger section is given below. ::</span>
<span class="gd">-</span>
<span class="gd">-   [logger_root]</span>
<span class="gd">-   level=NOTSET</span>
<span class="gd">-   handlers=hand01</span>
<span class="gd">-</span>
<span class="gd">-The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` or</span>
<span class="gd">-``NOTSET``. For the root logger only, ``NOTSET`` means that all messages will be</span>
<span class="gd">-logged. Level values are :func:`eval`\ uated in the context of the ``logging``</span>
<span class="gd">-package&#39;s namespace.</span>
<span class="gd">-</span>
<span class="gd">-The ``handlers`` entry is a comma-separated list of handler names, which must</span>
<span class="gd">-appear in the ``[handlers]`` section. These names must appear in the</span>
<span class="gd">-``[handlers]`` section and have corresponding sections in the configuration</span>
<span class="gd">-file.</span>
<span class="gd">-</span>
<span class="gd">-For loggers other than the root logger, some additional information is required.</span>
<span class="gd">-This is illustrated by the following example. ::</span>
<span class="gd">-</span>
<span class="gd">-   [logger_parser]</span>
<span class="gd">-   level=DEBUG</span>
<span class="gd">-   handlers=hand01</span>
<span class="gd">-   propagate=1</span>
<span class="gd">-   qualname=compiler.parser</span>
<span class="gd">-</span>
<span class="gd">-The ``level`` and ``handlers`` entries are interpreted as for the root logger,</span>
<span class="gd">-except that if a non-root logger&#39;s level is specified as ``NOTSET``, the system</span>
<span class="gd">-consults loggers higher up the hierarchy to determine the effective level of the</span>
<span class="gd">-logger. The ``propagate`` entry is set to 1 to indicate that messages must</span>
<span class="gd">-propagate to handlers higher up the logger hierarchy from this logger, or 0 to</span>
<span class="gd">-indicate that messages are **not** propagated to handlers up the hierarchy. The</span>
<span class="gd">-``qualname`` entry is the hierarchical channel name of the logger, that is to</span>
<span class="gd">-say the name used by the application to get the logger.</span>
<span class="gd">-</span>
<span class="gd">-Sections which specify handler configuration are exemplified by the following.</span>
<span class="gd">-::</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand01]</span>
<span class="gd">-   class=StreamHandler</span>
<span class="gd">-   level=NOTSET</span>
<span class="gd">-   formatter=form01</span>
<span class="gd">-   args=(sys.stdout,)</span>
<span class="gd">-</span>
<span class="gd">-The ``class`` entry indicates the handler&#39;s class (as determined by :func:`eval`</span>
<span class="gd">-in the ``logging`` package&#39;s namespace). The ``level`` is interpreted as for</span>
<span class="gd">-loggers, and ``NOTSET`` is taken to mean &quot;log everything&quot;.</span>
<span class="gd">-</span>
<span class="gd">-.. versionchanged:: 2.6</span>
<span class="gd">-  Added support for resolving the handler&#39;s class as a dotted module and class</span>
<span class="gd">-  name.</span>
<span class="gd">-</span>
<span class="gd">-The ``formatter`` entry indicates the key name of the formatter for this</span>
<span class="gd">-handler. If blank, a default formatter (``logging._defaultFormatter``) is used.</span>
<span class="gd">-If a name is specified, it must appear in the ``[formatters]`` section and have</span>
<span class="gd">-a corresponding section in the configuration file.</span>
<span class="gd">-</span>
<span class="gd">-The ``args`` entry, when :func:`eval`\ uated in the context of the ``logging``</span>
<span class="gd">-package&#39;s namespace, is the list of arguments to the constructor for the handler</span>
<span class="gd">-class. Refer to the constructors for the relevant handlers, or to the examples</span>
<span class="gd">-below, to see how typical entries are constructed. ::</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand02]</span>
<span class="gd">-   class=FileHandler</span>
<span class="gd">-   level=DEBUG</span>
<span class="gd">-   formatter=form02</span>
<span class="gd">-   args=(&#39;python.log&#39;, &#39;w&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand03]</span>
<span class="gd">-   class=handlers.SocketHandler</span>
<span class="gd">-   level=INFO</span>
<span class="gd">-   formatter=form03</span>
<span class="gd">-   args=(&#39;localhost&#39;, handlers.DEFAULT_TCP_LOGGING_PORT)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand04]</span>
<span class="gd">-   class=handlers.DatagramHandler</span>
<span class="gd">-   level=WARN</span>
<span class="gd">-   formatter=form04</span>
<span class="gd">-   args=(&#39;localhost&#39;, handlers.DEFAULT_UDP_LOGGING_PORT)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand05]</span>
<span class="gd">-   class=handlers.SysLogHandler</span>
<span class="gd">-   level=ERROR</span>
<span class="gd">-   formatter=form05</span>
<span class="gd">-   args=((&#39;localhost&#39;, handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand06]</span>
<span class="gd">-   class=handlers.NTEventLogHandler</span>
<span class="gd">-   level=CRITICAL</span>
<span class="gd">-   formatter=form06</span>
<span class="gd">-   args=(&#39;Python Application&#39;, &#39;&#39;, &#39;Application&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand07]</span>
<span class="gd">-   class=handlers.SMTPHandler</span>
<span class="gd">-   level=WARN</span>
<span class="gd">-   formatter=form07</span>
<span class="gd">-   args=(&#39;localhost&#39;, &#39;from@abc&#39;, [&#39;user1@abc&#39;, &#39;user2@xyz&#39;], &#39;Logger Subject&#39;)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand08]</span>
<span class="gd">-   class=handlers.MemoryHandler</span>
<span class="gd">-   level=NOTSET</span>
<span class="gd">-   formatter=form08</span>
<span class="gd">-   target=</span>
<span class="gd">-   args=(10, ERROR)</span>
<span class="gd">-</span>
<span class="gd">-   [handler_hand09]</span>
<span class="gd">-   class=handlers.HTTPHandler</span>
<span class="gd">-   level=NOTSET</span>
<span class="gd">-   formatter=form09</span>
<span class="gd">-   args=(&#39;localhost:9022&#39;, &#39;/log&#39;, &#39;GET&#39;)</span>
<span class="gd">-</span>
<span class="gd">-Sections which specify formatter configuration are typified by the following. ::</span>
<span class="gd">-</span>
<span class="gd">-   [formatter_form01]</span>
<span class="gd">-   format=F1 %(asctime)s %(levelname)s %(message)s</span>
<span class="gd">-   datefmt=</span>
<span class="gd">-   class=logging.Formatter</span>
<span class="gd">-</span>
<span class="gd">-The ``format`` entry is the overall format string, and the ``datefmt`` entry is</span>
<span class="gd">-the :func:`strftime`\ -compatible date/time format string.  If empty, the</span>
<span class="gd">-package substitutes ISO8601 format date/times, which is almost equivalent to</span>
<span class="gd">-specifying the date format string ``&quot;%Y-%m-%d %H:%M:%S&quot;``.  The ISO8601 format</span>
<span class="gd">-also specifies milliseconds, which are appended to the result of using the above</span>
<span class="gd">-format string, with a comma separator.  An example time in ISO8601 format is</span>
<span class="gd">-``2003-01-23 00:29:50,411``.</span>
<span class="gd">-</span>
<span class="gd">-The ``class`` entry is optional.  It indicates the name of the formatter&#39;s class</span>
<span class="gd">-(as a dotted module and class name.)  This option is useful for instantiating a</span>
<span class="gd">-:class:`Formatter` subclass.  Subclasses of :class:`Formatter` can present</span>
<span class="gd">-exception tracebacks in an expanded or condensed format.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Configuration server example</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-Here is an example of a module using the logging configuration server::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-    import logging.config</span>
<span class="gd">-    import time</span>
<span class="gd">-    import os</span>
<span class="gd">-</span>
<span class="gd">-    # read initial config file</span>
<span class="gd">-    logging.config.fileConfig(&quot;logging.conf&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    # create and start listener on port 9999</span>
<span class="gd">-    t = logging.config.listen(9999)</span>
<span class="gd">-    t.start()</span>
<span class="gd">-</span>
<span class="gd">-    logger = logging.getLogger(&quot;simpleExample&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    try:</span>
<span class="gd">-        # loop through logging calls to see the difference</span>
<span class="gd">-        # new configurations make, until Ctrl+C is pressed</span>
<span class="gd">-        while True:</span>
<span class="gd">-            logger.debug(&quot;debug message&quot;)</span>
<span class="gd">-            logger.info(&quot;info message&quot;)</span>
<span class="gd">-            logger.warn(&quot;warn message&quot;)</span>
<span class="gd">-            logger.error(&quot;error message&quot;)</span>
<span class="gd">-            logger.critical(&quot;critical message&quot;)</span>
<span class="gd">-            time.sleep(5)</span>
<span class="gd">-    except KeyboardInterrupt:</span>
<span class="gd">-        # cleanup</span>
<span class="gd">-        logging.config.stopListening()</span>
<span class="gd">-        t.join()</span>
<span class="gd">-</span>
<span class="gd">-And here is a script that takes a filename and sends that file to the server,</span>
<span class="gd">-properly preceded with the binary-encoded length, as the new logging</span>
<span class="gd">-configuration::</span>
<span class="gd">-</span>
<span class="gd">-    #!/usr/bin/env python</span>
<span class="gd">-    import socket, sys, struct</span>
<span class="gd">-</span>
<span class="gd">-    data_to_send = open(sys.argv[1], &quot;r&quot;).read()</span>
<span class="gd">-</span>
<span class="gd">-    HOST = &#39;localhost&#39;</span>
<span class="gd">-    PORT = 9999</span>
<span class="gd">-    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>
<span class="gd">-    print &quot;connecting...&quot;</span>
<span class="gd">-    s.connect((HOST, PORT))</span>
<span class="gd">-    print &quot;sending config...&quot;</span>
<span class="gd">-    s.send(struct.pack(&quot;&gt;L&quot;, len(data_to_send)))</span>
<span class="gd">-    s.send(data_to_send)</span>
<span class="gd">-    s.close()</span>
<span class="gd">-    print &quot;complete&quot;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-More examples</span>
<span class="gd">--------------</span>
<span class="gd">-</span>
<span class="gd">-Multiple handlers and formatters</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-Loggers are plain Python objects.  The :func:`addHandler` method has no minimum</span>
<span class="gd">-or maximum quota for the number of handlers you may add.  Sometimes it will be</span>
<span class="gd">-beneficial for an application to log all messages of all severities to a text</span>
<span class="gd">-file while simultaneously logging errors or above to the console.  To set this</span>
<span class="gd">-up, simply configure the appropriate handlers.  The logging calls in the</span>
<span class="gd">-application code will remain unchanged.  Here is a slight modification to the</span>
<span class="gd">-previous simple module-based configuration example::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-</span>
<span class="gd">-    logger = logging.getLogger(&quot;simple_example&quot;)</span>
<span class="gd">-    logger.setLevel(logging.DEBUG)</span>
<span class="gd">-    # create file handler which logs even debug messages</span>
<span class="gd">-    fh = logging.FileHandler(&quot;spam.log&quot;)</span>
<span class="gd">-    fh.setLevel(logging.DEBUG)</span>
<span class="gd">-    # create console handler with a higher log level</span>
<span class="gd">-    ch = logging.StreamHandler()</span>
<span class="gd">-    ch.setLevel(logging.ERROR)</span>
<span class="gd">-    # create formatter and add it to the handlers</span>
<span class="gd">-    formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)</span>
<span class="gd">-    ch.setFormatter(formatter)</span>
<span class="gd">-    fh.setFormatter(formatter)</span>
<span class="gd">-    # add the handlers to logger</span>
<span class="gd">-    logger.addHandler(ch)</span>
<span class="gd">-    logger.addHandler(fh)</span>
<span class="gd">-</span>
<span class="gd">-    # &quot;application&quot; code</span>
<span class="gd">-    logger.debug(&quot;debug message&quot;)</span>
<span class="gd">-    logger.info(&quot;info message&quot;)</span>
<span class="gd">-    logger.warn(&quot;warn message&quot;)</span>
<span class="gd">-    logger.error(&quot;error message&quot;)</span>
<span class="gd">-    logger.critical(&quot;critical message&quot;)</span>
<span class="gd">-</span>
<span class="gd">-Notice that the &quot;application&quot; code does not care about multiple handlers.  All</span>
<span class="gd">-that changed was the addition and configuration of a new handler named *fh*.</span>
<span class="gd">-</span>
<span class="gd">-The ability to create new handlers with higher- or lower-severity filters can be</span>
<span class="gd">-very helpful when writing and testing an application.  Instead of using many</span>
<span class="gd">-``print`` statements for debugging, use ``logger.debug``: Unlike the print</span>
<span class="gd">-statements, which you will have to delete or comment out later, the logger.debug</span>
<span class="gd">-statements can remain intact in the source code and remain dormant until you</span>
<span class="gd">-need them again.  At that time, the only change that needs to happen is to</span>
<span class="gd">-modify the severity level of the logger and/or handler to debug.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Using logging in multiple modules</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-It was mentioned above that multiple calls to</span>
<span class="gd">-``logging.getLogger(&#39;someLogger&#39;)`` return a reference to the same logger</span>
<span class="gd">-object.  This is true not only within the same module, but also across modules</span>
<span class="gd">-as long as it is in the same Python interpreter process.  It is true for</span>
<span class="gd">-references to the same object; additionally, application code can define and</span>
<span class="gd">-configure a parent logger in one module and create (but not configure) a child</span>
<span class="gd">-logger in a separate module, and all logger calls to the child will pass up to</span>
<span class="gd">-the parent.  Here is a main module::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-    import auxiliary_module</span>
<span class="gd">-</span>
<span class="gd">-    # create logger with &quot;spam_application&quot;</span>
<span class="gd">-    logger = logging.getLogger(&quot;spam_application&quot;)</span>
<span class="gd">-    logger.setLevel(logging.DEBUG)</span>
<span class="gd">-    # create file handler which logs even debug messages</span>
<span class="gd">-    fh = logging.FileHandler(&quot;spam.log&quot;)</span>
<span class="gd">-    fh.setLevel(logging.DEBUG)</span>
<span class="gd">-    # create console handler with a higher log level</span>
<span class="gd">-    ch = logging.StreamHandler()</span>
<span class="gd">-    ch.setLevel(logging.ERROR)</span>
<span class="gd">-    # create formatter and add it to the handlers</span>
<span class="gd">-    formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)</span>
<span class="gd">-    fh.setFormatter(formatter)</span>
<span class="gd">-    ch.setFormatter(formatter)</span>
<span class="gd">-    # add the handlers to the logger</span>
<span class="gd">-    logger.addHandler(fh)</span>
<span class="gd">-    logger.addHandler(ch)</span>
<span class="gd">-</span>
<span class="gd">-    logger.info(&quot;creating an instance of auxiliary_module.Auxiliary&quot;)</span>
<span class="gd">-    a = auxiliary_module.Auxiliary()</span>
<span class="gd">-    logger.info(&quot;created an instance of auxiliary_module.Auxiliary&quot;)</span>
<span class="gd">-    logger.info(&quot;calling auxiliary_module.Auxiliary.do_something&quot;)</span>
<span class="gd">-    a.do_something()</span>
<span class="gd">-    logger.info(&quot;finished auxiliary_module.Auxiliary.do_something&quot;)</span>
<span class="gd">-    logger.info(&quot;calling auxiliary_module.some_function()&quot;)</span>
<span class="gd">-    auxiliary_module.some_function()</span>
<span class="gd">-    logger.info(&quot;done with auxiliary_module.some_function()&quot;)</span>
<span class="gd">-</span>
<span class="gd">-Here is the auxiliary module::</span>
<span class="gd">-</span>
<span class="gd">-    import logging</span>
<span class="gd">-</span>
<span class="gd">-    # create logger</span>
<span class="gd">-    module_logger = logging.getLogger(&quot;spam_application.auxiliary&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    class Auxiliary:</span>
<span class="gd">-        def __init__(self):</span>
<span class="gd">-            self.logger = logging.getLogger(&quot;spam_application.auxiliary.Auxiliary&quot;)</span>
<span class="gd">-            self.logger.info(&quot;creating an instance of Auxiliary&quot;)</span>
<span class="gd">-        def do_something(self):</span>
<span class="gd">-            self.logger.info(&quot;doing something&quot;)</span>
<span class="gd">-            a = 1 + 1</span>
<span class="gd">-            self.logger.info(&quot;done doing something&quot;)</span>
<span class="gd">-</span>
<span class="gd">-    def some_function():</span>
<span class="gd">-        module_logger.info(&quot;received a call to \&quot;some_function\&quot;&quot;)</span>
<span class="gd">-</span>
<span class="gd">-The output looks like this::</span>
<span class="gd">-</span>
<span class="gd">-    2005-03-23 23:47:11,663 - spam_application - INFO -</span>
<span class="gd">-       creating an instance of auxiliary_module.Auxiliary</span>
<span class="gd">-    2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -</span>
<span class="gd">-       creating an instance of Auxiliary</span>
<span class="gd">-    2005-03-23 23:47:11,665 - spam_application - INFO -</span>
<span class="gd">-       created an instance of auxiliary_module.Auxiliary</span>
<span class="gd">-    2005-03-23 23:47:11,668 - spam_application - INFO -</span>
<span class="gd">-       calling auxiliary_module.Auxiliary.do_something</span>
<span class="gd">-    2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -</span>
<span class="gd">-       doing something</span>
<span class="gd">-    2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -</span>
<span class="gd">-       done doing something</span>
<span class="gd">-    2005-03-23 23:47:11,670 - spam_application - INFO -</span>
<span class="gd">-       finished auxiliary_module.Auxiliary.do_something</span>
<span class="gd">-    2005-03-23 23:47:11,671 - spam_application - INFO -</span>
<span class="gd">-       calling auxiliary_module.some_function()</span>
<span class="gd">-    2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -</span>
<span class="gd">-       received a call to &quot;some_function&quot;</span>
<span class="gd">-    2005-03-23 23:47:11,673 - spam_application - INFO -</span>
<span class="gd">-       done with auxiliary_module.some_function()</span>
<span class="gd">-</span>
</pre></div>

</body>
</html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/re.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -224,7 +224,7 @@</span>
    undefined.
 
 ``(?:...)``
<span class="gd">-   A non-grouping version of regular parentheses. Matches whatever regular</span>
<span class="gi">+   A non-capturing version of regular parentheses.  Matches whatever regular</span>
    expression is inside the parentheses, but the substring matched by the group
    *cannot* be retrieved after performing a match or referenced later in the
    pattern.
<span class="gu">@@ -332,7 +332,8 @@</span>
 ``\d``
    When the :const:`UNICODE` flag is not specified, matches any decimal digit; this
    is equivalent to the set ``[0-9]``.  With :const:`UNICODE`, it will match
<span class="gd">-   whatever is classified as a digit in the Unicode character properties database.</span>
<span class="gi">+   whatever is classified as a decimal digit in the Unicode character properties</span>
<span class="gi">+   database.</span>
 
 ``\D``
    When the :const:`UNICODE` flag is not specified, matches any non-digit
<span class="gu">@@ -536,7 +537,7 @@</span>
       instead.
 
 
<span class="gd">-.. function:: split(pattern, string[, maxsplit=0])</span>
<span class="gi">+.. function:: split(pattern, string[, maxsplit=0, flags=0])</span>
 
    Split *string* by the occurrences of *pattern*.  If capturing parentheses are
    used in *pattern*, then the text of all groups in the pattern are also returned
<span class="gu">@@ -551,6 +552,8 @@</span>
       [&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]
       &gt;&gt;&gt; re.split(&#39;\W+&#39;, &#39;Words, words, words.&#39;, 1)
       [&#39;Words&#39;, &#39;words, words.&#39;]
<span class="gi">+      &gt;&gt;&gt; re.split(&#39;[a-f]+&#39;, &#39;0a3B9&#39;, flags=re.IGNORECASE)</span>
<span class="gi">+      [&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
 
    If there are capturing groups in the separator and it matches at the start of
    the string, the result will start with an empty string.  The same holds for
<span class="gu">@@ -571,6 +574,9 @@</span>
       &gt;&gt;&gt; re.split(&quot;(?m)^$&quot;, &quot;foo\n\nbar\n&quot;)
       [&#39;foo\n\nbar\n&#39;]
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      Added the optional flags argument.</span>
<span class="gi">+</span>
 
 .. function:: findall(pattern, string[, flags])
 
<span class="gu">@@ -601,7 +607,7 @@</span>
       Added the optional flags argument.
 
 
<span class="gd">-.. function:: sub(pattern, repl, string[, count])</span>
<span class="gi">+.. function:: sub(pattern, repl, string[, count, flags])</span>
 
    Return the string obtained by replacing the leftmost non-overlapping occurrences
    of *pattern* in *string* by the replacement *repl*.  If the pattern isn&#39;t found,
<span class="gu">@@ -626,10 +632,10 @@</span>
       ...     else: return &#39;-&#39;
       &gt;&gt;&gt; re.sub(&#39;-{1,2}&#39;, dashrepl, &#39;pro----gram-files&#39;)
       &#39;pro--gram files&#39;
<span class="gi">+      &gt;&gt;&gt; re.sub(r&#39;\sAND\s&#39;, &#39; &amp; &#39;, &#39;Baked Beans And Spam&#39;, flags=re.IGNORECASE)</span>
<span class="gi">+      &#39;Baked Beans &amp; Spam&#39;</span>
 
<span class="gd">-   The pattern may be a string or an RE object; if you need to specify regular</span>
<span class="gd">-   expression flags, you must use a RE object, or use embedded modifiers in a</span>
<span class="gd">-   pattern; for example, ``sub(&quot;(?i)b+&quot;, &quot;x&quot;, &quot;bbbb BBBB&quot;)`` returns ``&#39;x x&#39;``.</span>
<span class="gi">+   The pattern may be a string or an RE object.</span>
 
    The optional argument *count* is the maximum number of pattern occurrences to be
    replaced; *count* must be a non-negative integer.  If omitted or zero, all
<span class="gu">@@ -646,12 +652,18 @@</span>
    character ``&#39;0&#39;``.  The backreference ``\g&lt;0&gt;`` substitutes in the entire
    substring matched by the RE.
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      Added the optional flags argument.</span>
 
<span class="gd">-.. function:: subn(pattern, repl, string[, count])</span>
<span class="gi">+</span>
<span class="gi">+.. function:: subn(pattern, repl, string[, count, flags])</span>
 
    Perform the same operation as :func:`sub`, but return a tuple ``(new_string,
    number_of_subs_made)``.
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      Added the optional flags argument.</span>
<span class="gi">+</span>
 
 .. function:: escape(string)
 
</pre></div>

</body>
</html>
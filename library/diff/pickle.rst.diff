--- r262/library/pickle.rst	2009-04-06 06:26:31.956399000 +0900
+++ r266/library/pickle.rst	2009-04-29 03:23:28.138007000 +0900
@@ -68,26 +68,26 @@
   when the object was stored.
 
 * The :mod:`marshal` serialization format is not guaranteed to be portable
   across Python versions.  Because its primary job in life is to support
   :file:`.pyc` files, the Python implementers reserve the right to change the
   serialization format in non-backwards compatible ways should the need arise.
   The :mod:`pickle` serialization format is guaranteed to be backwards compatible
   across Python releases.
 
 .. warning::
 
    The :mod:`pickle` module is not intended to be secure against erroneous or
-   maliciously constructed data.  Never unpickle data received from an untrusted or
-   unauthenticated source.
+   maliciously constructed data.  Never unpickle data received from an untrusted
+   or unauthenticated source.
 
 Note that serialization is a more primitive notion than persistence; although
 :mod:`pickle` reads and writes file objects, it does not handle the issue of
 naming persistent objects, nor the (even more complicated) issue of concurrent
 access to persistent objects.  The :mod:`pickle` module can transform a complex
 object into a byte stream and it can transform the byte stream into an object
 with the same internal structure.  Perhaps the most obvious thing to do with
 these byte streams is to write them onto a file, but it is also conceivable to
 send them across a network or store them in a database.  The module
 :mod:`shelve` provides a simple interface to pickle and unpickle objects on
 DBM-style database files.
 
@@ -444,25 +444,25 @@
    instance's dictionary.  If there is no :meth:`__getstate__` method, the
    instance's :attr:`__dict__` is pickled.
 
 .. method:: object.__setstate__()
 
    Upon unpickling, if the class also defines the method :meth:`__setstate__`,
    it is called with the unpickled state. [#]_ If there is no
    :meth:`__setstate__` method, the pickled state must be a dictionary and its
    items are assigned to the new instance's dictionary.  If a class defines both
    :meth:`__getstate__` and :meth:`__setstate__`, the state object needn't be a
    dictionary and these methods can do what they want. [#]_
 
-   .. warning::
+   .. note::
 
       For :term:`new-style class`\es, if :meth:`__getstate__` returns a false
       value, the :meth:`__setstate__` method will not be called.
 
 .. note::
 
    At unpickling time, some methods like :meth:`__getattr__`,
    :meth:`__getattribute__`, or :meth:`__setattr__` may be called upon the
    instance.  In case those methods rely on some internal invariant being
    true, the type should implement either :meth:`__getinitargs__` or
    :meth:`__getnewargs__` to establish such an invariant; otherwise, neither
    :meth:`__new__` nor :meth:`__init__` will be called.

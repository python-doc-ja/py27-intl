--- r262/library/email.parser.rst	2008-11-07 17:56:27.337630000 +0900
+++ r266/library/email.parser.rst	2009-04-29 03:16:02.904819000 +0900
@@ -1,47 +1,47 @@
 :mod:`email`: Parsing email messages
 ------------------------------------
 
 .. module:: email.parser
    :synopsis: Parse flat text email messages to produce a message object structure.
 
 
 Message object structures can be created in one of two ways: they can be created
-from whole cloth by instantiating :class:`Message` objects and stringing them
-together via :meth:`attach` and :meth:`set_payload` calls, or they can be
-created by parsing a flat text representation of the email message.
+from whole cloth by instantiating :class:`~email.message.Message` objects and
+stringing them together via :meth:`attach` and :meth:`set_payload` calls, or they
+can be created by parsing a flat text representation of the email message.
 
 The :mod:`email` package provides a standard parser that understands most email
 document structures, including MIME documents.  You can pass the parser a string
-or a file object, and the parser will return to you the root :class:`Message`
-instance of the object structure.  For simple, non-MIME messages the payload of
-this root object will likely be a string containing the text of the message.
-For MIME messages, the root object will return ``True`` from its
-:meth:`is_multipart` method, and the subparts can be accessed via the
-:meth:`get_payload` and :meth:`walk` methods.
+or a file object, and the parser will return to you the root
+:class:`~email.message.Message` instance of the object structure.  For simple,
+non-MIME messages the payload of this root object will likely be a string
+containing the text of the message.  For MIME messages, the root object will
+return ``True`` from its :meth:`is_multipart` method, and the subparts can be
+accessed via the :meth:`get_payload` and :meth:`walk` methods.
 
 There are actually two parser interfaces available for use, the classic
 :class:`Parser` API and the incremental :class:`FeedParser` API.  The classic
 :class:`Parser` API is fine if you have the entire text of the message in memory
 as a string, or if the entire message lives in a file on the file system.
 :class:`FeedParser` is more appropriate for when you're reading the message from
 a stream which might block waiting for more input (e.g. reading an email message
 from a socket).  The :class:`FeedParser` can consume and parse the message
 incrementally, and only returns the root object when you close the parser [#]_.
 
 Note that the parser can be extended in limited ways, and of course you can
 implement your own parser completely from scratch.  There is no magical
 connection between the :mod:`email` package's bundled parser and the
-:class:`Message` class, so your custom parser can create message object trees
-any way it finds necessary.
+:class:`~email.message.Message` class, so your custom parser can create message
+object trees any way it finds necessary.
 
 
 FeedParser API
 ^^^^^^^^^^^^^^
 
 .. versionadded:: 2.4
 
 The :class:`FeedParser`, imported from the :mod:`email.feedparser` module,
 provides an API that is conducive to incremental parsing of email messages, such
 as would be necessary when reading the text of an email message from a source
 that can block (e.g. a socket).  The :class:`FeedParser` can of course be used
 to parse an email message fully contained in a string or a file, but the classic
@@ -94,26 +94,26 @@
 used if you're only interested in the headers of the message.
 :class:`HeaderParser` can be much faster in these situations, since it does not
 attempt to parse the message body, instead setting the payload to the raw body
 as a string. :class:`HeaderParser` has the same API as the :class:`Parser`
 class.
 
 
 .. class:: Parser([_class])
 
    The constructor for the :class:`Parser` class takes an optional argument
    *_class*.  This must be a callable factory (such as a function or a class), and
    it is used whenever a sub-message object needs to be created.  It defaults to
-   :class:`Message` (see :mod:`email.message`).  The factory will be called without
-   arguments.
+   :class:`~email.message.Message` (see :mod:`email.message`).  The factory will
+   be called without arguments.
 
    The optional *strict* flag is ignored.
 
    .. deprecated:: 2.4
       Because the :class:`Parser` class is a backward compatible API wrapper
       around the new-in-Python 2.4 :class:`FeedParser`, *all* parsing is
       effectively non-strict.  You should simply stop passing a *strict* flag to
       the :class:`Parser` constructor.
 
    .. versionchanged:: 2.2.2
       The *strict* flag was added.
 
@@ -190,25 +190,26 @@
 ^^^^^^^^^^^^^^^^
 
 Here are some notes on the parsing semantics:
 
 * Most non-\ :mimetype:`multipart` type messages are parsed as a single message
   object with a string payload.  These objects will return ``False`` for
   :meth:`is_multipart`.  Their :meth:`get_payload` method will return a string
   object.
 
 * All :mimetype:`multipart` type messages will be parsed as a container message
   object with a list of sub-message objects for their payload.  The outer
   container message will return ``True`` for :meth:`is_multipart` and their
-  :meth:`get_payload` method will return the list of :class:`Message` subparts.
+  :meth:`get_payload` method will return the list of :class:`~email.message.Message`
+  subparts.
 
 * Most messages with a content type of :mimetype:`message/\*` (e.g.
   :mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will also be
   parsed as container object containing a list payload of length 1.  Their
   :meth:`is_multipart` method will return ``True``.  The single element in the
   list payload will be a sub-message object.
 
 * Some non-standards compliant messages may not be internally consistent about
   their :mimetype:`multipart`\ -edness.  Such messages may have a
   :mailheader:`Content-Type` header of type :mimetype:`multipart`, but their
   :meth:`is_multipart` method may return ``False``.  If such messages were parsed
   with the :class:`FeedParser`, they will have an instance of the

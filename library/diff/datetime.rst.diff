--- r262/library/datetime.rst	2009-04-02 13:52:48.345841000 +0900
+++ r266/library/datetime.rst	2010-08-02 07:19:17.150851000 +0900
@@ -29,73 +29,75 @@
 For applications requiring more, :class:`datetime` and :class:`time` objects
 have an optional time zone information member, :attr:`tzinfo`, that can contain
 an instance of a subclass of the abstract :class:`tzinfo` class.  These
 :class:`tzinfo` objects capture information about the offset from UTC time, the
 time zone name, and whether Daylight Saving Time is in effect.  Note that no
 concrete :class:`tzinfo` classes are supplied by the :mod:`datetime` module.
 Supporting timezones at whatever level of detail is required is up to the
 application.  The rules for time adjustment across the world are more political
 than rational, and there is no standard suitable for every application.
 
 The :mod:`datetime` module exports the following constants:
 
-
 .. data:: MINYEAR
 
    The smallest year number allowed in a :class:`date` or :class:`datetime` object.
    :const:`MINYEAR` is ``1``.
 
 
 .. data:: MAXYEAR
 
    The largest year number allowed in a :class:`date` or :class:`datetime` object.
    :const:`MAXYEAR` is ``9999``.
 
 
 .. seealso::
 
    Module :mod:`calendar`
       General calendar related functions.
 
    Module :mod:`time`
       Time access and conversions.
 
 
 Available Types
 ---------------
 
-
 .. class:: date
+   :noindex:
 
    An idealized naive date, assuming the current Gregorian calendar always was, and
    always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and
    :attr:`day`.
 
 
 .. class:: time
+   :noindex:
 
    An idealized time, independent of any particular day, assuming that every day
    has exactly 24\*60\*60 seconds (there is no notion of "leap seconds" here).
    Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:`microsecond`,
    and :attr:`tzinfo`.
 
 
 .. class:: datetime
+   :noindex:
 
    A combination of a date and a time. Attributes: :attr:`year`, :attr:`month`,
    :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:`microsecond`,
    and :attr:`tzinfo`.
 
 
 .. class:: timedelta
+   :noindex:
 
    A duration expressing the difference between two :class:`date`, :class:`time`,
    or :class:`datetime` instances to microsecond resolution.
 
 
 .. class:: tzinfo
 
    An abstract base class for time zone information objects.  These are used by the
    :class:`datetime` and :class:`time` classes to provide a customizable notion of
    time adjustment (for example, to account for time zone and/or daylight saving
    time).
 
@@ -120,25 +122,24 @@
        date
            datetime
 
 
 .. _datetime-timedelta:
 
 :class:`timedelta` Objects
 --------------------------
 
 A :class:`timedelta` object represents a duration, the difference between two
 dates or times.
 
-
 .. class:: timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])
 
    All arguments are optional and default to ``0``.  Arguments may be ints, longs,
    or floats, and may be positive or negative.
 
    Only *days*, *seconds* and *microseconds* are stored internally.  Arguments are
    converted to those units:
 
    * A millisecond is converted to 1000 microseconds.
    * A minute is converted to 60 seconds.
    * An hour is converted to 3600 seconds.
    * A week is converted to 7 days.
@@ -157,26 +158,26 @@
 
    If the normalized value of days lies outside the indicated range,
    :exc:`OverflowError` is raised.
 
    Note that normalization of negative values may be surprising at first. For
    example,
 
       >>> from datetime import timedelta
       >>> d = timedelta(microseconds=-1)
       >>> (d.days, d.seconds, d.microseconds)
       (-1, 86399, 999999)
 
-Class attributes are:
 
+Class attributes are:
 
 .. attribute:: timedelta.min
 
    The most negative :class:`timedelta` object, ``timedelta(-999999999)``.
 
 
 .. attribute:: timedelta.max
 
    The most positive :class:`timedelta` object, ``timedelta(days=999999999,
    hours=23, minutes=59, seconds=59, microseconds=999999)``.
 
 
@@ -222,42 +223,60 @@
 |                                | is true. (1)                                  |
 +--------------------------------+-----------------------------------------------+
 | ``t1 = t2 // i``               | The floor is computed and the remainder (if   |
 |                                | any) is thrown away. (3)                      |
 +--------------------------------+-----------------------------------------------+
 | ``+t1``                        | Returns a :class:`timedelta` object with the  |
 |                                | same value. (2)                               |
 +--------------------------------+-----------------------------------------------+
 | ``-t1``                        | equivalent to :class:`timedelta`\             |
 |                                | (-*t1.days*, -*t1.seconds*,                   |
 |                                | -*t1.microseconds*), and to *t1*\* -1. (1)(4) |
 +--------------------------------+-----------------------------------------------+
-| ``abs(t)``                     | equivalent to +*t* when ``t.days >= 0``, and  |
+| ``abs(t)``                     | equivalent to +\ *t* when ``t.days >= 0``, and|
 |                                | to -*t* when ``t.days < 0``. (2)              |
 +--------------------------------+-----------------------------------------------+
+| ``str(t)``                     | Returns a string in the form                  |
+|                                | ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D  |
+|                                | is negative for negative ``t``. (5)           |
++--------------------------------+-----------------------------------------------+
+| ``repr(t)``                    | Returns a string in the form                  |
+|                                | ``datetime.timedelta(D[, S[, U]])``, where D  |
+|                                | is negative for negative ``t``. (5)           |
++--------------------------------+-----------------------------------------------+
 
 Notes:
 
 (1)
    This is exact, but may overflow.
 
 (2)
    This is exact, and cannot overflow.
 
 (3)
    Division by 0 raises :exc:`ZeroDivisionError`.
 
 (4)
    -*timedelta.max* is not representable as a :class:`timedelta` object.
 
+(5)
+  String representations of :class:`timedelta` objects are normalized
+  similarly to their internal representation.  This leads to somewhat
+  unusual results for negative timedeltas.  For example:
+
+  >>> timedelta(hours=-5)
+  datetime.timedelta(-1, 68400)
+  >>> print(_)
+  -1 day, 19:00:00
+
 In addition to the operations listed above :class:`timedelta` objects support
 certain additions and subtractions with :class:`date` and :class:`datetime`
 objects (see below).
 
 Comparisons of :class:`timedelta` objects are supported with the
 :class:`timedelta` object representing the smaller duration considered to be the
 smaller timedelta. In order to stop mixed-type comparisons from falling back to
 the default comparison by object address, when a :class:`timedelta` object is
 compared to an object of a different type, :exc:`TypeError` is raised unless the
 comparison is ``==`` or ``!=``.  The latter cases return :const:`False` or
 :const:`True`, respectively.
 
@@ -303,85 +322,86 @@
 
 .. class:: date(year, month, day)
 
    All arguments are required.  Arguments may be ints or longs, in the following
    ranges:
 
    * ``MINYEAR <= year <= MAXYEAR``
    * ``1 <= month <= 12``
    * ``1 <= day <= number of days in the given month and year``
 
    If an argument outside those ranges is given, :exc:`ValueError` is raised.
 
-Other constructors, all class methods:
 
+Other constructors, all class methods:
 
-.. method:: date.today()
+.. classmethod:: date.today()
 
    Return the current local date.  This is equivalent to
    ``date.fromtimestamp(time.time())``.
 
 
-.. method:: date.fromtimestamp(timestamp)
+.. classmethod:: date.fromtimestamp(timestamp)
 
    Return the local date corresponding to the POSIX timestamp, such as is returned
    by :func:`time.time`.  This may raise :exc:`ValueError`, if the timestamp is out
    of the range of values supported by the platform C :cfunc:`localtime` function.
    It's common for this to be restricted to years from 1970 through 2038.  Note
    that on non-POSIX systems that include leap seconds in their notion of a
    timestamp, leap seconds are ignored by :meth:`fromtimestamp`.
 
 
-.. method:: date.fromordinal(ordinal)
+.. classmethod:: date.fromordinal(ordinal)
 
    Return the date corresponding to the proleptic Gregorian ordinal, where January
    1 of year 1 has ordinal 1.  :exc:`ValueError` is raised unless ``1 <= ordinal <=
    date.max.toordinal()``. For any date *d*, ``date.fromordinal(d.toordinal()) ==
    d``.
 
-Class attributes:
 
+Class attributes:
 
 .. attribute:: date.min
 
    The earliest representable date, ``date(MINYEAR, 1, 1)``.
 
 
 .. attribute:: date.max
 
    The latest representable date, ``date(MAXYEAR, 12, 31)``.
 
 
 .. attribute:: date.resolution
 
    The smallest possible difference between non-equal date objects,
    ``timedelta(days=1)``.
 
-Instance attributes (read-only):
 
+Instance attributes (read-only):
 
 .. attribute:: date.year
 
    Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive.
 
 
 .. attribute:: date.month
 
    Between 1 and 12 inclusive.
 
 
 .. attribute:: date.day
 
    Between 1 and the number of days in the given month of the given year.
 
+
 Supported operations:
 
 +-------------------------------+----------------------------------------------+
 | Operation                     | Result                                       |
 +===============================+==============================================+
 | ``date2 = date1 + timedelta`` | *date2* is ``timedelta.days`` days removed   |
 |                               | from *date1*.  (1)                           |
 +-------------------------------+----------------------------------------------+
 | ``date2 = date1 - timedelta`` | Computes *date2* such that ``date2 +         |
 |                               | timedelta == date1``. (2)                    |
 +-------------------------------+----------------------------------------------+
 | ``timedelta = date1 - date2`` | \(3)                                         |
@@ -416,25 +436,24 @@
    However, ``NotImplemented`` is returned instead if the other comparand has a
    :meth:`timetuple` attribute.  This hook gives other kinds of date objects a
    chance at implementing mixed-type comparison. If not, when a :class:`date`
    object is compared to an object of a different type, :exc:`TypeError` is raised
    unless the comparison is ``==`` or ``!=``.  The latter cases return
    :const:`False` or :const:`True`, respectively.
 
 Dates can be used as dictionary keys. In Boolean contexts, all :class:`date`
 objects are considered to be true.
 
 Instance methods:
 
-
 .. method:: date.replace(year, month, day)
 
    Return a date with the same value, except for those members given new values by
    whichever keyword arguments are specified.  For example, if ``d == date(2002,
    12, 31)``, then ``d.replace(day=26) == date(2002, 12, 26)``.
 
 
 .. method:: date.timetuple()
 
    Return a :class:`time.struct_time` such as returned by :func:`time.localtime`.
    The hours, minutes and seconds are 0, and the DST flag is -1. ``d.timetuple()``
    is equivalent to ``time.struct_time((d.year, d.month, d.day, 0, 0, 0,
@@ -458,25 +477,26 @@
 .. method:: date.isoweekday()
 
    Return the day of the week as an integer, where Monday is 1 and Sunday is 7.
    For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also
    :meth:`weekday`, :meth:`isocalendar`.
 
 
 .. method:: date.isocalendar()
 
    Return a 3-tuple, (ISO year, ISO week number, ISO weekday).
 
    The ISO calendar is a widely used variant of the Gregorian calendar. See
-   http://www.phys.uu.nl/ vgent/calendar/isocalendar.htm for a good explanation.
+   http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm for a good
+   explanation.
 
    The ISO year consists of 52 or 53 full weeks, and where a week starts on a
    Monday and ends on a Sunday.  The first week of an ISO year is the first
    (Gregorian) calendar week of a year containing a Thursday. This is called week
    number 1, and the ISO year of that Thursday is the same as its Gregorian year.
 
    For example, 2004 begins on a Thursday, so the first week of ISO year 2004
    begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004, so that
    ``date(2003, 12, 29).isocalendar() == (2004, 1, 1)`` and ``date(2004, 1,
    4).isocalendar() == (2004, 1, 7)``.
 
 
@@ -495,25 +515,26 @@
 
    Return a string representing the date, for example ``date(2002, 12,
    4).ctime() == 'Wed Dec 4 00:00:00 2002'``. ``d.ctime()`` is equivalent to
    ``time.ctime(time.mktime(d.timetuple()))`` on platforms where the native C
    :cfunc:`ctime` function (which :func:`time.ctime` invokes, but which
    :meth:`date.ctime` does not invoke) conforms to the C standard.
 
 
 .. method:: date.strftime(format)
 
    Return a string representing the date, controlled by an explicit format string.
    Format codes referring to hours, minutes or seconds will see 0 values. See
-   section :ref:`strftime-behavior`.
+   section :ref:`strftime-strptime-behavior`.
+
 
 Example of counting days to an event::
 
     >>> import time
     >>> from datetime import date
     >>> today = date.today()
     >>> today
     datetime.date(2007, 12, 5)
     >>> today == date.fromtimestamp(time.time())
     True
     >>> my_birthday = date(today.year, 6, 24)
     >>> if my_birthday < today:
@@ -562,151 +583,149 @@
 
 :class:`datetime` Objects
 -------------------------
 
 A :class:`datetime` object is a single object containing all the information
 from a :class:`date` object and a :class:`time` object.  Like a :class:`date`
 object, :class:`datetime` assumes the current Gregorian calendar extended in
 both directions; like a time object, :class:`datetime` assumes there are exactly
 3600\*24 seconds in every day.
 
 Constructor:
 
-
 .. class:: datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])
 
    The year, month and day arguments are required.  *tzinfo* may be ``None``, or an
    instance of a :class:`tzinfo` subclass.  The remaining arguments may be ints or
    longs, in the following ranges:
 
    * ``MINYEAR <= year <= MAXYEAR``
    * ``1 <= month <= 12``
    * ``1 <= day <= number of days in the given month and year``
    * ``0 <= hour < 24``
    * ``0 <= minute < 60``
    * ``0 <= second < 60``
    * ``0 <= microsecond < 1000000``
 
    If an argument outside those ranges is given, :exc:`ValueError` is raised.
 
 Other constructors, all class methods:
 
-
-.. method:: datetime.today()
+.. classmethod:: datetime.today()
 
    Return the current local datetime, with :attr:`tzinfo` ``None``. This is
    equivalent to ``datetime.fromtimestamp(time.time())``. See also :meth:`now`,
    :meth:`fromtimestamp`.
 
 
-.. method:: datetime.now([tz])
+.. classmethod:: datetime.now([tz])
 
    Return the current local date and time.  If optional argument *tz* is ``None``
    or not specified, this is like :meth:`today`, but, if possible, supplies more
    precision than can be gotten from going through a :func:`time.time` timestamp
    (for example, this may be possible on platforms supplying the C
    :cfunc:`gettimeofday` function).
 
    Else *tz* must be an instance of a class :class:`tzinfo` subclass, and the
    current date and time are converted to *tz*'s time zone.  In this case the
    result is equivalent to ``tz.fromutc(datetime.utcnow().replace(tzinfo=tz))``.
    See also :meth:`today`, :meth:`utcnow`.
 
 
-.. method:: datetime.utcnow()
+.. classmethod:: datetime.utcnow()
 
    Return the current UTC date and time, with :attr:`tzinfo` ``None``. This is like
    :meth:`now`, but returns the current UTC date and time, as a naive
    :class:`datetime` object. See also :meth:`now`.
 
 
-.. method:: datetime.fromtimestamp(timestamp[, tz])
+.. classmethod:: datetime.fromtimestamp(timestamp[, tz])
 
    Return the local date and time corresponding to the POSIX timestamp, such as is
    returned by :func:`time.time`. If optional argument *tz* is ``None`` or not
    specified, the timestamp is converted to the platform's local date and time, and
    the returned :class:`datetime` object is naive.
 
    Else *tz* must be an instance of a class :class:`tzinfo` subclass, and the
    timestamp is converted to *tz*'s time zone.  In this case the result is
    equivalent to
    ``tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz))``.
 
    :meth:`fromtimestamp` may raise :exc:`ValueError`, if the timestamp is out of
    the range of values supported by the platform C :cfunc:`localtime` or
    :cfunc:`gmtime` functions.  It's common for this to be restricted to years in
    1970 through 2038. Note that on non-POSIX systems that include leap seconds in
    their notion of a timestamp, leap seconds are ignored by :meth:`fromtimestamp`,
    and then it's possible to have two timestamps differing by a second that yield
    identical :class:`datetime` objects. See also :meth:`utcfromtimestamp`.
 
 
-.. method:: datetime.utcfromtimestamp(timestamp)
+.. classmethod:: datetime.utcfromtimestamp(timestamp)
 
    Return the UTC :class:`datetime` corresponding to the POSIX timestamp, with
    :attr:`tzinfo` ``None``. This may raise :exc:`ValueError`, if the timestamp is
    out of the range of values supported by the platform C :cfunc:`gmtime` function.
    It's common for this to be restricted to years in 1970 through 2038. See also
    :meth:`fromtimestamp`.
 
 
-.. method:: datetime.fromordinal(ordinal)
+.. classmethod:: datetime.fromordinal(ordinal)
 
    Return the :class:`datetime` corresponding to the proleptic Gregorian ordinal,
    where January 1 of year 1 has ordinal 1. :exc:`ValueError` is raised unless ``1
    <= ordinal <= datetime.max.toordinal()``.  The hour, minute, second and
    microsecond of the result are all 0, and :attr:`tzinfo` is ``None``.
 
 
-.. method:: datetime.combine(date, time)
+.. classmethod:: datetime.combine(date, time)
 
    Return a new :class:`datetime` object whose date members are equal to the given
    :class:`date` object's, and whose time and :attr:`tzinfo` members are equal to
    the given :class:`time` object's. For any :class:`datetime` object *d*, ``d ==
    datetime.combine(d.date(), d.timetz())``.  If date is a :class:`datetime`
    object, its time and :attr:`tzinfo` members are ignored.
 
 
-.. method:: datetime.strptime(date_string, format)
+.. classmethod:: datetime.strptime(date_string, format)
 
    Return a :class:`datetime` corresponding to *date_string*, parsed according to
    *format*.  This is equivalent to ``datetime(*(time.strptime(date_string,
    format)[0:6]))``. :exc:`ValueError` is raised if the date_string and format
    can't be parsed by :func:`time.strptime` or if it returns a value which isn't a
-   time tuple.
+   time tuple. See section :ref:`strftime-strptime-behavior`.
 
    .. versionadded:: 2.5
 
-Class attributes:
 
+Class attributes:
 
 .. attribute:: datetime.min
 
    The earliest representable :class:`datetime`, ``datetime(MINYEAR, 1, 1,
    tzinfo=None)``.
 
 
 .. attribute:: datetime.max
 
    The latest representable :class:`datetime`, ``datetime(MAXYEAR, 12, 31, 23, 59,
    59, 999999, tzinfo=None)``.
 
 
 .. attribute:: datetime.resolution
 
    The smallest possible difference between non-equal :class:`datetime` objects,
    ``timedelta(microseconds=1)``.
 
-Instance attributes (read-only):
 
+Instance attributes (read-only):
 
 .. attribute:: datetime.year
 
    Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive.
 
 
 .. attribute:: datetime.month
 
    Between 1 and 12 inclusive.
 
 
 .. attribute:: datetime.day
@@ -730,24 +749,25 @@
 
 
 .. attribute:: datetime.microsecond
 
    In ``range(1000000)``.
 
 
 .. attribute:: datetime.tzinfo
 
    The object passed as the *tzinfo* argument to the :class:`datetime` constructor,
    or ``None`` if none was passed.
 
+
 Supported operations:
 
 +---------------------------------------+-------------------------------+
 | Operation                             | Result                        |
 +=======================================+===============================+
 | ``datetime2 = datetime1 + timedelta`` | \(1)                          |
 +---------------------------------------+-------------------------------+
 | ``datetime2 = datetime1 - timedelta`` | \(2)                          |
 +---------------------------------------+-------------------------------+
 | ``timedelta = datetime1 - datetime2`` | \(3)                          |
 +---------------------------------------+-------------------------------+
 | ``datetime1 < datetime2``             | Compares :class:`datetime` to |
@@ -803,25 +823,24 @@
       ``NotImplemented`` is returned instead if the other comparand has a
       :meth:`timetuple` attribute.  This hook gives other kinds of date objects a
       chance at implementing mixed-type comparison.  If not, when a :class:`datetime`
       object is compared to an object of a different type, :exc:`TypeError` is raised
       unless the comparison is ``==`` or ``!=``.  The latter cases return
       :const:`False` or :const:`True`, respectively.
 
 :class:`datetime` objects can be used as dictionary keys. In Boolean contexts,
 all :class:`datetime` objects are considered to be true.
 
 Instance methods:
 
-
 .. method:: datetime.date()
 
    Return :class:`date` object with same year, month and day.
 
 
 .. method:: datetime.time()
 
    Return :class:`time` object with same hour, minute, second and microsecond.
    :attr:`tzinfo` is ``None``.  See also method :meth:`timetz`.
 
 
 .. method:: datetime.timetz()
@@ -981,25 +1000,26 @@
 .. method:: datetime.ctime()
 
    Return a string representing the date and time, for example ``datetime(2002, 12,
    4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40 2002'``. ``d.ctime()`` is
    equivalent to ``time.ctime(time.mktime(d.timetuple()))`` on platforms where the
    native C :cfunc:`ctime` function (which :func:`time.ctime` invokes, but which
    :meth:`datetime.ctime` does not invoke) conforms to the C standard.
 
 
 .. method:: datetime.strftime(format)
 
    Return a string representing the date and time, controlled by an explicit format
-   string.  See section :ref:`strftime-behavior`.
+   string.  See section :ref:`strftime-strptime-behavior`.
+
 
 Examples of working with datetime objects:
 
 .. doctest::
 
     >>> from datetime import datetime, date, time
     >>> # Using datetime.combine()
     >>> d = date(2005, 7, 14)
     >>> t = time(12, 30)
     >>> datetime.combine(d, t)
     datetime.datetime(2005, 7, 14, 12, 30)
     >>> # Using datetime.now() or datetime.utcnow()
@@ -1094,25 +1114,24 @@
     True
 
 
 
 .. _datetime-time:
 
 :class:`time` Objects
 ---------------------
 
 A time object represents a (local) time of day, independent of any particular
 day, and subject to adjustment via a :class:`tzinfo` object.
 
-
 .. class:: time(hour[, minute[, second[, microsecond[, tzinfo]]]])
 
    All arguments are optional.  *tzinfo* may be ``None``, or an instance of a
    :class:`tzinfo` subclass.  The remaining arguments may be ints or longs, in the
    following ranges:
 
    * ``0 <= hour < 24``
    * ``0 <= minute < 60``
    * ``0 <= second < 60``
    * ``0 <= microsecond < 1000000``.
 
    If an argument outside those ranges is given, :exc:`ValueError` is raised.  All
@@ -1128,26 +1147,26 @@
 
 .. attribute:: time.max
 
    The latest representable :class:`time`, ``time(23, 59, 59, 999999)``.
 
 
 .. attribute:: time.resolution
 
    The smallest possible difference between non-equal :class:`time` objects,
    ``timedelta(microseconds=1)``, although note that arithmetic on :class:`time`
    objects is not supported.
 
-Instance attributes (read-only):
 
+Instance attributes (read-only):
 
 .. attribute:: time.hour
 
    In ``range(24)``.
 
 
 .. attribute:: time.minute
 
    In ``range(60)``.
 
 
 .. attribute:: time.second
@@ -1156,48 +1175,49 @@
 
 
 .. attribute:: time.microsecond
 
    In ``range(1000000)``.
 
 
 .. attribute:: time.tzinfo
 
    The object passed as the tzinfo argument to the :class:`time` constructor, or
    ``None`` if none was passed.
 
+
 Supported operations:
 
 * comparison of :class:`time` to :class:`time`, where *a* is considered less
   than *b* when *a* precedes *b* in time.  If one comparand is naive and the other
   is aware, :exc:`TypeError` is raised.  If both comparands are aware, and have
   the same :attr:`tzinfo` member, the common :attr:`tzinfo` member is ignored and
   the base times are compared.  If both comparands are aware and have different
   :attr:`tzinfo` members, the comparands are first adjusted by subtracting their
   UTC offsets (obtained from ``self.utcoffset()``). In order to stop mixed-type
   comparisons from falling back to the default comparison by object address, when
   a :class:`time` object is compared to an object of a different type,
   :exc:`TypeError` is raised unless the comparison is ``==`` or ``!=``.  The
   latter cases return :const:`False` or :const:`True`, respectively.
 
 * hash, use as dict key
 
 * efficient pickling
 
 * in Boolean contexts, a :class:`time` object is considered to be true if and
   only if, after converting it to minutes and subtracting :meth:`utcoffset` (or
   ``0`` if that's ``None``), the result is non-zero.
 
-Instance methods:
 
+Instance methods:
 
 .. method:: time.replace([hour[, minute[, second[, microsecond[, tzinfo]]]]])
 
    Return a :class:`time` with the same value, except for those members given new
    values by whichever keyword arguments are specified.  Note that ``tzinfo=None``
    can be specified to create a naive :class:`time` from an aware :class:`time`,
    without conversion of the time members.
 
 
 .. method:: time.isoformat()
 
    Return a string representing the time in ISO 8601 format, HH:MM:SS.mmmmmm or, if
@@ -1205,49 +1225,50 @@
    6-character string is appended, giving the UTC offset in (signed) hours and
    minutes: HH:MM:SS.mmmmmm+HH:MM or, if self.microsecond is 0, HH:MM:SS+HH:MM
 
 
 .. method:: time.__str__()
 
    For a time *t*, ``str(t)`` is equivalent to ``t.isoformat()``.
 
 
 .. method:: time.strftime(format)
 
    Return a string representing the time, controlled by an explicit format string.
-   See section :ref:`strftime-behavior`.
+   See section :ref:`strftime-strptime-behavior`.
 
 
 .. method:: time.utcoffset()
 
    If :attr:`tzinfo` is ``None``, returns ``None``, else returns
    ``self.tzinfo.utcoffset(None)``, and raises an exception if the latter doesn't
    return ``None`` or a :class:`timedelta` object representing a whole number of
    minutes with magnitude less than one day.
 
 
 .. method:: time.dst()
 
    If :attr:`tzinfo` is ``None``, returns ``None``, else returns
    ``self.tzinfo.dst(None)``, and raises an exception if the latter doesn't return
    ``None``, or a :class:`timedelta` object representing a whole number of minutes
    with magnitude less than one day.
 
 
 .. method:: time.tzname()
 
    If :attr:`tzinfo` is ``None``, returns ``None``, else returns
    ``self.tzinfo.tzname(None)``, or raises an exception if the latter doesn't
    return ``None`` or a string object.
 
+
 Example:
 
     >>> from datetime import time, tzinfo
     >>> class GMT1(tzinfo):
     ...     def utcoffset(self, dt):
     ...         return timedelta(hours=1)
     ...     def dst(self, dt):
     ...         return timedelta(0)
     ...     def tzname(self,dt):
     ...         return "Europe/Prague"
     ...
     >>> t = time(12, 10, 30, tzinfo=GMT1())
@@ -1366,24 +1387,25 @@
    Return the time zone name corresponding to the :class:`datetime` object *dt*, as
    a string. Nothing about string names is defined by the :mod:`datetime` module,
    and there's no requirement that it mean anything in particular.  For example,
    "GMT", "UTC", "-500", "-5:00", "EDT", "US/Eastern", "America/New York" are all
    valid replies.  Return ``None`` if a string name isn't known.  Note that this is
    a method rather than a fixed string primarily because some :class:`tzinfo`
    subclasses will wish to return different names depending on the specific value
    of *dt* passed, especially if the :class:`tzinfo` class is accounting for
    daylight time.
 
    The default implementation of :meth:`tzname` raises :exc:`NotImplementedError`.
 
+
 These methods are called by a :class:`datetime` or :class:`time` object, in
 response to their methods of the same names.  A :class:`datetime` object passes
 itself as the argument, and a :class:`time` object passes ``None`` as the
 argument.  A :class:`tzinfo` subclass's methods should therefore be prepared to
 accept a *dt* argument of ``None``, or of class :class:`datetime`.
 
 When ``None`` is passed, it's up to the class designer to decide the best
 response.  For example, returning ``None`` is appropriate if the class wishes to
 say that time objects don't participate in the :class:`tzinfo` protocols.  It
 may be more useful for ``utcoffset(None)`` to return the standard UTC offset, as
 there is no other convention for discovering the standard offset.
 
@@ -1432,26 +1454,26 @@
               return dt + dtdst
           else:
               return dt
 
 Example :class:`tzinfo` classes:
 
 .. literalinclude:: ../includes/tzinfo-examples.py
 
 
 Note that there are unavoidable subtleties twice per year in a :class:`tzinfo`
 subclass accounting for both standard and daylight time, at the DST transition
 points.  For concreteness, consider US Eastern (UTC -0500), where EDT begins the
-minute after 1:59 (EST) on the first Sunday in April, and ends the minute after
-1:59 (EDT) on the last Sunday in October::
+minute after 1:59 (EST) on the second Sunday in March, and ends the minute after
+1:59 (EDT) on the first Sunday in November::
 
      UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM
      EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM
      EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM
 
    start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM
 
      end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM
 
 When DST starts (the "start" line), the local wall clock leaps from 1:59 to
 3:00.  A wall time of the form 2:MM doesn't really make sense on that day, so
 ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on the day DST
@@ -1469,38 +1491,43 @@
 form 5:MM and 6:MM both map to 1:MM when converted to Eastern.  In order for
 :meth:`astimezone` to make this guarantee, the :meth:`tzinfo.dst` method must
 consider times in the "repeated hour" to be in standard time.  This is easily
 arranged, as in the example, by expressing DST switch times in the time zone's
 standard local time.
 
 Applications that can't bear such ambiguities should avoid using hybrid
 :class:`tzinfo` subclasses; there are no ambiguities when using UTC, or any
 other fixed-offset :class:`tzinfo` subclass (such as a class representing only
 EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours)).
 
 
-.. _strftime-behavior:
+.. _strftime-strptime-behavior:
 
-:meth:`strftime` Behavior
--------------------------
+:meth:`strftime` and :meth:`strptime` Behavior
+----------------------------------------------
 
 :class:`date`, :class:`datetime`, and :class:`time` objects all support a
 ``strftime(format)`` method, to create a string representing the time under the
 control of an explicit format string.  Broadly speaking, ``d.strftime(fmt)``
 acts like the :mod:`time` module's ``time.strftime(fmt, d.timetuple())``
 although not all objects support a :meth:`timetuple` method.
 
+Conversely, the :meth:`datetime.strptime` class method creates a
+:class:`datetime` object from a string representing a date and time and a
+corresponding format string. ``datetime.strptime(date_string, format)`` is
+equivalent to ``datetime(*(time.strptime(date_string, format)[0:6]))``.
+
 For :class:`time` objects, the format codes for year, month, and day should not
 be used, as time objects have no such values.  If they're used anyway, ``1900``
-is substituted for the year, and ``0`` for the month and day.
+is substituted for the year, and ``1`` for the month and day.
 
 For :class:`date` objects, the format codes for hours, minutes, seconds, and
 microseconds should not be used, as :class:`date` objects have no such
 values.  If they're used anyway, ``0`` is substituted for them.
 
 .. versionadded:: 2.6
    :class:`time` and :class:`datetime` objects support a ``%f`` format code
    which expands to the number of microseconds in the object, zero-padded on
    the left to six places.
 
 For a naive object, the ``%z`` and ``%Z`` format codes are replaced by empty
 strings.
@@ -1609,37 +1636,37 @@
 |           | or -HHMM (empty string if the  |       |
 |           | the object is naive).          |       |
 +-----------+--------------------------------+-------+
 | ``%Z``    | Time zone name (empty string   |       |
 |           | if the object is naive).       |       |
 +-----------+--------------------------------+-------+
 | ``%%``    | A literal ``'%'`` character.   |       |
 +-----------+--------------------------------+-------+
 
 Notes:
 
 (1)
-   When used with the :func:`strptime` function, the ``%f`` directive
+   When used with the :meth:`strptime` method, the ``%f`` directive
    accepts from one to six digits and zero pads on the right.  ``%f`` is
    an extension to the set of format characters in the C standard (but
    implemented separately in datetime objects, and therefore always
    available).
 
 (2)
-   When used with the :func:`strptime` function, the ``%p`` directive only affects
+   When used with the :meth:`strptime` method, the ``%p`` directive only affects
    the output hour field if the ``%I`` directive is used to parse the hour.
 
 (3)
    The range really is ``0`` to ``61``; according to the Posix standard this
    accounts for leap seconds and the (very rare) double leap seconds.
    The :mod:`time` module may produce and does accept leap seconds since
    it is based on the Posix standard, but the :mod:`datetime` module
-   does not accept leap seconds in :func:`strptime` input nor will it
+   does not accept leap seconds in :meth:`strptime` input nor will it
    produce them in :func:`strftime` output.
 
 (4)
-   When used with the :func:`strptime` function, ``%U`` and ``%W`` are only used in
+   When used with the :meth:`strptime` method, ``%U`` and ``%W`` are only used in
    calculations when the day of the week and the year are specified.
 
 (5)
    For example, if :meth:`utcoffset` returns ``timedelta(hours=-3, minutes=-30)``,
    ``%z`` is replaced with the string ``'-0330'``.

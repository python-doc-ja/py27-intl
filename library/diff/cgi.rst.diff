--- r262/library/cgi.rst	2009-02-23 19:41:11.107573000 +0900
+++ r266/library/cgi.rst	2010-08-03 03:30:48.429673000 +0900
@@ -1,15 +1,14 @@
-
-:mod:`cgi` --- Common Gateway Interface support.
-================================================
+:mod:`cgi` --- Common Gateway Interface support
+===============================================
 
 .. module:: cgi
    :synopsis: Helpers for running Python scripts via the Common Gateway Interface.
 
 
 .. index::
    pair: WWW; server
    pair: CGI; protocol
    pair: HTTP; protocol
    pair: MIME; headers
    single: URL
    single: Common Gateway Interface
@@ -83,38 +82,39 @@
 It's very helpful to use this feature during script development. The reports
 produced by :mod:`cgitb` provide information that can save you a lot of time in
 tracking down bugs.  You can always remove the ``cgitb`` line later when you
 have tested your script and are confident that it works correctly.
 
 To get at submitted form data, it's best to use the :class:`FieldStorage` class.
 The other classes defined in this module are provided mostly for backward
 compatibility. Instantiate it exactly once, without arguments.  This reads the
 form contents from standard input or the environment (depending on the value of
 various environment variables set according to the CGI standard).  Since it may
 consume standard input, it should be instantiated only once.
 
-The :class:`FieldStorage` instance can be indexed like a Python dictionary, and
-also supports the standard dictionary methods :meth:`has_key` and :meth:`keys`.
-The built-in :func:`len` is also supported.  Form fields containing empty
-strings are ignored and do not appear in the dictionary; to keep such values,
-provide a true value for the optional *keep_blank_values* keyword parameter when
-creating the :class:`FieldStorage` instance.
+The :class:`FieldStorage` instance can be indexed like a Python dictionary.
+It allows membership testing with the :keyword:`in` operator, and also supports
+the standard dictionary method :meth:`keys` and the built-in function
+:func:`len`.  Form fields containing empty strings are ignored and do not appear
+in the dictionary; to keep such values, provide a true value for the optional
+*keep_blank_values* keyword parameter when creating the :class:`FieldStorage`
+instance.
 
 For instance, the following code (which assumes that the
 :mailheader:`Content-Type` header and blank line have already been printed)
 checks that the fields ``name`` and ``addr`` are both set to a non-empty
 string::
 
    form = cgi.FieldStorage()
-   if not (form.has_key("name") and form.has_key("addr")):
+   if "name" not in form or "addr" not in form:
        print "<H1>Error</H1>"
        print "Please fill in the name and addr fields."
        return
    print "<p>name:", form["name"].value
    print "<p>addr:", form["addr"].value
    ...further form processing here...
 
 Here the fields, accessed through ``form[key]``, are themselves instances of
 :class:`FieldStorage` (or :class:`MiniFieldStorage`, depending on the form
 encoding). The :attr:`value` attribute of the instance yields the string value
 of the field.  The :meth:`getvalue` method returns this string value directly;
 it also accepts an optional second argument as a default to return if the
@@ -127,54 +127,54 @@
 expect this possibility (when your HTML form contains multiple fields with the
 same name), use the :func:`getlist` function, which always returns a list of
 values (so that you do not need to special-case the single item case).  For
 example, this code concatenates any number of username fields, separated by
 commas::
 
    value = form.getlist("username")
    usernames = ",".join(value)
 
 If a field represents an uploaded file, accessing the value via the
 :attr:`value` attribute or the :func:`getvalue` method reads the entire file in
 memory as a string.  This may not be what you want. You can test for an uploaded
-file by testing either the :attr:`filename` attribute or the :attr:`file`
-attribute.  You can then read the data at leisure from the :attr:`file`
+file by testing either the :attr:`filename` attribute or the :attr:`!file`
+attribute.  You can then read the data at leisure from the :attr:`!file`
 attribute::
 
    fileitem = form["userfile"]
    if fileitem.file:
        # It's an uploaded file; count lines
        linecount = 0
        while 1:
            line = fileitem.file.readline()
            if not line: break
            linecount = linecount + 1
 
 If an error is encountered when obtaining the contents of an uploaded file
 (for example, when the user interrupts the form submission by clicking on
 a Back or Cancel button) the :attr:`done` attribute of the object for the
 field will be set to the value -1.
 
 The file upload draft standard entertains the possibility of uploading multiple
 files from one field (using a recursive :mimetype:`multipart/\*` encoding).
 When this occurs, the item will be a dictionary-like :class:`FieldStorage` item.
-This can be determined by testing its :attr:`type` attribute, which should be
+This can be determined by testing its :attr:`!type` attribute, which should be
 :mimetype:`multipart/form-data` (or perhaps another MIME type matching
 :mimetype:`multipart/\*`).  In this case, it can be iterated over recursively
 just like the top-level form object.
 
 When a form is submitted in the "old" format (as the query string or as a single
 data part of type :mimetype:`application/x-www-form-urlencoded`), the items will
 actually be instances of the class :class:`MiniFieldStorage`.  In this case, the
-:attr:`list`, :attr:`file`, and :attr:`filename` attributes are always ``None``.
+:attr:`!list`, :attr:`!file`, and :attr:`filename` attributes are always ``None``.
 
 A form submitted via POST that also has a query string will contain both
 :class:`FieldStorage` and :class:`MiniFieldStorage` items.
 
 Higher Level Interface
 ----------------------
 
 .. versionadded:: 2.2
 
 The previous section explains how to read CGI form data using the
 :class:`FieldStorage` class.  This section describes a higher level interface
 which was added to this class to allow one to do it in a more readable and
@@ -204,25 +204,25 @@
    <input type="checkbox" name="item" value="2" />
 
 In most situations, however, there's only one form control with a particular
 name in a form and then you expect and need only one value associated with this
 name.  So you write a script containing for example this code::
 
    user = form.getvalue("user").upper()
 
 The problem with the code is that you should never expect that a client will
 provide valid input to your scripts.  For example, if a curious user appends
 another ``user=foo`` pair to the query string, then the script would crash,
 because in this situation the ``getvalue("user")`` method call returns a list
-instead of a string.  Calling the :meth:`toupper` method on a list is not valid
+instead of a string.  Calling the :meth:`~str.upper` method on a list is not valid
 (since lists do not have a method of this name) and results in an
 :exc:`AttributeError` exception.
 
 Therefore, the appropriate way to read form data values was to always use the
 code which checks whether the obtained value is a single value or a list of
 values.  That's annoying and leads to less readable scripts.
 
 A more convenient approach is to use the methods :meth:`getfirst` and
 :meth:`getlist` provided by this higher level interface.
 
 
 .. method:: FieldStorage.getfirst(name[, default])
@@ -340,28 +340,31 @@
 
 
 .. function:: print_environ_usage()
 
    Print a list of useful (used by CGI) environment variables in HTML.
 
 
 .. function:: escape(s[, quote])
 
    Convert the characters ``'&'``, ``'<'`` and ``'>'`` in string *s* to HTML-safe
    sequences.  Use this if you need to display text that might contain such
    characters in HTML.  If the optional flag *quote* is true, the quotation mark
-   character (``'"'``) is also translated; this helps for inclusion in an HTML
-   attribute value, as in ``<A HREF="...">``.  If the value to be quoted might
-   include single- or double-quote characters, or both, consider using the
-   :func:`quoteattr` function in the :mod:`xml.sax.saxutils` module instead.
+   character (``"``) is also translated; this helps for inclusion in an HTML
+   attribute value delimited by double quotes, as in ``<a href="...">``.  Note
+   that single quotes are never translated.
+
+   If the value to be quoted might include single- or double-quote characters,
+   or both, consider using the :func:`quoteattr` function in the
+   :mod:`xml.sax.saxutils` module instead.
 
 
 .. _cgi-security:
 
 Caring about security
 ---------------------
 
 .. index:: pair: CGI; security
 
 There's one important rule: if you invoke an external program (via the
 :func:`os.system` or :func:`os.popen` functions. or others with similar
 functionality), make very sure you don't pass arbitrary strings received from

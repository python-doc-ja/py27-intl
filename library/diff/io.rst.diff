--- r262/library/io.rst	2009-02-02 17:27:16.400413000 +0900
+++ r266/library/io.rst	2010-05-29 21:08:31.993831000 +0900
@@ -1,61 +1,61 @@
 :mod:`io` --- Core tools for working with streams
 =================================================
 
 .. module:: io
    :synopsis: Core tools for working with streams.
 .. moduleauthor:: Guido van Rossum <guido@python.org>
 .. moduleauthor:: Mike Verdone <mike.verdone@gmail.com>
 .. moduleauthor:: Mark Russell <mark.russell@zen.co.uk>
 .. sectionauthor:: Benjamin Peterson <benjamin@python.org>
 .. versionadded:: 2.6
 
 The :mod:`io` module provides the Python interfaces to stream handling.  The
-builtin :func:`open` function is defined in this module.
+built-in :func:`open` function is defined in this module.
 
 At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  It
 defines the basic interface to a stream.  Note, however, that there is no
-seperation between reading and writing to streams; implementations are allowed
+separation between reading and writing to streams; implementations are allowed
 to throw an :exc:`IOError` if they do not support a given operation.
 
 Extending :class:`IOBase` is :class:`RawIOBase` which deals simply with the
 reading and writing of raw bytes to a stream.  :class:`FileIO` subclasses
 :class:`RawIOBase` to provide an interface to files in the machine's
 file system.
 
 :class:`BufferedIOBase` deals with buffering on a raw byte stream
 (:class:`RawIOBase`).  Its subclasses, :class:`BufferedWriter`,
 :class:`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are
 readable, writable, and both readable and writable.
 :class:`BufferedRandom` provides a buffered interface to random access
 streams.  :class:`BytesIO` is a simple stream of in-memory bytes.
 
 Another :class:`IOBase` subclass, :class:`TextIOBase`, deals with
 streams whose bytes represent text, and handles encoding and decoding
 from and to strings. :class:`TextIOWrapper`, which extends it, is a
 buffered text interface to a buffered raw stream
 (:class:`BufferedIOBase`). Finally, :class:`StringIO` is an in-memory
 stream for text.
 
 Argument names are not part of the specification, and only the arguments of
-:func:`open` are intended to be used as keyword arguments.
+:func:`.open` are intended to be used as keyword arguments.
 
 
 Module Interface
 ----------------
 
 .. data:: DEFAULT_BUFFER_SIZE
 
    An int containing the default buffer size used by the module's buffered I/O
-   classes.  :func:`open` uses the file's blksize (as obtained by
+   classes.  :func:`.open` uses the file's blksize (as obtained by
    :func:`os.stat`) if possible.
 
 .. function:: open(file[, mode[, buffering[, encoding[, errors[, newline[, closefd=True]]]]]])
 
    Open *file* and return a stream.  If the file cannot be opened, an
    :exc:`IOError` is raised.
 
    *file* is either a string giving the name (and the path if the file isn't in
    the current working directory) of the file to be opened or a file
    descriptor of the file to be opened.  (If a file descriptor is given,
    for example, from :func:`os.fdopen`, it is closed when the returned
    I/O object is closed, unless *closefd* is set to ``False``.)
@@ -85,28 +85,38 @@
    The default mode is ``'rt'`` (open for reading text).  For binary random
    access, the mode ``'w+b'`` opens and truncates the file to 0 bytes, while
    ``'r+b'`` opens the file without truncation.
 
    Python distinguishes between files opened in binary and text modes, even when
    the underlying operating system doesn't.  Files opened in binary mode
    (including ``'b'`` in the *mode* argument) return contents as ``bytes``
    objects without any decoding.  In text mode (the default, or when ``'t'`` is
    included in the *mode* argument), the contents of the file are returned as
    strings, the bytes having been first decoded using a platform-dependent
    encoding or using the specified *encoding* if given.
 
-   *buffering* is an optional integer used to set the buffering policy.  By
-   default full buffering is on.  Pass 0 to switch buffering off (only allowed
-   in binary mode), 1 to set line buffering, and an integer > 1 for full
-   buffering.
+   *buffering* is an optional integer used to set the buffering policy.
+   Pass 0 to switch buffering off (only allowed in binary mode), 1 to select
+   line buffering (only usable in text mode), and an integer > 1 to indicate
+   the size of a fixed-size chunk buffer.  When no *buffering* argument is
+   given, the default buffering policy works as follows:
+
+   * Binary files are buffered in fixed-size chunks; the size of the buffer
+     is chosen using a heuristic trying to determine the underlying device's
+     "block size" and falling back on :attr:`DEFAULT_BUFFER_SIZE`.
+     On many systems, the buffer will typically be 4096 or 8192 bytes long.
+
+   * "Interactive" text files (files for which :meth:`isatty` returns True)
+     use line buffering.  Other text files use the policy described above
+     for binary files.
 
    *encoding* is the name of the encoding used to decode or encode the file.
    This should only be used in text mode.  The default encoding is platform
    dependent, but any encoding supported by Python can be used.  See the
    :mod:`codecs` module for the list of supported encodings.
 
    *errors* is an optional string that specifies how encoding and decoding
    errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError`
    exception if there is an encoding error (the default of ``None`` has the same
    effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring encoding
    errors can lead to data loss.)  ``'replace'`` causes a replacement marker
    (such as ``'?'``) to be inserted where there is malformed data.  When
@@ -129,26 +139,26 @@
 
    * On output, if *newline* is ``None``, any ``'\n'`` characters written are
      translated to the system default line separator, :data:`os.linesep`.  If
      *newline* is ``''``, no translation takes place.  If *newline* is any of
      the other legal values, any ``'\n'`` characters written are translated to
      the given string.
 
    If *closefd* is ``False`` and a file descriptor rather than a
    filename was given, the underlying file descriptor will be kept open
    when the file is closed.  If a filename is given *closefd* has no
    effect but must be ``True`` (the default).
 
-   The type of file object returned by the :func:`open` function depends
-   on the mode.  When :func:`open` is used to open a file in a text mode
+   The type of file object returned by the :func:`.open` function depends
+   on the mode.  When :func:`.open` is used to open a file in a text mode
    (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a
    :class:`TextIOWrapper`. When used to open a file in a binary mode,
    the returned class varies: in read binary mode, it returns a
    :class:`BufferedReader`; in write binary and append binary modes, it
    returns a :class:`BufferedWriter`, and in read/write mode, it returns
    a :class:`BufferedRandom`.
 
    It is also possible to use a string or bytearray as a file for both reading
    and writing.  For strings :class:`StringIO` can be used like a file opened in
    a text mode, and for bytearrays a :class:`BytesIO` can be used like a
    file opened in a binary mode.
 
@@ -207,26 +217,28 @@
    :keyword:`with` statement.  In this example, *file* is closed after the
    :keyword:`with` statement's suite is finished---even if an exception occurs::
 
       with open('spam.txt', 'w') as file:
           file.write('Spam and eggs!')
 
    :class:`IOBase` provides these data attributes and methods:
 
    .. method:: close()
 
       Flush and close this stream. This method has no effect if the file is
       already closed. Once the file is closed, any operation on the file
-      (e.g. reading or writing) will raise an :exc:`IOError`. The internal
-      file descriptor isn't closed if *closefd* was False.
+      (e.g. reading or writing) will raise an :exc:`ValueError`.
+
+      As a convenience, it is allowed to call this method more than once;
+      only the first call, however, will have an effect.
 
    .. attribute:: closed
 
       True if the stream is closed.
 
    .. method:: fileno()
 
       Return the underlying file descriptor (an integer) of the stream if it
       exists.  An :exc:`IOError` is raised if the IO object does not use a file
       descriptor.
 
    .. method:: flush()
@@ -241,25 +253,25 @@
 
    .. method:: readable()
 
       Return ``True`` if the stream can be read from.  If False, :meth:`read`
       will raise :exc:`IOError`.
 
    .. method:: readline([limit])
 
       Read and return one line from the stream.  If *limit* is specified, at
       most *limit* bytes will be read.
 
       The line terminator is always ``b'\n'`` for binary files; for text files,
-      the *newlines* argument to :func:`open` can be used to select the line
+      the *newlines* argument to :func:`.open` can be used to select the line
       terminator(s) recognized.
 
    .. method:: readlines([hint])
 
       Read and return a list of lines from the stream.  *hint* can be specified
       to control the number of lines read: no more lines will be read if the
       total size (in bytes/characters) of all lines so far exceeds *hint*.
 
    .. method:: seek(offset[, whence])
 
       Change the stream position to the given byte *offset*.  *offset* is
       interpreted relative to the position indicated by *whence*.  Values for
@@ -273,26 +285,30 @@
 
    .. method:: seekable()
 
       Return ``True`` if the stream supports random access.  If ``False``,
       :meth:`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`IOError`.
 
    .. method:: tell()
 
       Return the current stream position.
 
    .. method:: truncate([size])
 
-      Truncate the file to at most *size* bytes.  *size* defaults to the current
-      file position, as returned by :meth:`tell`.
+      Resize the stream to the given *size* in bytes (or the current position
+      if *size* is not specified).  The current stream position isn't changed.
+      This resizing can extend or reduce the current file size.  In case of
+      extension, the contents of the new file area depend on the platform
+      (on most systems, additional bytes are zero-filled, on Windows they're
+      undetermined).  The new file size is returned.
 
    .. method:: writable()
 
       Return ``True`` if the stream supports writing.  If ``False``,
       :meth:`write` and :meth:`truncate` will raise :exc:`IOError`.
 
    .. method:: writelines(lines)
 
       Write a list of lines to the stream.  Line separators are not added, so it
       is usual for each of the lines provided to have a line separator at the
       end.
 
@@ -320,77 +336,24 @@
    .. method:: readinto(b)
 
       Read up to len(b) bytes into bytearray *b* and return the number of bytes
       read.
 
    .. method:: write(b)
 
       Write the given bytes or bytearray object, *b*, to the underlying raw
       stream and return the number of bytes written (This is never less than
       ``len(b)``, since if the write fails, an :exc:`IOError` will be raised).
 
 
-Raw File I/O
-------------
-
-.. class:: FileIO(name[, mode])
-
-   :class:`FileIO` represents a file containing bytes data.  It implements
-   the :class:`RawIOBase` interface (and therefore the :class:`IOBase`
-   interface, too).
-
-   The *mode* can be ``'r'``, ``'w'`` or ``'a'`` for reading (default), writing,
-   or appending.  The file will be created if it doesn't exist when opened for
-   writing or appending; it will be truncated when opened for writing.  Add a
-   ``'+'`` to the mode to allow simultaneous reading and writing.
-
-   In addition to the attributes and methods from :class:`IOBase` and
-   :class:`RawIOBase`, :class:`FileIO` provides the following data
-   attributes and methods:
-
-   .. attribute:: mode
-
-      The mode as given in the constructor.
-
-   .. attribute:: name
-
-      The file name.  This is the file descriptor of the file when no name is
-      given in the constructor.
-
-   .. method:: read([n])
-
-      Read and return at most *n* bytes.  Only one system call is made, so it is
-      possible that less data than was requested is returned.  Use :func:`len`
-      on the returned bytes object to see how many bytes were actually returned.
-      (In non-blocking mode, ``None`` is returned when no data is available.)
-
-   .. method:: readall()
-
-      Read and return the entire file's contents in a single bytes object.  As
-      much as immediately available is returned in non-blocking mode.  If the
-      EOF has been reached, ``b''`` is returned.
-
-   .. method:: write(b)
-
-      Write the bytes or bytearray object, *b*, to the file, and return
-      the number actually written. Only one system call is made, so it
-      is possible that only some of the data is written.
-
-   Note that the inherited ``readinto()`` method should not be used on
-   :class:`FileIO` objects.
-
-
-Buffered Streams
-----------------
-
 .. class:: BufferedIOBase
 
    Base class for streams that support buffering.  It inherits :class:`IOBase`.
    There is no public constructor.
 
    The main difference with :class:`RawIOBase` is that the :meth:`read` method
    supports omitting the *size* argument, and does not have a default
    implementation that defers to :meth:`readinto`.
 
    In addition, :meth:`read`, :meth:`readinto`, and :meth:`write` may raise
    :exc:`BlockingIOError` if the underlying raw stream is in non-blocking mode
    and not ready; unlike their raw counterparts, they will never return
@@ -430,47 +393,95 @@
       data at the moment.
 
    .. method:: write(b)
 
       Write the given bytes or bytearray object, *b*, to the underlying raw
       stream and return the number of bytes written (never less than ``len(b)``,
       since if the write fails an :exc:`IOError` will be raised).
 
       A :exc:`BlockingIOError` is raised if the buffer is full, and the
       underlying raw stream cannot accept more data at the moment.
 
 
+Raw File I/O
+------------
+
+.. class:: FileIO(name[, mode])
+
+   :class:`FileIO` represents a file containing bytes data.  It implements
+   the :class:`RawIOBase` interface (and therefore the :class:`IOBase`
+   interface, too).
+
+   The *mode* can be ``'r'``, ``'w'`` or ``'a'`` for reading (default), writing,
+   or appending.  The file will be created if it doesn't exist when opened for
+   writing or appending; it will be truncated when opened for writing.  Add a
+   ``'+'`` to the mode to allow simultaneous reading and writing.
+
+   In addition to the attributes and methods from :class:`IOBase` and
+   :class:`RawIOBase`, :class:`FileIO` provides the following data
+   attributes and methods:
+
+   .. attribute:: mode
+
+      The mode as given in the constructor.
+
+   .. attribute:: name
+
+      The file name.  This is the file descriptor of the file when no name is
+      given in the constructor.
+
+   .. method:: read([n])
+
+      Read and return at most *n* bytes.  Only one system call is made, so it is
+      possible that less data than was requested is returned.  Use :func:`len`
+      on the returned bytes object to see how many bytes were actually returned.
+      (In non-blocking mode, ``None`` is returned when no data is available.)
+
+   .. method:: readall()
+
+      Read and return the entire file's contents in a single bytes object.  As
+      much as immediately available is returned in non-blocking mode.  If the
+      EOF has been reached, ``b''`` is returned.
+
+   .. method:: write(b)
+
+      Write the bytes or bytearray object, *b*, to the file, and return
+      the number actually written. Only one system call is made, so it
+      is possible that only some of the data is written.
+
+   Note that the inherited ``readinto()`` method should not be used on
+   :class:`FileIO` objects.
+
+
+Buffered Streams
+----------------
+
 .. class:: BytesIO([initial_bytes])
 
    A stream implementation using an in-memory bytes buffer.  It inherits
    :class:`BufferedIOBase`.
 
    The argument *initial_bytes* is an optional initial bytearray.
 
    :class:`BytesIO` provides or overrides these methods in addition to those
    from :class:`BufferedIOBase` and :class:`IOBase`:
 
    .. method:: getvalue()
 
       Return ``bytes`` containing the entire contents of the buffer.
 
    .. method:: read1()
 
       In :class:`BytesIO`, this is the same as :meth:`read`.
 
-   .. method:: truncate([size])
-
-      Truncate the buffer to at most *size* bytes.  *size* defaults to the
-      current stream position, as returned by :meth:`tell`.
-
 
 .. class:: BufferedReader(raw[, buffer_size])
 
    A buffer for a readable, sequential :class:`RawIOBase` object.  It inherits
    :class:`BufferedIOBase`.
 
    The constructor creates a :class:`BufferedReader` for the given readable
    *raw* stream and *buffer_size*.  If *buffer_size* is omitted,
    :data:`DEFAULT_BUFFER_SIZE` is used.
 
    :class:`BufferedReader` provides or overrides these methods in addition to
    those from :class:`BufferedIOBase` and :class:`IOBase`:
@@ -603,46 +614,46 @@
    errors can lead to data loss.)  ``'replace'`` causes a replacement marker
    (such as ``'?'``) to be inserted where there is malformed data.  When
    writing, ``'xmlcharrefreplace'`` (replace with the appropriate XML character
    reference) or ``'backslashreplace'`` (replace with backslashed escape
    sequences) can be used.  Any other error handling name that has been
    registered with :func:`codecs.register_error` is also valid.
 
    *newline* can be ``None``, ``''``, ``'\n'``, ``'\r'``, or ``'\r\n'``.  It
    controls the handling of line endings.  If it is ``None``, universal newlines
    is enabled.  With this enabled, on input, the lines endings ``'\n'``,
    ``'\r'``, or ``'\r\n'`` are translated to ``'\n'`` before being returned to
    the caller.  Conversely, on output, ``'\n'`` is translated to the system
-   default line seperator, :data:`os.linesep`.  If *newline* is any other of its
+   default line separator, :data:`os.linesep`.  If *newline* is any other of its
    legal values, that newline becomes the newline when the file is read and it
    is returned untranslated.  On output, ``'\n'`` is converted to the *newline*.
 
    If *line_buffering* is ``True``, :meth:`flush` is implied when a call to
    write contains a newline character.
 
    :class:`TextIOWrapper` provides these data attributes in addition to those of
    :class:`TextIOBase` and its parents:
 
    .. attribute:: errors
 
       The encoding and decoding error setting.
 
    .. attribute:: line_buffering
 
       Whether line buffering is enabled.
 
 
 .. class:: StringIO([initial_value[, encoding[, errors[, newline]]]])
 
-   An in-memory stream for text.  It in inherits :class:`TextIOWrapper`.
+   An in-memory stream for text.  It inherits :class:`TextIOWrapper`.
 
    Create a new StringIO stream with an inital value, encoding, error handling,
    and newline setting.  See :class:`TextIOWrapper`\'s constructor for more
    information.
 
    :class:`StringIO` provides this method in addition to those from
    :class:`TextIOWrapper` and its parents:
 
    .. method:: getvalue()
 
       Return a ``str`` containing the entire contents of the buffer.
 

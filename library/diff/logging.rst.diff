--- r262/library/logging.rst	2009-01-14 09:08:09.462418000 +0900
+++ r266/library/logging.rst	2010-07-07 00:08:55.713458000 +0900
@@ -46,91 +46,93 @@
 mechanisms are all supported by the standard module.  You can also create your
 own log destination class if you have special requirements not met by any of the
 built-in classes.
 
 Simple examples
 ^^^^^^^^^^^^^^^
 
 .. sectionauthor:: Doug Hellmann
 .. (see <http://blog.doughellmann.com/2007/05/pymotw-logging.html>)
 
 Most applications are probably going to want to log to a file, so let's start
 with that case. Using the :func:`basicConfig` function, we can set up the
-default handler so that debug messages are written to a file::
+default handler so that debug messages are written to a file (in the example,
+we assume that you have the appropriate permissions to create a file called
+*example.log* in the current directory)::
 
    import logging
-   LOG_FILENAME = '/tmp/logging_example.out'
-   logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG,)
+   LOG_FILENAME = 'example.log'
+   logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)
 
    logging.debug('This message should go to the log file')
 
 And now if we open the file and look at what we have, we should find the log
 message::
 
    DEBUG:root:This message should go to the log file
 
 If you run the script repeatedly, the additional log messages are appended to
-the file.  To create a new file each time, you can pass a filemode argument to
+the file.  To create a new file each time, you can pass a *filemode* argument to
 :func:`basicConfig` with a value of ``'w'``.  Rather than managing the file size
 yourself, though, it is simpler to use a :class:`RotatingFileHandler`::
 
    import glob
    import logging
    import logging.handlers
 
-   LOG_FILENAME = '/tmp/logging_rotatingfile_example.out'
+   LOG_FILENAME = 'logging_rotatingfile_example.out'
 
    # Set up a specific logger with our desired output level
    my_logger = logging.getLogger('MyLogger')
    my_logger.setLevel(logging.DEBUG)
 
    # Add the log message handler to the logger
    handler = logging.handlers.RotatingFileHandler(
                  LOG_FILENAME, maxBytes=20, backupCount=5)
 
    my_logger.addHandler(handler)
 
    # Log some messages
    for i in range(20):
        my_logger.debug('i = %d' % i)
 
    # See what files are created
    logfiles = glob.glob('%s*' % LOG_FILENAME)
 
    for filename in logfiles:
        print filename
 
 The result should be 6 separate files, each with part of the log history for the
 application::
 
-   /tmp/logging_rotatingfile_example.out
-   /tmp/logging_rotatingfile_example.out.1
-   /tmp/logging_rotatingfile_example.out.2
-   /tmp/logging_rotatingfile_example.out.3
-   /tmp/logging_rotatingfile_example.out.4
-   /tmp/logging_rotatingfile_example.out.5
+   logging_rotatingfile_example.out
+   logging_rotatingfile_example.out.1
+   logging_rotatingfile_example.out.2
+   logging_rotatingfile_example.out.3
+   logging_rotatingfile_example.out.4
+   logging_rotatingfile_example.out.5
 
-The most current file is always :file:`/tmp/logging_rotatingfile_example.out`,
+The most current file is always :file:`logging_rotatingfile_example.out`,
 and each time it reaches the size limit it is renamed with the suffix
 ``.1``. Each of the existing backup files is renamed to increment the suffix
-(``.1`` becomes ``.2``, etc.)  and the ``.5`` file is erased.
+(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased.
 
 Obviously this example sets the log length much much too small as an extreme
 example.  You would want to set *maxBytes* to an appropriate value.
 
 Another useful feature of the logging API is the ability to produce different
 messages at different log levels.  This allows you to instrument your code with
 debug messages, for example, but turning the log level down so that those debug
 messages are not written for your production system.  The default levels are
-``CRITICAL``, ``ERROR``, ``WARNING``, ``INFO``, ``DEBUG`` and ``NOTSET``.
+``NOTSET``, ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` and ``CRITICAL``.
 
 The logger, handler, and log message call each specify a level.  The log message
 is only emitted if the handler and logger are configured to emit messages of
 that level or lower.  For example, if a message is ``CRITICAL``, and the logger
 is set to ``ERROR``, the message is emitted.  If a message is a ``WARNING``, and
 the logger is set to produce only ``ERROR``\s, the message is not emitted::
 
    import logging
    import sys
 
    LEVELS = {'debug': logging.DEBUG,
              'info': logging.INFO,
@@ -237,34 +239,34 @@
   logging methods care only about a keyword of :const:`exc_info` and use it to
   determine whether to log exception information.
 
 * :meth:`Logger.exception` creates a log message similar to
   :meth:`Logger.error`.  The difference is that :meth:`Logger.exception` dumps a
   stack trace along with it.  Call this method only from an exception handler.
 
 * :meth:`Logger.log` takes a log level as an explicit argument.  This is a
   little more verbose for logging messages than using the log level convenience
   methods listed above, but this is how to log at custom log levels.
 
 :func:`getLogger` returns a reference to a logger instance with the specified
-if it it is provided, or ``root`` if not.  The names are period-separated
+name if it is provided, or ``root`` if not.  The names are period-separated
 hierarchical structures.  Multiple calls to :func:`getLogger` with the same name
 will return a reference to the same logger object.  Loggers that are further
 down in the hierarchical list are children of loggers higher up in the list.
 For example, given a logger with a name of ``foo``, loggers with names of
-``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all children of ``foo``.
-Child loggers propagate messages up to their parent loggers.  Because of this,
-it is unnecessary to define and configure all the loggers an application uses.
-It is sufficient to configure a top-level logger and create child loggers as
-needed.
+``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` are all descendants of ``foo``.
+Child loggers propagate messages up to the handlers associated with their
+ancestor loggers.  Because of this, it is unnecessary to define and configure
+handlers for all the loggers an application uses. It is sufficient to
+configure handlers for a top-level logger and create child loggers as needed.
 
 
 Handlers
 ^^^^^^^^
 
 :class:`Handler` objects are responsible for dispatching the appropriate log
 messages (based on the log messages' severity) to the handler's specified
 destination.  Logger objects can add zero or more handler objects to themselves
 with an :func:`addHandler` method.  As an example scenario, an application may
 want to send all log messages to a log file, all log messages of error or higher
 to stdout, and all messages of critical to an email address.  This scenario
 requires three individual handlers where each handler is responsible for sending
@@ -274,52 +276,53 @@
 :class:`StreamHandler` and :class:`FileHandler` in its examples.
 
 There are very few methods in a handler for application developers to concern
 themselves with.  The only handler methods that seem relevant for application
 developers who are using the built-in handler objects (that is, not creating
 custom handlers) are the following configuration methods:
 
 * The :meth:`Handler.setLevel` method, just as in logger objects, specifies the
   lowest severity that will be dispatched to the appropriate destination.  Why
   are there two :func:`setLevel` methods?  The level set in the logger
   determines which severity of messages it will pass to its handlers.  The level
   set in each handler determines which messages that handler will send on.
-  :func:`setFormatter` selects a Formatter object for this handler to use.
+
+* :func:`setFormatter` selects a Formatter object for this handler to use.
 
 * :func:`addFilter` and :func:`removeFilter` respectively configure and
   deconfigure filter objects on handlers.
 
-Application code should not directly instantiate and use handlers.  Instead, the
-:class:`Handler` class is a base class that defines the interface that all
-Handlers should have and establishes some default behavior that child classes
-can use (or override).
+Application code should not directly instantiate and use instances of
+:class:`Handler`.  Instead, the :class:`Handler` class is a base class that
+defines the interface that all handlers should have and establishes some
+default behavior that child classes can use (or override).
 
 
 Formatters
 ^^^^^^^^^^
 
 Formatter objects configure the final order, structure, and contents of the log
 message.  Unlike the base :class:`logging.Handler` class, application code may
 instantiate formatter classes, although you could likely subclass the formatter
 if your application needs special behavior.  The constructor takes two optional
 arguments: a message format string and a date format string.  If there is no
 message format string, the default is to use the raw message.  If there is no
 date format string, the default date format is::
 
     %Y-%m-%d %H:%M:%S
 
 with the milliseconds tacked on at the end.
 
 The message format string uses ``%(<dictionary key>)s`` styled string
-substitution; the possible keys are documented in :ref:`formatter-objects`.
+substitution; the possible keys are documented in :ref:`formatter`.
 
 The following message format string will log the time in a human-readable
 format, the severity of the message, and the contents of the message, in that
 order::
 
     "%(asctime)s - %(levelname)s - %(message)s"
 
 
 Configuring Logging
 ^^^^^^^^^^^^^^^^^^^
 
 Programmers can configure logging either by creating loggers, handlers, and
@@ -501,74 +504,81 @@
 created from the logging message.
 
 Logging messages are subjected to a dispatch mechanism through the use of
 :dfn:`handlers`, which are instances of subclasses of the :class:`Handler`
 class. Handlers are responsible for ensuring that a logged message (in the form
 of a :class:`LogRecord`) ends up in a particular location (or set of locations)
 which is useful for the target audience for that message (such as end users,
 support desk staff, system administrators, developers). Handlers are passed
 :class:`LogRecord` instances intended for particular destinations. Each logger
 can have zero, one or more handlers associated with it (via the
 :meth:`addHandler` method of :class:`Logger`). In addition to any handlers
 directly associated with a logger, *all handlers associated with all ancestors
-of the logger* are called to dispatch the message.
+of the logger* are called to dispatch the message (unless the *propagate* flag
+for a logger is set to a false value, at which point the passing to ancestor
+handlers stops).
 
 Just as for loggers, handlers can have levels associated with them. A handler's
 level acts as a filter in the same way as a logger's level does. If a handler
 decides to actually dispatch an event, the :meth:`emit` method is used to send
 the message to its destination. Most user-defined subclasses of :class:`Handler`
 will need to override this :meth:`emit`.
 
+Useful Handlers
+---------------
+
 In addition to the base :class:`Handler` class, many useful subclasses are
 provided:
 
-#. :class:`StreamHandler` instances send error messages to streams (file-like
+#. :ref:`stream-handler` instances send error messages to streams (file-like
    objects).
 
-#. :class:`FileHandler` instances send error messages to disk files.
+#. :ref:`file-handler` instances send error messages to disk files.
 
-#. :class:`handlers.BaseRotatingHandler` is the base class for handlers that
+#. :class:`BaseRotatingHandler` is the base class for handlers that
    rotate log files at a certain point. It is not meant to be  instantiated
-   directly. Instead, use :class:`RotatingFileHandler` or
-   :class:`TimedRotatingFileHandler`.
+   directly. Instead, use :ref:`rotating-file-handler` or
+   :ref:`timed-rotating-file-handler`.
 
-#. :class:`handlers.RotatingFileHandler` instances send error messages to disk files,
-   with support for maximum log file sizes and log file rotation.
+#. :ref:`rotating-file-handler` instances send error messages to disk
+   files, with support for maximum log file sizes and log file rotation.
 
-#. :class:`handlers.TimedRotatingFileHandler` instances send error messages to disk files
-   rotating the log file at certain timed intervals.
+#. :ref:`timed-rotating-file-handler` instances send error messages to
+   disk files, rotating the log file at certain timed intervals.
 
-#. :class:`handlers.SocketHandler` instances send error messages to TCP/IP sockets.
+#. :ref:`socket-handler` instances send error messages to TCP/IP
+   sockets.
 
-#. :class:`handlers.DatagramHandler` instances send error messages to UDP sockets.
+#. :ref:`datagram-handler` instances send error messages to UDP
+   sockets.
 
-#. :class:`handlers.SMTPHandler` instances send error messages to a designated email
-   address.
+#. :ref:`smtp-handler` instances send error messages to a designated
+   email address.
 
-#. :class:`handlers.SysLogHandler` instances send error messages to a Unix syslog daemon,
-   possibly on a remote machine.
+#. :ref:`syslog-handler` instances send error messages to a Unix
+   syslog daemon, possibly on a remote machine.
 
-#. :class:`handlers.NTEventLogHandler` instances send error messages to a Windows
-   NT/2000/XP event log.
+#. :ref:`nt-eventlog-handler` instances send error messages to a
+   Windows NT/2000/XP event log.
 
-#. :class:`handlers.MemoryHandler` instances send error messages to a buffer in memory,
-   which is flushed whenever specific criteria are met.
+#. :ref:`memory-handler` instances send error messages to a buffer
+   in memory, which is flushed whenever specific criteria are met.
 
-#. :class:`handlers.HTTPHandler` instances send error messages to an HTTP server using
-   either ``GET`` or ``POST`` semantics.
+#. :ref:`http-handler` instances send error messages to an HTTP
+   server using either ``GET`` or ``POST`` semantics.
 
-#. :class:`handlers.WatchedFileHandler` instances watch the file they are logging to. If
-the file changes, it is closed and reopened using the file name. This handler
-is only useful on Unix-like systems; Windows does not support the underlying
-mechanism used.
+#. :ref:`watched-file-handler` instances watch the file they are
+   logging to. If the file changes, it is closed and reopened using the file
+   name. This handler is only useful on Unix-like systems; Windows does not
+   support the underlying mechanism used.
 
 The :class:`StreamHandler` and :class:`FileHandler`
 classes are defined in the core logging package. The other handlers are
 defined in a sub- module, :mod:`logging.handlers`. (There is also another
 sub-module, :mod:`logging.config`, for configuration functionality.)
 
 Logged messages are formatted for presentation through instances of the
 :class:`Formatter` class. They are initialized with a format string suitable for
 use with the % operator and a dictionary.
 
 For formatting multiple messages in a batch, instances of
 :class:`BufferingFormatter` can be used. In addition to the format string (which
@@ -577,24 +587,27 @@
 
 When filtering based on logger level and/or handler level is not enough,
 instances of :class:`Filter` can be added to both :class:`Logger` and
 :class:`Handler` instances (through their :meth:`addFilter` method). Before
 deciding to process a message further, both loggers and handlers consult all
 their filters for permission. If any filter returns a false value, the message
 is not processed further.
 
 The basic :class:`Filter` functionality allows filtering by specific logger
 name. If this feature is used, messages sent to the named logger and its
 children are allowed through the filter, and all others dropped.
 
+Module-Level Functions
+----------------------
+
 In addition to the classes described above, there are a number of module- level
 functions.
 
 
 .. function:: getLogger([name])
 
    Return a logger with the specified name or, if no name is specified, return a
    logger which is the root logger of the hierarchy. If specified, the name is
    typically a dot-separated hierarchical name like *"a"*, *"a.b"* or *"a.b.c.d"*.
    Choice of these names is entirely up to the developer who is using logging.
 
    All calls to this function with a given name return the same logger instance.
@@ -695,25 +708,29 @@
 
 
 .. function:: log(level, msg[, *args[, **kwargs]])
 
    Logs a message with level *level* on the root logger. The other arguments are
    interpreted as for :func:`debug`.
 
 
 .. function:: disable(lvl)
 
    Provides an overriding level *lvl* for all loggers which takes precedence over
    the logger's own level. When the need arises to temporarily throttle logging
-   output down across the whole application, this function can be useful.
+   output down across the whole application, this function can be useful. Its
+   effect is to disable all logging calls of severity *lvl* and below, so that
+   if you call it with a value of INFO, then all INFO and DEBUG events would be
+   discarded, whereas those of severity WARNING and above would be processed
+   according to the logger's effective level.
 
 
 .. function:: addLevelName(lvl, levelName)
 
    Associates level *lvl* with text *levelName* in an internal dictionary, which is
    used to map numeric levels to a textual representation, for example when a
    :class:`Formatter` formats a message. This function can also be used to define
    your own levels. The only constraints are that all levels used must be
    registered using this function, levels should be positive integers and they
    should increase in increasing order of severity.
 
 
@@ -731,30 +748,30 @@
 .. function:: makeLogRecord(attrdict)
 
    Creates and returns a new :class:`LogRecord` instance whose attributes are
    defined by *attrdict*. This function is useful for taking a pickled
    :class:`LogRecord` attribute dictionary, sent over a socket, and reconstituting
    it as a :class:`LogRecord` instance at the receiving end.
 
 
 .. function:: basicConfig([**kwargs])
 
    Does basic configuration for the logging system by creating a
    :class:`StreamHandler` with a default :class:`Formatter` and adding it to the
-   root logger. The function does nothing if any handlers have been defined for
-   the root logger. The functions :func:`debug`, :func:`info`, :func:`warning`,
+   root logger. The functions :func:`debug`, :func:`info`, :func:`warning`,
    :func:`error` and :func:`critical` will call :func:`basicConfig` automatically
    if no handlers are defined for the root logger.
 
-   This function does nothing if the root logger already has handlers configured.
+   This function does nothing if the root logger already has handlers
+   configured for it.
 
    .. versionchanged:: 2.4
       Formerly, :func:`basicConfig` did not take any keyword arguments.
 
    The following keyword arguments are supported.
 
    +--------------+---------------------------------------------+
    | Format       | Description                                 |
    +==============+=============================================+
    | ``filename`` | Specifies that a FileHandler be created,    |
    |              | using the specified filename, rather than a |
    |              | StreamHandler.                              |
@@ -797,38 +814,39 @@
 .. seealso::
 
    :pep:`282` - A Logging System
       The proposal which described this feature for inclusion in the Python standard
       library.
 
    `Original Python logging package <http://www.red-dove.com/python_logging.html>`_
       This is the original source for the :mod:`logging` package.  The version of the
       package available from this site is suitable for use with Python 1.5.2, 2.1.x
       and 2.2.x, which do not include the :mod:`logging` package in the standard
       library.
 
+.. _logger:
 
 Logger Objects
 --------------
 
 Loggers have the following attributes and methods. Note that Loggers are never
 instantiated directly, but always through the module-level function
 ``logging.getLogger(name)``.
 
 
 .. attribute:: Logger.propagate
 
    If this evaluates to false, logging messages are not passed by this logger or by
-   child loggers to higher level (ancestor) loggers. The constructor sets this
-   attribute to 1.
+   its child loggers to the handlers of higher level (ancestor) loggers. The
+   constructor sets this attribute to 1.
 
 
 .. method:: Logger.setLevel(lvl)
 
    Sets the threshold for this logger to *lvl*. Logging messages which are less
    severe than *lvl* will be ignored. When a logger is created, the level is set to
    :const:`NOTSET` (which causes all messages to be processed when the logger is
    the root logger, or delegation to the parent when the logger is a non-root
    logger). Note that the root logger is created with level :const:`WARNING`.
 
    The term "delegation to the parent" means that if a logger has a level of
    NOTSET, its chain of ancestor loggers is traversed until either an ancestor with
@@ -978,25 +996,25 @@
    number and function name as a 3-element tuple.
 
    .. versionchanged:: 2.4
       The function name was added. In earlier versions, the filename and line number
       were returned as a 2-element tuple..
 
 
 .. method:: Logger.handle(record)
 
    Handles a record by passing it to all handlers associated with this logger and
    its ancestors (until a false value of *propagate* is found). This method is used
    for unpickled records received from a socket, as well as those created locally.
-   Logger-level filtering is applied using :meth:`filter`.
+   Logger-level filtering is applied using :meth:`~Logger.filter`.
 
 
 .. method:: Logger.makeRecord(name, lvl, fn, lno, msg, args, exc_info [, func, extra])
 
    This is a factory method which can be overridden in subclasses to create
    specialized :class:`LogRecord` instances.
 
    .. versionchanged:: 2.5
       *func* and *extra* were added.
 
 
 .. _minimal-example:
@@ -1025,32 +1043,32 @@
 
 Because no particular logger was specified, the system used the root logger. The
 debug and info messages didn't appear because by default, the root logger is
 configured to only handle messages with a severity of WARNING or above. The
 message format is also a configuration default, as is the output destination of
 the messages - ``sys.stderr``. The severity level, the message format and
 destination can be easily changed, as shown in the example below::
 
    import logging
 
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s %(levelname)s %(message)s',
-                       filename='/tmp/myapp.log',
+                       filename='myapp.log',
                        filemode='w')
    logging.debug('A debug message')
    logging.info('Some information')
    logging.warning('A shot across the bows')
 
 The :meth:`basicConfig` method is used to change the configuration defaults,
-which results in output (written to ``/tmp/myapp.log``) which should look
+which results in output (written to ``myapp.log``) which should look
 something like the following::
 
    2004-07-02 13:00:08,743 DEBUG A debug message
    2004-07-02 13:00:08,743 INFO Some information
    2004-07-02 13:00:08,743 WARNING A shot across the bows
 
 This time, all messages with a severity of DEBUG or above were handled, and the
 format of the messages was also changed, and output went to the specified file
 rather than the console.
 
 Formatting uses standard Python string formatting - see section
 :ref:`string-formatting`. The format string takes the following common
@@ -1177,24 +1195,46 @@
    10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.
    10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.
    10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.
    10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.
    10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly.
 
 As you can see, the DEBUG message only shows up in the file. The other messages
 are sent to both destinations.
 
 This example uses console and file handlers, but you can use any number and
 combination of handlers you choose.
 
+.. _logging-exceptions:
+
+Exceptions raised during logging
+--------------------------------
+
+The logging package is designed to swallow exceptions which occur while logging
+in production. This is so that errors which occur while handling logging events
+- such as logging misconfiguration, network or other similar errors - do not
+cause the application using logging to terminate prematurely.
+
+:class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never
+swallowed. Other exceptions which occur during the :meth:`emit` method of a
+:class:`Handler` subclass are passed to its :meth:`handleError` method.
+
+The default implementation of :meth:`handleError` in :class:`Handler` checks
+to see if a module-level variable, :data:`raiseExceptions`, is set. If set, a
+traceback is printed to :data:`sys.stderr`. If not set, the exception is swallowed.
+
+**Note:** The default value of :data:`raiseExceptions` is ``True``. This is because
+during development, you typically want to be notified of any exceptions that
+occur. It's advised that you set :data:`raiseExceptions` to ``False`` for production
+usage.
 
 .. _context-info:
 
 Adding contextual information to your logging output
 ----------------------------------------------------
 
 Sometimes you want logging output to contain contextual information in
 addition to the parameters passed to the logging call. For example, in a
 networked application, it may be desirable to log client-specific information
 in the log (e.g. remote client's username, or IP address). Although you could
 use the *extra* parameter to achieve this, it's not always convenient to pass
 the information in this way. While it might be tempting to create
@@ -1303,24 +1343,49 @@
    2008-01-18 14:49:54,033 d.e.f ERROR    IP: 127.0.0.1       User: fred     A message at ERROR level with 2 parameters
    2008-01-18 14:49:54,033 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A message at ERROR level with 2 parameters
    2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters
    2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: jim      A message at WARNING level with 2 parameters
    2008-01-18 14:49:54,033 d.e.f INFO     IP: 192.168.0.1     User: fred     A message at INFO level with 2 parameters
    2008-01-18 14:49:54,033 d.e.f WARNING  IP: 192.168.0.1     User: sheila   A message at WARNING level with 2 parameters
    2008-01-18 14:49:54,033 d.e.f WARNING  IP: 127.0.0.1       User: jim      A message at WARNING level with 2 parameters
 
 .. versionadded:: 2.6
 
 The :class:`LoggerAdapter` class was not present in previous versions.
 
+.. _multiple-processes:
+
+Logging to a single file from multiple processes
+------------------------------------------------
+
+Although logging is thread-safe, and logging to a single file from multiple
+threads in a single process *is* supported, logging to a single file from
+*multiple processes* is *not* supported, because there is no standard way to
+serialize access to a single file across multiple processes in Python. If you
+need to log to a single file from multiple processes, the best way of doing
+this is to have all the processes log to a :class:`SocketHandler`, and have a
+separate process which implements a socket server which reads from the socket
+and logs to file. (If you prefer, you can dedicate one thread in one of the
+existing processes to perform this function.) The following section documents
+this approach in more detail and includes a working socket receiver which can
+be used as a starting point for you to adapt in your own applications.
+
+If you are using a recent version of Python which includes the
+:mod:`multiprocessing` module, you can write your own handler which uses the
+:class:`Lock` class from this module to serialize access to the file from
+your processes. The existing :class:`FileHandler` and subclasses do not make
+use of :mod:`multiprocessing` at present, though they may do so in the future.
+Note that at present, the :mod:`multiprocessing` module does not provide
+working lock functionality on all platforms (see
+http://bugs.python.org/issue3770).
 
 .. _network-logging:
 
 Sending and receiving logging events across a network
 -----------------------------------------------------
 
 Let's say you want to send logging events across a network, and handle them at
 the receiving end. A simple way of doing this is attaching a
 :class:`SocketHandler` instance to the root logger at the sending end::
 
    import logging, logging.handlers
 
@@ -1434,24 +1499,78 @@
        main()
 
 First run the server, and then the client. On the client side, nothing is
 printed on the console; on the server side, you should see something like::
 
    About to start TCP server...
       59 root            INFO     Jackdaws love my big sphinx of quartz.
       59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.
       69 myapp.area1     INFO     How quickly daft jumping zebras vex.
       69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.
       69 myapp.area2     ERROR    The five boxing wizards jump quickly.
 
+Note that there are some security issues with pickle in some scenarios. If
+these affect you, you can use an alternative serialization scheme by overriding
+the :meth:`makePickle` method and implementing your alternative there, as
+well as adapting the above script to use your alternative serialization.
+
+Using arbitrary objects as messages
+-----------------------------------
+
+In the preceding sections and examples, it has been assumed that the message
+passed when logging the event is a string. However, this is not the only
+possibility. You can pass an arbitrary object as a message, and its
+:meth:`__str__` method will be called when the logging system needs to convert
+it to a string representation. In fact, if you want to, you can avoid
+computing a string representation altogether - for example, the
+:class:`SocketHandler` emits an event by pickling it and sending it over the
+wire.
+
+Optimization
+------------
+
+Formatting of message arguments is deferred until it cannot be avoided.
+However, computing the arguments passed to the logging method can also be
+expensive, and you may want to avoid doing it if the logger will just throw
+away your event. To decide what to do, you can call the :meth:`isEnabledFor`
+method which takes a level argument and returns true if the event would be
+created by the Logger for that level of call. You can write code like this::
+
+    if logger.isEnabledFor(logging.DEBUG):
+        logger.debug("Message with %s, %s", expensive_func1(),
+                                            expensive_func2())
+
+so that if the logger's threshold is set above ``DEBUG``, the calls to
+:func:`expensive_func1` and :func:`expensive_func2` are never made.
+
+There are other optimizations which can be made for specific applications which
+need more precise control over what logging information is collected. Here's a
+list of things you can do to avoid processing during logging which you don't
+need:
+
++-----------------------------------------------+----------------------------------------+
+| What you don't want to collect                | How to avoid collecting it             |
++===============================================+========================================+
+| Information about where calls were made from. | Set ``logging._srcfile`` to ``None``.  |
++-----------------------------------------------+----------------------------------------+
+| Threading information.                        | Set ``logging.logThreads`` to ``0``.   |
++-----------------------------------------------+----------------------------------------+
+| Process information.                          | Set ``logging.logProcesses`` to ``0``. |
++-----------------------------------------------+----------------------------------------+
+
+Also note that the core logging module only includes the basic handlers. If
+you don't import :mod:`logging.handlers` and :mod:`logging.config`, they won't
+take up any memory.
+
+.. _handler:
 
 Handler Objects
 ---------------
 
 Handlers have the following attributes and methods. Note that :class:`Handler`
 is never instantiated directly; this class acts as a base for more useful
 subclasses. However, the :meth:`__init__` method in subclasses needs to call
 :meth:`Handler.__init__`.
 
 
 .. method:: Handler.__init__(level=NOTSET)
 
@@ -1540,87 +1659,96 @@
 
    Do formatting for a record - if a formatter is set, use it. Otherwise, use the
    default formatter for the module.
 
 
 .. method:: Handler.emit(record)
 
    Do whatever it takes to actually log the specified logging record. This version
    is intended to be implemented by subclasses and so raises a
    :exc:`NotImplementedError`.
 
 
+.. _stream-handler:
+
 StreamHandler
 ^^^^^^^^^^^^^
 
-.. module:: logging.handlers
-
 The :class:`StreamHandler` class, located in the core :mod:`logging` package,
 sends logging output to streams such as *sys.stdout*, *sys.stderr* or any
 file-like object (or, more precisely, any object which supports :meth:`write`
 and :meth:`flush` methods).
 
 
+.. currentmodule:: logging
+
 .. class:: StreamHandler([strm])
 
    Returns a new instance of the :class:`StreamHandler` class. If *strm* is
    specified, the instance will use it for logging output; otherwise, *sys.stderr*
    will be used.
 
 
    .. method:: emit(record)
 
       If a formatter is specified, it is used to format the record. The record
       is then written to the stream with a trailing newline. If exception
       information is present, it is formatted using
       :func:`traceback.print_exception` and appended to the stream.
 
 
    .. method:: flush()
 
       Flushes the stream by calling its :meth:`flush` method. Note that the
       :meth:`close` method is inherited from :class:`Handler` and so does
       no output, so an explicit :meth:`flush` call may be needed at times.
 
 
+.. _file-handler:
+
 FileHandler
 ^^^^^^^^^^^
 
 The :class:`FileHandler` class, located in the core :mod:`logging` package,
 sends logging output to a disk file.  It inherits the output functionality from
 :class:`StreamHandler`.
 
 
 .. class:: FileHandler(filename[, mode[, encoding[, delay]]])
 
    Returns a new instance of the :class:`FileHandler` class. The specified file is
    opened and used as the stream for logging. If *mode* is not specified,
    :const:`'a'` is used.  If *encoding* is not *None*, it is used to open the file
    with that encoding.  If *delay* is true, then file opening is deferred until the
    first call to :meth:`emit`. By default, the file grows indefinitely.
 
+   .. versionchanged:: 2.6
+      *delay* was added.
 
    .. method:: close()
 
       Closes the file.
 
 
    .. method:: emit(record)
 
       Outputs the record to the file.
 
+.. _null-handler:
 
 See :ref:`library-config` for more information on how to use
 :class:`NullHandler`.
 
+.. _watched-file-handler:
+
 WatchedFileHandler
 ^^^^^^^^^^^^^^^^^^
 
 .. versionadded:: 2.6
 
 The :class:`WatchedFileHandler` class, located in the :mod:`logging.handlers`
 module, is a :class:`FileHandler` which watches the file it is logging to. If
 the file changes, it is closed and reopened using the file name.
 
 A file change can happen because of usage of programs such as *newsyslog* and
 *logrotate* which perform log file rotation. This handler, intended for use
 under Unix/Linux, watches the file to see if it has changed since the last emit.
@@ -1634,31 +1762,35 @@
 *ST_INO* is not supported under Windows; :func:`stat` always returns zero for
 this value.
 
 
 .. class:: WatchedFileHandler(filename[,mode[, encoding[, delay]]])
 
    Returns a new instance of the :class:`WatchedFileHandler` class. The specified
    file is opened and used as the stream for logging. If *mode* is not specified,
    :const:`'a'` is used.  If *encoding* is not *None*, it is used to open the file
    with that encoding.  If *delay* is true, then file opening is deferred until the
    first call to :meth:`emit`.  By default, the file grows indefinitely.
 
+   .. versionchanged:: 2.6
+      *delay* was added.
+
 
    .. method:: emit(record)
 
       Outputs the record to the file, but first checks to see if the file has
       changed.  If it has, the existing stream is flushed and closed and the
       file opened again, before outputting the record to the file.
 
+.. _rotating-file-handler:
 
 RotatingFileHandler
 ^^^^^^^^^^^^^^^^^^^
 
 The :class:`RotatingFileHandler` class, located in the :mod:`logging.handlers`
 module, supports rotation of disk log files.
 
 
 .. class:: RotatingFileHandler(filename[, mode[, maxBytes[, backupCount[, encoding[, delay]]]]])
 
    Returns a new instance of the :class:`RotatingFileHandler` class. The specified
    file is opened and used as the stream for logging. If *mode* is not specified,
@@ -1670,35 +1802,38 @@
    :dfn:`rollover` at a predetermined size. When the size is about to be exceeded,
    the file is closed and a new file is silently opened for output. Rollover occurs
    whenever the current log file is nearly *maxBytes* in length; if *maxBytes* is
    zero, rollover never occurs.  If *backupCount* is non-zero, the system will save
    old log files by appending the extensions ".1", ".2" etc., to the filename. For
    example, with a *backupCount* of 5 and a base file name of :file:`app.log`, you
    would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, up to
    :file:`app.log.5`. The file being written to is always :file:`app.log`.  When
    this file is filled, it is closed and renamed to :file:`app.log.1`, and if files
    :file:`app.log.1`, :file:`app.log.2`, etc.  exist, then they are renamed to
    :file:`app.log.2`, :file:`app.log.3` etc.  respectively.
 
+   .. versionchanged:: 2.6
+      *delay* was added.
 
    .. method:: doRollover()
 
       Does a rollover, as described above.
 
 
    .. method:: emit(record)
 
       Outputs the record to the file, catering for rollover as described
       previously.
 
+.. _timed-rotating-file-handler:
 
 TimedRotatingFileHandler
 ^^^^^^^^^^^^^^^^^^^^^^^^
 
 The :class:`TimedRotatingFileHandler` class, located in the
 :mod:`logging.handlers` module, supports rotation of disk log files at certain
 timed intervals.
 
 
 .. class:: TimedRotatingFileHandler(filename [,when [,interval [,backupCount[, encoding[, delay[, utc]]]]]])
 
    Returns a new instance of the :class:`TimedRotatingFileHandler` class. The
@@ -1720,43 +1855,55 @@
    +----------------+-----------------------+
    | ``'D'``        | Days                  |
    +----------------+-----------------------+
    | ``'W'``        | Week day (0=Monday)   |
    +----------------+-----------------------+
    | ``'midnight'`` | Roll over at midnight |
    +----------------+-----------------------+
 
    The system will save old log files by appending extensions to the filename.
    The extensions are date-and-time based, using the strftime format
    ``%Y-%m-%d_%H-%M-%S`` or a leading portion thereof, depending on the
    rollover interval.
+
+   When computing the next rollover time for the first time (when the handler
+   is created), the last modification time of an existing log file, or else
+   the current time, is used to compute when the next rotation will occur.
+
    If the *utc* argument is true, times in UTC will be used; otherwise
    local time is used.
 
    If *backupCount* is nonzero, at most *backupCount* files
    will be kept, and if more would be created when rollover occurs, the oldest
    one is deleted. The deletion logic uses the interval to determine which
    files to delete, so changing the interval may leave old files lying around.
 
+   If *delay* is true, then file opening is deferred until the first call to
+   :meth:`emit`.
+
+   .. versionchanged:: 2.6
+      *delay* was added.
 
    .. method:: doRollover()
 
       Does a rollover, as described above.
 
 
    .. method:: emit(record)
 
       Outputs the record to the file, catering for rollover as described above.
 
 
+.. _socket-handler:
+
 SocketHandler
 ^^^^^^^^^^^^^
 
 The :class:`SocketHandler` class, located in the :mod:`logging.handlers` module,
 sends logging output to a network socket. The base class uses a TCP socket.
 
 
 .. class:: SocketHandler(host, port)
 
    Returns a new instance of the :class:`SocketHandler` class intended to
    communicate with a remote machine whose address is given by *host* and *port*.
 
@@ -1785,31 +1932,38 @@
    .. method:: makeSocket()
 
       This is a factory method which allows subclasses to define the precise
       type of socket they want. The default implementation creates a TCP socket
       (:const:`socket.SOCK_STREAM`).
 
 
    .. method:: makePickle(record)
 
       Pickles the record's attribute dictionary in binary format with a length
       prefix, and returns it ready for transmission across the socket.
 
+      Note that pickles aren't completely secure. If you are concerned about
+      security, you may want to override this method to implement a more secure
+      mechanism. For example, you can sign pickles using HMAC and then verify
+      them on the receiving end, or alternatively you can disable unpickling of
+      global objects on the receiving end.
 
    .. method:: send(packet)
 
       Send a pickled string *packet* to the socket. This function allows for
       partial sends which can happen when the network is busy.
 
 
+.. _datagram-handler:
+
 DatagramHandler
 ^^^^^^^^^^^^^^^
 
 The :class:`DatagramHandler` class, located in the :mod:`logging.handlers`
 module, inherits from :class:`SocketHandler` to support sending logging messages
 over UDP sockets.
 
 
 .. class:: DatagramHandler(host, port)
 
    Returns a new instance of the :class:`DatagramHandler` class intended to
    communicate with a remote machine whose address is given by *host* and *port*.
@@ -1825,24 +1979,26 @@
 
    .. method:: makeSocket()
 
       The factory method of :class:`SocketHandler` is here overridden to create
       a UDP socket (:const:`socket.SOCK_DGRAM`).
 
 
    .. method:: send(s)
 
       Send a pickled string to a socket.
 
 
+.. _syslog-handler:
+
 SysLogHandler
 ^^^^^^^^^^^^^
 
 The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` module,
 supports sending logging messages to a remote or local Unix syslog.
 
 
 .. class:: SysLogHandler([address[, facility]])
 
    Returns a new instance of the :class:`SysLogHandler` class intended to
    communicate with a remote Unix machine whose address is given by *address* in
    the form of a ``(host, port)`` tuple.  If *address* is not specified,
@@ -1861,24 +2017,105 @@
    .. method:: emit(record)
 
       The record is formatted, and then sent to the syslog server. If exception
       information is present, it is *not* sent to the server.
 
 
    .. method:: encodePriority(facility, priority)
 
       Encodes the facility and priority into an integer. You can pass in strings
       or integers - if strings are passed, internal mapping dictionaries are
       used to convert them to integers.
 
+      The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and
+      mirror the values defined in the ``sys/syslog.h`` header file.
+
+      **Priorities**
+
+      +--------------------------+---------------+
+      | Name (string)            | Symbolic value|
+      +==========================+===============+
+      | ``alert``                | LOG_ALERT     |
+      +--------------------------+---------------+
+      | ``crit`` or ``critical`` | LOG_CRIT      |
+      +--------------------------+---------------+
+      | ``debug``                | LOG_DEBUG     |
+      +--------------------------+---------------+
+      | ``emerg`` or ``panic``   | LOG_EMERG     |
+      +--------------------------+---------------+
+      | ``err`` or ``error``     | LOG_ERR       |
+      +--------------------------+---------------+
+      | ``info``                 | LOG_INFO      |
+      +--------------------------+---------------+
+      | ``notice``               | LOG_NOTICE    |
+      +--------------------------+---------------+
+      | ``warn`` or ``warning``  | LOG_WARNING   |
+      +--------------------------+---------------+
+
+      **Facilities**
+
+      +---------------+---------------+
+      | Name (string) | Symbolic value|
+      +===============+===============+
+      | ``auth``      | LOG_AUTH      |
+      +---------------+---------------+
+      | ``authpriv``  | LOG_AUTHPRIV  |
+      +---------------+---------------+
+      | ``cron``      | LOG_CRON      |
+      +---------------+---------------+
+      | ``daemon``    | LOG_DAEMON    |
+      +---------------+---------------+
+      | ``ftp``       | LOG_FTP       |
+      +---------------+---------------+
+      | ``kern``      | LOG_KERN      |
+      +---------------+---------------+
+      | ``lpr``       | LOG_LPR       |
+      +---------------+---------------+
+      | ``mail``      | LOG_MAIL      |
+      +---------------+---------------+
+      | ``news``      | LOG_NEWS      |
+      +---------------+---------------+
+      | ``syslog``    | LOG_SYSLOG    |
+      +---------------+---------------+
+      | ``user``      | LOG_USER      |
+      +---------------+---------------+
+      | ``uucp``      | LOG_UUCP      |
+      +---------------+---------------+
+      | ``local0``    | LOG_LOCAL0    |
+      +---------------+---------------+
+      | ``local1``    | LOG_LOCAL1    |
+      +---------------+---------------+
+      | ``local2``    | LOG_LOCAL2    |
+      +---------------+---------------+
+      | ``local3``    | LOG_LOCAL3    |
+      +---------------+---------------+
+      | ``local4``    | LOG_LOCAL4    |
+      +---------------+---------------+
+      | ``local5``    | LOG_LOCAL5    |
+      +---------------+---------------+
+      | ``local6``    | LOG_LOCAL6    |
+      +---------------+---------------+
+      | ``local7``    | LOG_LOCAL7    |
+      +---------------+---------------+
+
+   .. method:: mapPriority(levelname)
+
+      Maps a logging level name to a syslog priority name.
+      You may need to override this if you are using custom levels, or
+      if the default algorithm is not suitable for your needs. The
+      default algorithm maps ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` and
+      ``CRITICAL`` to the equivalent syslog names, and all other level
+      names to "warning".
+
+.. _nt-eventlog-handler:
 
 NTEventLogHandler
 ^^^^^^^^^^^^^^^^^
 
 The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers`
 module, supports sending logging messages to a local Windows NT, Windows 2000 or
 Windows XP event log. Before you can use it, you need Mark Hammond's Win32
 extensions for Python installed.
 
 
 .. class:: NTEventLogHandler(appname[, dllname[, logtype]])
 
@@ -1927,24 +2164,25 @@
       your own levels, you will either need to override this method or place a
       suitable dictionary in the handler's *typemap* attribute.
 
 
    .. method:: getMessageID(record)
 
       Returns the message ID for the record. If you are using your own messages,
       you could do this by having the *msg* passed to the logger being an ID
       rather than a format string. Then, in here, you could use a dictionary
       lookup to get the message ID. This version returns 1, which is the base
       message ID in :file:`win32service.pyd`.
 
+.. _smtp-handler:
 
 SMTPHandler
 ^^^^^^^^^^^
 
 The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` module,
 supports sending logging messages to an email address via SMTP.
 
 
 .. class:: SMTPHandler(mailhost, fromaddr, toaddrs, subject[, credentials])
 
    Returns a new instance of the :class:`SMTPHandler` class. The instance is
    initialized with the from and to addresses and subject line of the email. The
@@ -1958,24 +2196,25 @@
 
 
    .. method:: emit(record)
 
       Formats the record and sends it to the specified addressees.
 
 
    .. method:: getSubject(record)
 
       If you want to specify a subject line which is record-dependent, override
       this method.
 
+.. _memory-handler:
 
 MemoryHandler
 ^^^^^^^^^^^^^
 
 The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` module,
 supports buffering of logging records in memory, periodically flushing them to a
 :dfn:`target` handler. Flushing occurs whenever the buffer is full, or when an
 event of a certain severity or greater is seen.
 
 :class:`MemoryHandler` is a subclass of the more general
 :class:`BufferingHandler`, which is an abstract class. This buffers logging
 records in memory. Whenever each record is added to the buffer, a check is made
@@ -2028,63 +2267,65 @@
 
 
    .. method:: setTarget(target)
 
       Sets the target handler for this handler.
 
 
    .. method:: shouldFlush(record)
 
       Checks for buffer full or a record at the *flushLevel* or higher.
 
 
+.. _http-handler:
+
 HTTPHandler
 ^^^^^^^^^^^
 
 The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` module,
 supports sending logging messages to a Web server, using either ``GET`` or
 ``POST`` semantics.
 
 
 .. class:: HTTPHandler(host, url[, method])
 
    Returns a new instance of the :class:`HTTPHandler` class. The instance is
    initialized with a host address, url and HTTP method. The *host* can be of the
    form ``host:port``, should you need to use a specific port number. If no
    *method* is specified, ``GET`` is used.
 
 
    .. method:: emit(record)
 
       Sends the record to the Web server as an URL-encoded dictionary.
 
 
-.. _formatter-objects:
+.. _formatter:
 
 Formatter Objects
 -----------------
 
 .. currentmodule:: logging
 
 :class:`Formatter`\ s have the following attributes and methods. They are
 responsible for converting a :class:`LogRecord` to (usually) a string which can
 be interpreted by either a human or an external system. The base
 :class:`Formatter` allows a formatting string to be specified. If none is
 supplied, the default value of ``'%(message)s'`` is used.
 
 A Formatter can be initialized with a format string which makes use of knowledge
 of the :class:`LogRecord` attributes - such as the default value mentioned above
 making use of the fact that the user's message and arguments are pre-formatted
 into a :class:`LogRecord`'s *message* attribute.  This format string contains
-standard python %-style mapping keys. See section :ref:`string-formatting`
+standard Python %-style mapping keys. See section :ref:`string-formatting`
 for more information on string formatting.
 
 Currently, the useful mapping keys in a :class:`LogRecord` are:
 
 +-------------------------+-----------------------------------------------+
 | Format                  | Description                                   |
 +=========================+===============================================+
 | ``%(name)s``            | Name of the logger (logging channel).         |
 +-------------------------+-----------------------------------------------+
 | ``%(levelno)s``         | Numeric logging level for the message         |
 |                         | (:const:`DEBUG`, :const:`INFO`,               |
 |                         | :const:`WARNING`, :const:`ERROR`,             |
@@ -2173,49 +2414,51 @@
       :func:`time.strftime` to format the creation time of the
       record. Otherwise, the ISO8601 format is used.  The resulting string is
       returned.
 
 
    .. method:: formatException(exc_info)
 
       Formats the specified exception information (a standard exception tuple as
       returned by :func:`sys.exc_info`) as a string. This default implementation
       just uses :func:`traceback.print_exception`. The resulting string is
       returned.
 
+.. _filter:
 
 Filter Objects
 --------------
 
-:class:`Filter`\ s can be used by :class:`Handler`\ s and :class:`Logger`\ s for
+Filters can be used by :class:`Handler`\ s and :class:`Logger`\ s for
 more sophisticated filtering than is provided by levels. The base filter class
 only allows events which are below a certain point in the logger hierarchy. For
 example, a filter initialized with "A.B" will allow events logged by loggers
 "A.B", "A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If
 initialized with the empty string, all events are passed.
 
 
 .. class:: Filter([name])
 
    Returns an instance of the :class:`Filter` class. If *name* is specified, it
    names a logger which, together with its children, will have its events allowed
    through the filter. If no name is specified, allows every event.
 
 
    .. method:: filter(record)
 
       Is the specified record to be logged? Returns zero for no, nonzero for
       yes. If deemed appropriate, the record may be modified in-place by this
       method.
 
+.. _log-record:
 
 LogRecord Objects
 -----------------
 
 :class:`LogRecord` instances are created every time something is logged. They
 contain all the information pertinent to the event being logged. The main
 information passed in is in msg and args, which are combined using msg % args to
 create the message field of the record. The record also includes information
 such as when the record was created, the source line where the logging call was
 made, and any exception information to be logged.
 
 
@@ -2232,24 +2475,25 @@
    the name of the function from which the logging call was made. If not
    specified, it defaults to ``None``.
 
    .. versionchanged:: 2.5
       *func* was added.
 
 
    .. method:: getMessage()
 
       Returns the message for this :class:`LogRecord` instance after merging any
       user-supplied arguments with the message.
 
+.. _logger-adapter:
 
 LoggerAdapter Objects
 ---------------------
 
 .. versionadded:: 2.6
 
 :class:`LoggerAdapter` instances are used to conveniently pass contextual
 information into logging calls. For a usage example , see the section on
 `adding contextual information to your logging output`__.
 
 __ context-info_
 
@@ -2272,24 +2516,28 @@
 methods have the same signatures as their counterparts in :class:`Logger`, so
 you can use the two types of instances interchangeably.
 
 
 Thread Safety
 -------------
 
 The logging module is intended to be thread-safe without any special work
 needing to be done by its clients. It achieves this though using threading
 locks; there is one lock to serialize access to the module's shared data, and
 each handler also creates a lock to serialize access to its underlying I/O.
 
+If you are implementing asynchronous signal handlers using the :mod:`signal`
+module, you may not be able to use logging from within such handlers. This is
+because lock implementations in the :mod:`threading` module are not always
+re-entrant, and so cannot be invoked from such signal handlers.
 
 Configuration
 -------------
 
 
 .. _logging-config-api:
 
 Configuration functions
 ^^^^^^^^^^^^^^^^^^^^^^^
 
 The following functions configure the logging module. They are located in the
 :mod:`logging.config` module.  Their use is optional --- you can configure the
@@ -2327,35 +2575,35 @@
 
    Stops the listening server which was created with a call to :func:`listen`.
    This is typically called before calling :meth:`join` on the return value from
    :func:`listen`.
 
 
 .. _logging-config-fileformat:
 
 Configuration file format
 ^^^^^^^^^^^^^^^^^^^^^^^^^
 
 The configuration file format understood by :func:`fileConfig` is based on
-ConfigParser functionality. The file must contain sections called ``[loggers]``,
-``[handlers]`` and ``[formatters]`` which identify by name the entities of each
-type which are defined in the file. For each such entity, there is a separate
-section which identified how that entity is configured. Thus, for a logger named
-``log01`` in the ``[loggers]`` section, the relevant configuration details are
-held in a section ``[logger_log01]``. Similarly, a handler called ``hand01`` in
-the ``[handlers]`` section will have its configuration held in a section called
-``[handler_hand01]``, while a formatter called ``form01`` in the
-``[formatters]`` section will have its configuration specified in a section
-called ``[formatter_form01]``. The root logger configuration must be specified
-in a section called ``[logger_root]``.
+:mod:`ConfigParser` functionality. The file must contain sections called
+``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name the
+entities of each type which are defined in the file. For each such entity,
+there is a separate section which identifies how that entity is configured.
+Thus, for a logger named ``log01`` in the ``[loggers]`` section, the relevant
+configuration details are held in a section ``[logger_log01]``. Similarly, a
+handler called ``hand01`` in the ``[handlers]`` section will have its
+configuration held in a section called ``[handler_hand01]``, while a formatter
+called ``form01`` in the ``[formatters]`` section will have its configuration
+specified in a section called ``[formatter_form01]``. The root logger
+configuration must be specified in a section called ``[logger_root]``.
 
 Examples of these sections in the file are given below. ::
 
    [loggers]
    keys=root,log02,log03,log04,log05,log06,log07
 
    [handlers]
    keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09
 
    [formatters]
    keys=form01,form02,form03,form04,form05,form06,form07,form08,form09
 

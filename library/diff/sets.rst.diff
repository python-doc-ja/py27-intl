--- rest25/library/sets.rst	2008-12-19 16:58:08.000000000 +0900
+++ rest262/library/sets.rst	2009-04-05 05:02:09.000000000 +0900
@@ -1,26 +1,30 @@
 
 :mod:`sets` --- Unordered collections of unique elements
 ========================================================
 
 .. module:: sets
    :synopsis: Implementation of sets of unique elements.
+   :deprecated:
 .. moduleauthor:: Greg V. Wilson <gvwilson@nevex.com>
 .. moduleauthor:: Alex Martelli <aleax@aleax.it>
 .. moduleauthor:: Guido van Rossum <guido@python.org>
 .. sectionauthor:: Raymond D. Hettinger <python@rcn.com>
 
 
 .. versionadded:: 2.3
 
+.. deprecated:: 2.6
+   The built-in ``set``/``frozenset`` types replace this module.
+
 The :mod:`sets` module provides classes for constructing and manipulating
 unordered collections of unique elements.  Common uses include membership
 testing, removing duplicates from a sequence, and computing standard math
 operations on sets such as intersection, union, difference, and symmetric
 difference.
 
 Like other collections, sets support ``x in set``, ``len(set)``, and ``for x in
 set``.  Being an unordered collection, sets do not record element position or
 order of insertion.  Accordingly, sets do not support indexing, slicing, or
 other sequence-like behavior.
 
 Most set applications use the :class:`Set` class which provides every set method
@@ -76,34 +80,34 @@
 +-------------------------------+------------+---------------------------------+
 | ``x in s``                    |            | test *x* for membership in *s*  |
 +-------------------------------+------------+---------------------------------+
 | ``x not in s``                |            | test *x* for non-membership in  |
 |                               |            | *s*                             |
 +-------------------------------+------------+---------------------------------+
 | ``s.issubset(t)``             | ``s <= t`` | test whether every element in   |
 |                               |            | *s* is in *t*                   |
 +-------------------------------+------------+---------------------------------+
 | ``s.issuperset(t)``           | ``s >= t`` | test whether every element in   |
 |                               |            | *t* is in *s*                   |
 +-------------------------------+------------+---------------------------------+
-| ``s.union(t)``                | *s* \| *t* | new set with elements from both |
+| ``s.union(t)``                | ``s | t``  | new set with elements from both |
 |                               |            | *s* and *t*                     |
 +-------------------------------+------------+---------------------------------+
-| ``s.intersection(t)``         | *s* & *t*  | new set with elements common to |
+| ``s.intersection(t)``         | ``s & t``  | new set with elements common to |
 |                               |            | *s* and *t*                     |
 +-------------------------------+------------+---------------------------------+
-| ``s.difference(t)``           | *s* - *t*  | new set with elements in *s*    |
+| ``s.difference(t)``           | ``s - t``  | new set with elements in *s*    |
 |                               |            | but not in *t*                  |
 +-------------------------------+------------+---------------------------------+
-| ``s.symmetric_difference(t)`` | *s* ^ *t*  | new set with elements in either |
+| ``s.symmetric_difference(t)`` | ``s ^ t``  | new set with elements in either |
 |                               |            | *s* or *t* but not both         |
 +-------------------------------+------------+---------------------------------+
 | ``s.copy()``                  |            | new set with a shallow copy of  |
 |                               |            | *s*                             |
 +-------------------------------+------------+---------------------------------+
 
 Note, the non-operator versions of :meth:`union`, :meth:`intersection`,
 :meth:`difference`, and :meth:`symmetric_difference` will accept any iterable as
 an argument. In contrast, their operator based counterparts require their
 arguments to be sets.  This precludes error-prone constructions like
 ``Set('abc') & 'cbs'`` in favor of the more readable
 ``Set('abc').intersection('cbs')``.
@@ -179,63 +183,61 @@
 
 Also note, the module also includes a :meth:`union_update` method which is an
 alias for :meth:`update`.  The method is included for backwards compatibility.
 Programmers should prefer the :meth:`update` method because it is supported by
 the builtin :class:`set()` and :class:`frozenset()` types.
 
 
 .. _set-example:
 
 Example
 -------
 
-::
-
    >>> from sets import Set
    >>> engineers = Set(['John', 'Jane', 'Jack', 'Janice'])
    >>> programmers = Set(['Jack', 'Sam', 'Susan', 'Janice'])
    >>> managers = Set(['Jane', 'Jack', 'Susan', 'Zack'])
    >>> employees = engineers | programmers | managers           # union
    >>> engineering_management = engineers & managers            # intersection
    >>> fulltime_management = managers - engineers - programmers # difference
    >>> engineers.add('Marvin')                                  # add element
-   >>> print engineers
+   >>> print engineers # doctest: +SKIP
    Set(['Jane', 'Marvin', 'Janice', 'John', 'Jack'])
-   >>> employees.issuperset(engineers)           # superset test
+   >>> employees.issuperset(engineers)     # superset test
    False
-   >>> employees.union_update(engineers)         # update from another set
+   >>> employees.update(engineers)         # update from another set
    >>> employees.issuperset(engineers)
    True
-   >>> for group in [engineers, programmers, managers, employees]:
-   ...     group.discard('Susan')                # unconditionally remove element
+   >>> for group in [engineers, programmers, managers, employees]: # doctest: +SKIP
+   ...     group.discard('Susan')          # unconditionally remove element
    ...     print group
    ...
    Set(['Jane', 'Marvin', 'Janice', 'John', 'Jack'])
    Set(['Janice', 'Jack', 'Sam'])
    Set(['Jane', 'Zack', 'Jack'])
    Set(['Jack', 'Sam', 'Jane', 'Marvin', 'Janice', 'John', 'Zack'])
 
 
 .. _immutable-transforms:
 
 Protocol for automatic conversion to immutable
 ----------------------------------------------
 
 Sets can only contain immutable elements.  For convenience, mutable :class:`Set`
 objects are automatically copied to an :class:`ImmutableSet` before being added
 as a set element.
 
-The mechanism is to always add a hashable element, or if it is not hashable, the
-element is checked to see if it has an :meth:`__as_immutable__` method which
-returns an immutable equivalent.
+The mechanism is to always add a :term:`hashable` element, or if it is not
+hashable, the element is checked to see if it has an :meth:`__as_immutable__`
+method which returns an immutable equivalent.
 
 Since :class:`Set` objects have a :meth:`__as_immutable__` method returning an
 instance of :class:`ImmutableSet`, it is possible to construct sets of sets.
 
 A similar mechanism is needed by the :meth:`__contains__` and :meth:`remove`
 methods which need to hash an element to check for membership in a set.  Those
 methods check an element for hashability and, if not, check for a
 :meth:`__as_temporarily_immutable__` method which returns the element wrapped by
 a class that provides temporary methods for :meth:`__hash__`, :meth:`__eq__`,
 and :meth:`__ne__`.
 
 The alternate mechanism spares the need to build a separate copy of the original
@@ -265,20 +267,20 @@
 
 * There is no equivalent to :class:`BaseSet`.  Instead, use ``isinstance(x,
   (set, frozenset))``.
 
 * The hash algorithm for the built-ins performs significantly better (fewer
   collisions) for most datasets.
 
 * The built-in versions have more space efficient pickles.
 
 * The built-in versions do not have a :meth:`union_update` method. Instead, use
   the :meth:`update` method which is equivalent.
 
-* The built-in versions do not have a :meth:`_repr(sorted=True)` method.
+* The built-in versions do not have a ``_repr(sorted=True)`` method.
   Instead, use the built-in :func:`repr` and :func:`sorted` functions:
   ``repr(sorted(s))``.
 
 * The built-in version does not have a protocol for automatic conversion to
   immutable.  Many found this feature to be confusing and no one in the community
   reported having found real uses for it.
 

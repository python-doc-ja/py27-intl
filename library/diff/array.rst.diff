--- rest25/library/array.rst	2008-12-19 16:58:07.000000000 +0900
+++ rest262/library/array.rst	2009-04-05 05:02:09.000000000 +0900
@@ -1,23 +1,23 @@
 
 :mod:`array` --- Efficient arrays of numeric values
 ===================================================
 
 .. module:: array
-   :synopsis: Efficient arrays of uniformly typed numeric values.
+   :synopsis: Space efficient arrays of uniformly typed numeric values.
 
 
 .. index:: single: arrays
 
-This module defines an object type which can efficiently represent an array of
+This module defines an object type which can compactly represent an array of
 basic values: characters, integers, floating point numbers.  Arrays are sequence
 types and behave very much like lists, except that the type of objects stored in
 them is constrained.  The type is specified at object creation time by using a
 :dfn:`type code`, which is a single character.  The following type codes are
 defined:
 
 +-----------+----------------+-------------------+-----------------------+
 | Type code | C Type         | Python Type       | Minimum size in bytes |
 +===========+================+===================+=======================+
 | ``'c'``   | char           | character         | 1                     |
 +-----------+----------------+-------------------+-----------------------+
 | ``'b'``   | signed char    | int               | 1                     |
@@ -103,26 +103,25 @@
    memory buffer in bytes can be computed as ``array.buffer_info()[1] *
    array.itemsize``.  This is occasionally useful when working with low-level (and
    inherently unsafe) I/O interfaces that require memory addresses, such as certain
    :cfunc:`ioctl` operations.  The returned numbers are valid as long as the array
    exists and no length-changing operations are applied to it.
 
    .. note::
 
       When using array objects from code written in C or C++ (the only way to
       effectively make use of this information), it makes more sense to use the buffer
       interface supported by array objects.  This method is maintained for backward
       compatibility and should be avoided in new code.  The buffer interface is
-      documented in the Python/C API Reference Manual (XXX reference:
-      ../api/newTypes.html).
+      documented in :ref:`bufferobjects`.
 
 
 .. method:: array.byteswap()
 
    "Byteswap" all items of the array.  This is only supported for values which are
    1, 2, 4, or 8 bytes in size; for other types of values, :exc:`RuntimeError` is
    raised.  It is useful when reading data from a file written on a machine with a
    different byte order.
 
 
 .. method:: array.count(x)
 
@@ -154,28 +153,28 @@
    Append items from the list.  This is equivalent to ``for x in list:
    a.append(x)`` except that if there is a type error, the array is unchanged.
 
 
 .. method:: array.fromstring(s)
 
    Appends items from the string, interpreting the string as an array of machine
    values (as if it had been read from a file using the :meth:`fromfile` method).
 
 
 .. method:: array.fromunicode(s)
 
-   Extends this array with data from the given unicode string.  The array must be a
-   type ``'u'`` array; otherwise a :exc:`ValueError` is raised.  Use
-   ``array.fromstring(ustr.decode(enc))`` to append Unicode data to an array of
-   some other type.
+   Extends this array with data from the given unicode string.  The array must
+   be a type ``'u'`` array; otherwise a :exc:`ValueError` is raised.  Use
+   ``array.fromstring(unicodestring.encode(enc))`` to append Unicode data to an
+   array of some other type.
 
 
 .. method:: array.index(x)
 
    Return the smallest *i* such that *i* is the index of the first occurrence of
    *x* in the array.
 
 
 .. method:: array.insert(i, x)
 
    Insert a new item with value *x* in the array before position *i*. Negative
    values are treated as being relative to the end of the array.
@@ -236,38 +235,38 @@
 
 .. method:: array.write(f)
 
    .. deprecated:: 1.5.1
       Use the :meth:`tofile` method.
 
    Write all items (as machine values) to the file object *f*.
 
 When an array object is printed or converted to a string, it is represented as
 ``array(typecode, initializer)``.  The *initializer* is omitted if the array is
 empty, otherwise it is a string if the *typecode* is ``'c'``, otherwise it is a
 list of numbers.  The string is guaranteed to be able to be converted back to an
-array with the same type and value using reverse quotes (``````), so long as the
+array with the same type and value using :func:`eval`, so long as the
 :func:`array` function has been imported using ``from array import array``.
 Examples::
 
    array('l')
    array('c', 'hello world')
-   array('u', u'hello \textbackslash u2641')
+   array('u', u'hello \u2641')
    array('l', [1, 2, 3, 4, 5])
    array('d', [1.0, 2.0, 3.14])
 
 
 .. seealso::
 
    Module :mod:`struct`
       Packing and unpacking of heterogeneous binary data.
 
    Module :mod:`xdrlib`
       Packing and unpacking of External Data Representation (XDR) data as used in some
       remote procedure call systems.
 
    `The Numerical Python Manual <http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm>`_
       The Numeric Python extension (NumPy) defines another array type; see
-      `<http://numpy.sourceforge.net/>`_ for further information about Numerical
-      Python.  (A PDF version of the NumPy manual is available at
-      `<http://numpy.sourceforge.net/numdoc/numdoc.pdf>`_).
+      http://numpy.sourceforge.net/ for further information about Numerical Python.
+      (A PDF version of the NumPy manual is available at
+      http://numpy.sourceforge.net/numdoc/numdoc.pdf).
 

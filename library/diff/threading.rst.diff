--- r262/library/threading.rst	2009-04-06 06:48:06.719229000 +0900
+++ r266/library/threading.rst	2010-08-02 07:26:02.314226000 +0900
@@ -5,44 +5,44 @@
    :synopsis: Higher-level threading interface.
 
 
 This module constructs higher-level threading interfaces on top of the  lower
 level :mod:`thread` module.
 See also the :mod:`mutex` and :mod:`Queue` modules.
 
 The :mod:`dummy_threading` module is provided for situations where
 :mod:`threading` cannot be used because :mod:`thread` is missing.
 
 .. note::
 
-   Starting with Python 2.6, this module provides PEP 8 compliant aliases and
+   Starting with Python 2.6, this module provides :pep:`8` compliant aliases and
    properties to replace the ``camelCase`` names that were inspired by Java's
    threading API. This updated API is compatible with that of the
    :mod:`multiprocessing` module. However, no schedule has been set for the
    deprecation of the ``camelCase`` names and they remain fully supported in
    both Python 2.x and 3.x.
 
 .. note::
 
    Starting with Python 2.5, several Thread methods raise :exc:`RuntimeError`
    instead of :exc:`AssertionError` if called erroneously.
 
 
 This module defines the following functions and objects:
 
 .. function:: active_count()
               activeCount()
 
    Return the number of :class:`Thread` objects currently alive.  The returned
-   count is equal to the length of the list returned by :func:`enumerate`.
+   count is equal to the length of the list returned by :func:`.enumerate`.
 
 
 .. function:: Condition()
    :noindex:
 
    A factory function that returns a new condition variable object. A condition
    variable allows one or more threads to wait until they are notified by another
    thread.
 
 
 .. function:: current_thread()
               currentThread()
@@ -56,26 +56,27 @@
 .. function:: enumerate()
 
    Return a list of all :class:`Thread` objects currently alive.  The list
    includes daemonic threads, dummy thread objects created by
    :func:`current_thread`, and the main thread.  It excludes terminated threads
    and threads that have not yet been started.
 
 
 .. function:: Event()
    :noindex:
 
    A factory function that returns a new event object.  An event manages a flag
-   that can be set to true with the :meth:`set` method and reset to false with the
-   :meth:`clear` method.  The :meth:`wait` method blocks until the flag is true.
+   that can be set to true with the :meth:`~Event.set` method and reset to false
+   with the :meth:`clear` method.  The :meth:`wait` method blocks until the flag
+   is true.
 
 
 .. class:: local
 
    A class that represents thread-local data.  Thread-local data are data whose
    values are thread specific.  To manage thread-local data, just create an
    instance of :class:`local` (or a subclass) and store attributes on it::
 
       mydata = threading.local()
       mydata.x = 1
 
    The instance's values will be different for separate threads.
@@ -221,138 +222,131 @@
 control in the Python program.  It is not a daemon thread.
 
 There is the possibility that "dummy thread objects" are created. These are
 thread objects corresponding to "alien threads", which are threads of control
 started outside the threading module, such as directly from C code.  Dummy
 thread objects have limited functionality; they are always considered alive and
 daemonic, and cannot be :meth:`join`\ ed.  They are never deleted, since it is
 impossible to detect the termination of alien threads.
 
 
 .. class:: Thread(group=None, target=None, name=None, args=(), kwargs={})
 
-   This constructor should always be called with keyword arguments.  Arguments are:
+   This constructor should always be called with keyword arguments.  Arguments
+   are:
 
    *group* should be ``None``; reserved for future extension when a
    :class:`ThreadGroup` class is implemented.
 
    *target* is the callable object to be invoked by the :meth:`run` method.
    Defaults to ``None``, meaning nothing is called.
 
-   *name* is the thread name.  By default, a unique name is constructed of the form
-   "Thread-*N*" where *N* is a small decimal number.
+   *name* is the thread name.  By default, a unique name is constructed of the
+   form "Thread-*N*" where *N* is a small decimal number.
 
    *args* is the argument tuple for the target invocation.  Defaults to ``()``.
 
    *kwargs* is a dictionary of keyword arguments for the target invocation.
    Defaults to ``{}``.
 
-   If the subclass overrides the constructor, it must make sure to invoke the base
-   class constructor (``Thread.__init__()``) before doing anything else to the
-   thread.
-
-
-.. method:: Thread.start()
-
-   Start the thread's activity.
-
-   It must be called at most once per thread object.  It arranges for the object's
-   :meth:`run` method to be invoked in a separate thread of control.
-
-   This method will raise a :exc:`RuntimeException` if called more than once on the
-   same thread object.
+   If the subclass overrides the constructor, it must make sure to invoke the
+   base class constructor (``Thread.__init__()``) before doing anything else to
+   the thread.
 
+   .. method:: start()
 
-.. method:: Thread.run()
+      Start the thread's activity.
 
-   Method representing the thread's activity.
+      It must be called at most once per thread object.  It arranges for the
+      object's :meth:`run` method to be invoked in a separate thread of control.
 
-   You may override this method in a subclass.  The standard :meth:`run` method
-   invokes the callable object passed to the object's constructor as the *target*
-   argument, if any, with sequential and keyword arguments taken from the *args*
-   and *kwargs* arguments, respectively.
+      This method will raise a :exc:`RuntimeException` if called more than once
+      on the same thread object.
 
+   .. method:: run()
 
-.. method:: Thread.join([timeout])
+      Method representing the thread's activity.
 
-   Wait until the thread terminates. This blocks the calling thread until the
-   thread whose :meth:`join` method is called terminates -- either normally or
-   through an unhandled exception -- or until the optional timeout occurs.
+      You may override this method in a subclass.  The standard :meth:`run`
+      method invokes the callable object passed to the object's constructor as
+      the *target* argument, if any, with sequential and keyword arguments taken
+      from the *args* and *kwargs* arguments, respectively.
 
-   When the *timeout* argument is present and not ``None``, it should be a floating
-   point number specifying a timeout for the operation in seconds (or fractions
-   thereof). As :meth:`join` always returns ``None``, you must call :meth:`isAlive`
-   after :meth:`join` to decide whether a timeout happened -- if the thread is
-   still alive, the :meth:`join` call timed out.
+   .. method:: join([timeout])
 
-   When the *timeout* argument is not present or ``None``, the operation will block
-   until the thread terminates.
+      Wait until the thread terminates. This blocks the calling thread until the
+      thread whose :meth:`join` method is called terminates -- either normally
+      or through an unhandled exception -- or until the optional timeout occurs.
 
-   A thread can be :meth:`join`\ ed many times.
+      When the *timeout* argument is present and not ``None``, it should be a
+      floating point number specifying a timeout for the operation in seconds
+      (or fractions thereof). As :meth:`join` always returns ``None``, you must
+      call :meth:`isAlive` after :meth:`join` to decide whether a timeout
+      happened -- if the thread is still alive, the :meth:`join` call timed out.
 
-   :meth:`join` raises a :exc:`RuntimeError` if an attempt is made to join
-   the current thread as that would cause a deadlock. It is also an error to
-   :meth:`join` a thread before it has been started and attempts to do so
-   raises the same exception.
+      When the *timeout* argument is not present or ``None``, the operation will
+      block until the thread terminates.
 
+      A thread can be :meth:`join`\ ed many times.
 
-.. method:: Thread.getName()
-            Thread.setName()
+      :meth:`join` raises a :exc:`RuntimeError` if an attempt is made to join
+      the current thread as that would cause a deadlock. It is also an error to
+      :meth:`join` a thread before it has been started and attempts to do so
+      raises the same exception.
 
-   Old API for :attr:`~Thread.name`.
+   .. method:: getName()
+               setName()
 
+      Old API for :attr:`~Thread.name`.
 
-.. attribute:: Thread.name
+   .. attribute:: name
 
-   A string used for identification purposes only. It has no semantics.
-   Multiple threads may be given the same name.  The initial name is set by the
-   constructor.
+      A string used for identification purposes only. It has no semantics.
+      Multiple threads may be given the same name.  The initial name is set by
+      the constructor.
 
+   .. attribute:: ident
 
-.. attribute:: Thread.ident
+      The 'thread identifier' of this thread or ``None`` if the thread has not
+      been started.  This is a nonzero integer.  See the
+      :func:`thread.get_ident()` function.  Thread identifiers may be recycled
+      when a thread exits and another thread is created.  The identifier is
+      available even after the thread has exited.
 
-   The 'thread identifier' of this thread or ``None`` if the thread has not been
-   started.  This is a nonzero integer.  See the :func:`thread.get_ident()`
-   function.  Thread identifiers may be recycled when a thread exits and another
-   thread is created.  The identifier is available even after the thread has
-   exited.
+      .. versionadded:: 2.6
 
-   .. versionadded:: 2.6
+   .. method:: is_alive()
+               isAlive()
 
+      Return whether the thread is alive.
 
-.. method:: Thread.is_alive()
-            Thread.isAlive()
+      This method returns ``True`` just before the :meth:`run` method starts
+      until just after the :meth:`run` method terminates.  The module function
+      :func:`.enumerate` returns a list of all alive threads.
 
-   Return whether the thread is alive.
+   .. method:: isDaemon()
+               setDaemon()
 
-   Roughly, a thread is alive from the moment the :meth:`start` method returns
-   until its :meth:`run` method terminates. The module function :func:`enumerate`
-   returns a list of all alive threads.
+      Old API for :attr:`~Thread.daemon`.
 
+   .. attribute:: daemon
 
-.. method:: Thread.isDaemon()
-            Thread.setDaemon()
+      A boolean value indicating whether this thread is a daemon thread (True)
+      or not (False).  This must be set before :meth:`start` is called,
+      otherwise :exc:`RuntimeError` is raised.  Its initial value is inherited
+      from the creating thread; the main thread is not a daemon thread and
+      therefore all threads created in the main thread default to :attr:`daemon`
+      = ``False``.
 
-   Old API for :attr:`~Thread.daemon`.
-
-
-.. attribute:: Thread.daemon
-
-   A boolean value indicating whether this thread is a daemon thread (True) or
-   not (False).  This must be set before :meth:`start` is called, otherwise
-   :exc:`RuntimeError` is raised.  Its initial value is inherited from the
-   creating thread; the main thread is not a daemon thread and therefore all
-   threads created in the main thread default to :attr:`daemon` = ``False``.
-
-   The entire Python program exits when no alive non-daemon threads are left.
+      The entire Python program exits when no alive non-daemon threads are left.
 
 
 .. _lock-objects:
 
 Lock Objects
 ------------
 
 A primitive lock is a synchronization primitive that is not owned by a
 particular thread when locked.  In Python, it is currently the lowest level
 synchronization primitive available, implemented directly by the :mod:`thread`
 extension module.
 
@@ -505,138 +499,132 @@
    make_an_item_available()
    cv.notify()
    cv.release()
 
 To choose between :meth:`notify` and :meth:`notifyAll`, consider whether one
 state change can be interesting for only one or several waiting threads.  E.g.
 in a typical producer-consumer situation, adding one item to the buffer only
 needs to wake up one consumer thread.
 
 
 .. class:: Condition([lock])
 
-   If the *lock* argument is given and not ``None``, it must be a :class:`Lock` or
-   :class:`RLock` object, and it is used as the underlying lock.  Otherwise, a new
-   :class:`RLock` object is created and used as the underlying lock.
-
-
-.. method:: Condition.acquire(*args)
+   If the *lock* argument is given and not ``None``, it must be a :class:`Lock`
+   or :class:`RLock` object, and it is used as the underlying lock.  Otherwise,
+   a new :class:`RLock` object is created and used as the underlying lock.
 
-   Acquire the underlying lock. This method calls the corresponding method on the
-   underlying lock; the return value is whatever that method returns.
+   .. method:: acquire(*args)
 
+      Acquire the underlying lock. This method calls the corresponding method on
+      the underlying lock; the return value is whatever that method returns.
 
-.. method:: Condition.release()
+   .. method:: release()
 
-   Release the underlying lock. This method calls the corresponding method on the
-   underlying lock; there is no return value.
+      Release the underlying lock. This method calls the corresponding method on
+      the underlying lock; there is no return value.
 
+   .. method:: wait([timeout])
 
-.. method:: Condition.wait([timeout])
+      Wait until notified or until a timeout occurs. If the calling thread has not
+      acquired the lock when this method is called, a :exc:`RuntimeError` is raised.
 
-   Wait until notified or until a timeout occurs. If the calling thread has not
-   acquired the lock when this method is called, a :exc:`RuntimeError` is raised.
+      This method releases the underlying lock, and then blocks until it is
+      awakened by a :meth:`notify` or :meth:`notifyAll` call for the same
+      condition variable in another thread, or until the optional timeout
+      occurs.  Once awakened or timed out, it re-acquires the lock and returns.
 
-   This method releases the underlying lock, and then blocks until it is awakened
-   by a :meth:`notify` or :meth:`notifyAll` call for the same condition variable in
-   another thread, or until the optional timeout occurs.  Once awakened or timed
-   out, it re-acquires the lock and returns.
+      When the *timeout* argument is present and not ``None``, it should be a
+      floating point number specifying a timeout for the operation in seconds
+      (or fractions thereof).
 
-   When the *timeout* argument is present and not ``None``, it should be a floating
-   point number specifying a timeout for the operation in seconds (or fractions
-   thereof).
+      When the underlying lock is an :class:`RLock`, it is not released using
+      its :meth:`release` method, since this may not actually unlock the lock
+      when it was acquired multiple times recursively.  Instead, an internal
+      interface of the :class:`RLock` class is used, which really unlocks it
+      even when it has been recursively acquired several times. Another internal
+      interface is then used to restore the recursion level when the lock is
+      reacquired.
 
-   When the underlying lock is an :class:`RLock`, it is not released using its
-   :meth:`release` method, since this may not actually unlock the lock when it was
-   acquired multiple times recursively.  Instead, an internal interface of the
-   :class:`RLock` class is used, which really unlocks it even when it has been
-   recursively acquired several times. Another internal interface is then used to
-   restore the recursion level when the lock is reacquired.
+   .. method:: notify()
 
+      Wake up a thread waiting on this condition, if any.  If the calling thread
+      has not acquired the lock when this method is called, a
+      :exc:`RuntimeError` is raised.
 
-.. method:: Condition.notify()
+      This method wakes up one of the threads waiting for the condition
+      variable, if any are waiting; it is a no-op if no threads are waiting.
 
-   Wake up a thread waiting on this condition, if any. Wait until notified or until
-   a timeout occurs. If the calling thread has not acquired the lock when this
-   method is called, a :exc:`RuntimeError` is raised.
+      The current implementation wakes up exactly one thread, if any are
+      waiting.  However, it's not safe to rely on this behavior.  A future,
+      optimized implementation may occasionally wake up more than one thread.
 
-   This method wakes up one of the threads waiting for the condition variable, if
-   any are waiting; it is a no-op if no threads are waiting.
+      Note: the awakened thread does not actually return from its :meth:`wait`
+      call until it can reacquire the lock.  Since :meth:`notify` does not
+      release the lock, its caller should.
 
-   The current implementation wakes up exactly one thread, if any are waiting.
-   However, it's not safe to rely on this behavior.  A future, optimized
-   implementation may occasionally wake up more than one thread.
+   .. method:: notify_all()
+               notifyAll()
 
-   Note: the awakened thread does not actually return from its :meth:`wait` call
-   until it can reacquire the lock.  Since :meth:`notify` does not release the
-   lock, its caller should.
-
-
-.. method:: Condition.notify_all()
-            Condition.notifyAll()
-
-   Wake up all threads waiting on this condition.  This method acts like
-   :meth:`notify`, but wakes up all waiting threads instead of one. If the calling
-   thread has not acquired the lock when this method is called, a
-   :exc:`RuntimeError` is raised.
+      Wake up all threads waiting on this condition.  This method acts like
+      :meth:`notify`, but wakes up all waiting threads instead of one. If the
+      calling thread has not acquired the lock when this method is called, a
+      :exc:`RuntimeError` is raised.
 
 
 .. _semaphore-objects:
 
 Semaphore Objects
 -----------------
 
 This is one of the oldest synchronization primitives in the history of computer
 science, invented by the early Dutch computer scientist Edsger W. Dijkstra (he
 used :meth:`P` and :meth:`V` instead of :meth:`acquire` and :meth:`release`).
 
 A semaphore manages an internal counter which is decremented by each
 :meth:`acquire` call and incremented by each :meth:`release` call.  The counter
 can never go below zero; when :meth:`acquire` finds that it is zero, it blocks,
 waiting until some other thread calls :meth:`release`.
 
 
 .. class:: Semaphore([value])
 
    The optional argument gives the initial *value* for the internal counter; it
    defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is
    raised.
 
+   .. method:: acquire([blocking])
 
-.. method:: Semaphore.acquire([blocking])
-
-   Acquire a semaphore.
-
-   When invoked without arguments: if the internal counter is larger than zero on
-   entry, decrement it by one and return immediately.  If it is zero on entry,
-   block, waiting until some other thread has called :meth:`release` to make it
-   larger than zero.  This is done with proper interlocking so that if multiple
-   :meth:`acquire` calls are blocked, :meth:`release` will wake exactly one of them
-   up.  The implementation may pick one at random, so the order in which blocked
-   threads are awakened should not be relied on.  There is no return value in this
-   case.
-
-   When invoked with *blocking* set to true, do the same thing as when called
-   without arguments, and return true.
+      Acquire a semaphore.
 
-   When invoked with *blocking* set to false, do not block.  If a call without an
-   argument would block, return false immediately; otherwise, do the same thing as
-   when called without arguments, and return true.
-
-
-.. method:: Semaphore.release()
-
-   Release a semaphore, incrementing the internal counter by one.  When it was zero
-   on entry and another thread is waiting for it to become larger than zero again,
-   wake up that thread.
+      When invoked without arguments: if the internal counter is larger than
+      zero on entry, decrement it by one and return immediately.  If it is zero
+      on entry, block, waiting until some other thread has called
+      :meth:`release` to make it larger than zero.  This is done with proper
+      interlocking so that if multiple :meth:`acquire` calls are blocked,
+      :meth:`release` will wake exactly one of them up.  The implementation may
+      pick one at random, so the order in which blocked threads are awakened
+      should not be relied on.  There is no return value in this case.
+
+      When invoked with *blocking* set to true, do the same thing as when called
+      without arguments, and return true.
+
+      When invoked with *blocking* set to false, do not block.  If a call
+      without an argument would block, return false immediately; otherwise, do
+      the same thing as when called without arguments, and return true.
+
+   .. method:: release()
+
+      Release a semaphore, incrementing the internal counter by one.  When it
+      was zero on entry and another thread is waiting for it to become larger
+      than zero again, wake up that thread.
 
 
 .. _semaphore-examples:
 
 :class:`Semaphore` Example
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 Semaphores are often used to guard resources with limited capacity, for example,
 a database server.  In any situation where the size of the resource size is
 fixed, you should use a bounded semaphore.  Before spawning any worker threads,
 your main thread would initialize the semaphore::
 
@@ -657,61 +645,64 @@
 causes the semaphore to be released more than it's acquired will go undetected.
 
 
 .. _event-objects:
 
 Event Objects
 -------------
 
 This is one of the simplest mechanisms for communication between threads: one
 thread signals an event and other threads wait for it.
 
 An event object manages an internal flag that can be set to true with the
-:meth:`set` method and reset to false with the :meth:`clear` method.  The
+:meth:`~Event.set` method and reset to false with the :meth:`clear` method.  The
 :meth:`wait` method blocks until the flag is true.
 
 
 .. class:: Event()
 
    The internal flag is initially false.
 
+   .. method:: is_set()
+               isSet()
 
-.. method:: Event.is_set()
-            Event.isSet()
+      Return true if and only if the internal flag is true.
 
-   Return true if and only if the internal flag is true.
+      .. versionchanged:: 2.6
+         The ``is_set()`` syntax is new.
 
+   .. method:: set()
 
-.. method:: Event.set()
+      Set the internal flag to true. All threads waiting for it to become true
+      are awakened. Threads that call :meth:`wait` once the flag is true will
+      not block at all.
 
-   Set the internal flag to true. All threads waiting for it to become true are
-   awakened. Threads that call :meth:`wait` once the flag is true will not block at
-   all.
+   .. method:: clear()
 
+      Reset the internal flag to false. Subsequently, threads calling
+      :meth:`wait` will block until :meth:`.set` is called to set the internal
+      flag to true again.
 
-.. method:: Event.clear()
+   .. method:: wait([timeout])
 
-   Reset the internal flag to false. Subsequently, threads calling :meth:`wait`
-   will block until :meth:`set` is called to set the internal flag to true again.
+      Block until the internal flag is true.  If the internal flag is true on
+      entry, return immediately.  Otherwise, block until another thread calls
+      :meth:`.set` to set the flag to true, or until the optional timeout
+      occurs.
 
+      When the timeout argument is present and not ``None``, it should be a
+      floating point number specifying a timeout for the operation in seconds
+      (or fractions thereof).
 
-.. method:: Event.wait([timeout])
-
-   Block until the internal flag is true. If the internal flag is true on entry,
-   return immediately.  Otherwise, block until another thread calls :meth:`set` to
-   set the flag to true, or until the optional timeout occurs.
-
-   When the timeout argument is present and not ``None``, it should be a floating
-   point number specifying a timeout for the operation in seconds (or fractions
-   thereof).
+      This method always returns ``None``.
 
 
 .. _timer-objects:
 
 Timer Objects
 -------------
 
 This class represents an action that should be run only after a certain amount
 of time has passed --- a timer.  :class:`Timer` is a subclass of :class:`Thread`
 and as such also functions as an example of creating custom threads.
 
 Timers are started, as with threads, by calling their :meth:`start` method.  The
@@ -724,29 +715,28 @@
    def hello():
        print "hello, world"
 
    t = Timer(30.0, hello)
    t.start() # after 30 seconds, "hello, world" will be printed
 
 
 .. class:: Timer(interval, function, args=[], kwargs={})
 
    Create a timer that will run *function* with arguments *args* and  keyword
    arguments *kwargs*, after *interval* seconds have passed.
 
+   .. method:: cancel()
 
-.. method:: Timer.cancel()
-
-   Stop the timer, and cancel the execution of the timer's action.  This will only
-   work if the timer is still in its waiting stage.
+      Stop the timer, and cancel the execution of the timer's action.  This will
+      only work if the timer is still in its waiting stage.
 
 
 .. _with-locks:
 
 Using locks, conditions, and semaphores in the :keyword:`with` statement
 ------------------------------------------------------------------------
 
 All of the objects provided by this module that have :meth:`acquire` and
 :meth:`release` methods can be used as context managers for a :keyword:`with`
 statement.  The :meth:`acquire` method will be called when the block is entered,
 and :meth:`release` will be called when the block is exited.
 

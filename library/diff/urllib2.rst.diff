--- r262/library/urllib2.rst	2009-02-23 19:41:11.107573000 +0900
+++ r266/library/urllib2.rst	2010-08-02 06:48:47.574872000 +0900
@@ -34,34 +34,37 @@
    returns a string in this format.
 
    The optional *timeout* parameter specifies a timeout in seconds for blocking
    operations like the connection attempt (if not specified, the global default
    timeout setting will be used).  This actually only works for HTTP, HTTPS,
    FTP and FTPS connections.
 
    This function returns a file-like object with two additional methods:
 
    * :meth:`geturl` --- return the URL of the resource retrieved, commonly used to
      determine if a redirect was followed
 
-   * :meth:`info` --- return the meta-information of the page, such as headers, in
-     the form of an ``httplib.HTTPMessage`` instance
+   * :meth:`info` --- return the meta-information of the page, such as headers,
+     in the form of an :class:`mimetools.Message` instance
      (see `Quick Reference to HTTP Headers <http://www.cs.tut.fi/~jkorpela/http.html>`_)
 
    Raises :exc:`URLError` on errors.
 
    Note that ``None`` may be returned if no handler handles the request (though the
    default installed global :class:`OpenerDirector` uses :class:`UnknownHandler` to
    ensure this never happens).
 
+   In addition, default installed :class:`ProxyHandler` makes sure the requests
+   are handled through the proxy when they are set.
+
    .. versionchanged:: 2.6
       *timeout* was added.
 
 
 .. function:: install_opener(opener)
 
    Install an :class:`OpenerDirector` instance as the default global opener.
    Installing an opener is only necessary if you want urlopen to use that opener;
    otherwise, simply call :meth:`OpenerDirector.open` instead of :func:`urlopen`.
    The code does not check for a real :class:`OpenerDirector`, and any class with
    the appropriate interface will work.
 
@@ -178,26 +181,31 @@
 
    A class to handle redirections.
 
 
 .. class:: HTTPCookieProcessor([cookiejar])
 
    A class to handle HTTP Cookies.
 
 
 .. class:: ProxyHandler([proxies])
 
    Cause requests to go through a proxy. If *proxies* is given, it must be a
-   dictionary mapping protocol names to URLs of proxies. The default is to read the
-   list of proxies from the environment variables :envvar:`<protocol>_proxy`.
+   dictionary mapping protocol names to URLs of proxies. The default is to read
+   the list of proxies from the environment variables
+   :envvar:`<protocol>_proxy`.  If no proxy environment variables are set, in a
+   Windows environment, proxy settings are obtained from the registry's
+   Internet Settings section and in a Mac OS X  environment, proxy information
+   is retrieved from the OS X System Configuration Framework.
+
    To disable autodetected proxy pass an empty dictionary.
 
 
 .. class:: HTTPPasswordMgr()
 
    Keep a database of  ``(realm, uri) -> (user, password)`` mappings.
 
 
 .. class:: HTTPPasswordMgrWithDefaultRealm()
 
    Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm of
    ``None`` is considered a catch-all realm, which is searched if no other realm
@@ -410,25 +418,25 @@
    * :samp:`{protocol}_response` --- signal that the handler knows how to
      post-process *protocol* responses.
 
 
 .. method:: OpenerDirector.open(url[, data][, timeout])
 
    Open the given *url* (which can be a request object or a string), optionally
    passing the given *data*. Arguments, return values and exceptions raised are
    the same as those of :func:`urlopen` (which simply calls the :meth:`open`
    method on the currently installed global :class:`OpenerDirector`).  The
    optional *timeout* parameter specifies a timeout in seconds for blocking
    operations like the connection attempt (if not specified, the global default
-   timeout setting will be usedi). The timeout feature actually works only for
+   timeout setting will be used). The timeout feature actually works only for
    HTTP, HTTPS, FTP and FTPS connections).
 
    .. versionchanged:: 2.6
       *timeout* was added.
 
 
 .. method:: OpenerDirector.error(proto[, arg[, ...]])
 
    Handle an error of the given protocol.  This will call the registered error
    handlers for the given protocol with the given arguments (which are protocol
    specific).  The HTTP protocol is a special case which uses the HTTP response
    code to determine the specific error handler; refer to the :meth:`http_error_\*`
@@ -447,25 +455,26 @@
 #. Handlers with a method named like :samp:`{protocol}_open` are called to handle
    the request. This stage ends when a handler either returns a non-\ :const:`None`
    value (ie. a response), or raises an exception (usually :exc:`URLError`).
    Exceptions are allowed to propagate.
 
    In fact, the above algorithm is first tried for methods named
    :meth:`default_open`.  If all such methods return :const:`None`, the
    algorithm is repeated for methods named like :samp:`{protocol}_open`.  If all
    such methods return :const:`None`, the algorithm is repeated for methods
    named :meth:`unknown_open`.
 
    Note that the implementation of these methods may involve calls of the parent
-   :class:`OpenerDirector` instance's :meth:`.open` and :meth:`.error` methods.
+   :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and
+   :meth:`~OpenerDirector.error` methods.
 
 #. Every handler with a method named like :samp:`{protocol}_response` has that
    method called to post-process the response.
 
 
 .. _base-handler-objects:
 
 BaseHandler Objects
 -------------------
 
 :class:`BaseHandler` objects provide a couple of methods that are directly
 useful, and others that are meant to be used by derived classes.  These are
@@ -928,28 +937,28 @@
 
 :func:`build_opener` provides many handlers by default, including a
 :class:`ProxyHandler`.  By default, :class:`ProxyHandler` uses the environment
 variables named ``<scheme>_proxy``, where ``<scheme>`` is the URL scheme
 involved.  For example, the :envvar:`http_proxy` environment variable is read to
 obtain the HTTP proxy's URL.
 
 This example replaces the default :class:`ProxyHandler` with one that uses
 programmatically-supplied proxy URLs, and adds proxy authorization support with
 :class:`ProxyBasicAuthHandler`. ::
 
    proxy_handler = urllib2.ProxyHandler({'http': 'http://www.example.com:3128/'})
-   proxy_auth_handler = urllib2.HTTPBasicAuthHandler()
+   proxy_auth_handler = urllib2.ProxyBasicAuthHandler()
    proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
 
-   opener = build_opener(proxy_handler, proxy_auth_handler)
+   opener = urllib2.build_opener(proxy_handler, proxy_auth_handler)
    # This time, rather than install the OpenerDirector, we use it directly:
    opener.open('http://www.example.com/login.html')
 
 Adding HTTP headers:
 
 Use the *headers* argument to the :class:`Request` constructor, or::
 
    import urllib2
    req = urllib2.Request('http://www.example.com/')
    req.add_header('Referer', 'http://www.python.org/')
    r = urllib2.urlopen(req)
 

--- r262/library/decimal.rst	2009-01-04 06:55:17.853888000 +0900
+++ r266/library/decimal.rst	2010-05-29 21:57:00.619938000 +0900
@@ -99,25 +99,25 @@
 :const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:`Subnormal`,
 :const:`Overflow`, and :const:`Underflow`.
 
 For each signal there is a flag and a trap enabler.  When a signal is
 encountered, its flag is set to one, then, if the trap enabler is
 set to one, an exception is raised.  Flags are sticky, so the user needs to
 reset them before monitoring a calculation.
 
 
 .. seealso::
 
    * IBM's General Decimal Arithmetic Specification, `The General Decimal Arithmetic
-     Specification <http://www2.hursley.ibm.com/decimal/decarith.html>`_.
+     Specification <http://speleotrove.com/decimal/>`_.
 
    * IEEE standard 854-1987, `Unofficial IEEE 854 Text
      <http://754r.ucbtest.org/standards/854.pdf>`_.
 
 .. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 
 .. _decimal-tutorial:
 
 Quick-start Tutorial
 --------------------
 
@@ -321,24 +321,30 @@
 
       sign           ::=  '+' | '-'
       digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
       indicator      ::=  'e' | 'E'
       digits         ::=  digit [digit]...
       decimal-part   ::=  digits '.' [digits] | ['.'] digits
       exponent-part  ::=  indicator [sign] digits
       infinity       ::=  'Infinity' | 'Inf'
       nan            ::=  'NaN' [digits] | 'sNaN' [digits]
       numeric-value  ::=  decimal-part [exponent-part] | infinity
       numeric-string ::=  [sign] numeric-value | [sign] nan
 
+   If *value* is a unicode string then other Unicode decimal digits
+   are also permitted where ``digit`` appears above.  These include
+   decimal digits from various other alphabets (for example,
+   Arabic-Indic and Devanāgarī digits) along with the fullwidth digits
+   ``u'\uff10'`` through ``u'\uff19'``.
+
    If *value* is a :class:`tuple`, it should have three components, a sign
    (:const:`0` for positive or :const:`1` for negative), a :class:`tuple` of
    digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))``
    returns ``Decimal('1.414')``.
 
    The *context* precision does not affect how many digits are stored. That is
    determined exclusively by the number of digits in *value*. For example,
    ``Decimal('3.00000')`` records all five zeros even if the context precision is
    only three.
 
    The purpose of the *context* argument is determining what to do if *value* is a
    malformed string.  If the context traps :const:`InvalidOperation`, an exception
@@ -516,26 +522,29 @@
 
       .. versionadded:: 2.6
 
    .. method:: is_nan()
 
       Return :const:`True` if the argument is a (quiet or signaling) NaN and
       :const:`False` otherwise.
 
       .. versionadded:: 2.6
 
    .. method:: is_normal()
 
-      Return :const:`True` if the argument is a *normal* finite number.  Return
-      :const:`False` if the argument is zero, subnormal, infinite or a NaN.
+      Return :const:`True` if the argument is a *normal* finite non-zero
+      number with an adjusted exponent greater than or equal to *Emin*.
+      Return :const:`False` if the argument is zero, subnormal, infinite or a
+      NaN.  Note, the term *normal* is used here in a different sense with
+      the :meth:`normalize` method which is used to create canonical values.
 
       .. versionadded:: 2.6
 
    .. method:: is_qnan()
 
       Return :const:`True` if the argument is a quiet NaN, and
       :const:`False` otherwise.
 
       .. versionadded:: 2.6
 
    .. method:: is_signed()
 
@@ -545,25 +554,26 @@
       .. versionadded:: 2.6
 
    .. method:: is_snan()
 
       Return :const:`True` if the argument is a signaling NaN and :const:`False`
       otherwise.
 
       .. versionadded:: 2.6
 
    .. method:: is_subnormal()
 
       Return :const:`True` if the argument is subnormal, and :const:`False`
-      otherwise.
+      otherwise. A number is subnormal is if it is nonzero, finite, and has an
+      adjusted exponent less than *Emin*.
 
       .. versionadded:: 2.6
 
    .. method:: is_zero()
 
       Return :const:`True` if the argument is a (positive or negative) zero and
       :const:`False` otherwise.
 
       .. versionadded:: 2.6
 
    .. method:: ln([context])
 
@@ -588,28 +598,27 @@
       returned.
 
       .. versionadded:: 2.6
 
    .. method:: logical_and(other[, context])
 
       :meth:`logical_and` is a logical operation which takes two *logical
       operands* (see :ref:`logical_operands_label`).  The result is the
       digit-wise ``and`` of the two operands.
 
       .. versionadded:: 2.6
 
-   .. method:: logical_invert(other[, context])
+   .. method:: logical_invert([context])
 
-      :meth:`logical_invert` is a logical operation.  The argument must
-      be a *logical operand* (see :ref:`logical_operands_label`).  The
+      :meth:`logical_invert` is a logical operation.  The
       result is the digit-wise inversion of the operand.
 
       .. versionadded:: 2.6
 
    .. method:: logical_or(other[, context])
 
       :meth:`logical_or` is a logical operation which takes two *logical
       operands* (see :ref:`logical_operands_label`).  The result is the
       digit-wise ``or`` of the two operands.
 
       .. versionadded:: 2.6
 
@@ -621,39 +630,39 @@
 
       .. versionadded:: 2.6
 
    .. method:: max(other[, context])
 
       Like ``max(self, other)`` except that the context rounding rule is applied
       before returning and that :const:`NaN` values are either signaled or
       ignored (depending on the context and whether they are signaling or
       quiet).
 
    .. method:: max_mag(other[, context])
 
-      Similar to the :meth:`max` method, but the comparison is done using the
+      Similar to the :meth:`.max` method, but the comparison is done using the
       absolute values of the operands.
 
       .. versionadded:: 2.6
 
    .. method:: min(other[, context])
 
       Like ``min(self, other)`` except that the context rounding rule is applied
       before returning and that :const:`NaN` values are either signaled or
       ignored (depending on the context and whether they are signaling or
       quiet).
 
    .. method:: min_mag(other[, context])
 
-      Similar to the :meth:`min` method, but the comparison is done using the
+      Similar to the :meth:`.min` method, but the comparison is done using the
       absolute values of the operands.
 
       .. versionadded:: 2.6
 
    .. method:: next_minus([context])
 
       Return the largest number representable in the given context (or in the
       current thread's context if no context is given) that is smaller than the
       given operand.
 
       .. versionadded:: 2.6
 
@@ -903,25 +912,25 @@
    exceptions are not raised during computations).
 
    Because the traps are disabled, this context is useful for applications that
    prefer to have result value of :const:`NaN` or :const:`Infinity` instead of
    raising exceptions.  This allows an application to complete a run in the
    presence of conditions that would otherwise halt the program.
 
 
 .. class:: DefaultContext
 
    This context is used by the :class:`Context` constructor as a prototype for new
    contexts.  Changing a field (such a precision) has the effect of changing the
-   default for new contexts creating by the :class:`Context` constructor.
+   default for new contexts created by the :class:`Context` constructor.
 
    This context is most useful in multi-threaded environments.  Changing one of the
    fields before threads are started has the effect of setting system-wide
    defaults.  Changing the fields after threads have started is not recommended as
    it would require thread synchronization to prevent race conditions.
 
    In single threaded environments, it is preferable to not use this context at
    all.  Instead, simply create contexts explicitly as described below.
 
    The default values are precision=28, rounding=ROUND_HALF_EVEN, and enabled traps
    for Overflow, InvalidOperation, and DivisionByZero.
 
@@ -1257,27 +1266,30 @@
       the result is finite and can be expressed exactly in 'precision' digits.
       The result should always be correctly rounded, using the rounding mode of
       the current thread's context.
 
       With three arguments, compute ``(x**y) % modulo``.  For the three argument
       form, the following restrictions on the arguments hold:
 
          - all three arguments must be integral
          - ``y`` must be nonnegative
          - at least one of ``x`` or ``y`` must be nonzero
          - ``modulo`` must be nonzero and have at most 'precision' digits
 
-      The result of ``Context.power(x, y, modulo)`` is identical to the result
-      that would be obtained by computing ``(x**y) % modulo`` with unbounded
-      precision, but is computed more efficiently.  It is always exact.
+      The value resulting from ``Context.power(x, y, modulo)`` is
+      equal to the value that would be obtained by computing ``(x**y)
+      % modulo`` with unbounded precision, but is computed more
+      efficiently.  The exponent of the result is zero, regardless of
+      the exponents of ``x``, ``y`` and ``modulo``.  The result is
+      always exact.
 
       .. versionchanged:: 2.6
          ``y`` may now be nonintegral in ``x**y``.
          Stricter requirements for the three-argument version.
 
 
    .. method:: quantize(x, y)
 
       Returns a value equal to *x* (rounded), having the exponent of *y*.
 
 
    .. method:: radix()
@@ -1794,25 +1806,25 @@
 
    >>> # Round to two places
    >>> Decimal('3.214').quantize(TWOPLACES)
    Decimal('3.21')
 
    >>> # Validate that a number does not exceed two places
    >>> Decimal('3.21').quantize(TWOPLACES, context=Context(traps=[Inexact]))
    Decimal('3.21')
 
    >>> Decimal('3.214').quantize(TWOPLACES, context=Context(traps=[Inexact]))
    Traceback (most recent call last):
       ...
-   Inexact
+   Inexact: None
 
 Q. Once I have valid two place inputs, how do I maintain that invariant
 throughout an application?
 
 A. Some operations like addition, subtraction, and multiplication by an integer
 will automatically preserve fixed point.  Others operations, like division and
 non-integer multiplication, will change the number of decimal places and need to
 be followed-up with a :meth:`quantize` step:
 
     >>> a = Decimal('102.72')           # Initial fixed-point values
     >>> b = Decimal('3.17')
     >>> a + b                           # Addition preserves fixed-point

--- r262/library/imputil.rst	2008-07-13 05:16:19.414850000 +0900
+++ r266/library/imputil.rst	2009-10-27 23:37:48.900246000 +0900
@@ -70,25 +70,25 @@
           be a fully-loaded module object (e.g. loaded from a shared lib).
 
         * The third item is a dictionary of name/value pairs that will be
           inserted into new module before the code object is executed. This
           is provided in case the module's code expects certain values (such
           as where the module was found). When the second item is a module
           object, then these names/values will be inserted *after* the module
           has been loaded/initialized.
 
 
 .. class:: BuiltinImporter()
 
-   Emulate the import mechanism for builtin and frozen modules.  This is a
+   Emulate the import mechanism for built-in and frozen modules.  This is a
    sub-class of the :class:`Importer` class.
 
    .. method:: BuiltinImporter.get_code(parent, modname, fqname)
 
       Undocumented.
 
 .. function:: py_suffix_importer(filename, finfo, fqname)
 
    Undocumented.
 
 .. class:: DynLoadSuffixImporter([desc])
 
@@ -151,54 +151,54 @@
            tail = ""
        if parent:
            qname = "%s.%s" % (parent.__name__, head)
        else:
            qname = head
        q = import_module(head, qname, parent)
        if q: return q, tail
        if parent:
            qname = head
            parent = None
            q = import_module(head, qname, parent)
            if q: return q, tail
-       raise ImportError, "No module named " + qname
+       raise ImportError("No module named " + qname)
 
    def load_tail(q, tail):
        m = q
        while tail:
            i = tail.find('.')
            if i < 0: i = len(tail)
            head, tail = tail[:i], tail[i+1:]
            mname = "%s.%s" % (m.__name__, head)
            m = import_module(head, mname, m)
            if not m:
-               raise ImportError, "No module named " + mname
+               raise ImportError("No module named " + mname)
        return m
 
    def ensure_fromlist(m, fromlist, recursive=0):
        for sub in fromlist:
            if sub == "*":
                if not recursive:
                    try:
                        all = m.__all__
                    except AttributeError:
                        pass
                    else:
                        ensure_fromlist(m, all, 1)
                continue
            if sub != "*" and not hasattr(m, sub):
                subname = "%s.%s" % (m.__name__, sub)
                submod = import_module(sub, subname, m)
                if not submod:
-                   raise ImportError, "No module named " + subname
+                   raise ImportError("No module named " + subname)
 
    def import_module(partname, fqname, parent):
        try:
            return sys.modules[fqname]
        except KeyError:
            pass
        try:
            fp, pathname, stuff = imp.find_module(partname,
                                                  parent and parent.__path__)
        except ImportError:
            return None
        try:


.. _built-in-funcs:

組み込み関数
============

Python インタプリタは数多くの組み込み関数を持っていて、いつでも\
利用することができます。それらの関数をアルファベット順に挙げます。


.. function:: abs(x)

   数値の絶対値を返します。引数として通常の整数、長整数、浮動小数点数を\
   とることができます。引数が複素数の場合、その大きさ (magnitude) が返されます


.. function:: all(iterable)

   *iterable* の全ての要素が真ならば :const:`True` を返します。
   以下のコードと等価です。  ::

      def all(iterable):
          for element in iterable:
              if not element:
                  return False
          return True

   .. versionadded:: 2.5


.. function:: any(iterable)

   *iterable* のいずれかの要素が真ならば :const:`True` を返します。
   以下のコードと等価です。  ::

      def any(iterable):
          for element in iterable:
              if element:
                  return True
          return False

   .. versionadded:: 2.5


.. function:: basestring()

   この抽象型は、 :class:`str` および :class:`unicode` のスーパクラスです。
   この型は呼び出したりインスタンス化したりはできませんが、オブジェクトが
   :class:`str` や :class:`unicode` のインスタンスであるかどうかを調べる\
   際に利用できます。 ``isinstance(obj, basestring)`` は ``isinstance(obj,
   (str, unicode))`` と同じです。

   .. versionadded:: 2.3


.. function:: bin(x)

   整数値を二進数表現の文字列に変換します。戻り値はPythonの正しい式です。
   もし *x* が Pythonの :class:`int` のオブジェクトで無い場合は、整数を返す
   :meth:`__index__` メソッドを持っている必要があります。

   .. versionadded:: 2.6


.. function:: bool([x])

   標準の真値テストを使って、値をブール値に変換します。
   *x* が偽なら、 :const:`False` を返します; そうでなければ :const:`True` を返します。
   ``bool`` はクラスでもあり、 ``int`` のサブクラスになります。
   ``bool`` クラスはそれ以上サブクラス化できません。このクラスのインスタンスは
   :const:`False` および :const:`True` だけです。

   .. index:: pair: Boolean; type

   .. versionadded:: 2.2.1

   .. versionchanged:: 2.3
      引数が与えられなかった場合、この関数は :const:`False` を返します。


.. function:: callable(object)

   *object* 引数が呼び出し可能なオブジェクトの場合、 :const:`True` を返します。
   そうでなければ :const:`False` を返します。
   この関数が真を返しても *object* の呼び出しは失敗する可能性がありますが、\
   偽を返した場合は決して成功することはありません。
   クラスは呼び出し可能 (クラスを呼び出すと新しいインスタンスを返します) なことと、\
   クラスのインスタンスがメソッド :meth:`__call__` を持つ場合には呼び出しが可能なことに\
   注意してください。


.. function:: chr(i)

   ASCII コードが整数 *i* となるような文字 1 字からなる文字列を返します。
   例えば、 ``chr(97)`` は文字列 ``'a'`` を返します。
   この関数は :func:`ord` の逆です。
   引数は [0..255] の両端を含む範囲内に収まらなければなりません;
   *i* が範囲外の値のときには :exc:`ValueError` が送出されます。


.. function:: classmethod(function)

   *function* のクラスメソッドを返します。

   クラスメソッドは、インスタンスメソッドが暗黙の第一引数として\
   インスタンスをとるように、第一引数としてクラスをとります。
   クラスメソッドを宣言するには、以下の書きならわしを使います::

      class C:
          @classmethod
          def f(cls, arg1, arg2, ...): ...

   ``@classmethod`` は関数デコレータ(:term:`decorator`)形式です。
   詳しくは :ref:`function` を参照してください。

   このメソッドはクラスで呼び出すこと (例えば ``C.f()``) も、\
   インスタンスとして呼び出すこと (例えば ``C().f()``) もできます。
   インスタンスはそのクラスが何であるかを除いて無視されます。
   クラスメソッドが導出クラスに対して呼び出された場合、
   導出されたクラスオブジェクトが暗黙の第一引数として渡されます。

   クラスメソッドは C++ や Java における静的メソッドとは異なります。
   そのような機能を求めているなら、 :func:`staticmethod` を参照してください。

   もっとクラスメソッドについての情報が必要ならば、 :ref:`types` にある標準型の階層\
   を参照してください。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      関数デコレータ構文を追加しました.


.. function:: cmp(x, y)

   二つのオブジェクト *x* および *y* を比較し、その結果に従って整数を返します。
   戻り値は ``x`` < ``y`` のときには負、 ``x == y`` の時には0、 ``x > y``
   の時には厳密に正の値になります。


.. function:: compile(source, filename, mode[, flags[, dont_inherit]])

   *source* をコードオブジェクトかASTオブジェクトにコンパイルします。
   コードオブジェクトは :keyword:`exec` 文で実行したり、 :func:`eval`
   を呼び出して評価できます。
   *source* は文字列かASTオブジェクトです。ASTオブジェクトをどう使うかに\
   ついては :mod:`ast` モジュールのドキュメントを参照してください。

   *filename* 引数にはコードの読み出し元のファイル名を指定します。
   コードをファイルから読み出したのでない場合には、それとわかるような値を渡します
   (一般的には ``'<string>'`` を使います)。
   
   引数 *mode* はどの種類のコードをコンパイルするかを指定します。
   *string* が命令文の列からなる場合には ``'exec'`` 、単一の式からなる場合には
   ``'eval'`` 、単一の対話的な命令文からなる場合には ``'single'`` にします
   (最後のケースでは、式の評価結果が ``None`` 以外の場合に値を出力します)。

   オプションの引数 *flags* および *dont_inherit* は、 *string* のコンパイル時にどの
   future 文 (:pep:`236` 参照) の影響を及ぼすかを制御します。どちらも省略した場合\
   (または両方ともゼロの場合)、コンパイルを呼び出している側のコードで有効になっている
   future 文の内容を有効にして *string* をコンパイルします。
   *flags* が指定されていて、かつ *dont_inherit* が指定されていない (またはゼロ) の場合、\
   上の場合に加えて *flags* に指定された future 文をいます。
   *dont_inherit* がゼロでない整数の場合、 *flags* の値そのものを使い、この関数を呼び出した\
   側の future 文の効果は無視します。

   future 文はビットで指定され、互いにビット単位の論理和を取って複数の文を指定できます。
   ある機能を指定するために必要なビットフィールドは、 :mod:`__future__` モジュールの
   :class:`_Feature` インスタンスにおける :attr:`compiler_flag` 属性で得られます。

   この関数は *source* が不正な場合に :exc:`SyntaxError` を、NULL文字が含まれていた場合に
   :exc:`TypeError` を送出します。

   .. note::

      複数行の命令文をコンパイルする時には、行末は単一の改行文字 (``'\n'``) で表し、
      入力行は少なくとも1つの改行文字で終端せねばなりません。
      行末が ``'\r\n'`` で表現されている場合、文字列に :meth:`replace` メソッドを使って
      ``'\n'`` に変換してください。

   .. versionchanged:: 2.3
      *flags* と *dont_inherit* 引数が追加されました。

   .. versionchanged:: 2.6
      ASTオブジェクトのコンパイルがサポートされました。


.. function:: complex([real[, imag]])

   値 *real* + *imag*\*j の複素数型数を生成するか、文字列または数値を複素数型に変換します。
   最初の引数が文字列の場合、文字列を複素数として変換します。
   この場合関数は二つ目の引数無しで呼び出さなければなりません。
   二つ目の引数は文字列であってはなりません。
   それぞれの引数は (複素数を含む) 任意の数値型をとることができます。
   *imag* が省略された場合、標準の値はゼロで、関数は :func:`int` 、 :func:`long`
   および :func:`float` のような数値型への変換関数として動作します。
   全ての引数が省略された場合、 ``0j`` を返します。

   複素数型については :ref:`typesnumeric` で説明しています。


.. function:: delattr(object, name)

   :func:`setattr` の親戚となる関数です。引数はオブジェクトと文字列です。
   文字列はオブジェクトの属性のどれか一つの名前でなければなりません。
   この関数は与えられた名前の属性を削除しますが、オブジェクトがそれを許す場合に限ります。
   例えば、 ``delattr(x, 'foobar')`` は ``del x.foobar`` と等価です。


.. function:: dict([arg])
   :noindex:

   新しい辞書型データを作ります。オプションとして、 *arg* から要素を取ることができます。
   辞書型については :ref:`typesmapping` で解説されています。

   その他のコンテナ型については、ビルトイン型の :class:`list`, :class:`set`,
   :class:`tuple` と :mod:`collections` モジュールを参照してください。


.. function:: dir([object])

   引数がない場合、現在のローカルシンボルテーブルにある名前のリストを返します。
   引数がある場合、そのオブジェクトの有効な属性からなるリストを返そうと試みます。

   object が :meth:`__dir__` という名前のメソッドを持つ場合はこのメソッドを呼びます。\
   このメソッドは属性のリストを返さないといけません。\
   :func:`__getattr__` や :func:`__getattribute__` をカスタマイズしているオブジェクトは、
   この仕組みを使って :func:`dir` がカスタマイズされた属性名を返すようにできます。

   object が :meth:`__dir__` メソッドを提供しない場合、この関数は情報を、
   オブジェクトの :attr:`__dict__` 属性が定義されている場合はそこからと、
   クラスまたは型オブジェクトから集めます。
   リストは完全なものになるとは限りません。また、 object がカスタマイズした :func:`__getattr__`
   を持つ場合は不確かなものになります。

   :func:`dir` は完全な情報よりも意味のある情報を生成しようとするため、標準の動作は
   object の型によって異なります。

   * object がモジュールオブジェクトの場合、リストにはモジュール属性の名前も含まれます。

   * object が型オブジェクトやクラスオブジェクトの場合、リストにはそれらの属性が含まれ、\
     かつそれらの基底クラスの属性も再帰的にたどられて含まれます。

   * それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、再帰的にたどった\
     基底クラスの属性名が含まれます。

   返されるリストはアルファベット順に並べられています。例えば::

      >>> import struct
      >>> dir()   # doctest: +SKIP
      ['__builtins__', '__doc__', '__name__', 'struct']
      >>> dir(struct)   # doctest: +NORMALIZE_WHITESPACE
      ['Struct', '__builtins__', '__doc__', '__file__', '__name__',
       '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
       'unpack', 'unpack_from']
      >>> class Foo(object):
      ...     def __dir__(self):
      ...         return ["kan", "ga", "roo"]
      ...
      >>> f = Foo()
      >>> dir(f)
      ['ga', 'kan', 'roo']

   .. note::

      :func:`dir` は第一に対話プロンプトのために提供されているので、厳密さや\
      一貫性をもって定義された名前のセットよりも、むしろ興味深い名前のセットを\
      与えようとします。また、この関数の細かい動作はリリース間で変わる可能性があります。
      例えば、引数がクラスの場合メタクラスの属性は結果のリストに含まれません。


.. function:: divmod(a, b)

   2 つの (複素数でない) 数値を引数として取り、長除法を行ってその商と剰余からなるペアを返します。被演算子が型混合である場合、 2
   進算術演算子での規則が適用されます。通常の整数と長整数の場合、結果は  ``(a // b, a % b)`` と同じです。浮動小数点数の場合、結果は
   ``(q, a % b)`` であり、 *q* は通常 ``math.floor(a / b)`` ですが、そうではなく 1 になることもあります。
   いずれにせよ、 ``q * b + a % b``  は *a* に非常に近い値になり、 ``a % b``  がゼロでない値の場合、その符号は * b*
   と同じで、  ``0 <= abs(a % b) < abs(b)`` になります。

   .. versionchanged:: 2.3
      複素数に対する :func:`divmod` の使用は廃止されました。.


.. function:: enumerate(sequence[, start=0])

   列挙オブジェクトを返します。
   *iterable* はシーケンス (イテレータ(:term:`iterator` 型かその他の反復をサポートするオブジェクト) で
   なければなりません。
   :func:`enumerate` が返すイテレータの :meth:`next` メソッドは、 (デフォルトでは0である *start* の値から始まる) カウント値と、
   値だけ *iterable* を反復操作して得られる対応するオブジェクトを含むタプルを返します。
   :func:`enumerate` はインデクス付けされた値の列: ``(0, seq[0])``, ``(1, seq[1])``, ``(2, seq[2])``, ... を得るのに便利です。
   例えば、

      >>> for i, season in enumerate(['Spring', 'Summer', 'Fall', 'Winter']):
      ...     print i, season
      0 Spring
      1 Summer
      2 Fall
      3 Winter

   .. versionadded:: 2.3
   .. versionadded:: 2.6
      *start* 引数


.. function:: eval(expression[, globals[, locals]])

   文字列とオプションの引数 *globals* 、 *locals* をとります。 *globals* を指定する場合には辞書でなくてはなりません。 *locals*
   は任意のマップ型にできます。

   .. versionchanged:: 2.4
      以前は *locals* も辞書でなければなりませんでした.

   引数 *expression* は Python の表現式 (技術的にいうと、条件のリストです)  として構文解釈され、評価されます。このとき辞書
   *globals* および *locals* はそれぞれグローバルおよびローカルな名前空間として使われます。 *locals*
   辞書が存在するが、 '__builtins__' が欠けている場合、 *expression* を解析する前に現在のグローバル変数を *globals*
   にコピーします。このことから、 *expression* は通常標準の :mod:`__builtin__` モジュールへの完全なアクセス
   を有し、制限された環境が伝播するようになっています。 *locals* 辞書が省略された場合、標準の値として *globals* に
   設定されます。辞書が両方とも省略された場合、表現式は :func:`eval` が
   呼び出されている環境の下で実行されます。構文エラーは例外として報告されます。

   以下に例を示します:

      >>> x = 1
      >>> print eval('x+1')
      2

   この関数は (:func:`compile` で生成されるような) 任意のコードオブジェクトを実行するために利用することもできます。
   この場合、文字列の代わりにコードオブジェクトを渡します。
   コードオブジェクトが *kind* 引数を ``'exec'`` にしてコンパイルされた場合、
   :func:`eval` の戻り値は ``None`` になります。

   ヒント: 文の動的な実行は :keyword:`exec` 文でサポートされています。ファイルからの文の実行は関数 :func:`execfile`
   でサポートされています。関数 :func:`globals` および :func:`locals` は
   それぞれ現在のグローバルおよびローカルな辞書を返すので、 :func:`eval` や :func:`execfile` で使うことができます。


.. function:: execfile(filename[, globals[, locals]])

   この関数は :keyword:`exec` 文に似ていますが、文字列の代わりにファイルに対して構文解釈を行います。 :keyword:`import`
   文と違って、モジュール管理機構を使いません --- この関数はファイルを無条件に読み込み、新たなモジュールを生成しません。 [#]_

   引数は文字列とオプションの 2 つの辞書からなります。 *file*  は読み込まれ、(モジュールのように) Python 文の列として評価されます。このとき
   *globals* および *locals* がそれぞれグローバルおよびローカルな名前空間として使われます。 *locals*
   は任意のマップ型に指定できます。

   .. versionchanged:: 2.4
      以前は *locals* も辞書でなければなりませんでした.

   *locals* 辞書が省略された場合、標準の値として *globals* に設定されます。辞書が両方とも省略された場合、表現式は
   :func:`execfiles` が呼び出されている環境の下で実行されます。戻り値は ``None`` です。

   .. warning::

      標準では *locals* は後に述べる関数 :func:`locals`  のように動作します: 標準の *locals* 辞書に対する変更を試みては
      いけません。 :func:`execfile` の呼び出しが返る時にコードが *locals* に与える影響を知りたいなら、明示的に *loacals* 辞書を
      渡してください。 :func:`execfile` は関数のローカルを変更するための信頼性のある方法として使うことはできません


.. function:: file(filename[, mode[, bufsize]])

   :class:`file` 型のコンストラクタです。詳しくは :ref:`bltin-file-objects` を参照してください。
   コンストラクタの引数は後述の :func:`open` 組み込み関数と同じです。

   ファイルを開くときは、このコンストラクタを直接呼ばずに :func:`open` を呼び出すのが望ましい方法です。
   :class:`file` は型テストにより適しています (たとえば ``isinstance(f, file)`` と書くような)。

   .. versionadded:: 2.2


.. function:: filter(function, iterable)

   *iterable* のうち、 *function* が真を返すような要素からなるリストを構築します。
   *iterable* はシーケンスか、反復をサポートするコンテナか、イテレータです。
   *iterable* が文字列型かタプル型の場合、結果も同じ型になります。
   *function* が ``None`` の場合、恒等関数を仮定します。すなわち、 *list* の偽となる要素は除去されます。

   function が ``None`` ではない場合、 ``filter(function, iterable)`` は
   ``[item for item in literable if function(item)]`` と同等です。
   function が ``None`` の場合 ``[item for item in liiterable if item]``
   と同等です。

   この関数と相補的な、 *function* が偽を返す *iterable* の値だけを返す :func:`itertools.filterfalse` 
   関数も参照してください。

.. function:: float([x])

   文字列または数値を浮動小数点数に変換します。引数が文字列の場合、\
   十進の数または浮動小数点数を含んでいなければなりません。符号が付いていてもかまいません。
   また、空白文字中に埋め込まれていてもかまいません。
   また、引数は [+|-]nan や [+|-]inf でもかまいません。
   それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができ、
   同じ値の浮動小数点数が (Python の浮動小数点精度で) 返されます。 
   引数が指定されなかった場合、 ``0.0`` を返します。

   .. note::

      .. index::
         single: NaN
         single: Infinity

      文字列で値を渡す際、背後の C ライブラリによって NaN および Infinity が返されるかもしれません。
      Float は nan, inf, -inf という文字列を NaN と正負の無限値として受け付けます。
      先頭の + と、 NaN の先頭の - は無視されます。
      Float は常に NaN と無限値を nan, inf, -inf として表現(repr)します。


.. function:: format(value[, format_spec])

   .. index::
      pair: str; format
      single: __format__

   *value* を *format_spec* で制御された"書式化された"表現に変換します。
   *format_spec* の意味は *value* 引数の型に依存します。ただし、ほとんどの
   組み込み型で使われる標準のフォーマット文法があります。 :ref:`formatspec`
   を参照してください。

   .. note::

      ``format(value, format_spec)`` は単に ``value.__format__(format_spec)``
      の呼び出しです。

   .. versionadded:: 2.6


.. function:: frozenset([iterable])
   :noindex:

   Return a frozenset object, optionally with elements taken from *iterable*.
   The frozenset type is described in :ref:`types-set`.

   :class:`frozenset` オブジェクトを返します。要素はオプションの *iterable* から取得します。
   frozenset型については :ref:`types-set` で説明しています。
   
   その他のコンテナ型については、ビルトイン型の :class:`dict`, :class:`list`,
   :class:`tuple` と、 :mod:`collections` モジュールをご覧下さい。

   .. versionadded:: 2.4


.. function:: getattr(object, name[, default])

   指定された *object* の属性を返します。 *name* は文字列でなくてはなりません。文字列がオブジェクトの属性名の一つであった
   場合、戻り値はその属性の値になります。例えば、 ``getattr(x, 'foobar')`` は ``x.foobar`` と等価です。
   指定された属性が存在しない場合、 *default* が与えられている場合にはしれが返されます。そうでない場合には :exc:`AttributeError`
   が送出されます。


.. function:: globals()

   現在のグローバルシンボルテーブルを表す辞書を返します。常に現在のモジュールの辞書になります (関数またはメソッドの中では
   それらを定義しているモジュールを指し、この関数を呼び出したモジュールではありません)。


.. function:: hasattr(object, name)

   引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つであった場合 ``True`` を、そうでない場合 ``False`` を返します
   (この関数は ``getattr(object, name)`` を呼び出し、例外を送出するかどうかを調べることで実装しています)。


.. function:: hash(object)

   オブジェクトのハッシュ値を (存在すれれば) 返します。ハッシュ値は整数です。これらは辞書を検索する際に辞書のキーを高速に比較するために
   使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と 1.0 のように型が異なっていてもです)。


.. function:: help([object])

   組み込みヘルプシステムを起動します (この関数は対話的な使用のためのものです)。引数が与えられていない場合、対話的ヘルプシステムは
   インタプリタコンソール上で起動します。引数が文字列の場合、文字列はモジュール、関数、クラス、メソッド、キーワード、またはドキュメント
   の項目名として検索され、ヘルプページがコンソール上に印字されます。引数が何らかのオブジェクトの場合、そのオブジェクトに関するヘルプページが生成されます。

   この館数は :mod:`site` モジュールによってビルトイン名前空間に追加されます。

   .. versionadded:: 2.2


.. function:: hex(x)

   (任意のサイズの) 整数を16進の文字列に変換します。結果は Python の式としても使える形式になります。

   .. versionchanged:: 2.4
      以前は符号なしのリテラルしか返しませんでした.


.. function:: id(object)

   オブジェクトの "識別値" を返します。この値は整数 (または長整数) で、このオブジェクトの有効期間は一意かつ定数であることが保証されています。
   オブジェクトの有効期間が重ならない 2 つのオブジェクトは同じ :func:`id` 値を持つかもしれません。 (実装に関する注釈:
   この値はオブジェクトのアドレスです。)


.. function:: input([prompt])

   ``eval(raw_input(prompt))`` と同じです。

   .. warning::

      この関数はユーザのエラーに対して安全ではありません! この関数では、入力は有効な Python の式であると期待しています; 入力が
      構文的に正しくない場合、 :exc:`SyntaxError` が送出されます。式を評価する際にエラーが生じた場合、他の例外も送出されるかもしれません。
      (一方、この関数は時に、熟練者がすばやくスクリプトを書く際に必要なまさにそのものです)

   :mod:`readline` モジュールが読み込まれていれば、 :func:`input` は精緻な行編集およびヒストリ機能を提供します。

   一般的なユーザからの入力のための関数としては :func:`raw_input`  を使うことを検討してください。


.. function:: int([x[, radix]])

   文字列または数値を通常の整数に変換します。引数が文字列の場合、 Python 整数として表現可能な十進の数でなければなりません。
   符号が付いていてもかまいません。また、空白文字中に埋め込まれていてもかまいません。 *radix* 引数は変換の基数を表し、範囲 [2, 36] の
   整数またはゼロをとることができます。
   *radix* がゼロの場合、文字列の内容から適切な基数を推測します; 変換は整数リテラルと同じです。 (:ref:`numbers` を参照)
   *radix* が指定されており、 *x* が文字列でない場合、 :exc:`TypeError` が送出されます。
   それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができます。
   浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸めます。引数が通常整数の範囲を超えている場合、長整数が代わりに返されます。
   引数が与えられなかった場合、 ``0`` を返します。

   整数型については :ref:`typesnumeric` で説明しています。


.. function:: isinstance(object, classinfo)

   引数 *object* が引数 *classinfo* のインスタンスであるか、 (直接または間接的な) サブクラスのインスタンスの場合に真を返します。
   また、 *classinfo* が(new-style classを含む)型オブジェクトであり、
   *object* がその型のオブジェクトである場合にも真を返します。
   *object* がクラスインスタンスや与えられた型のオブジェクトでない場合、
   この関数は常に偽を返します。
   *classinfo* をクラスオブジェクトでも型オブジェクトにもせず、クラスや
   型オブジェクトからなるタプルや、そういったタプルを再帰的に含むタプル
   (他のシーケンス型は受理されません) でもかまいません。
   *classinfo* がクラス、型、クラスや型からなるタプル、そういったタプルが\
   再帰構造をとっているタプルのいずれでもない場合、例外
   :exc:`TypeError` が送出されます。

   .. versionchanged:: 2.2
      型情報をタプルにした形式のサポートが追加されました。.


.. function:: issubclass(class, classinfo)

   *class* が *classinfo* の (直接または間接的な) サブクラスである場合に真を返します。クラスはそのクラス自体のサブクラスと
   *clasinfo* はクラスオブジェクトからなるタプルでもよく、この場合には *classinfo* のすべてのエントリが調べられます。
   その他の場合では、例外 :exc:`TypeError` が送出されます。

   .. versionchanged:: 2.3
      型情報からなるタプルへのサポートが追加されました.


.. function:: iter(o[, sentinel])

   イテレータ(:term:`iterator`)オブジェクトを返します。
   2 つ目の引数があるかどうかで、最初の引数の解釈は非常に異なります。
   2 つ目の引数がない場合、 *o* は反復プロトコル
   (:meth:`__iter__` メソッド) か、シーケンス型プロトコル (引数が ``0`` から開始する
   :meth:`__getitem__` メソッド) をサポートする集合オブジェクトでなければなりません。
   これらのプロトコルが両方ともサポートされていない場合、 :exc:`TypeError`
   が送出されます。 2 つ目の引数 *sentinel* が与えられていれば、
   *o* は呼び出し可能なオブジェクトでなければなりません。この場合に\
   生成されるイテレータは、 :meth:`next` を呼ぶ毎に *o* を引数無しで呼び出します。
   返された値が *sentinel* と等しければ、
   :exc:`StopIteration` が送出されます。
   そうでない場合、戻り値がそのまま返されます。

   .. versionadded:: 2.2


.. function:: len(s)

   オブジェクトの長さ (要素の数) を返します。引数はシーケンス型 (文字列、タプル、またはリスト) か、マップ型 (辞書) です。


.. function:: list([iterable])

   *iterable* の要素と同じ要素をもち、かつ順番も同じなリストを返します。
   *iterable* はシーケンス、反復処理をサポートするコンテナ、あるいはイテレータオブジェクトです。
   *iterable* がすでにリストの場合、 ``iterable[:]`` と同様にコピーを作成して返します。
   例えば、 ``list('abc')`` は ``['a', 'b', 'c']`` を、 ``list((1, 2, 3))`` は ``[1, 2,
   3]`` を返します。引数が与えられなかった場合、新しい空のリスト ``[]`` を返します。

   :class:`list` は変更可能なシーケンス型で、 :ref:`typesseq` で解説されています。
   他のコンテナ型は、組み込み型の :class:`dict`, :class:`set`, :class:`tuple` ,
   そして :mod:`collections` モジュールを参照してください。


.. function:: locals()

   現在のローカルシンボルテーブルを表す辞書を更新して返します。

   .. warning::

      この辞書の内容は変更してはいけません; 値を変更しても、インタプリタが使うローカル変数の値には影響しません。

   関数ブロックの中で :func:`locals` を呼ぶと自由変数が返されます。
   返された自由変数に対する操作は、インタプリタが利用する値に影響しません。
   クラスブロックの中では自由変数は返されません。

.. function:: long([x[, radix]])

   文字列または数値を長整数値に変換します。
   引数が文字列の場合、 Python 整数として表現可能な十進の数でなければなりません。
   符号が付いていてもかまいません。また、空白文字中に埋め込まれていてもかまいません。
   *radix* 引数は :func:`int` と同じように解釈され、 *x* が文字列の時だけ与えることができます。
   それ以外の場合、引数は通常整数、長整数、または浮動小数点数をとることができ、同じ値の長整数が返されます。
   浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸めます。
   引数が与えられなかった場合、 ``0L`` を返します。

   long 型については :ref:`typesnumeric` で解説されています。

.. function:: map(function, iterable, ...)

   *function* を *iterable* の全ての要素に適用し、返された値からなるリストを返します。
   追加の *iterable* 引数を与えた場合、 *function* はそれらを引数として取らなければならず、\
   関数はそのリストの全ての要素について個別に適用されます;
   他のリストより短いリストがある場合、要素 ``None`` で延長されます。
   *function* が ``None`` の場合、恒等関数であると仮定されます;
   すなわち、複数のリスト引数が存在する場合、 :func:`map` は全てのリスト引数に対し、\
   対応する要素からなるタプルからなるリストを返します (転置操作のようなものです)。
   *iterable* 引数はどのようなシーケンス型でもかまいません; 結果は常にリストになります。


.. function:: max(iterable[, args...][key])

   単一の引数 *iterable* の場合、空でないシーケンス (文字列、タプルまたはリスト)
   の要素のうち最大のものを返します。
   1 個よりも引数が多い場合、引数間で最大のものを返します。

   オプションの *key* 引数には :meth:`list.sort` で使われるのと同じような1引数の順序付け関数を指定します。
   *key* を指定する場合はキーワード形式でなければなりません (たとえば ``max(a,b,c,key=func)``)。

   .. versionchanged:: 2.5
      オプションの *key* 引数が追加されました.


.. function:: min(iterable[, args...][key])

   単一の引数 *iterable* の場合、空でないシーケンス (文字列、タプルまたはリスト) の要素のうち最小のものを返します。
   1 個よりも引数が多い場合、引数間で最小のものを返します。

   オプションの *key* 引数には :meth:`list.sort` で使われるのと同じような1引数の順序付け関数を指定します。
   *key* を指定する場合はキーワード形式でなければなりません (たとえば ``min(a,b,c,key=func)``)。

   .. versionchanged:: 2.5
      オプションの *key* 引数が追加されました.


.. function:: next(iterator[, default])

   *iterator* の :meth:`next` メソッドを呼ぶことで、次の要素を取得します。
   *default* が与えられた場合、イテレータの要素を使い尽くしたときに\
   その値を返します。与えられなかった場合は :exc:`StopIteration` 例外が\
   送出されます。

   .. versionadded:: 2.6


.. function:: object()

   ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。 :class:`object()` は新スタイルのクラスの、基底クラスです。これは、新ス
   タイルのクラスのインスタンスに共通のメソッド群を持ちます。

   .. versionadded:: 2.2

   .. versionchanged:: 2.3
      この関数はいかなる引数も受け付けません。以前は、引数を受理しましたが無視していました。.


.. function:: oct(x)

   (任意のサイズの) 整数を 8 進の文字列に変換します。結果は Python の式としても使える形式になります。

   .. versionchanged:: 2.4
      以前は符号なしのリテラルしか返しませんでした.


.. function:: open(filename[, mode[, bufsize]])

   ファイルを開いて、 :ref:`bltin-file-objects` 節に記述されている
   :class:`file` 型のオブジェクトを返します。
   ファイルが開けなければ、 :exc:`IOError` が送出されます。
   ファイルを開くときは :class:`file` のコンストラクタを直接呼ばずに
   :func:`open` を使うのが望ましい方法です。

   最初の 2 つの引数は ``studio`` の :cfunc:`fopen` と同じです: *filename* は開きたいファイルの名前で、 *mode*
   はファイルをどのようにして開くかを指定します。

   最もよく使われる *mode* の値は、読み出しの ``'r'`` 、書き込み (ファイルがすでに存在すれば切り詰められます) の
   ``'w'`` 、追記書き込みの ``'a'`` です  (*いくつかの* Unix システムでは、 *全て* の書き込みが
   現在のファイルシーク位置に関係なくファイルの末尾に追加されます)。
   *mode* が省略された場合、標準の値は ``'r'`` になります。
   デフォルト値がテキストモードになっていて、 ``'\n'`` 文字とプラットフォーム\
   依存の改行文字との変換がファイルの読み書きで発生します。
   なので、移植性を高めるためにはバイナリファイルを開くときに、 *mode*  の値に ``'b'``
   を追加しなければなりません。(バイナリファイルとテキストファイルを区別なく扱うようなシステムでも、\
   ドキュメンテーションの代わりになるので便利です。)
   他に *mode* に与えられる可能性のある値については後述します。

   .. index::
      single: line-buffered I/O
      single: unbuffered I/O
      single: buffer size, I/O
      single: I/O control; buffering

   オプションの *bufsize* 引数は、ファイルのために必要とするバッファのサイズを指定します: 0 は非バッファリング、 1 は行単位
   バッファリング、その他の正の値は指定した値 (の近似値) のサイズをもつバッファを使用することを意味します。 *bufsize* の値が負の
   場合、システムの標準を使います。通常、端末は行単位のバッファリングであり、その他のファイルは完全なバッファリングです。省略された
   場合、システムの標準の値が使われます。  [#]_

   ``'r+'`` 、 ``'w+'`` 、および ``'a+'`` はファイルを更新モードで開きます (``'w+'`` はファイルがすでに存在すれば切り詰め
   るので注意してください) 。バイナリとテキストファイルを区別するシステムでは、ファイルをバイナリモードで開くためには ``'b'`` を追加してください
   (区別しないシステムでは ``'b'`` は無視されます)。

   標準の :cfunc:`fopen` における *mode* の値に加えて、 ``'U'`` または ``'rU'`` を使うことができます。 Python
   が全改行文字サポートを行っている (標準ではしています)　場合, ファイルがテキストファイルで開かれますが、行末文字として Unix における慣行である
   ``'\n'`` 、Macintosh における慣行である ``'\r'`` 、 Windows における慣行である ``'\r\n'`` のいずれを使うことも
   できます。これらの改行文字の外部表現はどれも、Python プログラムからは ``'\n'`` に見えます。Python が全改行文字サポートなしで構築
   されている場合、 *mode* ``'U'`` は通常のテキストモードと同様になります。開かれたファイルオブジェクトはまた、 :attr:`newlines`
   と呼ばれる属性を持っており、その値は ``None`` (改行が見つからなかった場合)、 ``'\n'`` 、 ``'\r'`` 、 ``'\r\n'`` 、
   または見つかった全ての改行タイプを含むタプルになります。

   ``'U'`` を取り除いた後のモードは ``'r'`` 、 ``'w'`` 、 ``'a'`` のいずれかで始まる、というのが Python における規則です。

   Python は :mod:`fileinput`, :mod:`os`, :mod:`os.path`, :mod:`tempfile`, :mod:`shutil`
   といったファイルを扱うモジュールをたくさん提供しています。

   .. versionchanged:: 2.5
      モード文字列の先頭についての制限が導入されました.


.. function:: ord(c)

   長さ 1 の与えられた文字列に対し、その文字列が unicode オブジェクトならば Unicode
   コードポイントを表す整数を、8ビット文字列ならばそのバイトの値を返します。たとえば、 ``ord('a')`` は整数 ``97`` を返し、
   ``ord(u'\u2020')`` は ``8224`` を返します。この値は 8ビット文字列に対する :func:`chr` の逆であり、unicode
   オブジェクトに対する :func:`unichr` の逆です。引数が unicode で Python が UCS2 Unicode
   対応版ならば、その文字のコードポイントは両端を含めて [0..65535] の範囲に入っていなければなりません。この範囲から外れると文字列の長さが 2
   になり、 :exc:`TypeError` が送出されることになります。


.. function:: pow(x, y[, z])

   *x* の *y* 乗を返します; *z* があれば、 *x*  の *y* 乗に対する *z* のモジュロを返します
   (``pow(x, y)% z`` より効率よく計算されます)。引数二つの ``pow(x, y)``
   という形式は、冪乗演算子を使った ``x**y`` と等価です。

   引数は数値型でなくてはなりません。型混合の場合、2進算術演算における型強制規則が適用されます。
   通常整数および長整数の被演算子に対しては、二つ目の引数が負の数でない限り、\
   結果は (型強制後の)被演算子と同じ型になります;
   負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型の結果が返されます。\
   例えば、 ``10**2`` は ``100``  を返しますが、 ``100**-2`` は ``0.01`` を返します。
   (最後に述べた機能は Python 2.2 で追加されたものです。 Python 2.1 以前では、\
   双方の引数が整数で二つ目の値が負の場合、例外が送出されます。) 二つ目の引数が負の場合、
   三つめの引数は無視されます。 *z* がある場合、 *x* および *y* は整数型でなければならず、
   *y* は非負の値でなくてはなりません。(この制限は Python 2.2 で追加されました。 Python
   2.1 以前では、3 つの浮動小数点引数を持つ ``pow()`` は浮動小数点の丸めに関する\
   偶発誤差により、プラットフォーム依存の結果を返します。)


.. function:: print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout])

   *object* を *file* ストリームに、 *sep* で区切り、 *end* を最後に付けた\
   形で表示します。
   *sep* と *end* と *file* を渡すときには、キーワード引数でなければなりません。

   非キーワード引数は :func:`str` がするように文字列に変換されてからストリームに\
   出力されます。 *sep* と *end* は文字列か、 ``None`` でなければなりません。
   ``None`` の場合はデフォルト値が利用されます。
   もし *object* が一つも与えられなかった場合、 :func:`print` は *end*
   だけを出力します。

   *file* 引数は ``write(string)`` メソッドを持つオブジェクトで無ければなりません。
   もし引数が無い場合や ``None`` である場合は、 :data:`sys.stdout` が使われます。

   .. note::

      ``print`` は :keyword:`print` 文と認識されるため、この関数は通常は\
      利用できません。文を無効にして :func:`print` 関数を使うには、モジュールの先頭で\
      次の future 文を実行してください。 ::

         from __future__ import print_function

   .. versionadded:: 2.6


.. function:: property([fget[, fset[, fdel[, doc]]]])

   新しい形式のクラス(:class:`object` から導出されたクラス)におけるプロパティ属性を返します。

   *fget* は属性値を取得するための関数で、同様に *fset* は属性値を設定するための関数です。\
   また、 *fdel* は属性を削除するための関数です。以下に属性 x を扱う典型的な利用法を示します::

      class C(object):
          def __init__(self):
              self._x = None

          def getx(self):
              return self._x
          def setx(self, value):
              self._x = value
          def delx(self):
              del self._x
          x = property(getx, setx, delx, "I'm the 'x' property.")

   *doc* がもし与えられたならばそれがプロパティ属性のドキュメント文字列になります。
   与えられない場合、プロパティは *fget* のドキュメント文字列(がもしあれば)をコピーします。
   これにより、読み取り専用プロパティを :func:`property`
   をデコレータ(:term:`decorator`)として使って容易に作れるようになります。 ::

      class Parrot(object):
          def __init__(self):
              self._voltage = 100000

          @property
          def voltage(self):
              """Get the current voltage."""
              return self._voltage

   のようにすると、 :meth:`voltage` が同じ名前の読み取り専用属性の "getter" になります。

   プロパティオブジェクトはデコレータとして利用できる :attr:`getter`, :attr:`setter`, :attr:`deleter`
   メソッドを持っていて、デコレート対象を対応するアクセッサとして追加した新しいプロパティを\
   返します。次のコードを見ればよくわかると思います ::

      class C(object):
          def __init__(self):
              self._x = None

          @property
          def x(self):
              """I'm the 'x' property."""
              return self._x

          @x.setter
          def x(self, value):
              self._x = value

          @x.deleter
          def x(self):
              del self._x

   このコードは最初の例と全く同じ動作をします。
   追加の関数が元のプロパティと同じ名前 (この例では ``x``) であること確認してください。

   返されたプロパティはまた ``fget``, ``fset``, ``fdel`` という属性を、対応する\
   コンストラクタの引数として持っています。

   .. versionadded:: 2.2

   .. versionchanged:: 2.5
      *doc* が与えられない場合に *fget* のドキュメント文字列を使う .

   .. versionchanged:: 2.6
      ``getter``, ``setter``, ``deleter`` 属性が追加されました。


.. function:: range([start,] stop[, step])

   数列を含むリストを生成するための多機能関数です。 :keyword:`for`  ループでよく使われます。引数は通常の整数でなければなりません。 *step*
   引数が無視された場合、標準の値 ``1`` になります。 *start* 引数が蒸しされた場合標準の値 ``0`` になります。完全な形式では、通常の整数列
   ``[start, start + step, start + 2 * step, ...]`` を返します。 * step* が正の値の場合、最後の要素は
   *stop* よりも小さい ``start + i * step`` の最大値になります; * step * が負の値の場合、最後の要素は * stop*
   よりも大きい ``start + i * step`` の最小値になります。 * step* はゼロであってはなりません (さもなければ
   :exc:`ValueError` が送出されます)。以下に例を示します:

      >>> range(10)
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      >>> range(1, 11)
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      >>> range(0, 30, 5)
      [0, 5, 10, 15, 20, 25]
      >>> range(0, 10, 3)
      [0, 3, 6, 9]
      >>> range(0, -10, -1)
      [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
      >>> range(0)
      []
      >>> range(1, 0)
      []


.. function:: raw_input([prompt])

   引数 *proompt* が存在する場合、末尾の改行を除いて標準出力に出力されます。次に、この関数は入力から 1 行を読み込んで文字列に変換して
   (末尾の改行を除いて) 返します。EOF が読み込まれると :exc:`EOFError` が送出されます。以下に例を示します::

      >>> s = raw_input('--> ')
      --> Monty Python's Flying Circus
      >>> s
      "Monty Python's Flying Circus"

   :mod:`readline` モジュールが読み込まれていれば、 :func:`input` は精緻な行編集およびヒストリ機能を提供します。


.. function:: reduce(function, iterator[, initializer])

   *iterator* の要素に対して、シーケンスを単一の値に短縮するような形で 2 つの引数をもつ *function* を左から右に累積的に適用します。
   例えば、 ``reduce(labmda x, y: x+y, [1, 2, 3, 4, 5])`` は ``((((1+2)+3)+4)+5)``
   を計算します。左引数 *x* は累計の値になり、右引数 *y* は ``iterator`` から取り出した更新値になります。オプションの
   *initializer* が存在する場合、計算の際にシーケンスの先頭に置かれます。また、
   シーケンスが空の場合には標準の値になります。 *initializer* が与えられておらず、 *iterator* が単一の要素しか持っていない場合、
   最初の要素が返されます。


.. function:: reload(module)

   すでにインポートされた *module* を再解釈し、再初期化します。引数はモジュールオブジェクトでなければならないので、予めインポート
   に成功していなければなりません。この関数はモジュールのソースコードファイルを外部エディタで編集して、Python インタプリタから
   離れることなく新しいバージョンを試したい際に有効です。戻り値は (*module* 引数と同じ) モジュールオブジェクトです。

   ``reload(module)`` を実行すると、以下の処理が行われます:

   * Python モジュールのコードは再コンパイルされ、モジュールレベルのコードは再度実行されます。モジュールの辞書中に
     ある、何らかの名前に結び付けられたオブジェクトを新たに定義します。拡張モジュール中の ``init`` 関数が二度呼び出されることはありません。

   * Python における他のオブジェクトと同様、以前のオブジェクトのメモリ領域は、参照カウントがゼロにならないかぎり再利用されません。

   * モジュール名前空間内の名前は新しいオブジェクト (または更新されたオブジェクト) を指すよう更新されます。

   * 以前のオブジェクトが (外部の他のモジュールなどからの) 参照を受けている場合、それらを新たなオブジェクトにバインドし直すことは
     ないので、必要なら自分で名前空間を更新せねばなりません。

   いくつか補足説明があります:

   モジュールは文法的に正しいが、その初期化には失敗した場合、そのモジュールの最初の :keyword:`import` 文はモジュール名を
   ローカルにはバインドしませんが、(部分的に初期化された) モジュールオブジェクトを ``sys.modules`` に記憶します。従って、モジュールを
   ロードしなおすには、 :func:`reload` する前にまず :keyword:`import`
   (モジュールの名前を部分的に初期化されたオブジェクトにバインドします) を再度行わなければなりません。

   モジュールが再ロードされた再、その辞書 (モジュールのグローバル変数を含みます) はそのまま残ります。名前の再定義を行うと、以前の定義を
   上書きするので、一般的には問題はありません。新たなバージョンのモジュールが古いバージョンで定義された名前を定義していない場合、古い定義がそのまま残ります。
   辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、この機能をモジュールを有効性を引き出すために使うことができます --- つまり、
   :keyword:`try` 文を使えば、必要に応じてテーブルがあるかどうかをテストし、その初期化を飛ばすことができます::

      try:
          cache
      except NameError:
          cache = {}

   組み込みモジュールや動的にロードされるモジュールを再ロードすることは、不正なやり方ではありませんが、一般的にそれほど便利ではありません。例外は
   :mod:`sys` 、 :mod:`__main__` および :mod:`__builtin__` です。しかしながら、多くの場合、拡張モジュールは 1
   度以上初期化されるようには設計されておらず、再ロードされた場合には何らかの理由で失敗するかもしれません。

   一方のモジュールが :keyword:`from` ... :keyword:`import` ...
   を使って、オブジェクトを他方のモジュールからインポートしているなら、他方のモジュールを :func:`reload` で呼び出しても、その
   モジュールからインポートされたオブジェクトを再定義することはできません --- この問題を回避する一つの方法は、 :keyword:`from` 文を
   再度実行することで、もう一つの方法は :keyword:`from` 文の代わりに :keyword:`import` と限定的な名前
   (*module*.*name*) を使うことです。

   あるモジュールがクラスのインスタンスを生成している場合、そのクラスを定義しているモジュールの再ロードはそれらインスタンスのメソッド定義に影響しません ---
   それらは古いクラス定義を使いつづけます。これは導出クラスの場合でも同じです。


.. function:: repr(object)

   オブジェクトの印字可能な表現を含む文字列を返します。これは型変換で得られる (逆クオートの) 値と同じです。通常の関数として
   この操作にアクセスできるとたまに便利です。この関数は多くの型について、 :func:`eval` に渡されたときに同じ値を持つようなオブジェクトを
   表す文字列を生成しようとします。
   その他の場合、表現は型と追加の情報を '<', '>' で囲んだものになります。
   追加の情報としてはよくオブジェクトの名前とアドレスが利用されます。
   クラスは :meth:`__repr__` メソッドを定義することでこの関数の結果を\
   制御することができます。


.. function:: reversed(seq)

   要素を逆順に取り出すイテレータ (reverse iterator) を返します。
   *seq* オブジェクトは :meth:`__reversed__` メソッドを持つか、 シーケンス型プロトコル (:meth:`__len__`
   メソッド、および ``0`` から始まる整数を引数にとる :meth:`__getitem__` メソッド) をサポートしていなければなりません。

   .. versionadded:: 2.4

   .. versionchanged:: 2.6
      :meth:`__reversed__` メソッドを定義してカスタマイズできるようになりました。


.. function:: round(x[, n])

   *x* を小数点以下 *n* 桁で丸めた浮動小数点数の値を返します。 *n* が省略されると、標準の値はゼロになります。結果は浮動小数点数です。値は最も近い
   10 のマイナス *n* の倍数に丸められます。二つの倍数との距離が等しい場合、ゼロから離れる方向に丸められます (従って、例えば
   ``round(0.5)`` は ``1.0`` になり、 ``round(-0.5)`` は ``-1.0`` になります)。


.. function:: set([iterable])
   :noindex:

   集合を表現する :class:`set` 型オブジェクトを返します。
   オプションとして要素を  *iterable* から取得します。
   集合型については :ref:`types-set` で解説しています。

   その他のコンテナ型については、ビルトイン型の :class:`dict`, :class:`list`,
   :class:`tuple` と :mod:`collections` モジュールを参照してください。

   .. versionadded:: 2.4


.. function:: setattr(object, name, value)

   :func:`getattr` と対をなす関数です。引数はそれぞれオブジェクト、文字列、そして任意の値です。文字列はすでに存在する属性の名前でも、
   新たな属性の名前でもかまいません。この関数は指定した値を指定した属性に関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。
   例えば、 ``setattr(x, 'foobar', 123)`` は ``x.foobar = 123`` と等価です。


.. function:: slice([start,] stop[, step])

   .. index:: single: Numerical Python

   ``range(start, stop, step)`` で指定されるインデクスの集合を表すスライス(:term:`slice`)オブジェクトを返します。
   ``range(start)`` スライスオブジェクトを返します。引数 *start* および *step* は標準では ``None`` です。
   スライスオブジェクトは読み出し専用の属性 :attr:`start` 、 :attr:`stop` および :attr:`step`
   を持ち、これらは単に引数で使われた値 (または標準の値) を返します。これらの値には、その他のはっきりとした機能はありません; しかしながら、これらの値は
   Numerical Python   およびその他のサードパーティによる拡張で利用されています。スライスオブジェクトは拡張されたインデクス指定
   構文が使われる際にも生成されます。例えば: ``a[start:stop:step]``  や ``a[start:stop, i]`` です。
   代わりにイテレータを返す :func:`itertools.islice` も参照してください。


.. function:: sorted(iterable[, cmp[, key[, reverse]]])

   *iterable* の要素をもとに、並べ替え済みの新たなリストを生成して返します。オプション引数 *cmp* 、 *key* 、および *reverse*
   の意味は :meth:`list.sort` メソッドと同じです。 (:ref:`typesseq-mutable` 節に説明があります。)

   *cmp* は2つの引数(iterable の要素)からなるカスタムの比較関数を指定します。
   これは始めの引数が2つ目の引数に比べて小さい、等しい、大きいかに応じて負数、ゼロ、正数を返します。 ``cmp=lambda x,y:
   cmp(x.lower(), y.lower())``
   デフォルト値は ``None`` です。

   *key* は1つの引数からなる関数を指定します。これは個々のリストの要素から比較のキーを取り出すのに使われます。 ``key=str.lower``
   デフォルト値は ``None`` です。

   *reverse* は真偽値です。 ``True`` がセットされた場合、リストの要素は個々の比較が反転したものとして並び替えられます。

   一般的に、 *key* および *reverse* の変換プロセスは同等の *cmp* 関数を指定するより早く動作します。これは *key* および
   *reverse* がそれぞれの要素に一度だけ触れる間に、 *cmp* はリストのそれぞれの要素に対して複数回呼ばれることによるものです。
   古いスタイルの *cmp* 関数を *key* 関数に変換するには、 `CmpToKey recipe in the ASPN cookbook
   <http://code.activestate.com/recipes/576653/>`_ を見てください。

   .. versionadded:: 2.4


.. function:: staticmethod(function)

   *function* の静的メソッドを返します。

   静的メソッドは暗黙の第一引数を受け取りません。静的メソッドの宣言は、以下のように書き慣わされます::

      class C:
          @staticmethod
          def f(arg1, arg2, ...): ...

   ``@staticmethod`` は関数デコレータ(:term:`decorator`)形式です。
   詳しくは :ref:`function` の関数定義を見てください。

   このメソッドはクラスで呼び出すこと (例えば C.f() ) も、インスタンスとして呼び出すこと (例えば C().f()) もできます。
   インスタンスはそのクラスが何であるかを除いて無視されます。

   Python における静的メソッドは Java や C++ における静的メソッドと類似しています。より進んだ概念については、
   :func:`classmethod` を参照してください。

   もっと静的メソッドについての情報が必要ならば、 :ref:`types`
   にある標準型階層についてのドキュメントを見てください。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      関数デコレータ構文を追加しました.


.. function:: str([object])

   オブジェクトをうまく印字可能な形に表現したものを含む文字列を返します。文字列に対してはその文字列自体を返します。 ``repr(object)``
   との違いは、 ``str(object)`` は常に :func:`eval` が受理できるような文字列を返そうと試みるわけではないという点です;
   この関数の目的は印字可能な文字列を返すところにあります。引数が与えられなかった場合、空の文字列 ``''`` を返します。

   文字列についての詳しい情報は、 シーケンス型の機能について書かれた(文字列型は\
   シーケンス型の一種です) :ref:`typeseq` と、文字列独自のメソッドについて書かれた\
   :ref:`string-formatting` 節を参照してください。
   テンプレート文字列や ``%`` 演算子を使って出力をフォーマットする方法は
   :ref:`string-formatting` 節にあります。
   加えて、 :ref:`stringservices` や :func:`unicode` も参照してください。

.. function:: sum(iteratable[, start])

   *start* と *iteratable* の要素を左から右へ加算してゆき、総和を返します。 *start* はデフォルトで ``0`` です。
   *iteratable* の要素は通常は数値で、文字列であってはなりません。
   文字列からなるシーケンスを結合する高速かつ正しい方法は ``''.join(iteratable)`` です。
   ``sum(range(n), m)`` は ``reduce(operator.add, range(n), m)`` と同等です。

   .. versionadded:: 2.3


.. function:: super(type[, object-or-type])

   メソッド呼び出しを *type* の親クラスや兄弟クラスに委譲するプロクシオブジェクトを返します。
   これは、継承されたメソッドのうちオーバーライドされてしまったものを呼び出すのに有用です。
   メソッドの検索順序は、 *type* 自身がスキップされる以外 :func:`getattr` と同じです。

   :func:`getattr` も :func:`super` も、 *type* の :attr:`__mro__` というメソッド解決\
   順序リストを利用します。
   この属性は動的で、継承階層が更新された時に変更されます。

   二つ目の引数が省略された場合、返される super オブジェクトはバインドされていません。
   二つ目の引数がオブジェクトの場合、 ``isinstance(obj, type)`` は真でなくてはなりません。
   二つ目の引数が型オブジェクトの場合、 ``issubclass(type2, type)`` は真でなくてはなりません。
   (これはクラスメソッドにおいて有用です)

   ..note::
      :func:`super` は新スタイルのクラス(:term:`new-style class`)にのみ機能します。

   *super* には２種類の典型的なユースケースがあります。単一継承のクラス階層において、\
   *super* は親クラスを明示的に名前を指定しないで参照するのに利用でき、\
   コードのメンテナンス性を向上します。
   この使い方は他のプログラミング言語における *super* の使われ方と似ています。

   もう一つのユースケースは、動的に実行される環境においての協調的な多重継承を\
   サポートすることです。
   このユースケースはPython独特で、静的型付け言語や単一継承しかサポートしない言語では見られません。
   これは複数の親クラスが同じメソッドを持つ "ダイアモンド継承" の実装を可能にします。
   このメソッドは全ての場所で同じ呼び出しシグネチャを持つのが良い設計です。
   それは、関数の呼び出し順序が実行時に決められる、クラス階層に適応して順序が変化する、\
   呼び出し順序が実行前には知ることのできない兄弟クラスを含む場合があるから、です。

   どちらのユースケースにおいても、スーパークラスの典型的な呼び出し方は次のようになります::

      class C(B):
          def method(self, arg):
              super(C, self).method(arg)

   :func:`super` は ``super().__getitem__(name)`` のような明示的なドット表記の属性参照の\
   一部として使われているので注意してください。
   これは、独自の :meth:`__getattribute__` メソッドを実装してそのなかで呼び出し順序の中の\
   協調多重継承をサポートするクラスを検索することで実現されています。
   これに伴って、 :func:`super` は ``super(C, self)[name]`` のような文や演算子を使った\
   非明示的な属性参照向けには定義されていないので注意してください。

   .. Also note that :func:`super` is not limited to use inside methods.  The two
      argument form specifies the arguments exactly and makes the appropriate
      references.

   また、 :func:`super` がメソッド内での利用のみに制限されているわけでないことにも\
   注意してください。
   二つの引数を取る形は引数を厳密に明示し、適切な参照を作成します。

   .. versionadded:: 2.2


.. function:: tuple([iterable])

   *iterable* の要素と要素が同じで、かつ順番も同じになるタプルを返します。
   *iterable* はシーケンス、反復をサポートするコンテナ、およびイテレータオブジェクトをとることができます。
   *iterable* がすでにタプルの場合、そのタプルを変更せずに返します。
   例えば、 ``tuple('abc')`` は ``('a', 'b', 'c')`` を返し、
   ``tuple([1, 2, 3])`` は ``(1, 2, 3)`` を返します。

   :class:`tuple` は :ref:`typesseq` で説明されているように不変な(immutable)シーケンス型です。
   その他のコンテナ型については、ビルトイン型の :class:`dict`, :class:`list`, :class:`set`
   と、 :mod:`collections` モジュールを参照してください。

.. function:: type(object)

   *object* の型を返します。オブジェクトの型の検査には :func:`isinstance` 組み込み関数を使うことが推奨されます。

   3 引数で呼び出された場合には :func:`type` 関数は後述するようにコンストラクタとして働きます。


.. function:: type(name, bases, dict)
   :noindex:

   新しい型オブジェクトを返します。本質的には :keyword:`class` 文の動的な形です。 *name*
   文字列はクラス名で、 :attr:`__name__` 属性になります。 *bases* タプルは基底クラスの羅列で、 :attr:`__bases__`
   属性になります。 *dict* 辞書はクラス本体の定義を含む名前空間で、 :attr:`__dict__` 属性になります。たとえば、以下の二つの文は同じ
   :class:`type` オブジェクトを作ります:

      >>> class X(object):
      ...     a = 1
      ...
      >>> X = type('X', (object,), dict(a=1))

   .. versionadded:: 2.2


.. function:: unichr(i)

   Unicode におけるコードが整数 *i* になるような文字 1 文字からなる Unicode 文字列を返します。例えば、 ``unichr(97)``
   は文字列 ``u'a'`` を返します。この関数は Unicode 文字列に対する :func:`ord` の逆です。引数の正当な範囲は Python
   がどのように構成されているかに依存しています --- UCS2 ならば [0..0xFFFF] であり UCS4 ならば [0..0x10FFFF] であり、
   このどちらかです。それ以外の値に対しては  :exc:`ValueError` が送出されます。
   ASCII と 8-bit 文字列については、 :func:`chr` を見てください。

   .. versionadded:: 2.0


.. function:: unicode([object[, encoding [, errors]]])

   以下のモードのうち一つを使って、 *object* のUnicode 文字列バージョンを返します:

   もし *encoding* かつ/または *errors* が与えられていれば、 ``unicode()`` は 8
   ビットの文字列または文字列バッファになっているオブジェクトを *encoding* の codec を使ってデコードします。 *encoding*
   パラメタはエンコーディング名を与える文字列です; 未知のエンコーディングの場合、 :exc:`LookupError` が送出されます。エラー処理は
   *errors* に従って行われます; このパラメタは入力エンコーディング中で無効な文字の扱い方を指定します。 *errors* が ``'strict'``
   (標準の設定です) の場合、エラー発生時には :exc:`ValueError` が送出されます。一方、 ``'ignore'`` では、
   エラーは暗黙のうちに無視されるようになり、 ``'replace'`` では公式の置換文字、 ``U+FFFD`` を使って、デコードできなかった
   文字を置き換えます。 :mod:`codecs` モジュールについても参照してください。

   オプションのパラメタが与えられていない場合、 ``unicode()`` は ``str()`` の動作をまねます。ただし、8 ビット文字列ではなく、
   Unicode 文字列を返します。もっと詳しくいえば、 *object* が Unicode 文字列かそのサブクラスなら、デコード処理を一切介することなく
   Unicode 文字列を返すということです。

   :meth:`__unicode__` メソッドを提供しているオブジェクトの場合、 :func:`unicode` はこのメソッドを引数なしで呼び出して
   Unicode 文字列を生成します。それ以外のオブジェクトの場合、 8 ビットの文字列か、オブジェクトのデータ表現 (representation)
   を呼び出し、その後デフォルトエンコーディングで ``'strict'`` モードの codec を使って Unicode 文字列に変換します。

   Unicode文字列についてのより詳細な情報については、シーケンス型の機能について書かれた
   :ref:`typesseq` と(Unicode文字列はシーケンス型の一種です)、文字列型の機能について書かれた
   :ref:`string-methods` 節を参照してください。
   テンプレート文字列や ``%`` 演算子を使って書式化した出力をする方法については、
   :ref:`string-formatting` 節で説明されています。
   それに加えて、 :ref:`stringservices` 節も参照してください。
   :func:`str` もご覧下さい。

   .. versionadded:: 2.0

   .. versionchanged:: 2.2
      :meth:`__unicode__` のサポートが追加されました.


.. function:: vars([object])

   引数無しでは、現在のローカルシンボルテーブルに対応する辞書を返します。
   モジュール、クラス、またはクラスインスタンスオブジェクト (またはその他
   :attr:`__dict__` 属性を持つもの) を引数として与えた場合、そのオブジェクトのシンボルテーブルに対応する辞書を返します。

   .. warning::

      返される辞書は変更すべきではありません: 変更が対応するシンボルテーブルにもたらす影響は未定義です。 [#]_


.. function:: xrange([start,] stop[, step])

   この関数は :func:`range` に非常によく似ていますが、リストの代わりに "xrange オブジェクト" を返します。このオブジェクトは不透明な
   シーケンス型で、対応するリストと同じ値を持ちますが、それらの値全てを同時に記憶しません。 :func:`ragne` に対する :func:`xrange`
   の利点は微々たるものです (:func:`xrange` は要求に応じて値を生成するからです) ただし、メモリ量の厳しい計算機で
   巨大な範囲の値を使う時や、(ループがよく :keyword:`break` で中断されるといったように) 範囲中の全ての値を使うとは限らない場合は
   その限りではありません。

   .. note::

      :func:`xrange` はシンプルさと速度のために定義されている関数であり、その実現のために実装上の制限を課している場合があります。 Python の
      C 実装では、全ての引数をネイティブの C long 型 (Python の "short" 整数型) に制限しており、要素数がネイティブの C long 型の
      範囲内に収まるよう要求しています。
      より大きな範囲が必要な場合は、代わりに利用できるバージョンを :mod:`itertools`
      モジュールから作ることができます: ``islice(count(sart, step), (stop-start+step-1)//step)``


.. function:: zip([iterable, ...])

   この関数はタプルのリストを返します。このリストの *i* 番目のタプルは各引数のシーケンスまたはイテレート可能オブジェクト中の *i* 番目の要素を含みます。
   返されるリストは引数のシーケンスのうち長さが最小のものの長さに切り詰められます。引数が全て同じ長さの際には、 :func:`zip` は初期値引数が
   ``None`` の :func:`map`  と似ています。引数が単一のシーケンスの場合、1 要素のタプルからなる
   リストを返します。引数を指定しない場合、空のリストを返します。

   引数の評価順序は左から右であると保証されています。
   これにより、連続するデータを n 個の長さのグループにクラスタリングする
   ``zip(*[iter(s)]*n)`` というイディオムが可能になっています。

   :func:`zip` と ``*`` 演算子による結合を使ってリストの unzip が可能です::

      >>> x = [1, 2, 3]
      >>> y = [4, 5, 6]
      >>> zipped = zip(x, y)
      >>> zipped
      [(1, 4), (2, 5), (3, 6)]
      >>> x2, y2 = zip(*zipped)
      >>> x == x2, y == y2
      True

   .. versionadded:: 2.0

   .. versionchanged:: 2.4
      これまでは、 :func:`zip` は少なくとも一つの引数を要求しており、空のリストを返す代わりに :exc:`TypeError` を送出していました.

.. function:: __import__(name[, globals[, locals[, fromlist[, level]]]])

   .. index::
      statement: import
      module: imp

   .. note::

      この関数は日常的なPythonプログラミングでは必要にならない高度なものです。
:
   この関数は :keyword:`import` 文によって呼び出されます。\
   :mod:`builtins` を import して ``builtins.__import__`` に代入することで、この関数を\
   置き換えて :keyword:`import` 文の動作を変えることができるのですが、現代においては\
   たいてい import hook (:pep:`302` を参照) を使った方が簡単です。
   import するモジュールの名前が動的に決まる場合を除いて、 :func:`__import__`
   を直接使うことは希です。

   この関数は *name* という名前のモジュールを import します。
   モジュール名がどのモジュールを指しているのかをパッケージのコンテキストに依存して\
   決定するために、 *globals* と *locals* を利用する場合があります。
   *fromlist* は、 *name* で示すモジュールの中から import するオブジェクトや\
   サブモジュールの名前です。
   標準の実装では *locals* を全く使わず、 *globals* は :keyword:`import` 文の\
   パッケージコンテキストを決定するためだけに利用します。

   *level* で絶対インポートを使うか相対インポートを使うかを指定します。
   デフォルトは ``-1`` で、この値は絶対と相対の両方を試すことを示します。
   ``0`` を指定すると絶対インポートだけ行なう、という意味になります。
   *level* が正の値ならば、 :func:`__import__` を呼び出すモジュールのディレクトリから\
   幾つ上の親ディレクトリまで探索するかを意味します。

   変数 *name* が ``package.module`` の形式であった場合、通常、 *name* という名前のモジュール
   *ではなく* トップレベルのパッケージ (最初のドットまでの名前が示すパッケージ) が返されます。
   しかし、空でない *fromlist* 引数が与えられていれば、 *name* と名づけられたモジュールが返されます。

   例えば、文 ``import spam`` は結果として次のコードと似たバイトコードになります。 ::

      spam = __import__('spam', globals(), locals(), [], -1)

   ``import spam.ham`` という文はこうなります。 ::

      spam = __import__('spam.ham', globals(), locals(), [], -1)

   :func:`__import__` がトップレベルのモジュールを返すのは、そのモジュールが
   :keyword:`import` 文によって名前に代入されるオブジェクトであることに注目してください。

   一方、 ``from spam.ham import eggs, sausage as saus`` はこうなります。 ::

      _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], -1)
      eggs = _temp.eggs
      saus = _temp.sausage

   この場合、 :func:`__import__` 関数は ``spam.ham`` モジュールを返します。
   各々の名前は、このモジュールから取得され、それぞれの名前に代入されます。

   もし単純に(パッケージ内にあるかもしれない)モジュールを名前でインポートする場合は、
   :data:`sys.modules` から取得することができます。 ::

      >>> import sys
      >>> name = 'foo.bar.baz'
      >>> __import__(name)
      <module 'foo' from ...>
      >>> baz = sys.modules[name]
      >>> baz
      <module 'foo.bar.baz' from ...>

   .. versionchanged:: 2.5
      level 引数が追加されました.

   .. versionchanged:: 2.5
      引数のキーワードサポートが追加されました.


..  ---------------------------------------------------------------------------


.. _non-essential-built-in-funcs:

非必須組み込み関数 (Non-essential Built-in Functions)
=====================================================

いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。
こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性を維持するだけの目的で残されています。

Python のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ばしてもかまわず、\
その際に何か重要なことを忘れていると思う必要もありません。


.. function:: apply(function, args[, keywords])

   引数 *function* は呼び出しができるオブジェクト (ユーザ定義および組み込みの関数またはメソッド、またはクラスオブジェクト)
   でなければなりません。 *args* はシーケンス型でなくてはなりません。 *function* は引数リスト *args* を使って呼び出されます;
   引数の数はタプルの長さになります。オプションの引数 *keywords*  を与える場合、 *keywords* は文字列のキーを持つ辞書で
   なければなりません。これは引数リストの最後に追加されるキーワード引数です。 :func:`apply` の呼び出しは、単なる
   ``function(args)`` の呼び出しとは異なります。というのは、
   :func:`apply` の場合、引数は常に一つだからです。
   :func:`apply` は ``function(*args, * *keywords)`` を使うのと等価です。
   

   .. deprecated:: 2.3
      ``*args`` と ``**keywords`` を使った拡張呼び出し構文を利用してください。


.. function:: buffer(object[, offset[, size]])

   引数 *object* を参照する新たなバッファオブジェクトが生成されます。引数 *object* は (文字列、アレイ、バッファといった) バッファ
   呼び出しインタフェースをサポートするオブジェクトでなければなりません。返されるバッファオブジェクトは *object* の先頭 (または *offset*)
   からのスライスになります。スライスの末端は *object* の末端まで (または引数 *size* で与えられた長さになるまで) です。


.. function:: coerce(x, y)

   二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを返します。変換に使われる規則は算術演算における規則と同じです。
   型変換が不可能である場合、 :exc:`TypeError` を送出します。


.. function:: intern(string)

   *string* を "隔離" された文字列のテーブルに入力し、隔離された文字列を返します -- この文字列は *string* 自体かコピーです。
   隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに有効です -- 辞書中のキーが隔離されており、検索するキーが隔離されて
   いる場合、(ハッシュ化後の) キーの比較は文字列の比較ではなくポインタの比較で行うことができるからです。通常、Python プログラム内で
   利用されている名前は自動的に隔離され、モジュール、クラス、またはインスタンス属性を保持するための辞書は隔離されたキーを持っています。

   .. versionchanged:: 2.3
      隔離された文字列の有効期限は (Python 2.2  またはそれ以前は永続的でしたが) 永続的ではなくなりました; :func:`intern`
      の恩恵を受けるためには、 :func:`intern` の返す値に対する参照を保持しなければなりません.

.. rubric:: Footnotes

.. [#] この関数は比較利用されない方なので、将来構文にするかどうかは保証できません。

.. [#] 現状では、 :cfunc:`setvbuf` を持っていないシステムでは、バッファサイズを指定しても効果はありません。バッファサイズを指定
   するためのインタフェースは :cfunc:`setvbuf` を使っては行われていません。何らかの I/O
   が実行された後で呼び出されるとコアダンプすることがあり、どのような場合にそうなるかを決定する信頼性のある方法がないからです。

.. [#] 現在の実装では、ローカルな値のバインディングは通常は影響を受けませんが、(モジュールのような) 他のスコープから取り出した値は影響を受けるかもしれません。また
   この実装は変更されるかもしれません。


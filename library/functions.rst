
.. _built-in-funcs:

組み込み関数
============

Python インタプリタは数多くの組み込み関数を持っていて、いつでも利用す
ることができます。それらの関数をアルファベット順に挙げます。


.. function:: abs(x)

   数値の絶対値を返します。引数として通常の整数、長整数、浮動小数点数
   をとることができます。引数が複素数の場合、その大きさ (magnitude) が
   返されます。


.. function:: all(iterable)

   *iterable* の全ての要素が真ならば :const:`True` を返します。以下の
   コードと等価です。 ::

      def all(iterable):
          for element in iterable:
              if not element:
                  return False
          return True

   .. versionadded:: 2.5


.. function:: any(iterable)

   *iterable* のいずれかの要素が真ならば :const:`True` を返します。以
   下のコードと等価です。 ::

      def any(iterable):
          for element in iterable:
              if element:
                  return True
          return False

   .. versionadded:: 2.5


.. function:: basestring()

   この抽象型は、 :class:`str` および :class:`unicode` のスーパクラス
   です。
   この型は呼び出したりインスタンス化したりはできませんが、オブジェク
   トが :class:`str` や :class:`unicode` のインスタンスであるかどうか
   を調べる際に利用できます。 ``isinstance(obj, basestring)`` は
   ``isinstance(obj, (str, unicode))`` と等価です。

   .. versionadded:: 2.3


.. function:: bin(x)

   Convert an integer number to a binary string. The result is a valid Python
   整数値をバイナリ文字列に変換します。結果は正常な Python の表現となります。
   *x* が Python の :class:`int` オブジェクトで無い場合、 :meth:`__index__` 
   expression.  If *x* is not a Python :class:`int` object, it has to define an
   :meth:`__index__` method that returns an integer.

   .. versionadded:: 2.6


.. function:: bool([x])

   標準の真値テストを使って、値をブール値に変換します。 *x* が偽なら、
   :const:`False` を返します; そうでなければ :const:`True` を返します。
   ``bool`` はクラスでもあり、 ``int`` のサブクラスになります。
   ``bool`` クラスはそれ以上サブクラス化できません。このクラスのインス
   タンスは :const:`False` および :const:`True` だけです。

   .. index:: pair: Boolean; type

   .. versionadded:: 2.2.1

   .. versionchanged:: 2.3
      引数が与えられなかった場合、この関数は :const:`False` を返します。


.. function:: callable(object)

   引数 *object* が呼び出し可能オブジェクトであれば、 :const:`True` を
   返します。そうでなければ、 :const:`False` を返します。
   この関数が真を返しても *object* の呼び出しは失敗する可能性がありま
   すが、偽を返した場合は決して成功することはありません。クラスは呼び
   出し可能 (クラスを呼び出すと新しいインスタンスを返します) なことと、
   クラスのインスタンスがメソッド :meth:`__call__` を持つ場合には呼び
   出しが可能なので注意してください。


.. function:: chr(i)

   ASCII コードが整数 *i* となるような文字 1 字からなる文字列を返しま
   す。例えば、 ``chr(97)`` は文字列 ``'a'`` を返します。
   この関数は :func:`ord` の逆です。引数は [0..255] の両端を含む範囲内
   に収まらなければなりません; *i* が範囲外の値のときには
   :exc:`ValueError` が送出されます。 :func:`unichr` も参照下さい。


.. function:: classmethod(function)

   *function* のクラスメソッドを返します。

   クラスメソッドは、インスタンスメソッドが暗黙の第一引数としてインス
   タンスをとるように、第一引数としてクラスをとります。
   クラスメソッドを宣言するには、以下の書きならわしを使います。::

      class C:
          @classmethod
          def f(cls, arg1, arg2, ...): ...

   ``@classmethod`` は関数 :term:`decorator` (デコレータ)形式です。詳
   しくは :ref:`function` の、関数定義についての説明を参照してください。

   このメソッドはクラスで呼び出すこと (例えば C.f() ) も、インスタンス
   として呼び出すこと (例えば C().f()) もできます。
   インスタンスはそのクラスが何であるかを除いて無視されます。クラスメ
   ソッドが導出クラスに対して呼び出された場合、導出されたクラスオブジェ
   クトが暗黙の第一引数として渡されます。

   クラスメソッドは C++ や Java における静的メソッドとは異なります。そ
   のような機能を求めているなら、 :func:`staticmethod` を参照してくだ
   さい。

   クラスメソッドについてさらに情報が必要ならば、 :ref:`types` の型階
   層の項を参照下さい。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      関数デコレータ構文を追加しました.


.. function:: cmp(x, y)

   二つのオブジェクト *x* および *y* を比較し、その結果に従って整数を
   返します。戻り値は ``x`` < ``y`` のときには負、 ``x == y`` の時には
   ゼロ、 ``x > y`` には厳密に正の値になります。


.. function:: compile(source, filename, mode[, flags[, dont_inherit]])

   *source* をコード、もしくは、 AST オブジェクトにコンパイルします。
   コードオブジェクトは :keyword:`exec` 文により実行したり、
   :func:`eval` で評価したりすることができます。
   *source* は、文字列と AST オブジェクトのどちらでもかまいません。
   AST オブジェクトへの、また、 AST オブジェクトからのコンパイルの方法
   は、 :mod:`_ast` モジュールのドキュメントを参照下さい。

   複数行にわたる文字列をコンパイルするとき、以下の2点に注意して下さい。 :
   行は単一の改行文字 (``'\n'``) で表現されなければなりません。また、
   入力は少なくとも1つの改行文字で終端されなければなりません。もし、行
   の終わりが ``'\r\n'`` で表現されていれば、 :meth:`replace` を使って
   ``'\n'`` に置き換えて下さい。

   引数 *filename* には、コードの読み出し元のファイルを与えなければなり
   ません。 ;
   ファイルから読み出されたもので無い場合は、認識可能な値を渡して下さ
   い (``'<string>'`` が一般的に使われます ) 。

   引数 *mode* は、どのような種類のコードがコンパイルされるべきかを指
   定します。 ;
   もし、 *source* が一連の文から成る場合、 ``'exec'`` 、単一の式の場
   合、 ``'eval'`` 、単一の対話的文の場合 ``'single'`` が指定できます
   ( 後者の場合、 ``None`` 以外のものを評価する式が印字されます ) 。

   オプションの引数 *flags* および *dont_inherit* (Python 2.2 で新た
   に追加) は、 *string* のコンパイル時にどの future 文 (:pep:`236` 参
   照) の影響を及ぼすかを制御します。どちらも省略した場合 (または両方
   ともゼロの場合)、コンパイルを呼び出している側のコードで有効になって
   いる future 文の内容を有効にして *string* をコンパイルします。　
   *flags* が指定されていて、かつ *dont_inherit* が指定されていない
   (またはゼロ) の場合、上の場合に加えて *flags* に指定された future
   文を使います。 *dont_inherit* がゼロでない整数の場合、 *flags* の値
   そのものを使い、この関数呼び出し周辺での future 文の効果は無視しま
   す。

   future 文はビットで指定され、互いにビット単位の論理和を取って複数の
   文を指定できます。ある機能を指定するために必要なビットフィールドは、
   :mod:`__future__` モジュールの :class:`_Feature` インスタンスにおけ
   る :attr:`compiler_flag` 属性で得られます。

   この関数は、コンパイルするソースが不正である場合、
   :exc:`SyntaxError` を送出します。ソースがNull Byteを含む場合、
   :exc:`TypeError` を送出します。

   .. versionadded:: 2.6
      AST オブジェクトのコンパイルをサポートしました。


.. function:: complex([real[, imag]])

   値 *real* + *imag*\*j の複素数型数を生成するか、文字列または数値を
   複素数型に変換します。最初の引数が文字列の場合、文字列を複素数とし
   て変換します。この場合関数は二つ目の引数無しで呼び出さなければなり
   ません。二つ目の引数は文字列であってはなりません。それぞれの引数は
   (複素数を含む) 任意の数値型をとることができます。 *imag* が省略され
   た場合、標準の値はゼロで、関数は :func:`int` 、 :func:`long` および
   :func:`float` のような数値型への変換関数として動作します。全ての引
   数が省略された場合、 ``0j`` を返します。
   
   複素数型については :ref:`typesnumeric` に説明があります。


.. function:: delattr(object, name)

   :func:`setattr` の親戚となる関数です。引数はオブジェクトと文字列で
   す。文字列はオブジェクトの属性のどれか一つの名前でなければなりませ
   ん。この関数は与えられた名前の属性を削除しますが、オブジェクトがそ
   れを許す場合に限ります。例えば、 ``delattr(x, 'foobar')`` は ``del
   x.foobar`` と等価です。


.. function:: dict([arg])
   :noindex:

   新しい辞書型データを作成します。オプションとして引数 *arg* が与える
   ことができます。
   辞書型については、 :ref:`typesmapping` に説明があります。

   他のコンテナについては、組み込みクラスの :class:`list` 、
   :class:`set` 、 :class:`tuple` 、および、モジュールの
   :mod:`collections` を参照下さい。


.. function:: dir([object])

   引数がない場合、現在のローカルスコープにある名前のリストを返します。
   引数がある場合、そのオブジェクトの有効な属性からなるリストを返そう
   と試みます。
   もし、オブジェクトが :meth:`__dir__` メソッドを持つなら、このメソッ
   ドが呼び出され、属性のリストを返します。これにより、 :func:`dir` が
   オブジェクトの属性を返す方法をカスタマイズするために、
   :func:`__getattr__` や :func:`__getattribute__` といったカスタム関
   数を実装することができます。

   オブジェクトが :meth:`__dir__` を提供していない場合、オブジェクトの
   :attr:`__dict__` 属性が定義されていれば、そこから収集しようと試みます。
   また、型オブジェクトからも集められます。リストは完全なものになると
   は限りません。また、カスタム関数 :func:`__getattr__` を持つ場合、不
   正確になるでしょう。

   デフォルトの :func:`dir` メカニズムの振る舞いは、異なる型のオブジェ
   クトでは、異なります。それは、完全というよりは、より関連のある情報
   を生成しようとするためです。
   
   * オブジェクトがモジュールオブジェクトの場合、リストにはモジュール
     属性の名前が含まれます。

   * オブジェクトが型オブジェクトやクラスオブジェクトの場合、リストに
     はそれらの属性が含まれ、かつそれらの基底クラスの属性も再帰的にた
     どられて含まれます。

   * それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、
     再帰的にたどった基底クラスの属性名が含まれます。
     
   返されるリストはアルファベット順に並べられています。例えば ::

      >>> import struct
      >>> dir()   # doctest: +SKIP
      ['__builtins__', '__doc__', '__name__', 'struct']
      >>> dir(struct)   # doctest: +NORMALIZE_WHITESPACE
      ['Struct', '__builtins__', '__doc__', '__file__', '__name__',
       '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
       'unpack', 'unpack_from']
      >>> class Foo(object):
      ...     def __dir__(self):
      ...         return ["kan", "ga", "roo"]
      ...
      >>> f = Foo()
      >>> dir(f)
      ['ga', 'kan', 'roo']

   .. note::

      :func:`dir` は主に対話プロンプトのために提供されているので、厳
      密さや一貫性をもって定義された名前のセットよりも、むしろ興味深い
      名前のセットを与えようとします。また、この関数の細かい動作はリリー
      ス間で変わる可能性があります。例えば、引数がクラスである場合、メ
      タクラス属性は結果のリストに含まれません。


.. function:: divmod(a, b)

   2 つの (複素数でない) 数値を引数として取り、長除法を行ってその商と
   剰余からなるペアを返します。被演算子が型混合である場合、 2 進算術演
   算子での規則が適用されます。通常の整数と長整数の場合、結果は  ``(a
   // b, a % b)`` と同じです。浮動小数点数の場合、結果は ``(q, a %
   b)`` であり、 *q* は通常 ``math.floor(a / b)`` ですが、そうではなく
   1 になることもあります。
   いずれにせよ、 ``q * b + a % b`` は *a* に非常に近い値になり、 ``a %
   b`` がゼロでない値の場合、その符号は *b* と同じで、 `` 0 <= abs(a %
   b) < abs(b)`` になります。

   .. versionchanged:: 2.3
      複素数に対する :func:`divmod` の使用は廃用されました。


.. function:: enumerate(sequence[, start=0])

   列挙オブジェクトを返します。 *sequence* はシーケンス型、イテレータ
   型、反復をサポートする他のオブジェクト型のいずれかでなければなりま
   せん。 :func:`enumerate` が返すイテレータの :meth:`next` メソッドは、
   (ゼロから始まる) カウント値と、値だけ *iterable* を反復操作して得ら
   れる、対応するオブジェクトを含むタプルを返します。
   :func:`enumerate` はインデクス付けされた値の列: ``(0, seq[0])``,
   ``(1, seq[1])``, ``(2, seq[2])``, ... を得るのに便利です。
   例 :

      >>> for i, season in enumerate(['Spring', 'Summer', 'Fall', 'Winter']):
      ...     print i, season
      0 Spring
      1 Summer
      2 Fall
      3 Winter

   .. versionadded:: 2.3
   .. versionadded:: 2.6
      *start* 引数が追加されました。


.. function:: eval(expression[, globals[, locals]])

   文字列とオプションの引数 *globals* 、 *locals* をとります。
   *globals* を指定する場合には辞書でなくてはなりません。 *locals* は
   任意のマップ型にできます。

   .. versionchanged:: 2.4
      以前は *locals* も辞書でなければなりませんでした.

   引数 *expression* は Python の表現式 (技術的にいうと、条件のリスト
   です) として構文解釈され、評価されます。このとき辞書 *globals* およ
   び *locals* はそれぞれグローバルおよびローカルな名前空間として使わ
   れます。 *locals* 辞書が存在するが、 '__builtins__' が欠けている場
   合、 *expression* を解析する前に現在のグローバル変数を *globals* に
   コピーします。このことから、 *expression* は通常、標準の
   :mod:`__builtin__` モジュールへの完全なアクセスを有し、制限された環
   境が伝播するようになっています。 *locals* 辞書が省略された場合、標
   準の値として *globals* に設定されます。辞書が両方とも省略された場合、
   表現式は :func:`eval` が呼び出されている環境の下で実行されます。
   構文エラーは例外として報告されます。

   以下に例を示します :

      >>> x = 1
      >>> print eval('x+1')
      2

   この関数は (:func:`compile` で生成されるような) 任意のコードオブジェ
   クトを実行するために利用することもできます。この場合、文字列の代わ
   りにコードオブジェクトを渡します。このコードオブジェクトが、引数
   *kind* を ``'exec'`` としてコンパイルされている場合、 :func:`eval`
   が返す値は、 ``None`` になります。

   ヒント: 文の動的な実行は :keyword:`exec` 文でサポートされています。
   ファイルからの文の実行は関数 :func:`execfile` でサポートされていま
   す。関数 :func:`globals` および :func:`locals` は、それぞれ現在のグ
   ローバルおよびローカルな辞書を返すので、 :func:`eval` や
   :func:`execfile` で使うことができます。


.. function:: execfile(filename[, globals[, locals]])

   この関数は :keyword:`exec` 文に似ていますが、文字列の代わりにファイ
   ルに対して構文解釈を行います。 :keyword:`import` 文と違って、モジュー
   ル管理機構を使いません --- この関数はファイルを無条件に読み込み、新
   たなモジュールを生成しません。 [#]_

   引数は文字列とオプションの 2 つの辞書からなります。 *file* は読み込
   まれ、 (モジュールのように) Python 文の列として評価されます。このとき
   *globals* および *locals* がそれぞれグローバル、および、ローカルな
   名前空間として使われます。 *locals* は任意のマップ型に指定できます。

   .. versionchanged:: 2.4
      以前は *locals* も辞書でなければなりませんでした.

   *locals* 辞書が省略された場合、標準の値として *globals* に設定され
    ます。辞書が両方とも省略された場合、表現式は :func:`execfiles` が
    呼び出されている環境の下で実行されます。戻り値は ``None`` です。

   .. warning::

      標準では *locals* は後に述べる関数 :func:`locals` のように動作し
      ます: 標準の *locals* 辞書に対する変更を試みてはいけません。
      :func:`execfile` の呼び出しが返る時にコードが *locals* に与える
      影響を知りたいなら、明示的に *loacals* 辞書を渡してください。
      :func:`execfile` は関数のローカルを変更するための信頼性のある方
      法として使うことはできません。


.. function:: file(filename[, mode[, bufsize]])

   :class:`file` 型のコンストラクタです。詳しくは
   :ref:`bltin-file-objects` 節を参照してください。コンストラクタの引数
   は後述の :func:`open` 組み込み関数と同じです。

   ファイルを開くときは、このコンストラクタを直接呼ばずに :func:`open`
   を呼び出すのが望ましい方法です。 :class:`file` は型テストにより適し
   ています (たとえば ``isinstance(f, file)`` と書くような)。

   .. versionadded:: 2.2


.. function:: filter(function, iterable)

   *iterable* のうち、 *function* が真を返すような要素からなるリストを
   構築します。 *iterable* はシーケンスか、反復をサポートするコンテナ
   か、イテレータです。 *iterable* が文字列型かタプル型の場合、結果も
   同じ型になります。そうでない場合はリストとなります。 *function* が
   ``None`` の場合、恒等関数を仮定します。すなわち、 *iterable* の偽と
   なる要素は除去されます。

   function が ``None`` ではない場合、 ``filter(function, iterable)``
   は ``[item for item in iterable if function(item)]`` と同等です。
   function が ``None`` の場合 ``[item for item in iterable if item]``
   と同等です。

   *function* が false を返す場合に *iterable* の各要素を返す、補完的
   関数である :func:`itertools.filterfalse` を参照下さい。


.. function:: float([x])

   文字列または数値を浮動小数点数に変換します。引数が文字列の場合、十
   進の数または浮動小数点数を含んでいなければなりません。符号が付いて
   いてもかまいません。また、空白文字中に埋め込まれていてもかまいませ
   ん。引数は [+|-]nan 、 [+|-]inf であっても構いません。それ以外の場
   合、引数は通常整数、長整数、または浮動小数点数をとることができ、同
   じ値の浮動小数点数が (Python の浮動小数点精度で) 返されます。引数が
   指定されなかった場合、 ``0.0`` を返します。

   .. note::

      .. index::
         single: NaN
         single: Infinity

      文字列で値を渡す際、背後の C ライブラリによって NaN および
      Infinity が返されるかもしれません。 float は文字列、 nan 、 inf
      、および -inf を、それぞれ、 NaN 、正の無限大、負の無限大として
      解釈します。大文字小文字の違い、 + 記号、および、 nan に対する -
      記号は無視されます。
      
   浮動小数点数型については、 :ref:`typesnumeric` も参照下さい。


.. function:: frozenset([iterable])
   :noindex:

   :class:`frozenset` セットオブジェクトを返します。オプションで
   *iterable* から要素を取得します。
   frozenset 型については、 :ref:`types-set` も参照下さい。

   他のコンテナ型については、組み込みクラスの :class:`dict`,
   :class:`list`, および , :class:`tuple` と、 :mod:`collections` モ
   ジュールを参照下さい。
   
   .. versionadded:: 2.4


.. function:: getattr(object, name[, default])

   指定された *object* の属性を返します。 *name* は文字列でなくてはな
   りません。文字列がオブジェクトの属性名の一つであった場合、戻り値は
   その属性の値になります。例えば、 ``getattr(x, 'foobar')`` は
   ``x.foobar`` と等価です。
   指定された属性が存在しない場合、 *default* が与えられている場合には
   それが返されます。そうでない場合には :exc:`AttributeError`
   が送出されます。


.. function:: globals()

   現在のグローバルシンボルテーブルを表す辞書を返します。常に現在のモ
   ジュールの辞書になります (関数またはメソッドの中ではそれらを定義し
   ているモジュールを指し、この関数を呼び出したモジュールではありませ
   ん)。


.. function:: hasattr(object, name)

   引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つ
   であった場合 ``True`` を、そうでない場合 ``False`` を返します (この
   関数は ``getattr(object, name)`` を呼び出し、例外を送出するかどうか
   を調べることで実装しています)。


.. function:: hash(object)

   オブジェクトのハッシュ値を (存在すれれば) 返します。ハッシュ値は整
   数です。これらは辞書を検索する際に辞書のキーを高速に比較するために
   使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と
   1.0 のように型が異なっていてもです)。


.. function:: help([object])

   組み込みヘルプシステムを起動します (この関数は対話的な使用のための
   ものです)。引数が与えられていない場合、対話的ヘルプシステムはインタ
   プリタコンソール上で起動します。引数が文字列の場合、文字列はモジュー
   ル、関数、クラス、メソッド、キーワード、またはドキュメントの項目名
   として検索され、ヘルプページがコンソール上に印字されます。引数が何
   らかのオブジェクトの場合、そのオブジェクトに関するヘルプページが生
   成されます。

   この関数は、 :mod:`site` モジュールから、組み込みの名前空間に移され
   ました。
   
   .. versionadded:: 2.2


.. function:: hex(x)

   (任意のサイズの) 整数を16進の文字列に変換します。結果は Python の式
   としても使える形式になります。

   .. versionchanged:: 2.4
      以前は符号なしのリテラルしか返しませんでした.


.. function:: id(object)

   オブジェクトの "識別値" を返します。この値は整数 (または長整数) で、
   このオブジェクトの有効期間は一意かつ定数であることが保証されていま
   す。
   オブジェクトの有効期間が重ならない 2 つのオブジェクトは同じ
   :func:`id` 値を持つかもしれません。 (実装に関する注釈: この値はオブ
   ジェクトのアドレスです。)


.. function:: input([prompt])

   ``eval(raw_input(prompt))`` と同じです。

   .. warning::

      この関数はユーザのエラーに対して安全ではありません ! この関数で
      は、入力は有効な Python の式であると期待しています; 入力が構文的
      に正しくない場合、 :exc:`SyntaxError` が送出されます。式を評価す
      る際にエラーが生じた場合、他の例外も送出されるかもしれません。
      (一方、この関数は時に、熟練者がすばやくスクリプトを書く際に必要
      なまさにそのものです)

   :mod:`readline` モジュールが読み込まれていれば、 :func:`input` は精
   緻な行編集およびヒストリ機能を提供します。

   一般的なユーザからの入力のための関数としては :func:`raw_input` を使
   うことを検討してください。


.. function:: int([x[, radix]])

   文字列または数値を通常の整数に変換します。引数が文字列の場合、
   Python 整数として表現可能な十進の数でなければなりません。
   符号が付いていてもかまいません。また、空白文字中に埋め込まれていて
   もかまいません。 *radix* 引数は変換の基数 (デフォルト値は10です) を
   表し、範囲 [2, 36] の整数またはゼロをとることができます。 *radix*
   がゼロの場合、文字列の内容から適切な基数を推測します; 変換は整数リ
   テラルと同じです (:ref:`numbers` を参照下さい) 。
   *radix* が指定されており、 *x* が文字列でない場合、
   :exc:`TypeError` が送出されます。それ以外の場合、引数は通常整数、長
   整数、または浮動小数点数をとることができます。浮動小数点数から整数
   へ変換では (ゼロ方向に) 値を丸めます。引数が通常整数の範囲を超えて
   いる場合、長整数が代わりに返されます。
   引数が与えられなかった場合、 ``0`` を返します。

   整数型については、 :ref:`typesnumeric` も参照下さい。


.. function:: isinstance(object, classinfo)

   引数 *object* が引数 *classinfo* のインスタンスであるか、 (直接また
   は間接的な) サブクラスのインスタンスの場合に真を返します。
   また、 *classinfo* が型オブジェクト (新しい形式のクラス) であり、
   *object* がその型のオブジェクトであるか、または、 (直接的または間接
   的な) サブクラスの場合にも真を返します。 *object* がクラスインスタ
   ンスや与えられた型のオブジェクトでない場合、この関数は常に偽を返し
   ます。
   *classinfo* をクラスオブジェクトでも型オブジェクトにもせず、クラス
   や型オブジェクトからなるタプルや、そういったタプルを再帰的に含むタ
   プル (他のシーケンス型は受理されません) でもかまいません。
   *classinfo* がクラス、型、クラスや型からなるタプル、そういったタプ
   ルが再帰構造をとっているタプルのいずれでもない場合、例外
   :exc:`TypeError` が送出されます。

   .. versionchanged:: 2.2
      型情報をタプルにした形式のサポートが追加されました。


.. function:: issubclass(class, classinfo)

   *class* が *classinfo* の (直接または間接的な) サブクラスである場合
   に真を返します。クラスはそのクラス自体のサブクラスと *clasinfo* は
   クラスオブジェクトからなるタプルでもよく、この場合には *classinfo*
   のすべてのエントリが調べられます。その他の場合では、例外
   :exc:`TypeError` が送出されます。

   .. versionchanged:: 2.3
      型情報からなるタプルへのサポートが追加されました.


.. function:: iter(o[, sentinel])

   :term:`iterator` (イテレータ)オブジェクトを返します。 2 つ目の引数
   があるかどうかで、最初の引数の解釈は非常に異なります。 2 つ目の引数
   がない場合、 *o* は反復プロトコル (:meth:`__iter__` メソッド) か、
   シーケンス型プロトコル (引数が ``0`` から開始する
   :meth:`__getitem__` メソッド) をサポートする集合オブジェクトでなけ
   ればなりません。これらのプロトコルが両方ともサポートされていない場
   合、 :exc:`TypeError` が送出されます。
   2 つ目の引数 *sentinel* が与えられていれば、 *o* は呼び出し可能なオ
   ブジェクトでなければなりません。この場合に生成されるイテレータは、
   :meth:`next` を呼ぶ毎に *o* を引数無しで呼び出します。返された値が
   *sentinel* と等しければ、 :exc:`StopIteration` が送出されます。そう
   でない場合、戻り値がそのまま返されます。

   .. versionadded:: 2.2


.. function:: len(s)

   オブジェクトの長さ (要素の数) を返します。引数はシーケンス型 (文字
   列、タプル、またはリスト) か、マップ型 (辞書) です。


.. function:: list([iterable])

   *iterable* の要素と同じ要素をもち、かつ順番も同じなリストを返します。
   *sequence* はシーケンス、反復処理をサポートするコンテナ、あるいはイ
   テレータオブジェクトです。 *sequence* がすでにリストの場合、
   ``iterable[:]`` と同様にコピーを作成して返します。
   例えば、 ``list('abc')`` は ``['a', 'b', 'c']`` および ``list((1, 2,
   3))`` は ``[1, 2, 3]`` を返します。引数が与えられなかった場合、新
   しい空のリスト ``[]`` を返します。

   :class:`list` は変更可能なシーケンス型であり、 :ref:`typesseq` に記
   述があります。他のコンテナ型については組み込み型の :class:`dict`,
   :class:`set`, および :class:`tuple` クラスと、 :mod:`collections`
   モジュールを参照下さい。


.. function:: locals()

   現在のローカルシンボルテーブルを表す辞書を更新して返します。

   .. warning::

      この辞書の内容は変更してはいけません; 値を変更しても、インタプリ
      タが使うローカル変数の値には影響しません。

   :func:`locals` が関数ブロックで呼び出された場合、自由変数を返します。
   自由変数を変更しても、インタープリタが使う変数に影響しません。自由
   変数はクラスブロックの中では返されません。


.. function:: long([x[, radix]])

   文字列または数値を長整数値に変換します。引数が文字列の場合、 Python
   整数として表現可能な十進の数でなければなりません。
   符号が付いていてもかまいません。また、空白文字中に埋め込まれていて
   もかまいません。 *radix* 引数は :func:`int` と同じように解釈され、
   *x* が文字列の時だけ与えることができます。それ以外の場合、引数は通
   常整数、長整数、または浮動小数点数をとることができ、同じ値の長整数
   が返されます。浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸め
   ます。引数が与えられなかった場合、 ``0L`` を返します。

   長整数型については、 :ref:`typesnumeric` も参照下さい。


.. function:: map(function, iterable, ...)

   *function* を *iterable* の全ての要素に適用し、返された値からなるリ
   ストを返します。追加の *iterable* 引数を与えた場合、 *function* は
   それらを引数として取らなければならず、関数はそのリストの全ての要素
   について個別に適用されます; 他のリストより短いリストがある場合、要
   素 ``None`` で延長されます。 *function* が ``None`` の場合、恒等関
   数であると仮定されます; すなわち、複数のリスト引数が存在する場合、
   :func:`map` は全てのリスト引数に対し、対応する要素からなるタプルか
   らなるリストを返します (転置操作のようなものです)。 *list* 引数はど
   のようなシーケンス型でもかまいません; 結果は常にリストになります。


.. function:: max(iterable[, args...][key])

   引数が *iterable* だけの場合、空でないシーケンス (文字列、タプルま
   たはリスト) の要素のうち最大のものを返します。 1 個よりも引数が多い
   場合、引数間で最大のものを返します。

   オプションの *key* 引数には :meth:`list.sort` で使われるのと同じよ
   うな 1 引数の順序付け関数を指定します。 *key* を指定する場合はキー
   ワード形式でなければなりません (たとえば ``max(a,b,c,key=func)``)。

   .. versionchanged:: 2.5
      オプションの *key* 引数が追加されました.


.. function:: min(iterable[, args...][key])

   引数が *iterable* だけの場合、空でないシーケンス (文字列、タプルま
   たはリスト) の要素のうち最小のものを返します。 1  個よりも引数が多
   い場合、引数間で最小のものを返します。

   オプションの *key* 引数には :meth:`list.sort` で使われるのと同じよ
   うな 1 引数の順序付け関数を指定します。 *key* を指定する場合はキー
   ワード形式でなければなりません (たとえば ``min(a,b,c,key=func)``)。

   .. versionchanged:: 2.5
      オプションの *key* 引数が追加されました.


.. function:: next(iterator[, default])

   *iterator* から、 :meth:`next` メソッドにより、次の要素を取得します。
   もし、 *default* が与えられると、イテレータが空である場合に、それが
   返されます。それ以外の場合は、 :exc:`StopIteration` が送出されます。

   .. versionadded:: 2.6


.. function:: object()

   ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。
   :class:`object()` は新スタイルのクラスの、基底クラスです。これは、
   新スタイルのクラスのインスタンスに共通のメソッド群を持ちます。

   .. versionadded:: 2.2

   .. versionchanged:: 2.3
      この関数はいかなる引数も受け付けません。以前は、引数を受理しまし
      たが無視していました。


.. function:: oct(x)

   (任意のサイズの) 整数を 8 進の文字列に変換します。結果は Python の
   式としても使える形式になります。

   .. versionchanged:: 2.4
      以前は符号なしのリテラルしか返しませんでした.


.. function:: open(filename[, mode[, bufsize]])

   ファイルを開いて、  :ref:`bltin-file-objects` にて説明される、
   :class:`file` オブジェクトを返します。もし、ファイルが開けないなら、
   :exc:`IOError` が送出されます。ファイルを開くときは :class:`file`
   のコンストラクタを直接呼ばずに :func:`open` を使うのが望ましい方法
   です。

   最初の 2 つの引数は ``studio`` の :cfunc:`fopen` と同じです:
   *filename* は開きたいファイルの名前で、 *mode* はファイルをどのよう
   にして開くかを指定します。

   最もよく使われる *mode* の値は、読み出しの ``'r'`` 、書き込み (ファ
   イルがすでに存在すれば切り詰められます) の ``'w'`` 、追記書き込みの
   ``'a'`` です (*いくつかの* Unix システムでは、 *全て* の書き込みが
   現在のファイルシーク位置に関係なくファイルの末尾に追加されます)。
   *mode* が省略された場合、標準の値は ``'r'`` になります。デフォルト
   ではテキストモードでファイルを開きます。 ``'\n'`` 文字は、プラット
   フォームでの改行の表現に変換されます。移植性を高めるために、バイナ
   リファイルを開くときには、 *mode* の値に ``'b'`` を追加しなければな
   りません。(バイナリファイルとテキストファイルを区別なく扱うようなシ
   ステムでも、ドキュメンテーションの代わりになるので便利です。) 他に
   *mode* に与えられる可能性のある値については後述します。

   .. index::
      single: line-buffered I/O
      single: unbuffered I/O
      single: buffer size, I/O
      single: I/O control; buffering

   オプションの *bufsize* 引数は、ファイルのために必要とするバッファの
   サイズを指定します: 0 は非バッファリング、 1 は行単位バッファリング、
   その他の正の値は指定した値 (の近似値) のサイズをもつバッファを使用
   することを意味します。 *bufsize* の値が負の場合、システムの標準を使
   います。通常、端末は行単位のバッファリングであり、その他のファイル
   は完全なバッファリングです。省略された場合、システムの標準の値が使
   われます。  [#]_

   ``'r+'``, ``'w+'``, および ``'a+'`` はファイルを更新モードで開き
   ます (``'w+'`` はファイルがすでに存在すれば切り詰めるので注意してく
   ださい)。バイナリとテキストファイルを区別するシステムでは、ファイル
   をバイナリモードで開くためには ``'b'`` を追加してください (区別しな
   いシステムでは ``'b'`` は無視されます)。

   標準の :cfunc:`fopen` における *mode* の値に加えて、 ``'U'`` または
   ``'rU'`` を使うことができます。 Python が全改行文字サポートを行って
   いる (標準ではしています) 場合、ファイルがテキストファイルで開かれ
   ますが、行末文字として Unix における慣行である ``'\n'`` 、Macintosh
   における慣行である ``'\r'`` 、 Windows における慣行である
   ``'\r\n'`` のいずれを使うこともできます。これらの改行文字の外部表現
   はどれも、 Python プログラムからは ``'\n'`` に見えます。 Python が
   全改行文字サポートなしで構築されている場合、 *mode* ``'U'`` は通常
   のテキストモードと同様になります。開かれたファイルオブジェクトはま
   た、 :attr:`newlines` と呼ばれる属性を持っており、その値は ``None``
   (改行が見つからなかった場合)、 ``'\n'``, ``'\r'``, ``'\r\n'``,
   または見つかった全ての改行タイプを含むタプルになります。

   ``'U'`` を取り除いた後のモードは ``'r'``, ``'w'``, ``'a'`` のいず
   れかで始まる、というのが Python における規則です。
   
   Python では、 :mod:`fileinput`, :mod:`os`, :mod:`os.path`,
   :mod:`tempfile`, :mod:`shutil` などの多数のファイル操作モジュールが
   提供されています。
   
   .. versionchanged:: 2.5
      モード文字列の先頭についての制限が導入されました.


.. function:: ord(c)

   長さ 1 の与えられた文字列に対し、その文字列が unicode オブジェクト
   ならば Unicode コードポイントを表す整数を、 8 ビット文字列ならばそ
   のバイトの値を返します。たとえば、 ``ord('a')`` は整数 ``97`` を返
   し、 ``ord(u'\u2020')`` は ``8224`` を返します。この値は 8 ビット文
   字列に対する :func:`chr` の逆であり、 unicode オブジェクトに対する
   :func:`unichr` の逆です。引数が unicode で Python が UCS2 Unicode
   対応版ならば、その文字のコードポイントは両端を含めて [0..65535] の
   範囲に入っていなければなりません。この範囲から外れると文字列の長さ
   が 2 になり、 :exc:`TypeError` が送出されることになります。


.. function:: pow(x, y[, z])

   *x* の *y* 乗を返します; *z* があれば、 *x* の *y* 乗に対する *z*
   のモジュロを返します (``pow(x, y)% z`` より効率よく計算されます)。
   引数二つの ``pow(x, y)`` という形式は、冪乗演算子を使った ``x**y``
   と等価です。
    
   引数は数値型でなくてはなりません。型混合の場合、 2 進算術演算におけ
   る型強制規則が適用されます。通常整数、および、長整数の被演算子に対
   しては、二つ目の引数が負の数でない限り、結果は (型強制後の) 被演算
   子と同じ型になります;
   負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型の結果が
   返されます。例えば、 ``10**2`` は ``100`` を返しますが、 ``10**-2``
   は ``0.01`` を返します。 (最後に述べた機能は Python 2.2 で追加され
   たものです。 Python 2.1 以前では、双方の引数が整数で二つ目の値が負
   の場合、例外が送出されます。) 二つ目の引数が負の場合、三つめの引数
   は無視されます。 *z* がある場合、 *x* および *y* は整数型でなければ
   ならず、 *y* は非負の値でなくてはなりません (この制限は Python 2.2
   で追加されました。 Python 2.1 以前では、 3 つの浮動小数点引数を持つ
   ``pow()`` は浮動小数点の丸めに関する偶発誤差により、プラットフォー
   ム依存の結果を返します)。


.. function:: print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout])

   *object* (複数でも可) を *sep* で区切りながらストリーム、 *file* に
   表示し、最後に *end* を表示します。 *sep*, *end* そして *file* が
   与えられる場合、キーワードと共に与えられる必要があります。

   キーワードなしの引数は、 :func:`str` がするように、すべて、文字列に
   変換され、 *sep* で区切られながらストリームに書き出され、最後に
   *end* を書き出します。 *sep* と *end* の両方とも、文字列でなければ
   なりません。; デフォルトの値を指定するために、 ``None`` であっても
   構いません。もし、 *object* が与えられなければ、 :func:`print` は、
   単純に *end* だけ書き出します。

   *file* 引数は、 ``write(string)`` メソッドを持つオブジェクトでなけ
   ればなりません。指定されないか、 ``None`` であった場合には、
   :data:`sys.stdout` が使われます。

   .. note::

      この関数は ``print`` という名前が :keyword:`print` ステートメン
      トとして解釈されるため、通常は使用できません。ステートメントを無
      効化して、 :func:`print` 関数を使うためには、以下の future ステー
      トメントをモジュールの最初に書いて下さい。::

         from __future__ import print_function

   .. versionadded:: 2.6


.. function:: property([fget[, fset[, fdel[, doc]]]])

   :term:`new-style class` (新しい形式のクラス) (:class:`object` から
   導出されたクラス) におけるプロパティ属性を返します。

   *fget* は属性値を取得するための関数で、同様に *fset* は属性値を設定
   するための関数です。また、 *fdel* は属性を削除するための関数です。
   以下に属性 x を扱う典型的な利用法を示します。::

      class C(object):
          def __init__(self):
              self._x = None

          def getx(self):
              return self._x
          def setx(self, value):
              self._x = value
          def delx(self):
              del self._x
          x = property(getx, setx, delx, "I'm the 'x' property.")

   *doc* がもし与えられたならばそれがプロパティ属性のドキュメント文字
   列になります。与えられない場合、プロパティは *fget* のドキュメント
   文字列(がもしあれば)をコピーします。これにより、読み取り専用プロパ
   ティを :func:`property` を :term:`decorator` (デコレータ)として使っ
   て容易に作れるようになります。::

      class Parrot(object):
          def __init__(self):
              self._voltage = 100000

          @property
          def voltage(self):
              """Get the current voltage."""
              return self._voltage

   のようにすると、 :meth:`voltage` が同じ名前の読み取り専用属性の
   "getter" になります。
   
   プロパティオブジェクトは、属性参照関数を装飾関数として備えた、属性
   の複製を生成するデコレータに適した、 :attr:`getter`,
   :attr:`setter`, および :attr:`deleter` メソッドを持ちます。これは、
   以下が良い例です。::

      class C(object):
          def __init__(self):
              self._x = None

          @property
          def x(self):
              """I'm the 'x' property."""
              return self._x

          @x.setter
          def x(self, value):
              self._x = value

          @x.deleter
          def x(self):
              del self._x

   このコードは、最初の例と等価です。追加の関数に、元々の属性と同じ名
   前 (この例では、 ``x`` です) を与えることに注意して下さい。

   返される属性も、コンストラクタの引数を反映した、 ``fget``,
   ``fset``, そして ``fdel`` 属性を持ちます。 

   .. versionadded:: 2.2

   .. versionchanged:: 2.5
      *doc* が与えられない場合に *fget* のドキュメント文字列を使う。


.. function:: range([start,] stop[, step])

   数列を含むリストを生成するための多機能関数です。 :keyword:`for` ルー
   プでよく使われます。引数は通常の整数でなければなりません。 *step*
   引数が無視された場合、標準の値 ``1`` になります。 *start* 引数が省
   略された場合、標準の値 ``0`` になります。完全な形式では、通常の整数列
   ``[start, start + step, start + 2 * step, ...]`` を返します。
   ...*step* が正の値の場合、最後の要素は *stop* よりも小さい ``start
   + i * step`` の最大値になります; *step* が負の値の場合、最後の要素
   は *stop* よりも大きい ``start + i * step`` の最小値になります。
   *step* はゼロであってはなりません (さもなければ :exc:`ValueError`
   が送出されます)。以下に例を示します。::

      >>> range(10)
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      >>> range(1, 11)
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      >>> range(0, 30, 5)
      [0, 5, 10, 15, 20, 25]
      >>> range(0, 10, 3)
      [0, 3, 6, 9]
      >>> range(0, -10, -1)
      [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
      >>> range(0)
      []
      >>> range(1, 0)
      []


.. function:: raw_input([prompt])

   引数 *proompt* が存在する場合、末尾の改行を除いて標準出力に出力され
   ます。次に、この関数は入力から 1 行を読み込んで文字列に変換して (末
   尾の改行を除いて) 返します。 EOF が読み込まれると :exc:`EOFError`
   が送出されます。以下に例を示します。::

      >>> s = raw_input('--> ')
      --> Monty Python's Flying Circus
      >>> s
      "Monty Python's Flying Circus"

   :mod:`readline` モジュールが読み込まれていれば、 :func:`input` は精
   緻な行編集およびヒストリ機能を提供します。


.. function:: reduce(function, iterable[, initializer])

   *iterable* の要素に対して、iterableを単一の値に短縮するような形で
   2 つの引数をもつ *function* を左から右に累積的に適用します。
   例えば、 ``reduce(labmda x, y: x+y, [1, 2, 3, 4, 5])`` は
   ``((((1+2)+3)+4)+5)`` を計算します。左引数 *x* は累計の値になり、右
   引数 *y* は ``iterable`` から取り出した更新値になります。オプション
   の *initializer* が存在する場合、計算の際に iterable の先頭に置かれ
   ます。また、 iterable が空の場合には標準の値になります。
   *initializer* が与えられておらず、 *iterable* が単一の要素しか持っ
   ていない場合、最初の要素が返されます。


.. function:: reload(module)

   すでにインポートされた *module* を再解釈し、再初期化します。引数は
   モジュールオブジェクトでなければならないので、予めインポートに成功
   していなければなりません。この関数はモジュールのソースコードファイ
   ルを外部エディタで編集して、 Python インタプリタから離れることなく
   新しいバージョンを試したい際に有効です。戻り値は (*module* 引数と同
   じ) モジュールオブジェクトです。

   ``reload(module)`` を実行すると、以下の処理が行われます:

   * Python モジュールのコードは再コンパイルされ、モジュールレベルのコー
     ドは再度実行されます。モジュールの辞書中にある、何らかの名前に結
     び付けられたオブジェクトを新たに定義します。拡張モジュール中の
     ``init`` 関数が二度呼び出されることはありません。

   * Python における他のオブジェクトと同様、以前のオブジェクトのメモリ
     領域は、参照カウントがゼロにならないかぎり再利用されません。

   * モジュール名前空間内の名前は新しいオブジェクト (または更新された
     オブジェクト) を指すよう更新されます。

   * 以前のオブジェクトが (外部の他のモジュールなどからの) 参照を受け
     ている場合、それらを新たなオブジェクトにバインドし直すことはない
     ので、必要なら自分で名前空間を更新せねばなりません。

   いくつか補足説明があります:

   モジュールは文法的に正しいが、その初期化には失敗した場合、そのモジュー
   ルの最初の :keyword:`import` 文はモジュール名をローカルにはバインド
   しませんが、(部分的に初期化された) モジュールオブジェクトを
   ``sys.modules`` に記憶します。従って、モジュールをロードしなおすに
   は、 :func:`reload` する前にまず :keyword:`import` (モジュールの名
   前を部分的に初期化されたオブジェクトにバインドします) を再度行わな
   ければなりません。

   モジュールが再ロードされた再、その辞書 (モジュールのグローバル変数
   を含みます) はそのまま残ります。名前の再定義を行うと、以前の定義を
   上書きするので、一般的には問題はありません。新たなバージョンのモジュー
   ルが古いバージョンで定義された名前を定義していない場合、古い定義が
   そのまま残ります。
   辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、
   この機能をモジュールを有効性を引き出すために使うことができます ---
   つまり、 :keyword:`try` 文を使えば、必要に応じてテーブルがあるかど
   うかをテストし、その初期化を飛ばすことができます。::

      try:
          cache
      except NameError:
          cache = {}

   組み込みモジュールや動的にロードされるモジュールを再ロードすること
   は、不正なやり方ではありませんが、一般的にそれほど便利ではありませ
   ん。例外は :mod:`sys`, :mod:`__main__` および :mod:`__builtin__` で
   す。しかしながら、多くの場合、拡張モジュールは 1 度以上初期化される
   ようには設計されておらず、再ロードされた場合には何らかの理由で失敗
   するかもしれません。

   一方のモジュールが :keyword:`from` ... :keyword:`import` ...
   を使って、オブジェクトを他方のモジュールからインポートしているなら、
   他方のモジュールを :func:`reload` で呼び出しても、そのモジュールか
   らインポートされたオブジェクトを再定義することはできません --- この
   問題を回避する一つの方法は、 :keyword:`from` 文を再度実行することで、
   もう一つの方法は :keyword:`from` 文の代わりに :keyword:`import` と
   限定的な名前 (*module*.*name*) を使うことです。

   あるモジュールがクラスのインスタンスを生成している場合、そのクラス
   を定義しているモジュールの再ロードはそれらインスタンスのメソッド定
   義に影響しません --- それらは古いクラス定義を使いつづけます。これは
   導出クラスの場合でも同じです。


.. function:: repr(object)

   オブジェクトの印字可能な表現を含む文字列を返します。これは型変換で
   得られる (逆クオートの) 値と同じです。通常の関数としてこの操作にア
   クセスできるとたまに便利です。この関数は多くの型について、
   :func:`eval` に渡されたときに同じ値を持つようなオブジェクトを表す文
   字列を生成しようとします。そうでない場合は、角括弧に囲まれたオブジェ
   クトの型の名前と追加の情報 (大抵の場合はオブジェクトの名前とアドレ
   スを含みます) を返します。クラスは、 :meth:`__repr__` メソッドを定
   義することで、この関数によりそのクラスのインスタンスが返すものを制
   御することができます。


.. function:: reversed(seq)

   要素を逆順に取り出すイテレータ (reverse :term:`iterator`) を返します。
   *seq* は :meth:`__reversed__` メソッドを持つオブジェクトであるか、
   シーケンス型プロトコル (:meth:`__len__` メソッド、および、 ``0`` か
   ら始まる整数を引数にとる :meth:`__getitem__` メソッド) をサポートし
   ていなければなりません。

   .. versionadded:: 2.4

   .. versionchanged:: 2.6
      カスタムの :meth:`__reversed__` メソッドを書く可能性を追加しました。


.. function:: round(x[, n])

   *x* を小数点以下 *n* 桁で丸めた浮動小数点数の値を返します。 *n* が
   省略されると、標準の値はゼロになります。結果は浮動小数点数です。値
   は最も近い 10 のマイナス *n* の倍数に丸められます。二つの倍数との
   距離が等しい場合、ゼロから離れる方向に丸められます (従って、例えば
   ``round(0.5)`` は ``1.0`` になり、 ``round(-0.5)`` は ``-1.0`` に
   なります)。


.. function:: set([iterable])
   :noindex:

   新しいセット型オブジェクトを返します。オプションで *iterable* から
   とった要素を持たせることもできます。
   
   他のコンテナについては、組み込みクラスの :class:`dict`,
   :class:`list`, および :class:`tuple` クラス、および、
   :mod:`collections` モジュールを参照下さい。
   
   .. versionadded:: 2.4


.. function:: setattr(object, name, value)

   :func:`getattr` と対をなす関数です。引数はそれぞれオブジェクト、文
   字列、そして任意の値です。文字列はすでに存在する属性の名前でも、新
   たな属性の名前でもかまいません。この関数は指定した値を指定した属性
   に関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。
   例えば、 ``setattr(x, 'foobar', 123)`` は ``x.foobar = 123`` と等価
   です。


.. function:: slice([start,] stop[, step])

   .. index:: single: Numerical Python

   ``range(start, stop, step)`` で指定されるインデクスの集合を表す
   スライス(:term:`slice`)オブジェクトを返します。
   ``range(start)`` スライスオブジェクトを返します。引数 *start* およ
   び *step* は標準では ``None`` です。
   スライスオブジェクトは読み出し専用の属性 :attr:`start`,
   :attr:`stop` および :attr:`step` を持ち、これらは単に引数で使われた
   値 (または標準の値) を返します。これらの値には、その他のはっきりと
   した機能はありません; しかしながら、これらの値は Numerical Python
   および、その他のサードパーティによる拡張で利用されています。スライ
   スオブジェクトは拡張されたインデクス指定構文が使われる際にも生成さ
   れます。例えば: ``a[start:stop:step]`` や ``a[start:stop, i]`` です。
   イテレータを返すもうひとつの関数、 :func:`itertools.islice` も参照
   下さい。
   
   
.. function:: sorted(iterable[, cmp[, key[, reverse]]])

   *iterable* の要素をもとに、並べ替え済みの新たなリストを生成して返し
   ます。オプション引数 *cmp*, *key*, および *reverse* の意味は
   :meth:`list.sort` メソッドと同じです。 (:ref:`typesseq-mutable` 節に
   説明があります。)

   *cmp* は2つの引数 (iterable の要素) からなるカスタムの比較関数を指
   定します。
   これは始めの引数が 2 つ目の引数に比べて小さい、等しい、大きいかに応
   じて負数、ゼロ、正数を返します。 ``cmp=lambda x,y: cmp(x.lower(),
   y.lower())`` 。デフォルト値は ``None`` です。

   *key* は 1 つの引数からなる関数を指定します。これは個々のリストの要
   素から比較のキーを取り出すのに使われます。 ``key=str.lower`` 。デフォ
   ルト値は ``None`` です。

   *reverse* は真偽値です。 ``True`` がセットされた場合、リストの要素
   は個々の比較が反転したものとして並び替えられます。

   一般的に、 *key* および *reverse* の変換プロセスは同等の *cmp* 関数
   を指定するより早く動作します。これは *key* および *reverse* がそれ
   ぞれの要素に一度だけ触れる間に、 *cmp* はリストのそれぞれの要素に対
   して複数回呼ばれることによるものです。旧式の *cmp* 関数を、 *key*
   関数に変換する方法は、 `CmpToKey recipe in the ASPN cookbook
   <http://code.activestate.com/recipes/576653/>` を参照下さい。

   .. versionadded:: 2.4


.. function:: staticmethod(function)

   *function* の静的メソッドを返します。

   静的メソッドは暗黙の第一引数を受け取りません。静的メソッドの宣言は、
   以下のように書き慣わされます::

      class C:
          @staticmethod
          def f(arg1, arg2, ...): ...

   ``@staticmethod`` は関数 :term:`decorator` (デコレータ)形式です。詳
   しくは :ref:`function` リファレンスマニュアルの 7 章にある関数定義
   についての説明を参照してください。

   このメソッドはクラスで呼び出すこと (例えば C.f() ) も、インスタンス
   として呼び出すこと (例えば C().f()) もできます。インスタンスはその
   クラスが何であるかを除いて無視されます。

   Python における静的メソッドは Java や C++ における静的メソッドと類
   似しています。より進んだ概念については、 :func:`classmethod` を参照
   してください。

   もっと静的メソッドについての情報が必要ならば、 :ref:`types` の標準
   型階層についてのドキュメントを繙いてください。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      関数デコレータ構文を追加しました.


.. function:: str([object])

   オブジェクトをうまく印字可能な形に表現したものを含む文字列を返しま
   す。文字列に対してはその文字列自体を返します。 ``repr(object)`` と
   の違いは、 ``str(object)`` は常に :func:`eval` が受理できるような文
   字列を返そうと試みるわけではないという点です;
   この関数の目的は印字可能な文字列を返すところにあります。引数が与え
   られなかった場合、空の文字列 ``''`` を返します。

   文字列についての詳細は、シーケンスの機能についての説明、
   :ref:`typesseq` を参照下さい(文字列はシーケンスです)。
   また、文字列特有のメソッドについては、 :ref:`string-methods` を参照
   下さい。整形した文字列を出力するためには、テンプレート文字列か、
   :ref:`string-formatting` にて説明される ``%`` 演算子を使用して下さい。
   さらには、 :ref:`stringservices` と :func:`unicode` も参照下さい。
   

.. function:: sum(iterable[, start])

   *start* と *iterable* の要素を左から右へ加算してゆき、総和を返しま
   す。 *start* はデフォルトで ``0`` です。 *iterablee* の要素は通常は
   数値で、文字列であってはなりません。文字列からなるシーケンスを結合
   する高速かつ正しい方法は ``''.join(sequence)`` です。
   ``sum(range(n), m)`` は ``reduce(operator.add, range(n), m)`` と同
   等です。浮動小数点数を拡張精度で加算するには、 :func:`math.fsum` を
   参照下さい。

   .. versionadded:: 2.3


.. function:: super(type[, object-or-type])

   *type* クラスの親、または、兄弟を呼び出すメソッドを代理する、代理オ
   ブジェクトを返します。これはクラスの中でオーバーライドされた継承メ
   ソッドにアクセスするのに便利です。探索の順序は、 *type* 自身が飛ば
   されるとおをのぞいては、 :func:`getattr` と同じです。

   *type* の :attr:`__mro__` 属性は、 :func:`getattr` と :func:`super`
   の両方で使われる探索の順序で、メソッドを記載します。
   属性は、動的で、継承の階層構造が更新されれば、随時変化します。

   もし、ふたつめの引数が与えられれば、返されるスーパーオブジェクトは
   解放されます。もし、ふたつめの引数がオブジェクトであれば、
   ``isinstance(obj, type)`` は真でなければなりません。もし、ふたつめ
   の引数が型であれば、 ``issubclass(type2, type)`` は真でなければなり
   ません(これはクラスメソッドにとって役に立つでしょう)。

   .. note::
      :func:`super` は、 :term:`new-style class` でのみ機能します。

   *super* の典型的な使用例を2例示します。クラスの階層は単一の継承とし、
   *super* は名前を明示することなく親クラスを参照することができるとし
   *ます。コードはメンテナンスが容易になるようにします。この用途の
   *super* は他のプログラミング言語で見られるものと同じ方向性です。

   ふたつめの使用例は、動的な実行環境下での複数の継承をサポートするた
   めのものです。この用途は Python 特有で単一の継承しかサポートしない
   言語や、静的なコンパイルが必要となる言語では見られないものです。こ
   れは "diamond diagrams" のような、複数の基底クラスが同じメソッドを
   実装することを可能とします。良い設計は、すべてのこのメソッドが同じ
   呼び出し規約を持つことを要求します(呼び出しが実行時に決定されること
   や、クラスの階層の変更に対応させることや、実行時に優先される未知の
   兄弟クラスに対応することのためです)。

   両方のケースにおいて、典型的なスーパークラスの呼び出しはこのように
   なるでしょう。::

      class C(B):
          def method(self, arg):
              super(C, self).method(arg)

   :func:`super` は ``super(C, self).__getitem__(name)`` のような明示的
   なドット表記の属性参照の一部として使われているので注意してください。
   :meth:`__getattribute__` メソッドは予期される順番で検索されるように
   実装されており、複数の継承がサポートできるようになっています。
   これに伴って、 :func:`super` は ``super()[name]`` のような文や演算
   子を使った非明示的な属性参照向けには定義されていないので注意してく
   ださい。

   また、 :func:`super` の使用がメソッド内部に限定されないことにも注目
   して下さい。ふたつの引数が引数を規定し、適当な参照となります。

   .. versionadded:: 2.2


.. function:: tuple([iterable])

   *iterable* の要素と要素が同じで、かつ順番も同じになるタプルを返しま
   す。 *iterable* はシーケンス、反復をサポートするコンテナ、およびイ
   テレータオブジェクトをとることができます。 *iterable* がすでにタプ
   ルの場合、そのタプルを変更せずに返します。
   例えば、 ``tuple('abc')`` は ``('a', 'b', 'c')`` を返し、
   ``tuple([1, 2, 3])`` は ``(1, 2, 3)`` を返します。
   
   :class:`tuple` クラスは、不変のシーケンス型で、 :ref:`typesseq` に
   て説明されます。他のコンテナ型については、組み込みクラスの
   :class:`dict`, :class:`list`, および :class:`set` と、
   :mod:`collections` モジュールを参照下さい。


.. function:: type(object)

   *object* の型を返します。オブジェクトの型の検査には
    :func:`isinstance` 組み込み関数を使うことが推奨されます。

   3 引数で呼び出された場合には :func:`type` 関数は後述するようにコン
   ストラクタとして働きます。


.. function:: type(name, bases, dict)
   :noindex:

   新しい型オブジェクトを返します。本質的には :keyword:`class` 文の動
   的な形です。 *name* 文字列はクラス名で、 :attr:`__name__` 属性にな
   ります。 *bases* タプルは基底クラスの羅列で、 :attr:`__bases__` 属
   性になります。 *dict* 辞書はクラス本体の定義を含む名前空間で、
   :attr:`__dict__` 属性になります。たとえば、以下の二つの文は同じ
   :class:`type` オブジェクトを作ります。 :

      >>> class X(object):
      ...     a = 1
      ...
      >>> X = type('X', (object,), dict(a=1))

   .. versionadded:: 2.2


.. function:: unichr(i)

   Unicode におけるコードが整数 *i* になるような文字 1 文字からなる
   Unicode 文字列を返します。例えば、 ``unichr(97)`` は文字列 ``u'a'``
   を返します。この関数は Unicode 文字列に対する :func:`ord` の逆です。
   引数の正当な範囲は Python がどのように構成されているかに依存してい
   ます --- UCS2 ならば [0..0xFFFF] であり UCS4 ならば [0..0x10FFFF]
   であり、このどちらかです。それ以外の値に対しては :exc:`ValueError`
   が送出されます。ASCIIの 8 ビットの文字列に対しては、 :func:`chr` を
   参照下さい。

   .. versionadded:: 2.0


.. function:: unicode([object[, encoding [, errors]]])

   以下のモードのうち一つを使って、 *object* のUnicode 文字列バージョ
   ンを返します:

   もし *encoding* かつ/または *errors* が与えられていれば、
   ``unicode()`` は 8 ビットの文字列または文字列バッファになっているオ
   ブジェクトを *encoding* の codec を使ってデコードします。
   *encoding* パラメタはエンコーディング名を与える文字列です; 未知のエ
   ンコーディングの場合、 :exc:`LookupError` が送出されます。エラー処理は
   *errors* に従って行われます; このパラメータは入力エンコーディング中
   で無効な文字の扱い方を指定します。 *errors* が ``'strict'`` (標準の
   設定です) の場合、エラー発生時には :exc:`ValueError` が送出されます。
   一方、 ``'ignore'`` では、エラーは暗黙のうちに無視されるようになり、
   ``'replace'`` では公式の置換文字、 ``U+FFFD`` を使って、デコードで
   きなかった文字を置き換えます。 :mod:`codecs` モジュールについても参
   照してください。

   オプションのパラメータが与えられていない場合、 ``unicode()`` は
   ``str()`` の動作をまねます。ただし、8 ビット文字列ではなく、
   Unicode 文字列を返します。もっと詳しくいえば、 *object* が Unicode
   文字列かそのサブクラスなら、デコード処理を一切介することなく
   Unicode 文字列を返すということです。

   :meth:`__unicode__` メソッドを提供しているオブジェクトの場合、
   :func:`unicode` はこのメソッドを引数なしで呼び出して Unicode 文字列
   を生成します。それ以外のオブジェクトの場合、 8 ビットの文字列か、オ
   ブジェクトのデータ表現 (representation) を呼び出し、その後デフォル
   トエンコーディングで ``'strict'`` モードの codec を使って Unicode
   文字列に変換します。

   Unicode 文字列についてのさらなる情報については、シーケンス型の機能
   についての説明、 :ref:`typesseq` を参照下さい(Unicode 文字列はシー
   ケンスです)。また、文字列特有のメソッドについては、
   :ref:`string-methods` を参照下さい。整形した文字列を出力するために
   は、テンプレート文字列か、 :ref:`string-formatting` にて説明される
   ``%`` 演算子を使用して下さい。さらには、 :ref:`stringservices` と
   :func:`str` も参照下さい。
   
   .. versionadded:: 2.0

   .. versionchanged:: 2.2
      :meth:`__unicode__` のサポートが追加されました.


.. function:: vars([object])

   引数無しでは、現在のローカルシンボルテーブルに対応する辞書を返しま
   す。モジュール、クラス、またはクラスインスタンスオブジェクト (また
   はその他 :attr:`__dict__` 属性を持つもの) を引数として与えた場合、
   そのオブジェクトのシンボルテーブルに対応する辞書を返します。

   .. warning::
   
      返される辞書は変更すべきではありません: 変更が対応するシンボルテー
      ブルにもたらす影響は未定義です。 [#]_


.. function:: xrange([start,] stop[, step])

   この関数は :func:`range` に非常によく似ていますが、リストの代わりに
   "xrange オブジェクト" を返します。このオブジェクトは不透明なシーケ
   ンス型で、対応するリストと同じ値を持ちますが、それらの値全てを同時
   に記憶しません。 :func:`ragne` に対する :func:`xrange` の利点は微々
   たるものです (:func:`xrange` は要求に応じて値を生成するからです) た
   だし、メモリ量の厳しい計算機で巨大な範囲の値を使う時や、(ループがよ
   く :keyword:`break` で中断されるといったように) 範囲中の全ての値を
   使うとは限らない場合はその限りではありません。

   .. note::

      :func:`xrange` はシンプルさと速度のために定義されている関数であ
      り、その実現のために実装上の制限を課している場合があります。
      Python の C 実装では、全ての引数をネイティブの C long 型 (Python
      の "short" 整数型) に制限しており、要素数がネイティブの C long
      型の範囲内に収まるよう要求しています。もし大きな範囲が必要ならば、
      別の実装である :mod:`itertools` モジュールの、
      ``islice(count(start, step), (stop-start+step-1)//step)``.を使う
      のが巧い方法かも知れません。


.. function:: zip([iterable, ...])

   この関数はタプルのリストを返します。このリストの *i* 番目のタプルは
   各引数のシーケンスまたはイテレート可能オブジェクト中の *i* 番目の要
   素を含みます。
   返されるリストは引数のシーケンスのうち長さが最小のものの長さに切り
   詰められます。引数が全て同じ長さの際には、 :func:`zip` は初期値引数
   が ``None`` の :func:`map` と似ています。引数が単一のシーケンスの場
   合、1 要素のタプルからなるリストを返します。引数を指定しない場合、
   空のリストを返します。

   イテラブルの、左から右への評価順序が保証されます。そのため
   ``zip(*[iter(s)]*n)`` を使ってデータ系列を n 長のグループにするクラ
   スタリングすることができます。

   ``*`` 演算子と共の論理積に対して、リストを upzip するために
   :func:`zip` を使うこともできます。 ::

      >>> x = [1, 2, 3]
      >>> y = [4, 5, 6]
      >>> zipped = zip(x, y)
      >>> zipped
      [(1, 4), (2, 5), (3, 6)]
      >>> x2, y2 = zip(*zipped)
      >>> x == x2, y == y2
      True

   .. versionadded:: 2.0

   .. versionchanged:: 2.4
      これまでは、 :func:`zip` は少なくとも一つの引数を要求しており、
      空のリストを返す代わりに :exc:`TypeError` を送出していました。


.. function:: __import__(name[, globals[, locals[, fromlist[, level]]]])

   .. index::
      statement: import
      module: imp

   .. note::

      これは日々の Python プログラミングでは必要ではない、高等な関数です。

   この関数は :keyword:`import` ステートメントにより呼び出されます。こ
   れは (:mod:`builtins` モジュールをインポートし、
   ``builtins.__import__`` を割り当てることで) :keyword:`import` ステー
   トメントの意味を変更するための置き換えが可能ですが、今では、フック
   をインポートするほうが、大抵の場合簡単です (:pep:`302` を参照下さい)。
   :func:`__import__` を直接使用することは稀で、例外は、実行時に名前が
   決定するモジュールをインポートするときです。

   この関数は、モジュール、 *name* をインポートし、 *globals* と
   *locals* が与えられれば、パッケージのコンテキストで名前をどう解釈す
   るか決定するのに使います。
   *fromlist* はオブジェクト、もしくは、サブモジュールの名前を与え、
   *name* で与えられるモジュールからインポートされる必要があります。
   標準的な実装では、 *locals* 引数はまったく使われず、 *globals* だけ
   が :keyword:`import` ステートメントのパッケージコンテキストを決定す
   るために使われます。

   *level* は絶対、もしくは、相対のどちらのインポートを使うかを指定し
   ます。デフォルトは ``-1`` で絶対、相対インポートの両方を試みます。
   ``0`` は絶対インポートのみ実行します。正の *level* の値は、
   :func:`__import__` を呼び出したディレクトリから検索対象となる親ディ
   レクトリの階層を示します。

   *name* は通常、 ``package.module`` の形式となり、 *name* で与えられ
   た名前 *ではなく* 最上位のパッケージ (最初のドットまでの名前) が返
   されます。しかしながら、空でない *fromlist* 引数が与えられると、
   *name* で与えられた名前が返されます。

   例えば、 ``import spam`` ステートメントは、以下のようなバイトコード
   に帰結します。 ::

      spam = __import__('spam', globals(), locals(), [], -1)

   ``import spam.ham`` ステートメントは、以下となります。 ::

      spam = __import__('spam.ham', globals(), locals(), [], -1)

   ここで :func:`__import__` がどのように最上位モジュールを返している
   かに注意して下さい。 :keyword:`import` ステートメントにより、名前が
   飛び越されたオブジェクトになっています。

   一方で、 ``from spam.ham import eggs, sausage as saus`` ステートメ
   ントは、以下となります。  ::

      _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], -1)
      eggs = _temp.eggs
      saus = _temp.sausage

   ここで、 ``spam.ham`` モジュールが :func:`__import__` より返されま
   す。このオブジェクトからインポートされる名前が取り出され、それぞれ
   の名前として割り当てられます。
   
   単純にモジュールをインポートする場合(パッケージの範囲内であるかも知
   れません)、 :data:`sys.modules` でも実現できます。 ::

      >>> import sys
      >>> name = 'foo.bar.baz'
      >>> __import__(name)
      <module 'foo' from >
      >>> baz = sys.modules[name]
      >>> baz
      <module 'foo.bar.baz' from >

   .. versionchanged:: 2.5
      level パラメータが追加されました。

   .. versionchanged:: 2.5
      Keyword サポートパラメータが追加されました。

..  ---------------------------------------------------------------------------


.. _non-essential-built-in-funcs:

非必須組み込み関数 (Non-essential Built-in Functions)
=====================================================

いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、
必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。
こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性
を維持するだけの目的で残されています。

Python のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ば
してもかまわず、その際に何か重要なことを忘れていると思う必要もありませ
ん。


.. function:: apply(function, args[, keywords])

   引数 *function* は呼び出しができるオブジェクト (ユーザ定義および組
   み込みの関数またはメソッド、またはクラスオブジェクト) でなければな
   りません。 *args* はシーケンス型でなくてはなりません。 *function*
   は引数リスト *args* を使って呼び出されます;
   引数の数はタプルの長さになります。オプションの引数 *keywords* を与
   える場合、 *keywords* は文字列のキーを持つ辞書でなければなりません。
   これは引数リストの最後に追加されるキーワード引数です。
   :func:`apply` の呼び出しは、単なる ``function(args)`` の呼び出しと
   は異なります。というのは、 :func:`apply` の場合、引数は常に一つだから
   です。 :func:`apply` は ``function(*args, **keywords)`` を使うのと
   等価です。

   .. deprecated:: 2.3
       ``*args`` と ``**keywords`` を使った拡張呼び出し構文を使ってく
       ださい。


.. function:: buffer(object[, offset[, size]])

   引数 *object* を参照する新たなバッファオブジェクトが生成されます。
   引数 *object* は (文字列、アレイ、バッファといった) バッファ呼び出
   しインタフェースをサポートするオブジェクトでなければなりません。返
   されるバッファオブジェクトは *object* の先頭 (または *offset*) から
   のスライスになります。スライスの末端は *object* の末端まで (または
   引数 *size* で与えられた長さになるまで) です。


.. function:: coerce(x, y)

   二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを
   返します。変換に使われる規則は算術演算における規則と同じです。型変
   換が不可能である場合、 :exc:`TypeError` を送出します。


.. function:: intern(string)

   *string* を "隔離" された文字列のテーブルに入力し、隔離された文字列
   を返します -- この文字列は *string* 自体かコピーです。
   隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに
   有効です -- 辞書中のキーが隔離されており、検索するキーが隔離されて
   いる場合、 (ハッシュ化後の) キーの比較は文字列の比較ではなくポイン
   タの比較で行うことができるからです。通常、 Python プログラム内で利
   用されている名前は自動的に隔離され、モジュール、クラス、またはイン
   スタンス属性を保持するための辞書は隔離されたキーを持っています。

   .. versionchanged:: 2.3
      隔離された文字列の有効期限は (Python 2.2 またはそれ以前は永続的
      でしたが) 永続的ではなくなりました; :func:`intern` の恩恵を受け
      るためには、 :func:`intern` の返す値に対する参照を保持しなければ
      なりません。

.. rubric:: Footnotes

.. [#] この関数は比較利用されない方なので、将来構文にするかどうかは保
   証できません。

.. [#] 現状では、 :cfunc:`setvbuf` を持っていないシステムでは、バッファ
   サイズを指定しても効果はありません。バッファサイズを指定するための
   インタフェースは :cfunc:`setvbuf` を使っては行われていません。何ら
   かの I/O が実行された後で呼び出されるとコアダンプすることがあり、ど
   のような場合にそうなるかを決定する信頼性のある方法がないからです。

.. [#] 現在の実装では、ローカルな値のバインディングは通常は影響を受け
   ませんが、 (モジュールのような) 他のスコープから取り出した値は影響
   を受けるかもしれません。またこの実装は変更されるかもしれません。


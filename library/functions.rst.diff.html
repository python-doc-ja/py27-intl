<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/functions.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -7,6 +7,26 @@</span>
 The Python interpreter has a number of functions built into it that are always
 available.  They are listed here in alphabetical order.
 
<span class="gi">+===================  =================  ==================  =================  ====================</span>
<span class="gi">+..                   ..                 Built-in Functions  ..                 ..</span>
<span class="gi">+===================  =================  ==================  =================  ====================</span>
<span class="gi">+:func:`abs`          :func:`divmod`     :func:`input`       :func:`open`       :func:`staticmethod`</span>
<span class="gi">+:func:`all`          :func:`enumerate`  :func:`int`         :func:`ord`        :func:`str`</span>
<span class="gi">+:func:`any`          :func:`eval`       :func:`isinstance`  :func:`pow`        :func:`sum`</span>
<span class="gi">+:func:`basestring`   :func:`execfile`   :func:`issubclass`  :func:`print`      :func:`super`</span>
<span class="gi">+:func:`bin`          :func:`file`       :func:`iter`        :func:`property`   :func:`tuple`</span>
<span class="gi">+:func:`bool`         :func:`filter`     :func:`len`         :func:`range`      :func:`type`</span>
<span class="gi">+:func:`bytearray`    :func:`float`      :func:`list`        :func:`raw_input`  :func:`unichr`</span>
<span class="gi">+:func:`callable`     :func:`format`     :func:`locals`      :func:`reduce`     :func:`unicode`</span>
<span class="gi">+:func:`chr`          :func:`frozenset`  :func:`long`        :func:`reload`     :func:`vars`</span>
<span class="gi">+:func:`classmethod`  :func:`getattr`    :func:`map`         :func:`repr`       :func:`xrange`</span>
<span class="gi">+:func:`cmp`          :func:`globals`    :func:`max`         :func:`reversed`   :func:`zip`</span>
<span class="gi">+:func:`compile`      :func:`hasattr`    :func:`memoryview`  :func:`round`      :func:`__import__`</span>
<span class="gi">+:func:`complex`      :func:`hash`       :func:`min`         :func:`set`        :func:`apply`</span>
<span class="gi">+:func:`delattr`      :func:`help`       :func:`next`        :func:`setattr`    :func:`buffer`</span>
<span class="gi">+:func:`dict`         :func:`hex`        :func:`object`      :func:`slice`      :func:`coerce`</span>
<span class="gi">+:func:`dir`          :func:`id`         :func:`oct`         :func:`sorted`     :func:`intern`</span>
<span class="gi">+===================  =================  ==================  =================  ====================</span>
 
 .. function:: abs(x)
 
<span class="gu">@@ -78,6 +98,32 @@</span>
       If no argument is given, this function returns :const:`False`.
 
 
<span class="gi">+.. function:: bytearray([source[, encoding[, errors]]])</span>
<span class="gi">+</span>
<span class="gi">+   Return a new array of bytes.  The :class:`bytearray` type is a mutable</span>
<span class="gi">+   sequence of integers in the range 0 &lt;= x &lt; 256.  It has most of the usual</span>
<span class="gi">+   methods of mutable sequences, described in :ref:`typesseq-mutable`, as well</span>
<span class="gi">+   as most methods that the :class:`str` type has, see :ref:`string-methods`.</span>
<span class="gi">+</span>
<span class="gi">+   The optional *source* parameter can be used to initialize the array in a few</span>
<span class="gi">+   different ways:</span>
<span class="gi">+</span>
<span class="gi">+   * If it is a *string*, you must also give the *encoding* (and optionally,</span>
<span class="gi">+     *errors*) parameters; :func:`bytearray` then converts the string to</span>
<span class="gi">+     bytes using :meth:`str.encode`.</span>
<span class="gi">+</span>
<span class="gi">+   * If it is an *integer*, the array will have that size and will be</span>
<span class="gi">+     initialized with null bytes.</span>
<span class="gi">+</span>
<span class="gi">+   * If it is an object conforming to the *buffer* interface, a read-only buffer</span>
<span class="gi">+     of the object will be used to initialize the bytes array.</span>
<span class="gi">+</span>
<span class="gi">+   * If it is an *iterable*, it must be an iterable of integers in the range</span>
<span class="gi">+     ``0 &lt;= x &lt; 256``, which are used as the initial contents of the array.</span>
<span class="gi">+</span>
<span class="gi">+   Without an argument, an array of size 0 is created.</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. function:: callable(object)
 
    Return :const:`True` if the *object* argument appears callable,
<span class="gu">@@ -173,11 +219,10 @@</span>
 
    .. note::
 
<span class="gd">-      When compiling a string with multi-line code, line endings must be</span>
<span class="gd">-      represented by a single newline character (``&#39;\n&#39;``), and the input must</span>
<span class="gd">-      be terminated by at least one newline character.  If line endings are</span>
<span class="gd">-      represented by ``&#39;\r\n&#39;``, use :meth:`str.replace` to change them into</span>
<span class="gd">-      ``&#39;\n&#39;``.</span>
<span class="gi">+      When compiling a string with multi-line code in ``&#39;single&#39;`` or</span>
<span class="gi">+      ``&#39;eval&#39;`` mode, input must be terminated by at least one newline</span>
<span class="gi">+      character.  This is to facilitate detection of incomplete and complete</span>
<span class="gi">+      statements in the :mod:`code` module.</span>
 
    .. versionchanged:: 2.3
       The *flags* and *dont_inherit* arguments were added.
<span class="gu">@@ -185,6 +230,10 @@</span>
    .. versionchanged:: 2.6
       Support for compiling AST objects.
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      Allowed use of Windows and Mac newlines.  Also input in ``&#39;exec&#39;`` mode</span>
<span class="gi">+      does not have to end in a newline anymore.</span>
<span class="gi">+</span>
 
 .. function:: complex([real[, imag]])
 
<span class="gu">@@ -344,6 +393,9 @@</span>
    returns the current global and local dictionary, respectively, which may be
    useful to pass around for use by :func:`eval` or :func:`execfile`.
 
<span class="gi">+   See :func:`ast.literal_eval` for a function that can safely evaluate strings</span>
<span class="gi">+   with expressions containing only literals.</span>
<span class="gi">+</span>
 
 .. function:: execfile(filename[, globals[, locals]])
 
<span class="gu">@@ -462,7 +514,7 @@</span>
 
 .. function:: getattr(object, name[, default])
 
<span class="gd">-   Return the value of the named attributed of *object*.  *name* must be a string.</span>
<span class="gi">+   Return the value of the named attribute of *object*.  *name* must be a string.</span>
    If the string is the name of one of the object&#39;s attributes, the result is the
    value of that attribute.  For example, ``getattr(x, &#39;foobar&#39;)`` is equivalent to
    ``x.foobar``.  If the named attribute does not exist, *default* is returned if
<span class="gu">@@ -689,6 +741,13 @@</span>
       Added support for the optional *key* argument.
 
 
<span class="gi">+.. function:: memoryview(obj)</span>
<span class="gi">+   :noindex:</span>
<span class="gi">+</span>
<span class="gi">+   Return a &quot;memory view&quot; object created from the given argument.  See</span>
<span class="gi">+   :ref:`typememoryview` for more information.</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. function:: min(iterable[, args...][key])
 
    With a single argument *iterable*, return the smallest item of a non-empty
<span class="gu">@@ -1088,6 +1147,14 @@</span>
    example, ``round(0.5)`` is ``1.0`` and ``round(-0.5)`` is ``-1.0``).
 
 
<span class="gi">+   .. note::</span>
<span class="gi">+</span>
<span class="gi">+      The behavior of :func:`round` for floats can be surprising: for example,</span>
<span class="gi">+      ``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``.</span>
<span class="gi">+      This is not a bug: it&#39;s a result of the fact that most decimal fractions</span>
<span class="gi">+      can&#39;t be represented exactly as a float.  See :ref:`tut-fp-issues` for</span>
<span class="gi">+      more information.</span>
<span class="gi">+</span>
 .. function:: set([iterable])
    :noindex:
 
<span class="gu">@@ -1148,9 +1215,8 @@</span>
    In general, the *key* and *reverse* conversion processes are much faster
    than specifying an equivalent *cmp* function.  This is because *cmp* is
    called multiple times for each list element while *key* and *reverse* touch
<span class="gd">-   each element only once.  To convert an old-style *cmp* function to a *key*</span>
<span class="gd">-   function, see the `CmpToKey recipe in the ASPN cookbook</span>
<span class="gd">-   &lt;http://code.activestate.com/recipes/576653/&gt;`_\.</span>
<span class="gi">+   each element only once.  Use :func:`functools.cmp_to_key` to convert an</span>
<span class="gi">+   old-style *cmp* function to a *key* function.</span>
 
    For sorting examples and a brief sorting tutorial, see `Sorting HowTo
    &lt;http://wiki.python.org/moin/HowTo/Sorting/&gt;`_\.
<span class="gu">@@ -1207,10 +1273,13 @@</span>
 
    Sums *start* and the items of an *iterable* from left to right and returns the
    total.  *start* defaults to ``0``. The *iterable*&#39;s items are normally numbers,
<span class="gd">-   and are not allowed to be strings.  The fast, correct way to concatenate a</span>
<span class="gd">-   sequence of strings is by calling ``&#39;&#39;.join(sequence)``. Note that</span>
<span class="gd">-   ``sum(range(n), m)`` is equivalent to ``reduce(operator.add, range(n), m)``</span>
<span class="gd">-   To add floating point values with extended precision, see :func:`math.fsum`\.</span>
<span class="gi">+   and the start value is not allowed to be a string.</span>
<span class="gi">+</span>
<span class="gi">+   For some use cases, there are good alternatives to :func:`sum`.</span>
<span class="gi">+   The preferred, fast way to concatenate a sequence of strings is by calling</span>
<span class="gi">+   ``&#39;&#39;.join(sequence)``.  To add floating point values with extended precision,</span>
<span class="gi">+   see :func:`math.fsum`\.  To concatenate a series of iterables, consider using</span>
<span class="gi">+   :func:`itertools.chain`.</span>
 
    .. versionadded:: 2.3
 
<span class="gu">@@ -1394,8 +1463,8 @@</span>
       restricts all arguments to native C longs (&quot;short&quot; Python integers), and
       also requires that the number of elements fit in a native C long.  If a
       larger range is needed, an alternate version can be crafted using the
<span class="gd">-      :mod:`itertools` module: ``takewhile(lambda x: x&lt;stop, (start+i*step</span>
<span class="gd">-      for i in count()))``.</span>
<span class="gi">+      :mod:`itertools` module: ``islice(count(start, step),</span>
<span class="gi">+      (stop-start+step-1+2*(step&lt;0))//step)``.</span>
 
 
 .. function:: zip([iterable, ...])
</pre></div>

</body>
</html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/email.message.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -124,26 +124,40 @@</span>
 
       .. versionchanged:: 2.2.2
          *charset* argument added.
 
 
    .. method:: set_charset(charset)
 
       Set the character set of the payload to *charset*, which can either be a
       :class:`~email.charset.Charset` instance (see :mod:`email.charset`), a
       string naming a character set, or ``None``.  If it is a string, it will
       be converted to a :class:`~email.charset.Charset` instance.  If *charset*
       is ``None``, the ``charset`` parameter will be removed from the
<span class="gd">-      :mailheader:`Content-Type` header. Anything else will generate a</span>
<span class="gd">-      :exc:`TypeError`.</span>
<span class="gi">+      :mailheader:`Content-Type` header (the message will not be otherwise</span>
<span class="gi">+      modified).  Anything else will generate a :exc:`TypeError`.</span>
<span class="gi">+</span>
<span class="gi">+      If there is no existing :mailheader:`MIME-Version` header one will be</span>
<span class="gi">+      added.  If there is no existing :mailheader:`Content-Type` header, one</span>
<span class="gi">+      will be added with a value of :mimetype:`text/plain`.  Whether the</span>
<span class="gi">+      :mailheader:`Content-Type` header already exists or not, its ``charset``</span>
<span class="gi">+      parameter will be set to *charset.output_charset*.   If</span>
<span class="gi">+      *charset.input_charset* and *charset.output_charset* differ, the payload</span>
<span class="gi">+      will be re-encoded to the *output_charset*.  If there is no existing</span>
<span class="gi">+      :mailheader:`Content-Transfer-Encoding` header, then the payload will be</span>
<span class="gi">+      transfer-encoded, if needed, using the specified</span>
<span class="gi">+      :class:`~email.charset.Charset`, and a header with the appropriate value</span>
<span class="gi">+      will be added.  If a :mailheader:`Content-Transfer-Encoding` header</span>
<span class="gi">+      already exists, the payload is assumed to already be correctly encoded</span>
<span class="gi">+      using that :mailheader:`Content-Transfer-Encoding` and is not modified.</span>
 
       The message will be assumed to be of type :mimetype:`text/\*`, with the
       payload either in unicode or encoded with *charset.input_charset*.
       It will be encoded or converted to *charset.output_charset*
       and transfer encoded properly, if needed, when generating the plain text
       representation of the message.  MIME headers (:mailheader:`MIME-Version`,
       :mailheader:`Content-Type`, :mailheader:`Content-Transfer-Encoding`) will
       be added as needed.
 
       .. versionadded:: 2.2.2
 
 
<span class="gu">@@ -257,34 +271,48 @@</span>
 
    .. method:: add_header(_name, _value, **_params)
 
       Extended header setting.  This method is similar to :meth:`__setitem__`
       except that additional header parameters can be provided as keyword
       arguments.  *_name* is the header field to add and *_value* is the
       *primary* value for the header.
 
       For each item in the keyword argument dictionary *_params*, the key is
       taken as the parameter name, with underscores converted to dashes (since
       dashes are illegal in Python identifiers).  Normally, the parameter will
       be added as ``key=&quot;value&quot;`` unless the value is ``None``, in which case
<span class="gd">-      only the key will be added.</span>
<span class="gi">+      only the key will be added.  If the value contains non-ASCII characters,</span>
<span class="gi">+      it must be specified as a three tuple in the format</span>
<span class="gi">+      ``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the</span>
<span class="gi">+      charset to be used to encode the value, ``LANGUAGE`` can usually be set</span>
<span class="gi">+      to ``None`` or the empty string (see :RFC:`2231` for other possibilities),</span>
<span class="gi">+      and ``VALUE`` is the string value containing non-ASCII code points.</span>
 
       Here&#39;s an example::
 
          msg.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;, filename=&#39;bud.gif&#39;)
 
       This will add a header that looks like ::
 
          Content-Disposition: attachment; filename=&quot;bud.gif&quot;
 
<span class="gi">+      An example with with non-ASCII characters::</span>
<span class="gi">+</span>
<span class="gi">+         msg.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;,</span>
<span class="gi">+                        filename=(&#39;iso-8859-1&#39;, &#39;&#39;, &#39;Fu√üballer.ppt&#39;))</span>
<span class="gi">+</span>
<span class="gi">+      Which produces ::</span>
<span class="gi">+</span>
<span class="gi">+         Content-Disposition: attachment; filename*=&quot;iso-8859-1&#39;&#39;Fu%DFballer.ppt&quot;</span>
<span class="gi">+</span>
 
    .. method:: replace_header(_name, _value)
 
       Replace a header.  Replace the first header found in the message that
       matches *_name*, retaining header order and field name case.  If no
       matching header was found, a :exc:`KeyError` is raised.
 
       .. versionadded:: 2.2.2
 
 
    .. method:: get_content_type()
 
<span class="gu">@@ -371,25 +399,25 @@</span>
       Parameter keys are always compared case insensitively.  The return value
       can either be a string, or a 3-tuple if the parameter was :rfc:`2231`
       encoded.  When it&#39;s a 3-tuple, the elements of the value are of the form
       ``(CHARSET, LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and
       ``LANGUAGE`` can be ``None``, in which case you should consider ``VALUE``
       to be encoded in the ``us-ascii`` charset.  You can usually ignore
       ``LANGUAGE``.
 
       If your application doesn&#39;t care whether the parameter was encoded as in
       :rfc:`2231`, you can collapse the parameter value by calling
       :func:`email.utils.collapse_rfc2231_value`, passing in the return value
       from :meth:`get_param`.  This will return a suitably decoded Unicode
<span class="gd">-      string whn the value is a tuple, or the original string unquoted if it</span>
<span class="gi">+      string when the value is a tuple, or the original string unquoted if it</span>
       isn&#39;t.  For example::
 
          rawparam = msg.get_param(&#39;foo&#39;)
          param = email.utils.collapse_rfc2231_value(rawparam)
 
       In any case, the parameter value (either the returned string, or the
       ``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is set
       to ``False``.
 
       .. versionchanged:: 2.2.2
          *unquote* argument added, and 3-tuple return value possible.
 
<span class="gu">@@ -439,27 +467,28 @@</span>
       An alternative header can be specified in the *header* argument. When the
       :mailheader:`Content-Type` header is set a :mailheader:`MIME-Version`
       header is also added.
 
       .. versionadded:: 2.2.2
 
 
    .. method:: get_filename([failobj])
 
       Return the value of the ``filename`` parameter of the
       :mailheader:`Content-Disposition` header of the message.  If the header
       does not have a ``filename`` parameter, this method falls back to looking
<span class="gd">-      for the ``name`` parameter.  If neither is found, or the header is</span>
<span class="gd">-      missing, then *failobj* is returned.  The returned string will always be</span>
<span class="gd">-      unquoted as per :func:`email.utils.unquote`.</span>
<span class="gi">+      for the ``name`` parameter on the :mailheader:`Content-Type` header.  If</span>
<span class="gi">+      neither is found, or the header is missing, then *failobj* is returned.</span>
<span class="gi">+      The returned string will always be unquoted as per</span>
<span class="gi">+      :func:`email.utils.unquote`.</span>
 
 
    .. method:: get_boundary([failobj])
 
       Return the value of the ``boundary`` parameter of the
       :mailheader:`Content-Type` header of the message, or *failobj* if either
       the header is missing, or has no ``boundary`` parameter.  The returned
       string will always be unquoted as per :func:`email.utils.unquote`.
 
 
    .. method:: set_boundary(boundary)
 
</pre></div>

</body>
</html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/bisect.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -1,106 +1,152 @@</span>
<span class="gd">-</span>
 :mod:`bisect` --- Array bisection algorithm
 ===========================================
 
 .. module:: bisect
    :synopsis: Array bisection algorithms for binary searching.
 .. sectionauthor:: Fred L. Drake, Jr. &lt;fdrake@acm.org&gt;
<span class="gi">+.. sectionauthor:: Raymond Hettinger &lt;python at rcn.com&gt;</span>
 .. example based on the PyModules FAQ entry by Aaron Watters &lt;arw@pythonpros.com&gt;
 
 This module provides support for maintaining a list in sorted order without
 having to sort the list after each insertion.  For long lists of items with
 expensive comparison operations, this can be an improvement over the more common
 approach.  The module is called :mod:`bisect` because it uses a basic bisection
 algorithm to do its work.  The source code may be most useful as a working
 example of the algorithm (the boundary conditions are already right!).
 
<span class="gi">+.. versionadded:: 2.1</span>
<span class="gi">+</span>
<span class="gi">+.. seealso::</span>
<span class="gi">+</span>
<span class="gi">+   Latest version of the `bisect module Python source code</span>
<span class="gi">+   &lt;http://svn.python.org/view/python/branches/release27-maint/Lib/bisect.py?view=markup&gt;`_</span>
<span class="gi">+</span>
 The following functions are provided:
 
 
<span class="gd">-.. function:: bisect_left(list, item[, lo[, hi]])</span>
<span class="gi">+.. function:: bisect_left(a, x, lo=0, hi=len(a))</span>
 
<span class="gd">-   Locate the proper insertion point for *item* in *list* to maintain sorted order.</span>
<span class="gd">-   The parameters *lo* and *hi* may be used to specify a subset of the list which</span>
<span class="gd">-   should be considered; by default the entire list is used.  If *item* is already</span>
<span class="gd">-   present in *list*, the insertion point will be before (to the left of) any</span>
<span class="gd">-   existing entries.  The return value is suitable for use as the first parameter</span>
<span class="gd">-   to ``list.insert()``.  This assumes that *list* is already sorted.</span>
<span class="gi">+   Locate the insertion point for *x* in *a* to maintain sorted order.</span>
<span class="gi">+   The parameters *lo* and *hi* may be used to specify a subset of the list</span>
<span class="gi">+   which should be considered; by default the entire list is used.  If *x* is</span>
<span class="gi">+   already present in *a*, the insertion point will be before (to the left of)</span>
<span class="gi">+   any existing entries.  The return value is suitable for use as the first</span>
<span class="gi">+   parameter to ``list.insert()`` assuming that *a* is already sorted.</span>
 
<span class="gd">-   .. versionadded:: 2.1</span>
<span class="gi">+   The returned insertion point *i* partitions the array *a* into two halves so</span>
<span class="gi">+   that ``all(val &lt; x for val in a[lo:i])`` for the left side and</span>
<span class="gi">+   ``all(val &gt;= x for val in a[i:hi])`` for the right side.</span>
 
<span class="gi">+.. function:: bisect_right(a, x, lo=0, hi=len(a))</span>
<span class="gi">+              bisect(a, x, lo=0, hi=len(a))</span>
 
<span class="gd">-.. function:: bisect_right(list, item[, lo[, hi]])</span>
<span class="gi">+   Similar to :func:`bisect_left`, but returns an insertion point which comes</span>
<span class="gi">+   after (to the right of) any existing entries of *x* in *a*.</span>
 
<span class="gd">-   Similar to :func:`bisect_left`, but returns an insertion point which comes after</span>
<span class="gd">-   (to the right of) any existing entries of *item* in *list*.</span>
<span class="gi">+   The returned insertion point *i* partitions the array *a* into two halves so</span>
<span class="gi">+   that ``all(val &lt;= x for val in a[lo:i])`` for the left side and</span>
<span class="gi">+   ``all(val &gt; x for val in a[i:hi])`` for the right side.</span>
 
<span class="gd">-   .. versionadded:: 2.1</span>
<span class="gi">+.. function:: insort_left(a, x, lo=0, hi=len(a))</span>
 
<span class="gi">+   Insert *x* in *a* in sorted order.  This is equivalent to</span>
<span class="gi">+   ``a.insert(bisect.bisect_left(a, x, lo, hi), x)`` assuming that *a* is</span>
<span class="gi">+   already sorted.  Keep in mind that the O(log n) search is dominated by</span>
<span class="gi">+   the slow O(n) insertion step.</span>
 
<span class="gd">-.. function:: bisect(...)</span>
<span class="gi">+.. function:: insort_right(a, x, lo=0, hi=len(a))</span>
<span class="gi">+              insort(a, x, lo=0, hi=len(a))</span>
 
<span class="gd">-   Alias for :func:`bisect_right`.</span>
<span class="gi">+   Similar to :func:`insort_left`, but inserting *x* in *a* after any existing</span>
<span class="gi">+   entries of *x*.</span>
 
<span class="gi">+.. seealso::</span>
 
<span class="gd">-.. function:: insort_left(list, item[, lo[, hi]])</span>
<span class="gi">+   `SortedCollection recipe</span>
<span class="gi">+   &lt;http://code.activestate.com/recipes/577197-sortedcollection/&gt;`_ that uses</span>
<span class="gi">+   bisect to build a full-featured collection class with straight-forward search</span>
<span class="gi">+   methods and support for a key-function.  The keys are precomputed to save</span>
<span class="gi">+   unnecessary calls to the key function during searches.</span>
 
<span class="gd">-   Insert *item* in *list* in sorted order.  This is equivalent to</span>
<span class="gd">-   ``list.insert(bisect.bisect_left(list, item, lo, hi), item)``.  This assumes</span>
<span class="gd">-   that *list* is already sorted.</span>
 
<span class="gd">-   .. versionadded:: 2.1</span>
<span class="gi">+Searching Sorted Lists</span>
<span class="gi">+----------------------</span>
 
<span class="gi">+The above :func:`bisect` functions are useful for finding insertion points but</span>
<span class="gi">+can be tricky or awkward to use for common searching tasks. The following five</span>
<span class="gi">+functions show how to transform them into the standard lookups for sorted</span>
<span class="gi">+lists::</span>
 
<span class="gd">-.. function:: insort_right(list, item[, lo[, hi]])</span>
<span class="gi">+    def index(a, x):</span>
<span class="gi">+        &#39;Locate the leftmost value exactly equal to x&#39;</span>
<span class="gi">+        i = bisect_left(a, x)</span>
<span class="gi">+        if i != len(a) and a[i] == x:</span>
<span class="gi">+            return i</span>
<span class="gi">+        raise ValueError</span>
 
<span class="gd">-   Similar to :func:`insort_left`, but inserting *item* in *list* after any</span>
<span class="gd">-   existing entries of *item*.</span>
<span class="gi">+    def find_lt(a, x):</span>
<span class="gi">+        &#39;Find rightmost value less than x&#39;</span>
<span class="gi">+        i = bisect_left(a, x)</span>
<span class="gi">+        if i:</span>
<span class="gi">+            return a[i-1]</span>
<span class="gi">+        raise ValueError</span>
 
<span class="gd">-   .. versionadded:: 2.1</span>
<span class="gi">+    def find_le(a, x):</span>
<span class="gi">+        &#39;Find rightmost value less than or equal to x&#39;</span>
<span class="gi">+        i = bisect_right(a, x)</span>
<span class="gi">+        if i:</span>
<span class="gi">+            return a[i-1]</span>
<span class="gi">+        raise ValueError</span>
 
<span class="gi">+    def find_gt(a, x):</span>
<span class="gi">+        &#39;Find leftmost value greater than x&#39;</span>
<span class="gi">+        i = bisect_right(a, x)</span>
<span class="gi">+        if i != len(a):</span>
<span class="gi">+            return a[i]</span>
<span class="gi">+        raise ValueError</span>
 
<span class="gd">-.. function:: insort(...)</span>
<span class="gi">+    def find_ge(a, x):</span>
<span class="gi">+        &#39;Find leftmost item greater than or equal to x&#39;</span>
<span class="gi">+        i = bisect_left(a, x)</span>
<span class="gi">+        if i != len(a):</span>
<span class="gi">+            return a[i]</span>
<span class="gi">+        raise ValueError</span>
 
<span class="gd">-   Alias for :func:`insort_right`.</span>
 
<span class="gd">-</span>
<span class="gd">-Examples</span>
<span class="gd">---------</span>
<span class="gi">+Other Examples</span>
<span class="gi">+--------------</span>
 
 .. _bisect-example:
 
<span class="gd">-The :func:`bisect` function is generally useful for categorizing numeric data.</span>
<span class="gd">-This example uses :func:`bisect` to look up a letter grade for an exam total</span>
<span class="gd">-(say) based on a set of ordered numeric breakpoints: 85 and up is an &#39;A&#39;, 75..84</span>
<span class="gd">-is a &#39;B&#39;, etc.</span>
<span class="gi">+The :func:`bisect` function can be useful for numeric table lookups. This</span>
<span class="gi">+example uses :func:`bisect` to look up a letter grade for an exam score (say)</span>
<span class="gi">+based on a set of ordered numeric breakpoints: 90 and up is an &#39;A&#39;, 80 to 89 is</span>
<span class="gi">+a &#39;B&#39;, and so on::</span>
 
<span class="gd">-   &gt;&gt;&gt; grades = &quot;FEDCBA&quot;</span>
<span class="gd">-   &gt;&gt;&gt; breakpoints = [30, 44, 66, 75, 85]</span>
<span class="gd">-   &gt;&gt;&gt; from bisect import bisect</span>
<span class="gd">-   &gt;&gt;&gt; def grade(total):</span>
<span class="gd">-   ...           return grades[bisect(breakpoints, total)]</span>
<span class="gi">+   &gt;&gt;&gt; def grade(score, breakpoints=[60, 70, 80, 90], grades=&#39;FDCBA&#39;):</span>
<span class="gi">+   ...     i = bisect(breakpoints, score)</span>
<span class="gi">+   ...     return grades[i]</span>
    ...
<span class="gd">-   &gt;&gt;&gt; grade(66)</span>
<span class="gd">-   &#39;C&#39;</span>
<span class="gd">-   &gt;&gt;&gt; map(grade, [33, 99, 77, 44, 12, 88])</span>
<span class="gd">-   [&#39;E&#39;, &#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;F&#39;, &#39;A&#39;]</span>
<span class="gi">+   &gt;&gt;&gt; [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]</span>
<span class="gi">+   [&#39;F&#39;, &#39;A&#39;, &#39;C&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;]</span>
 
 Unlike the :func:`sorted` function, it does not make sense for the :func:`bisect`
 functions to have *key* or *reversed* arguments because that would lead to an
<span class="gd">-inefficent design (successive calls to bisect functions would not &quot;remember&quot;</span>
<span class="gi">+inefficient design (successive calls to bisect functions would not &quot;remember&quot;</span>
 all of the previous key lookups).
 
 Instead, it is better to search a list of precomputed keys to find the index
 of the record in question::
 
     &gt;&gt;&gt; data = [(&#39;red&#39;, 5), (&#39;blue&#39;, 1), (&#39;yellow&#39;, 8), (&#39;black&#39;, 0)]
     &gt;&gt;&gt; data.sort(key=lambda r: r[1])
     &gt;&gt;&gt; keys = [r[1] for r in data]         # precomputed list of keys
     &gt;&gt;&gt; data[bisect_left(keys, 0)]
     (&#39;black&#39;, 0)
     &gt;&gt;&gt; data[bisect_left(keys, 1)]
     (&#39;blue&#39;, 1)
     &gt;&gt;&gt; data[bisect_left(keys, 5)]
     (&#39;red&#39;, 5)
     &gt;&gt;&gt; data[bisect_left(keys, 8)]
     (&#39;yellow&#39;, 8)
<span class="gi">+</span>
</pre></div>

</body>
</html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/difflib.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -28,29 +28,34 @@</span>
    find the longest contiguous matching subsequence that contains no &quot;junk&quot;
    elements (the Ratcliff and Obershelp algorithm doesn&#39;t address junk).  The same
    idea is then applied recursively to the pieces of the sequences to the left and
    to the right of the matching subsequence.  This does not yield minimal edit
    sequences, but does tend to yield matches that &quot;look right&quot; to people.
 
    **Timing:** The basic Ratcliff-Obershelp algorithm is cubic time in the worst
    case and quadratic time in the expected case. :class:`SequenceMatcher` is
    quadratic time for the worst case and has expected-case behavior dependent in a
    complicated way on how many elements the sequences have in common; best case
    time is linear.
 
<span class="gd">-   **Heuristic:** To speed-up matching, items that appear more than 1% of the</span>
<span class="gd">-   time in sequences of at least 200 items are treated as junk.  This has the</span>
<span class="gd">-   unfortunate side-effect of giving bad results for sequences constructed from</span>
<span class="gd">-   a small set of items.  An option to turn off the heuristic will be added to a</span>
<span class="gd">-   future version.</span>
<span class="gi">+   **Automatic junk heuristic:** :class:`SequenceMatcher` supports a heuristic that</span>
<span class="gi">+   automatically treats certain sequence items as junk. The heuristic counts how many</span>
<span class="gi">+   times each individual item appears in the sequence. If an item&#39;s duplicates (after</span>
<span class="gi">+   the first one) account for more than 1% of the sequence and the sequence is at least</span>
<span class="gi">+   200 items long, this item is marked as &quot;popular&quot; and is treated as junk for</span>
<span class="gi">+   the purpose of sequence matching. This heuristic can be turned off by setting</span>
<span class="gi">+   the ``autojunk`` argument to ``False`` when creating the :class:`SequenceMatcher`.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7.1</span>
<span class="gi">+      The *autojunk* parameter.</span>
 
 .. class:: Differ
 
    This is a class for comparing sequences of lines of text, and producing
    human-readable differences or deltas.  Differ uses :class:`SequenceMatcher`
    both to compare sequences of lines, and to compare sequences of characters
    within similar (near-matching) lines.
 
    Each line of a :class:`Differ` delta begins with a two-letter code:
 
    +----------+-------------------------------------------+
    | Code     | Meaning                                   |
<span class="gu">@@ -142,26 +147,26 @@</span>
 
    By default, the diff control lines (those with ``***`` or ``---``) are created
    with a trailing newline.  This is helpful so that inputs created from
    :func:`file.readlines` result in diffs that are suitable for use with
    :func:`file.writelines` since both the inputs and outputs have trailing
    newlines.
 
    For inputs that do not have trailing newlines, set the *lineterm* argument to
    ``&quot;&quot;`` so that the output will be uniformly newline free.
 
    The context diff format normally has a header for filenames and modification
    times.  Any or all of these may be specified using strings for *fromfile*,
<span class="gd">-   *tofile*, *fromfiledate*, and *tofiledate*. The modification times are normally</span>
<span class="gd">-   expressed in the format returned by :func:`time.ctime`.  If not specified, the</span>
<span class="gi">+   *tofile*, *fromfiledate*, and *tofiledate*.  The modification times are normally</span>
<span class="gi">+   expressed in the ISO 8601 format. If not specified, the</span>
    strings default to blanks.
 
       &gt;&gt;&gt; s1 = [&#39;bacon\n&#39;, &#39;eggs\n&#39;, &#39;ham\n&#39;, &#39;guido\n&#39;]
       &gt;&gt;&gt; s2 = [&#39;python\n&#39;, &#39;eggy\n&#39;, &#39;hamster\n&#39;, &#39;guido\n&#39;]
       &gt;&gt;&gt; for line in context_diff(s1, s2, fromfile=&#39;before.py&#39;, tofile=&#39;after.py&#39;):
       ...     sys.stdout.write(line)  # doctest: +NORMALIZE_WHITESPACE
       *** before.py
       --- after.py
       ***************
       *** 1,4 ****
       ! bacon
       ! eggs
<span class="gu">@@ -277,26 +282,26 @@</span>
 
    By default, the diff control lines (those with ``---``, ``+++``, or ``@@``) are
    created with a trailing newline.  This is helpful so that inputs created from
    :func:`file.readlines` result in diffs that are suitable for use with
    :func:`file.writelines` since both the inputs and outputs have trailing
    newlines.
 
    For inputs that do not have trailing newlines, set the *lineterm* argument to
    ``&quot;&quot;`` so that the output will be uniformly newline free.
 
    The context diff format normally has a header for filenames and modification
    times.  Any or all of these may be specified using strings for *fromfile*,
<span class="gd">-   *tofile*, *fromfiledate*, and *tofiledate*. The modification times are normally</span>
<span class="gd">-   expressed in the format returned by :func:`time.ctime`.  If not specified, the</span>
<span class="gi">+   *tofile*, *fromfiledate*, and *tofiledate*.  The modification times are normally</span>
<span class="gi">+   expressed in the ISO 8601 format. If not specified, the</span>
    strings default to blanks.
 
       &gt;&gt;&gt; s1 = [&#39;bacon\n&#39;, &#39;eggs\n&#39;, &#39;ham\n&#39;, &#39;guido\n&#39;]
       &gt;&gt;&gt; s2 = [&#39;python\n&#39;, &#39;eggy\n&#39;, &#39;hamster\n&#39;, &#39;guido\n&#39;]
       &gt;&gt;&gt; for line in unified_diff(s1, s2, fromfile=&#39;before.py&#39;, tofile=&#39;after.py&#39;):
       ...     sys.stdout.write(line)   # doctest: +NORMALIZE_WHITESPACE
       --- before.py
       +++ after.py
       @@ -1,4 +1,4 @@
       -bacon
       -eggs
       -ham
<span class="gu">@@ -330,43 +335,48 @@</span>
       Discussion of a similar algorithm by John W. Ratcliff and D. E. Metzener. This
       was published in `Dr. Dobb&#39;s Journal &lt;http://www.ddj.com/&gt;`_ in July, 1988.
 
 
 .. _sequence-matcher:
 
 SequenceMatcher Objects
 -----------------------
 
 The :class:`SequenceMatcher` class has this constructor:
 
 
<span class="gd">-.. class:: SequenceMatcher([isjunk[, a[, b]]])</span>
<span class="gi">+.. class:: SequenceMatcher([isjunk[, a[, b[, autojunk=True]]]])</span>
 
    Optional argument *isjunk* must be ``None`` (the default) or a one-argument
    function that takes a sequence element and returns true if and only if the
    element is &quot;junk&quot; and should be ignored. Passing ``None`` for *isjunk* is
    equivalent to passing ``lambda x: 0``; in other words, no elements are ignored.
    For example, pass::
 
       lambda x: x in &quot; \t&quot;
 
    if you&#39;re comparing lines as sequences of characters, and don&#39;t want to synch up
    on blanks or hard tabs.
 
    The optional arguments *a* and *b* are sequences to be compared; both default to
    empty strings.  The elements of both sequences must be :term:`hashable`.
 
<span class="gi">+   The optional argument *autojunk* can be used to disable the automatic junk</span>
<span class="gi">+   heuristic.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7.1</span>
<span class="gi">+      The *autojunk* parameter.</span>
<span class="gi">+</span>
    :class:`SequenceMatcher` objects have the following methods:
 
<span class="gd">-</span>
    .. method:: set_seqs(a, b)
 
       Set the two sequences to be compared.
 
    :class:`SequenceMatcher` computes and caches detailed information about the
    second sequence, so if you want to compare one sequence against many
    sequences, use :meth:`set_seq2` to set the commonly used sequence once and
    call :meth:`set_seq1` repeatedly, once for each of the other sequences.
 
 
    .. method:: set_seq1(a)
 
<span class="gu">@@ -508,34 +518,29 @@</span>
       sequences are identical, and ``0.0`` if they have nothing in common.
 
       This is expensive to compute if :meth:`get_matching_blocks` or
       :meth:`get_opcodes` hasn&#39;t already been called, in which case you may want
       to try :meth:`quick_ratio` or :meth:`real_quick_ratio` first to get an
       upper bound.
 
 
    .. method:: quick_ratio()
 
       Return an upper bound on :meth:`ratio` relatively quickly.
 
<span class="gd">-      This isn&#39;t defined beyond that it is an upper bound on :meth:`ratio`, and</span>
<span class="gd">-      is faster to compute.</span>
<span class="gd">-</span>
 
    .. method:: real_quick_ratio()
 
       Return an upper bound on :meth:`ratio` very quickly.
 
<span class="gd">-      This isn&#39;t defined beyond that it is an upper bound on :meth:`ratio`, and</span>
<span class="gd">-      is faster to compute than either :meth:`ratio` or :meth:`quick_ratio`.</span>
 
 The three methods that return the ratio of matching to total characters can give
 different results due to differing levels of approximation, although
 :meth:`quick_ratio` and :meth:`real_quick_ratio` are always at least as large as
 :meth:`ratio`:
 
    &gt;&gt;&gt; s = SequenceMatcher(None, &quot;abcd&quot;, &quot;bcde&quot;)
    &gt;&gt;&gt; s.ratio()
    0.75
    &gt;&gt;&gt; s.quick_ratio()
    0.75
    &gt;&gt;&gt; s.real_quick_ratio()
</pre></div>

</body>
</html>
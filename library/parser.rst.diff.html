<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/parser.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -112,45 +112,45 @@</span>
 -------------------
 
 ST objects may be created from source code or from a parse tree. When creating
 an ST object from source, different functions are used to create the ``&#39;eval&#39;``
 and ``&#39;exec&#39;`` forms.
 
 
 .. function:: expr(source)
 
    The :func:`expr` function parses the parameter *source* as if it were an input
    to ``compile(source, &#39;file.py&#39;, &#39;eval&#39;)``.  If the parse succeeds, an ST object
    is created to hold the internal parse tree representation, otherwise an
<span class="gd">-   appropriate exception is thrown.</span>
<span class="gi">+   appropriate exception is raised.</span>
 
 
 .. function:: suite(source)
 
    The :func:`suite` function parses the parameter *source* as if it were an input
    to ``compile(source, &#39;file.py&#39;, &#39;exec&#39;)``.  If the parse succeeds, an ST object
    is created to hold the internal parse tree representation, otherwise an
<span class="gd">-   appropriate exception is thrown.</span>
<span class="gi">+   appropriate exception is raised.</span>
 
 
 .. function:: sequence2st(sequence)
 
    This function accepts a parse tree represented as a sequence and builds an
    internal representation if possible.  If it can validate that the tree conforms
    to the Python grammar and all nodes are valid node types in the host version of
    Python, an ST object is created from the internal representation and returned
    to the called.  If there is a problem creating the internal representation, or
<span class="gd">-   if the tree cannot be validated, a :exc:`ParserError` exception is thrown.  An</span>
<span class="gi">+   if the tree cannot be validated, a :exc:`ParserError` exception is raised.  An</span>
    ST object created this way should not be assumed to compile correctly; normal
<span class="gd">-   exceptions thrown by compilation may still be initiated when the ST object is</span>
<span class="gi">+   exceptions raised by compilation may still be initiated when the ST object is</span>
    passed to :func:`compilest`.  This may indicate problems not related to syntax
    (such as a :exc:`MemoryError` exception), but may also be due to constructs such
    as the result of parsing ``del f(0)``, which escapes the Python parser but is
    checked by the bytecode compiler.
 
    Sequences representing terminal tokens may be represented as either two-element
    lists of the form ``(1, &#39;name&#39;)`` or as three-element lists of the form ``(1,
    &#39;name&#39;, 56)``.  If the third element is present, it is assumed to be a valid
    line number.  The line number may be specified for any subset of the terminal
    symbols in the input tree.
 
 
<span class="gu">@@ -255,34 +255,34 @@</span>
 
 Exceptions and Error Handling
 -----------------------------
 
 The parser module defines a single exception, but may also pass other built-in
 exceptions from other portions of the Python runtime environment.  See each
 function for information about the exceptions it can raise.
 
 
 .. exception:: ParserError
 
    Exception raised when a failure occurs within the parser module.  This is
<span class="gd">-   generally produced for validation failures rather than the built in</span>
<span class="gd">-   :exc:`SyntaxError` thrown during normal parsing. The exception argument is</span>
<span class="gi">+   generally produced for validation failures rather than the built-in</span>
<span class="gi">+   :exc:`SyntaxError` raised during normal parsing. The exception argument is</span>
    either a string describing the reason of the failure or a tuple containing a
    sequence causing the failure from a parse tree passed to :func:`sequence2st`
    and an explanatory string.  Calls to :func:`sequence2st` need to be able to
    handle either type of exception, while calls to other functions in the module
    will only need to be aware of the simple string values.
 
 Note that the functions :func:`compilest`, :func:`expr`, and :func:`suite` may
<span class="gd">-throw exceptions which are normally thrown by the parsing and compilation</span>
<span class="gi">+raise exceptions which are normally raised by the parsing and compilation</span>
 process.  These include the built in exceptions :exc:`MemoryError`,
 :exc:`OverflowError`, :exc:`SyntaxError`, and :exc:`SystemError`.  In these
 cases, these exceptions carry all the meaning normally associated with them.
 Refer to the descriptions of each function for detailed information.
 
 
 .. _st-objects:
 
 ST Objects
 ----------
 
 Ordered and equality comparisons are supported between ST objects. Pickling of
<span class="gu">@@ -313,40 +313,26 @@</span>
 
 
 .. method:: ST.tolist([line_info])
 
    Same as ``st2list(st, line_info)``.
 
 
 .. method:: ST.totuple([line_info])
 
    Same as ``st2tuple(st, line_info)``.
 
 
<span class="gd">-.. _st-examples:</span>
<span class="gd">-</span>
<span class="gd">-Examples</span>
<span class="gd">---------</span>
<span class="gd">-</span>
<span class="gd">-.. index:: builtin: compile</span>
<span class="gd">-</span>
<span class="gd">-The parser modules allows operations to be performed on the parse tree of Python</span>
<span class="gd">-source code before the :term:`bytecode` is generated, and provides for inspection of the</span>
<span class="gd">-parse tree for information gathering purposes. Two examples are presented.  The</span>
<span class="gd">-simple example demonstrates emulation of the :func:`compile` built-in function</span>
<span class="gd">-and the complex example shows the use of a parse tree for information discovery.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Emulation of :func:`compile`</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gi">+Example: Emulation of :func:`compile`</span>
<span class="gi">+-------------------------------------</span>
 
 While many useful operations may take place between parsing and bytecode
 generation, the simplest operation is to do nothing.  For this purpose, using
 the :mod:`parser` module to produce an intermediate data structure is equivalent
 to the code ::
 
    &gt;&gt;&gt; code = compile(&#39;a + 5&#39;, &#39;file.py&#39;, &#39;eval&#39;)
    &gt;&gt;&gt; a = 5
    &gt;&gt;&gt; eval(code)
    10
 
 The equivalent operation using the :mod:`parser` module is somewhat longer, and
<span class="gu">@@ -362,331 +348,12 @@</span>
 An application which needs both ST and code objects can package this code into
 readily available functions::
 
    import parser
 
    def load_suite(source_string):
        st = parser.suite(source_string)
        return st, st.compile()
 
    def load_expression(source_string):
        st = parser.expr(source_string)
        return st, st.compile()
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-Information Discovery</span>
<span class="gd">-^^^^^^^^^^^^^^^^^^^^^</span>
<span class="gd">-</span>
<span class="gd">-.. index::</span>
<span class="gd">-   single: string; documentation</span>
<span class="gd">-   single: docstrings</span>
<span class="gd">-</span>
<span class="gd">-Some applications benefit from direct access to the parse tree.  The remainder</span>
<span class="gd">-of this section demonstrates how the parse tree provides access to module</span>
<span class="gd">-documentation defined in docstrings without requiring that the code being</span>
<span class="gd">-examined be loaded into a running interpreter via :keyword:`import`.  This can</span>
<span class="gd">-be very useful for performing analyses of untrusted code.</span>
<span class="gd">-</span>
<span class="gd">-Generally, the example will demonstrate how the parse tree may be traversed to</span>
<span class="gd">-distill interesting information.  Two functions and a set of classes are</span>
<span class="gd">-developed which provide programmatic access to high level function and class</span>
<span class="gd">-definitions provided by a module.  The classes extract information from the</span>
<span class="gd">-parse tree and provide access to the information at a useful semantic level, one</span>
<span class="gd">-function provides a simple low-level pattern matching capability, and the other</span>
<span class="gd">-function defines a high-level interface to the classes by handling file</span>
<span class="gd">-operations on behalf of the caller.  All source files mentioned here which are</span>
<span class="gd">-not part of the Python installation are located in the :file:`Demo/parser/`</span>
<span class="gd">-directory of the distribution.</span>
<span class="gd">-</span>
<span class="gd">-The dynamic nature of Python allows the programmer a great deal of flexibility,</span>
<span class="gd">-but most modules need only a limited measure of this when defining classes,</span>
<span class="gd">-functions, and methods.  In this example, the only definitions that will be</span>
<span class="gd">-considered are those which are defined in the top level of their context, e.g.,</span>
<span class="gd">-a function defined by a :keyword:`def` statement at column zero of a module, but</span>
<span class="gd">-not a function defined within a branch of an :keyword:`if` ... :keyword:`else`</span>
<span class="gd">-construct, though there are some good reasons for doing so in some situations.</span>
<span class="gd">-Nesting of definitions will be handled by the code developed in the example.</span>
<span class="gd">-</span>
<span class="gd">-To construct the upper-level extraction methods, we need to know what the parse</span>
<span class="gd">-tree structure looks like and how much of it we actually need to be concerned</span>
<span class="gd">-about.  Python uses a moderately deep parse tree so there are a large number of</span>
<span class="gd">-intermediate nodes.  It is important to read and understand the formal grammar</span>
<span class="gd">-used by Python.  This is specified in the file :file:`Grammar/Grammar` in the</span>
<span class="gd">-distribution. Consider the simplest case of interest when searching for</span>
<span class="gd">-docstrings: a module consisting of a docstring and nothing else.  (See file</span>
<span class="gd">-:file:`docstring.py`.) ::</span>
<span class="gd">-</span>
<span class="gd">-   &quot;&quot;&quot;Some documentation.</span>
<span class="gd">-   &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-Using the interpreter to take a look at the parse tree, we find a bewildering</span>
<span class="gd">-mass of numbers and parentheses, with the documentation buried deep in nested</span>
<span class="gd">-tuples. ::</span>
<span class="gd">-</span>
<span class="gd">-   &gt;&gt;&gt; import parser</span>
<span class="gd">-   &gt;&gt;&gt; import pprint</span>
<span class="gd">-   &gt;&gt;&gt; st = parser.suite(open(&#39;docstring.py&#39;).read())</span>
<span class="gd">-   &gt;&gt;&gt; tup = st.totuple()</span>
<span class="gd">-   &gt;&gt;&gt; pprint.pprint(tup)</span>
<span class="gd">-   (257,</span>
<span class="gd">-    (264,</span>
<span class="gd">-     (265,</span>
<span class="gd">-      (266,</span>
<span class="gd">-       (267,</span>
<span class="gd">-        (307,</span>
<span class="gd">-         (287,</span>
<span class="gd">-          (288,</span>
<span class="gd">-           (289,</span>
<span class="gd">-            (290,</span>
<span class="gd">-             (292,</span>
<span class="gd">-              (293,</span>
<span class="gd">-               (294,</span>
<span class="gd">-                (295,</span>
<span class="gd">-                 (296,</span>
<span class="gd">-                  (297,</span>
<span class="gd">-                   (298,</span>
<span class="gd">-                    (299,</span>
<span class="gd">-                     (300, (3, &#39;&quot;&quot;&quot;Some documentation.\n&quot;&quot;&quot;&#39;))))))))))))))))),</span>
<span class="gd">-      (4, &#39;&#39;))),</span>
<span class="gd">-    (4, &#39;&#39;),</span>
<span class="gd">-    (0, &#39;&#39;))</span>
<span class="gd">-</span>
<span class="gd">-The numbers at the first element of each node in the tree are the node types;</span>
<span class="gd">-they map directly to terminal and non-terminal symbols in the grammar.</span>
<span class="gd">-Unfortunately, they are represented as integers in the internal representation,</span>
<span class="gd">-and the Python structures generated do not change that.  However, the</span>
<span class="gd">-:mod:`symbol` and :mod:`token` modules provide symbolic names for the node types</span>
<span class="gd">-and dictionaries which map from the integers to the symbolic names for the node</span>
<span class="gd">-types.</span>
<span class="gd">-</span>
<span class="gd">-In the output presented above, the outermost tuple contains four elements: the</span>
<span class="gd">-integer ``257`` and three additional tuples.  Node type ``257`` has the symbolic</span>
<span class="gd">-name :const:`file_input`.  Each of these inner tuples contains an integer as the</span>
<span class="gd">-first element; these integers, ``264``, ``4``, and ``0``, represent the node</span>
<span class="gd">-types :const:`stmt`, :const:`NEWLINE`, and :const:`ENDMARKER`, respectively.</span>
<span class="gd">-Note that these values may change depending on the version of Python you are</span>
<span class="gd">-using; consult :file:`symbol.py` and :file:`token.py` for details of the</span>
<span class="gd">-mapping.  It should be fairly clear that the outermost node is related primarily</span>
<span class="gd">-to the input source rather than the contents of the file, and may be disregarded</span>
<span class="gd">-for the moment.  The :const:`stmt` node is much more interesting.  In</span>
<span class="gd">-particular, all docstrings are found in subtrees which are formed exactly as</span>
<span class="gd">-this node is formed, with the only difference being the string itself.  The</span>
<span class="gd">-association between the docstring in a similar tree and the defined entity</span>
<span class="gd">-(class, function, or module) which it describes is given by the position of the</span>
<span class="gd">-docstring subtree within the tree defining the described structure.</span>
<span class="gd">-</span>
<span class="gd">-By replacing the actual docstring with something to signify a variable component</span>
<span class="gd">-of the tree, we allow a simple pattern matching approach to check any given</span>
<span class="gd">-subtree for equivalence to the general pattern for docstrings.  Since the</span>
<span class="gd">-example demonstrates information extraction, we can safely require that the tree</span>
<span class="gd">-be in tuple form rather than list form, allowing a simple variable</span>
<span class="gd">-representation to be ``[&#39;variable_name&#39;]``.  A simple recursive function can</span>
<span class="gd">-implement the pattern matching, returning a Boolean and a dictionary of variable</span>
<span class="gd">-name to value mappings.  (See file :file:`example.py`.) ::</span>
<span class="gd">-</span>
<span class="gd">-   from types import ListType, TupleType</span>
<span class="gd">-</span>
<span class="gd">-   def match(pattern, data, vars=None):</span>
<span class="gd">-       if vars is None:</span>
<span class="gd">-           vars = {}</span>
<span class="gd">-       if type(pattern) is ListType:</span>
<span class="gd">-           vars[pattern[0]] = data</span>
<span class="gd">-           return 1, vars</span>
<span class="gd">-       if type(pattern) is not TupleType:</span>
<span class="gd">-           return (pattern == data), vars</span>
<span class="gd">-       if len(data) != len(pattern):</span>
<span class="gd">-           return 0, vars</span>
<span class="gd">-       for pattern, data in map(None, pattern, data):</span>
<span class="gd">-           same, vars = match(pattern, data, vars)</span>
<span class="gd">-           if not same:</span>
<span class="gd">-               break</span>
<span class="gd">-       return same, vars</span>
<span class="gd">-</span>
<span class="gd">-Using this simple representation for syntactic variables and the symbolic node</span>
<span class="gd">-types, the pattern for the candidate docstring subtrees becomes fairly readable.</span>
<span class="gd">-(See file :file:`example.py`.) ::</span>
<span class="gd">-</span>
<span class="gd">-   import symbol</span>
<span class="gd">-   import token</span>
<span class="gd">-</span>
<span class="gd">-   DOCSTRING_STMT_PATTERN = (</span>
<span class="gd">-       symbol.stmt,</span>
<span class="gd">-       (symbol.simple_stmt,</span>
<span class="gd">-        (symbol.small_stmt,</span>
<span class="gd">-         (symbol.expr_stmt,</span>
<span class="gd">-          (symbol.testlist,</span>
<span class="gd">-           (symbol.test,</span>
<span class="gd">-            (symbol.and_test,</span>
<span class="gd">-             (symbol.not_test,</span>
<span class="gd">-              (symbol.comparison,</span>
<span class="gd">-               (symbol.expr,</span>
<span class="gd">-                (symbol.xor_expr,</span>
<span class="gd">-                 (symbol.and_expr,</span>
<span class="gd">-                  (symbol.shift_expr,</span>
<span class="gd">-                   (symbol.arith_expr,</span>
<span class="gd">-                    (symbol.term,</span>
<span class="gd">-                     (symbol.factor,</span>
<span class="gd">-                      (symbol.power,</span>
<span class="gd">-                       (symbol.atom,</span>
<span class="gd">-                        (token.STRING, [&#39;docstring&#39;])</span>
<span class="gd">-                        )))))))))))))))),</span>
<span class="gd">-        (token.NEWLINE, &#39;&#39;)</span>
<span class="gd">-        ))</span>
<span class="gd">-</span>
<span class="gd">-Using the :func:`match` function with this pattern, extracting the module</span>
<span class="gd">-docstring from the parse tree created previously is easy::</span>
<span class="gd">-</span>
<span class="gd">-   &gt;&gt;&gt; found, vars = match(DOCSTRING_STMT_PATTERN, tup[1])</span>
<span class="gd">-   &gt;&gt;&gt; found</span>
<span class="gd">-   1</span>
<span class="gd">-   &gt;&gt;&gt; vars</span>
<span class="gd">-   {&#39;docstring&#39;: &#39;&quot;&quot;&quot;Some documentation.\n&quot;&quot;&quot;&#39;}</span>
<span class="gd">-</span>
<span class="gd">-Once specific data can be extracted from a location where it is expected, the</span>
<span class="gd">-question of where information can be expected needs to be answered.  When</span>
<span class="gd">-dealing with docstrings, the answer is fairly simple: the docstring is the first</span>
<span class="gd">-:const:`stmt` node in a code block (:const:`file_input` or :const:`suite` node</span>
<span class="gd">-types).  A module consists of a single :const:`file_input` node, and class and</span>
<span class="gd">-function definitions each contain exactly one :const:`suite` node.  Classes and</span>
<span class="gd">-functions are readily identified as subtrees of code block nodes which start</span>
<span class="gd">-with ``(stmt, (compound_stmt, (classdef, ...`` or ``(stmt, (compound_stmt,</span>
<span class="gd">-(funcdef, ...``.  Note that these subtrees cannot be matched by :func:`match`</span>
<span class="gd">-since it does not support multiple sibling nodes to match without regard to</span>
<span class="gd">-number.  A more elaborate matching function could be used to overcome this</span>
<span class="gd">-limitation, but this is sufficient for the example.</span>
<span class="gd">-</span>
<span class="gd">-Given the ability to determine whether a statement might be a docstring and</span>
<span class="gd">-extract the actual string from the statement, some work needs to be performed to</span>
<span class="gd">-walk the parse tree for an entire module and extract information about the names</span>
<span class="gd">-defined in each context of the module and associate any docstrings with the</span>
<span class="gd">-names.  The code to perform this work is not complicated, but bears some</span>
<span class="gd">-explanation.</span>
<span class="gd">-</span>
<span class="gd">-The public interface to the classes is straightforward and should probably be</span>
<span class="gd">-somewhat more flexible.  Each &quot;major&quot; block of the module is described by an</span>
<span class="gd">-object providing several methods for inquiry and a constructor which accepts at</span>
<span class="gd">-least the subtree of the complete parse tree which it represents.  The</span>
<span class="gd">-:class:`ModuleInfo` constructor accepts an optional *name* parameter since it</span>
<span class="gd">-cannot otherwise determine the name of the module.</span>
<span class="gd">-</span>
<span class="gd">-The public classes include :class:`ClassInfo`, :class:`FunctionInfo`, and</span>
<span class="gd">-:class:`ModuleInfo`.  All objects provide the methods :meth:`get_name`,</span>
<span class="gd">-:meth:`get_docstring`, :meth:`get_class_names`, and :meth:`get_class_info`.  The</span>
<span class="gd">-:class:`ClassInfo` objects support :meth:`get_method_names` and</span>
<span class="gd">-:meth:`get_method_info` while the other classes provide</span>
<span class="gd">-:meth:`get_function_names` and :meth:`get_function_info`.</span>
<span class="gd">-</span>
<span class="gd">-Within each of the forms of code block that the public classes represent, most</span>
<span class="gd">-of the required information is in the same form and is accessed in the same way,</span>
<span class="gd">-with classes having the distinction that functions defined at the top level are</span>
<span class="gd">-referred to as &quot;methods.&quot; Since the difference in nomenclature reflects a real</span>
<span class="gd">-semantic distinction from functions defined outside of a class, the</span>
<span class="gd">-implementation needs to maintain the distinction. Hence, most of the</span>
<span class="gd">-functionality of the public classes can be implemented in a common base class,</span>
<span class="gd">-:class:`SuiteInfoBase`, with the accessors for function and method information</span>
<span class="gd">-provided elsewhere. Note that there is only one class which represents function</span>
<span class="gd">-and method information; this parallels the use of the :keyword:`def` statement</span>
<span class="gd">-to define both types of elements.</span>
<span class="gd">-</span>
<span class="gd">-Most of the accessor functions are declared in :class:`SuiteInfoBase` and do not</span>
<span class="gd">-need to be overridden by subclasses.  More importantly, the extraction of most</span>
<span class="gd">-information from a parse tree is handled through a method called by the</span>
<span class="gd">-:class:`SuiteInfoBase` constructor.  The example code for most of the classes is</span>
<span class="gd">-clear when read alongside the formal grammar, but the method which recursively</span>
<span class="gd">-creates new information objects requires further examination.  Here is the</span>
<span class="gd">-relevant part of the :class:`SuiteInfoBase` definition from :file:`example.py`::</span>
<span class="gd">-</span>
<span class="gd">-   class SuiteInfoBase:</span>
<span class="gd">-       _docstring = &#39;&#39;</span>
<span class="gd">-       _name = &#39;&#39;</span>
<span class="gd">-</span>
<span class="gd">-       def __init__(self, tree = None):</span>
<span class="gd">-           self._class_info = {}</span>
<span class="gd">-           self._function_info = {}</span>
<span class="gd">-           if tree:</span>
<span class="gd">-               self._extract_info(tree)</span>
<span class="gd">-</span>
<span class="gd">-       def _extract_info(self, tree):</span>
<span class="gd">-           # extract docstring</span>
<span class="gd">-           if len(tree) == 2:</span>
<span class="gd">-               found, vars = match(DOCSTRING_STMT_PATTERN[1], tree[1])</span>
<span class="gd">-           else:</span>
<span class="gd">-               found, vars = match(DOCSTRING_STMT_PATTERN, tree[3])</span>
<span class="gd">-           if found:</span>
<span class="gd">-               self._docstring = eval(vars[&#39;docstring&#39;])</span>
<span class="gd">-           # discover inner definitions</span>
<span class="gd">-           for node in tree[1:]:</span>
<span class="gd">-               found, vars = match(COMPOUND_STMT_PATTERN, node)</span>
<span class="gd">-               if found:</span>
<span class="gd">-                   cstmt = vars[&#39;compound&#39;]</span>
<span class="gd">-                   if cstmt[0] == symbol.funcdef:</span>
<span class="gd">-                       name = cstmt[2][1]</span>
<span class="gd">-                       self._function_info[name] = FunctionInfo(cstmt)</span>
<span class="gd">-                   elif cstmt[0] == symbol.classdef:</span>
<span class="gd">-                       name = cstmt[2][1]</span>
<span class="gd">-                       self._class_info[name] = ClassInfo(cstmt)</span>
<span class="gd">-</span>
<span class="gd">-After initializing some internal state, the constructor calls the</span>
<span class="gd">-:meth:`_extract_info` method.  This method performs the bulk of the information</span>
<span class="gd">-extraction which takes place in the entire example.  The extraction has two</span>
<span class="gd">-distinct phases: the location of the docstring for the parse tree passed in, and</span>
<span class="gd">-the discovery of additional definitions within the code block represented by the</span>
<span class="gd">-parse tree.</span>
<span class="gd">-</span>
<span class="gd">-The initial :keyword:`if` test determines whether the nested suite is of the</span>
<span class="gd">-&quot;short form&quot; or the &quot;long form.&quot;  The short form is used when the code block is</span>
<span class="gd">-on the same line as the definition of the code block, as in ::</span>
<span class="gd">-</span>
<span class="gd">-   def square(x): &quot;Square an argument.&quot;; return x ** 2</span>
<span class="gd">-</span>
<span class="gd">-while the long form uses an indented block and allows nested definitions::</span>
<span class="gd">-</span>
<span class="gd">-   def make_power(exp):</span>
<span class="gd">-       &quot;Make a function that raises an argument to the exponent `exp`.&quot;</span>
<span class="gd">-       def raiser(x, y=exp):</span>
<span class="gd">-           return x ** y</span>
<span class="gd">-       return raiser</span>
<span class="gd">-</span>
<span class="gd">-When the short form is used, the code block may contain a docstring as the</span>
<span class="gd">-first, and possibly only, :const:`small_stmt` element.  The extraction of such a</span>
<span class="gd">-docstring is slightly different and requires only a portion of the complete</span>
<span class="gd">-pattern used in the more common case.  As implemented, the docstring will only</span>
<span class="gd">-be found if there is only one :const:`small_stmt` node in the</span>
<span class="gd">-:const:`simple_stmt` node. Since most functions and methods which use the short</span>
<span class="gd">-form do not provide a docstring, this may be considered sufficient.  The</span>
<span class="gd">-extraction of the docstring proceeds using the :func:`match` function as</span>
<span class="gd">-described above, and the value of the docstring is stored as an attribute of the</span>
<span class="gd">-:class:`SuiteInfoBase` object.</span>
<span class="gd">-</span>
<span class="gd">-After docstring extraction, a simple definition discovery algorithm operates on</span>
<span class="gd">-the :const:`stmt` nodes of the :const:`suite` node.  The special case of the</span>
<span class="gd">-short form is not tested; since there are no :const:`stmt` nodes in the short</span>
<span class="gd">-form, the algorithm will silently skip the single :const:`simple_stmt` node and</span>
<span class="gd">-correctly not discover any nested definitions.</span>
<span class="gd">-</span>
<span class="gd">-Each statement in the code block is categorized as a class definition, function</span>
<span class="gd">-or method definition, or something else.  For the definition statements, the</span>
<span class="gd">-name of the element defined is extracted and a representation object appropriate</span>
<span class="gd">-to the definition is created with the defining subtree passed as an argument to</span>
<span class="gd">-the constructor.  The representation objects are stored in instance variables</span>
<span class="gd">-and may be retrieved by name using the appropriate accessor methods.</span>
<span class="gd">-</span>
<span class="gd">-The public classes provide any accessors required which are more specific than</span>
<span class="gd">-those provided by the :class:`SuiteInfoBase` class, but the real extraction</span>
<span class="gd">-algorithm remains common to all forms of code blocks.  A high-level function can</span>
<span class="gd">-be used to extract the complete set of information from a source file.  (See</span>
<span class="gd">-file :file:`example.py`.) ::</span>
<span class="gd">-</span>
<span class="gd">-   def get_docs(fileName):</span>
<span class="gd">-       import os</span>
<span class="gd">-       import parser</span>
<span class="gd">-</span>
<span class="gd">-       source = open(fileName).read()</span>
<span class="gd">-       basename = os.path.basename(os.path.splitext(fileName)[0])</span>
<span class="gd">-       st = parser.suite(source)</span>
<span class="gd">-       return ModuleInfo(st.totuple(), basename)</span>
<span class="gd">-</span>
<span class="gd">-This provides an easy-to-use interface to the documentation of a module.  If</span>
<span class="gd">-information is required which is not extracted by the code of this example, the</span>
<span class="gd">-code may be extended at clearly defined points to provide additional</span>
<span class="gd">-capabilities.</span>
<span class="gd">-</span>
</pre></div>

</body>
</html>
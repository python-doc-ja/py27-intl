
:mod:`math` --- 数学関数
========================

.. module:: math
   :synopsis: 数学関数(sin() など)。


このモジュールはいつでも利用できます。標準 C で定義されている数学関数に アクセスすることができます。

これらの関数で複素数を使うことはできません。複素数に対応する必要がある ならば、 :mod:`cmath` モジュールにある同じ名前の関数を使ってくだ
さい。ほとんどのユーザーは複素数を理解するのに必要なだけの数学を勉強し たくないので、複素数に対応した関数と対応していない関数の区別がされてい
ます。これらの関数では複素数が利用できないため、引数に複素数を渡される と、複素数の結果が返えるのではなく例外が発生します。その結果、プログラ
マは、そもそもどういった理由で例外がスローされたのかに早い段階で気づく 事ができます。 [#]_

このモジュールでは次の関数を提供しています。 明示的な注記のない限り、戻り値は全て浮動小数点数になります。

以下は整数論および数表現にまつわる関数です:


.. function:: ceil(x)

   *x* の天井値 (ceil)、すなわち*x* 以上の最も小さい整数を float型で返します。


.. function:: fabs(x)

   *x* の絶対値を返します。


.. function:: floor(x)

   *x* の床値 (floor)、すなわち*x* 以下の最も大きい整数を float型で返します。


.. function:: fmod(x, y)

   プラットフォームの C ライブラリで定義されている ``fmod(x, y)`` を返します。 Python の ``x % y``
   という式は必ずしも同じ結果を 返さないということに注意してください。 C 標準の要求では、:cfunc:`fmod` は除算の結果が *x* と同じ符号に
   なり、大きさが``abs(y)`` より小さくなるような整数 *n* に ついては``fmod(x, y)`` が厳密に (数学的に、つまり限りなく高い精度で)
   ``x - n*y``  と等価であるよう求めています。 Python の ``x % y`` は、*y* と同じ符号の結果を
   返し、浮動小数点の引数に対して厳密な解を出せないことがあります。 例えば、 ``fmod(-1e-100, 1e100)`` は ``-1e-100``
   ですが、 Python の``-1e-100 % 1e100`` は ``1e100-1e-100`` になり、
   浮動小数点型で厳密に表現できず、ややこしいことに``1e100`` に 丸められます。このため、一般には浮動小数点の場合には関数 :func:`fmod`、
   整数の場合には``x % y`` を使う方がよいでしょう。


.. function:: frexp(x)

   *x* の仮数と指数を ``(m, e)``のペアとして返します。 *m*はfloat型で、*e*は厳密に``x == m * 2**e``
   であるような整数型です。 *x* がゼロの場合は、 ``(0.0, 0)``を返し、それ以外の場合は、 ``0.5 <= abs(m) < 1``
   を返します。これは浮動小数点型の内部表現 を可搬性を保ったまま "分解する (pick apart)" するためです。

   .. % Blessed by Tim.


.. function:: ldexp(x, i)

   ``x * (2**i)`` を返します。


.. function:: modf(x)

   *x*の小数部分と整数部分を返します。 両方の結果は *x*の符号を受け継ぎます。 整数部はfloat型で返されます。

:func:`frexp`と :func:`modf` は C のものとは異なった呼び出し/返し
パターンを持っていることに注意してください。引数を1つだけ受け取り、1組のペアに なった値を返すので、2つ目の戻り値を '出力用の引数'
経由で返したりはしません (Python には出力用の引数はありません)。

:func:`ceil`、:func:`floor`、および:func:`modf` 関数に ついては、非常に大きな浮動小数点数が*全て*
整数そのものになるという ことに注意してください。通常、Python の浮動小数点型は 53 ビット以上の 精度をもたない (プラットフォームにおける C
double 型と同じ) ので、 結果的に``abs(x) >= 2**52`` であるような浮動小数点型*x* は 小数部分を持たなくなるのです。

以下は指数および対数関数です:


.. function:: exp(x)

   ``e**x`` を返します。


.. function:: log(x[, base])

   *x* の自然対数を返します。 *base* を底とした *x* の対数を返します。*base* を省略した場合 *x* の自然対数を返します。

   .. versionchanged:: 2.3
      *base* argument added.


.. function:: log10(x)

   *x* の10を底とした対数を返します。


.. function:: pow(x, y)

   ``x**y``を返します。


.. function:: sqrt(x)

   *x* の平方根を返します。

以下は三角関数です:


.. function:: acos(x)

   *x* の逆余弦を返します。


.. function:: asin(x)

   *x* の逆正弦を返します。


.. function:: atan(x)

   *x* 逆正接を返します。


.. function:: atan2(y, x)

   ``atan(y / x)`` の逆正接をラジアンで返します。 戻り値は ``-pi`` から ``pi`` の間になります。この角度は、
   極座標平面において原点から ``(x, y)`` へのベクトル が X 軸の正の方向となす角です。:func:`atan2` のポイントは、 入力 *x*,
   *y* の両方の符号が既知であるために、位相角の 正しい象限を計算できることにあります。例えば、``atan(1)`` と ``atan2(1,1)``
   はいずれも ``pi/4`` ですが、``atan2(-1, -1)`` は ``-3*pi/4`` になります。


.. function:: cos(x)

   *x* の余弦を返します。


.. function:: hypot(x, y)

   ユークリッド距離(``sqrt(x*x + y*y)``)を返します。


.. function:: sin(x)

   *x*の正弦を返します。


.. function:: tan(x)

   *x* の正接を返します。

以下は角度に関する関数です:


.. function:: degrees(x)

   角 *x* をラジアンから度数に変換します。


.. function:: radians(x)

   角 *x* を度数からラジアンに変換します。

以下は双曲線関数です:


.. function:: cosh(x)

   *x* の双曲線余弦を返します。


.. function:: sinh(x)

   *x*の双曲線正弦を返します。


.. function:: tanh(x)

   *x* の双曲線正接を返します。

このモジュールでは以下の 2つの数学定数も定義しています:


.. data:: pi

   数学定数 *pi*。


.. data:: e

   数学定数 *e*。

.. note::

   :mod:`math` モジュールは、ほとんどが実行プラットフォームにおける C 言語の数学ライブラリ関数に対する薄いラッパでできています。
   例外的な場合での挙動は、 C 言語標準ではおおさっぱにしか定義されておらず、 さらに Python は数学関数におけるエラー報告機能の挙動をプラットフォームの
   C 実装から受け継いでいます。その結果として、エラーの際 (およびなんらか の引数がとにかく例外的であると考えられる場合) に送出される特定の例外に
   ついては、プラットフォーム間やリリースバージョン間を通じて有意なものと なっていません。例えば、 ``math.log(0)`` が ``-Inf`` を返すか
   :exc:`ValueError`  または  :exc:`OverflowError` を送出するかは不定であり、 ``math.log(0)`` が
   :exc:`OverflowError` を送出する場合において ``math.log(0L)`` が :exc:`ValueError`
   を送出するときもあります。


.. seealso::

   Module :mod:`cmath`
      これらの多くの関数の複素数版。

.. rubric:: Footnotes

.. [#] 訳注：例外が発生しないで、計算結果が返えってし まうと、計算結果がおかしい事から、原因が複素数を渡したせいである事に
   プログラマが気づくのがおくれる可能性があります。


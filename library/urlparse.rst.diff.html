<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/urlparse.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -24,24 +24,29 @@</span>
 to an absolute URL given a &quot;base URL.&quot;
 
 The module has been designed to match the Internet RFC on Relative Uniform
 Resource Locators (and discovered a bug in an earlier draft!). It supports the
 following URL schemes: ``file``, ``ftp``, ``gopher``, ``hdl``, ``http``,
 ``https``, ``imap``, ``mailto``, ``mms``, ``news``,  ``nntp``, ``prospero``,
 ``rsync``, ``rtsp``, ``rtspu``,  ``sftp``, ``shttp``, ``sip``, ``sips``,
 ``snews``, ``svn``,  ``svn+ssh``, ``telnet``, ``wais``.
 
 .. versionadded:: 2.5
    Support for the ``sftp`` and ``sips`` schemes.
 
<span class="gi">+.. seealso::</span>
<span class="gi">+</span>
<span class="gi">+   Latest version of the `urlparse module Python source code</span>
<span class="gi">+   &lt;http://svn.python.org/view/python/branches/release27-maint/Lib/urlparse.py?view=markup&gt;`_</span>
<span class="gi">+</span>
 The :mod:`urlparse` module defines the following functions:
 
 
 .. function:: urlparse(urlstring[, scheme[, allow_fragments]])
 
    Parse a URL into six components, returning a 6-tuple.  This corresponds to the
    general structure of a URL: ``scheme://netloc/path;parameters?query#fragment``.
    Each tuple item is a string, possibly empty. The components are not broken up in
    smaller parts (for example, the network location is a single string), and %
    escapes are not expanded. The delimiters as shown above are not part of the
    result, except for a leading slash in the *path* component, which is retained if
    present.  For example:
<span class="gu">@@ -49,24 +54,41 @@</span>
       &gt;&gt;&gt; from urlparse import urlparse
       &gt;&gt;&gt; o = urlparse(&#39;http://www.cwi.nl:80/%7Eguido/Python.html&#39;)
       &gt;&gt;&gt; o   # doctest: +NORMALIZE_WHITESPACE
       ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,
                   params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)
       &gt;&gt;&gt; o.scheme
       &#39;http&#39;
       &gt;&gt;&gt; o.port
       80
       &gt;&gt;&gt; o.geturl()
       &#39;http://www.cwi.nl:80/%7Eguido/Python.html&#39;
 
<span class="gi">+</span>
<span class="gi">+   Following the syntax specifications in :rfc:`1808`, urlparse recognizes</span>
<span class="gi">+   a netloc only if it is properly introduced by &#39;//&#39;.  Otherwise the</span>
<span class="gi">+   input is presumed to be a relative URL and thus to start with</span>
<span class="gi">+   a path component.</span>
<span class="gi">+</span>
<span class="gi">+       &gt;&gt;&gt; from urlparse import urlparse</span>
<span class="gi">+       &gt;&gt;&gt; urlparse(&#39;//www.cwi.nl:80/%7Eguido/Python.html&#39;)</span>
<span class="gi">+       ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="gi">+                  params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gi">+       &gt;&gt;&gt; urlparse(&#39;www.cwi.nl:80/%7Eguido/Python.html&#39;)</span>
<span class="gi">+       ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;www.cwi.nl:80/%7Eguido/Python.html&#39;,</span>
<span class="gi">+                  params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gi">+       &gt;&gt;&gt; urlparse(&#39;help/Python.html&#39;)</span>
<span class="gi">+       ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;help/Python.html&#39;, params=&#39;&#39;,</span>
<span class="gi">+                  query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gi">+</span>
    If the *scheme* argument is specified, it gives the default addressing
    scheme, to be used only if the URL does not specify one.  The default value for
    this argument is the empty string.
 
    If the *allow_fragments* argument is false, fragment identifiers are not
    allowed, even if the URL&#39;s addressing scheme normally does support them.  The
    default value for this argument is :const:`True`.
 
    The return value is actually an instance of a subclass of :class:`tuple`.  This
    class has the following additional read-only convenience attributes:
 
    +------------------+-------+--------------------------+----------------------+
<span class="gu">@@ -92,56 +114,60 @@</span>
    | :attr:`hostname` |       | Host name (lower case)   | :const:`None`        |
    +------------------+-------+--------------------------+----------------------+
    | :attr:`port`     |       | Port number as integer,  | :const:`None`        |
    |                  |       | if present               |                      |
    +------------------+-------+--------------------------+----------------------+
 
    See section :ref:`urlparse-result-object` for more information on the result
    object.
 
    .. versionchanged:: 2.5
       Added attributes to return value.
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      Added IPv6 URL parsing capabilities.</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. function:: parse_qs(qs[, keep_blank_values[, strict_parsing]])
 
    Parse a query string given as a string argument (data of type
    :mimetype:`application/x-www-form-urlencoded`).  Data are returned as a
    dictionary.  The dictionary keys are the unique query variable names and the
    values are lists of values for each name.
 
    The optional argument *keep_blank_values* is a flag indicating whether blank
<span class="gd">-   values in URL encoded queries should be treated as blank strings.   A true value</span>
<span class="gi">+   values in percent-encoded queries should be treated as blank strings.   A true value</span>
    indicates that blanks should be retained as  blank strings.  The default false
    value indicates that blank values are to be ignored and treated as if they were
    not included.
 
    The optional argument *strict_parsing* is a flag indicating what to do with
    parsing errors.  If false (the default), errors are silently ignored.  If true,
    errors raise a :exc:`ValueError` exception.
 
    Use the :func:`urllib.urlencode` function to convert such dictionaries into
    query strings.
 
    .. versionadded:: 2.6
       Copied from the :mod:`cgi` module.
 
 
 .. function:: parse_qsl(qs[, keep_blank_values[, strict_parsing]])
 
    Parse a query string given as a string argument (data of type
    :mimetype:`application/x-www-form-urlencoded`).  Data are returned as a list of
    name, value pairs.
 
    The optional argument *keep_blank_values* is a flag indicating whether blank
<span class="gd">-   values in URL encoded queries should be treated as blank strings.   A true value</span>
<span class="gi">+   values in percent-encoded queries should be treated as blank strings.   A true value</span>
    indicates that blanks should be retained as  blank strings.  The default false
    value indicates that blank values are to be ignored and treated as if they were
    not included.
 
    The optional argument *strict_parsing* is a flag indicating what to do with
    parsing errors.  If false (the default), errors are silently ignored.  If true,
    errors raise a :exc:`ValueError` exception.
 
    Use the :func:`urllib.urlencode` function to convert such lists of pairs into
    query strings.
 
    .. versionadded:: 2.6
<span class="gu">@@ -245,27 +271,30 @@</span>
 
    If *url* contains a fragment identifier, returns a modified version of *url*
    with no fragment identifier, and the fragment identifier as a separate string.
    If there is no fragment identifier in *url*, returns *url* unmodified and an
    empty string.
 
 
 .. seealso::
 
    :rfc:`3986` - Uniform Resource Identifiers
       This is the current standard (STD66). Any changes to urlparse module
       should conform to this. Certain deviations could be observed, which are
<span class="gd">-      mostly due backward compatiblity purposes and for certain to de-facto</span>
<span class="gi">+      mostly due backward compatiblity purposes and for certain de-facto</span>
       parsing requirements as commonly observed in major browsers.
 
<span class="gi">+   :rfc:`2732` - Format for Literal IPv6 Addresses in URL&#39;s.</span>
<span class="gi">+      This specifies the parsing requirements of IPv6 URLs.</span>
<span class="gi">+</span>
    :rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax
       Document describing the generic syntactic requirements for both Uniform Resource
       Names (URNs) and Uniform Resource Locators (URLs).
 
    :rfc:`2368` - The mailto URL scheme.
       Parsing requirements for mailto url schemes.
 
    :rfc:`1808` - Relative Uniform Resource Locators
       This Request For Comments includes the rules for joining an absolute and a
       relative URL, including a fair number of &quot;Abnormal Examples&quot; which govern the
       treatment of border cases.
 
</pre></div>

</body>
</html>
@@ -215,25 +215,25 @@
    and :const:`re.X` (verbose), for the entire regular expression. (The
    flags are described in :ref:`contents-of-module-re`.) This
    is useful if you wish to include the flags as part of the regular
    expression, instead of passing a *flag* argument to the
    :func:`re.compile` function.
 
    Note that the ``(?x)`` flag changes how the expression is parsed. It should be
    used first in the expression string, or after one or more whitespace characters.
    If there are non-whitespace characters before the flag, the results are
    undefined.
 
 ``(?:...)``
-   A non-grouping version of regular parentheses. Matches whatever regular
+   A non-capturing version of regular parentheses.  Matches whatever regular
    expression is inside the parentheses, but the substring matched by the group
    *cannot* be retrieved after performing a match or referenced later in the
    pattern.
 
 ``(?P<name>...)``
    Similar to regular parentheses, but the substring matched by the group is
    accessible within the rest of the regular expression via the symbolic group
    name *name*.  Group names must be valid Python identifiers, and each group
    name must be defined only once within a regular expression.  A symbolic group
    is also a numbered group, just as if the group were not named.  So the group
    named ``id`` in the example below can also be referenced as the numbered group
    ``1``.
@@ -323,25 +323,26 @@
    precise set of characters deemed to be alphanumeric depends on the values of the
    ``UNICODE`` and ``LOCALE`` flags.  Inside a character range, ``\b`` represents
    the backspace character, for compatibility with Python's string literals.
 
 ``\B``
    Matches the empty string, but only when it is *not* at the beginning or end of a
    word.  This is just the opposite of ``\b``, so is also subject to the settings
    of ``LOCALE`` and ``UNICODE``.
 
 ``\d``
    When the :const:`UNICODE` flag is not specified, matches any decimal digit; this
    is equivalent to the set ``[0-9]``.  With :const:`UNICODE`, it will match
-   whatever is classified as a digit in the Unicode character properties database.
+   whatever is classified as a decimal digit in the Unicode character properties
+   database.
 
 ``\D``
    When the :const:`UNICODE` flag is not specified, matches any non-digit
    character; this is equivalent to the set  ``[^0-9]``.  With :const:`UNICODE`, it
    will match  anything other than character marked as digits in the Unicode
    character  properties database.
 
 ``\s``
    When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, matches
    any whitespace character; this is equivalent to the set ``[ \t\n\r\f\v]``. With
    :const:`LOCALE`, it will match this set plus whatever characters are defined as
    space for the current locale. If :const:`UNICODE` is set, this will match the
@@ -527,59 +528,64 @@
 
    If zero or more characters at the beginning of *string* match the regular
    expression *pattern*, return a corresponding :class:`MatchObject` instance.
    Return ``None`` if the string does not match the pattern; note that this is
    different from a zero-length match.
 
    .. note::
 
       If you want to locate a match anywhere in *string*, use :func:`search`
       instead.
 
 
-.. function:: split(pattern, string[, maxsplit=0])
+.. function:: split(pattern, string[, maxsplit=0, flags=0])
 
    Split *string* by the occurrences of *pattern*.  If capturing parentheses are
    used in *pattern*, then the text of all groups in the pattern are also returned
    as part of the resulting list. If *maxsplit* is nonzero, at most *maxsplit*
    splits occur, and the remainder of the string is returned as the final element
    of the list.  (Incompatibility note: in the original Python 1.5 release,
    *maxsplit* was ignored.  This has been fixed in later releases.)
 
       >>> re.split('\W+', 'Words, words, words.')
       ['Words', 'words', 'words', '']
       >>> re.split('(\W+)', 'Words, words, words.')
       ['Words', ', ', 'words', ', ', 'words', '.', '']
       >>> re.split('\W+', 'Words, words, words.', 1)
       ['Words', 'words, words.']
+      >>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
+      ['0', '3', '9']
 
    If there are capturing groups in the separator and it matches at the start of
    the string, the result will start with an empty string.  The same holds for
    the end of the string:
 
       >>> re.split('(\W+)', '...words, words...')
       ['', '...', 'words', ', ', 'words', '...', '']
 
    That way, separator components are always found at the same relative
    indices within the result list (e.g., if there's one capturing group
    in the separator, the 0th, the 2nd and so forth).
 
    Note that *split* will never split a string on an empty pattern match.
    For example:
 
       >>> re.split('x*', 'foo')
       ['foo']
       >>> re.split("(?m)^$", "foo\n\nbar\n")
       ['foo\n\nbar\n']
 
+   .. versionchanged:: 2.7
+      Added the optional flags argument.
+
 
 .. function:: findall(pattern, string[, flags])
 
    Return all non-overlapping matches of *pattern* in *string*, as a list of
    strings.  The *string* is scanned left-to-right, and matches are returned in
    the order found.  If one or more groups are present in the pattern, return a
    list of groups; this will be a list of tuples if the pattern has more than
    one group.  Empty matches are included in the result unless they touch the
    beginning of another match.
 
    .. versionadded:: 1.5.2
 
@@ -592,75 +598,81 @@
    Return an :term:`iterator` yielding :class:`MatchObject` instances over all
    non-overlapping matches for the RE *pattern* in *string*.  The *string* is
    scanned left-to-right, and matches are returned in the order found.  Empty
    matches are included in the result unless they touch the beginning of another
    match.
 
    .. versionadded:: 2.2
 
    .. versionchanged:: 2.4
       Added the optional flags argument.
 
 
-.. function:: sub(pattern, repl, string[, count])
+.. function:: sub(pattern, repl, string[, count, flags])
 
    Return the string obtained by replacing the leftmost non-overlapping occurrences
    of *pattern* in *string* by the replacement *repl*.  If the pattern isn't found,
    *string* is returned unchanged.  *repl* can be a string or a function; if it is
    a string, any backslash escapes in it are processed.  That is, ``\n`` is
    converted to a single newline character, ``\r`` is converted to a linefeed, and
    so forth.  Unknown escapes such as ``\j`` are left alone.  Backreferences, such
    as ``\6``, are replaced with the substring matched by group 6 in the pattern.
    For example:
 
       >>> re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
       ...        r'static PyObject*\npy_\1(void)\n{',
       ...        'def myfunc():')
       'static PyObject*\npy_myfunc(void)\n{'
 
    If *repl* is a function, it is called for every non-overlapping occurrence of
    *pattern*.  The function takes a single match object argument, and returns the
    replacement string.  For example:
 
       >>> def dashrepl(matchobj):
       ...     if matchobj.group(0) == '-': return ' '
       ...     else: return '-'
       >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')
       'pro--gram files'
+      >>> re.sub(r'\sAND\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE)
+      'Baked Beans & Spam'
 
-   The pattern may be a string or an RE object; if you need to specify regular
-   expression flags, you must use a RE object, or use embedded modifiers in a
-   pattern; for example, ``sub("(?i)b+", "x", "bbbb BBBB")`` returns ``'x x'``.
+   The pattern may be a string or an RE object.
 
    The optional argument *count* is the maximum number of pattern occurrences to be
    replaced; *count* must be a non-negative integer.  If omitted or zero, all
    occurrences will be replaced. Empty matches for the pattern are replaced only
    when not adjacent to a previous match, so ``sub('x*', '-', 'abc')`` returns
    ``'-a-b-c-'``.
 
    In addition to character escapes and backreferences as described above,
    ``\g<name>`` will use the substring matched by the group named ``name``, as
    defined by the ``(?P<name>...)`` syntax. ``\g<number>`` uses the corresponding
    group number; ``\g<2>`` is therefore equivalent to ``\2``, but isn't ambiguous
    in a replacement such as ``\g<2>0``.  ``\20`` would be interpreted as a
    reference to group 20, not a reference to group 2 followed by the literal
    character ``'0'``.  The backreference ``\g<0>`` substitutes in the entire
    substring matched by the RE.
 
+   .. versionchanged:: 2.7
+      Added the optional flags argument.
 
-.. function:: subn(pattern, repl, string[, count])
+
+.. function:: subn(pattern, repl, string[, count, flags])
 
    Perform the same operation as :func:`sub`, but return a tuple ``(new_string,
    number_of_subs_made)``.
 
+   .. versionchanged:: 2.7
+      Added the optional flags argument.
+
 
 .. function:: escape(string)
 
    Return *string* with all non-alphanumerics backslashed; this is useful if you
    want to match an arbitrary literal string that may have regular expression
    metacharacters in it.
 
 
 .. function:: purge()
 
    Clear the regular expression cache.
 

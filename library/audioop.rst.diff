@@ -227,26 +227,26 @@
    Convert sound fragments in u-LAW encoding to linearly encoded sound fragments.
    u-LAW encoding always uses 8 bits samples, so *width* refers only to the sample
    width of the output fragment here.
 
 Note that operations such as :func:`.mul` or :func:`.max` make no distinction
 between mono and stereo fragments, i.e. all samples are treated equal.  If this
 is a problem the stereo fragment should be split into two mono fragments first
 and recombined later.  Here is an example of how to do that::
 
    def mul_stereo(sample, width, lfactor, rfactor):
        lsample = audioop.tomono(sample, width, 1, 0)
        rsample = audioop.tomono(sample, width, 0, 1)
-       lsample = audioop.mul(sample, width, lfactor)
-       rsample = audioop.mul(sample, width, rfactor)
+       lsample = audioop.mul(lsample, width, lfactor)
+       rsample = audioop.mul(rsample, width, rfactor)
        lsample = audioop.tostereo(lsample, width, 1, 0)
        rsample = audioop.tostereo(rsample, width, 0, 1)
        return audioop.add(lsample, rsample, width)
 
 If you use the ADPCM coder to build network packets and you want your protocol
 to be stateless (i.e. to be able to tolerate packet loss) you should not only
 transmit the data but also the state.  Note that you should send the *initial*
 state (the one you passed to :func:`lin2adpcm`) along to the decoder, not the
 final state (as returned by the coder).  If you want to use
 :func:`struct.struct` to store the state in binary you can code the first
 element (the predicted value) in 16 bits and the second (the delta index) in 8.
 

@@ -160,110 +160,126 @@
 refers to the size of the packed value in bytes when using standard size; that
 is, when the format string starts with one of ``'<'``, ``'>'``, ``'!'`` or
 ``'='``.  When using native size, the size of the packed value is
 platform-dependent.
 
 +--------+-------------------------+--------------------+----------------+------------+
 | Format | C Type                  | Python type        | Standard size  | Notes      |
 +========+=========================+====================+================+============+
 | ``x``  | pad byte                | no value           |                |            |
 +--------+-------------------------+--------------------+----------------+------------+
 | ``c``  | :ctype:`char`           | string of length 1 | 1              |            |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``b``  | :ctype:`signed char`    | integer            | 1              |            |
+| ``b``  | :ctype:`signed char`    | integer            | 1              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``B``  | :ctype:`unsigned char`  | integer            | 1              |            |
+| ``B``  | :ctype:`unsigned char`  | integer            | 1              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
 | ``?``  | :ctype:`_Bool`          | bool               | 1              | \(1)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``h``  | :ctype:`short`          | integer            | 2              |            |
+| ``h``  | :ctype:`short`          | integer            | 2              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``H``  | :ctype:`unsigned short` | integer            | 2              |            |
+| ``H``  | :ctype:`unsigned short` | integer            | 2              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``i``  | :ctype:`int`            | integer            | 4              |            |
+| ``i``  | :ctype:`int`            | integer            | 4              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``I``  | :ctype:`unsigned int`   | integer            | 4              |            |
+| ``I``  | :ctype:`unsigned int`   | integer            | 4              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``l``  | :ctype:`long`           | integer            | 4              |            |
+| ``l``  | :ctype:`long`           | integer            | 4              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``L``  | :ctype:`unsigned long`  | integer            | 4              |            |
+| ``L``  | :ctype:`unsigned long`  | integer            | 4              | \(3)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``q``  | :ctype:`long long`      | integer            | 8              | \(2)       |
+| ``q``  | :ctype:`long long`      | integer            | 8              | \(2), \(3) |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``Q``  | :ctype:`unsigned long   | integer            | 8              | \(2)       |
+| ``Q``  | :ctype:`unsigned long   | integer            | 8              | \(2), \(3) |
 |        | long`                   |                    |                |            |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``f``  | :ctype:`float`          | float              | 4              | \(3)       |
+| ``f``  | :ctype:`float`          | float              | 4              | \(4)       |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``d``  | :ctype:`double`         | float              | 8              | \(3)       |
+| ``d``  | :ctype:`double`         | float              | 8              | \(4)       |
 +--------+-------------------------+--------------------+----------------+------------+
 | ``s``  | :ctype:`char[]`         | string             |                |            |
 +--------+-------------------------+--------------------+----------------+------------+
 | ``p``  | :ctype:`char[]`         | string             |                |            |
 +--------+-------------------------+--------------------+----------------+------------+
-| ``P``  | :ctype:`void \*`        | integer            |                | \(4)       |
+| ``P``  | :ctype:`void \*`        | integer            |                | \(5), \(3) |
 +--------+-------------------------+--------------------+----------------+------------+
 
 Notes:
 
 (1)
    The ``'?'`` conversion code corresponds to the :ctype:`_Bool` type defined by
    C99. If this type is not available, it is simulated using a :ctype:`char`. In
    standard mode, it is always represented by one byte.
 
    .. versionadded:: 2.6
 
 (2)
    The ``'q'`` and ``'Q'`` conversion codes are available in native mode only if
    the platform C compiler supports C :ctype:`long long`, or, on Windows,
    :ctype:`__int64`.  They are always available in standard modes.
 
    .. versionadded:: 2.2
 
 (3)
+   When attempting to pack a non-integer using any of the integer conversion
+   codes, if the non-integer has a :meth:`__index__` method then that method is
+   called to convert the argument to an integer before packing.  If no
+   :meth:`__index__` method exists, or the call to :meth:`__index__` raises
+   :exc:`TypeError`, then the :meth:`__int__` method is tried.  However, the use
+   of :meth:`__int__` is deprecated, and will raise :exc:`DeprecationWarning`.
+
+   .. versionchanged:: 2.7
+      Use of the :meth:`__index__` method for non-integers is new in 2.7.
+
+   .. versionchanged:: 2.7
+      Prior to version 2.7, not all integer conversion codes would use the
+      :meth:`__int__` method to convert, and :exc:`DeprecationWarning` was
+      raised only for float arguments.
+
+(4)
    For the ``'f'`` and ``'d'`` conversion codes, the packed representation uses
    the IEEE 754 binary32 (for ``'f'``) or binary64 (for ``'d'``) format,
    regardless of the floating-point format used by the platform.
 
-(4)
+(5)
    The ``'P'`` format character is only available for the native byte ordering
    (selected as the default or with the ``'@'`` byte order character). The byte
    order character ``'='`` chooses to use little- or big-endian ordering based
    on the host system. The struct module does not interpret this as native
    ordering, so the ``'P'`` format is not available.
 
 
 A format character may be preceded by an integral repeat count.  For example,
 the format string ``'4h'`` means exactly the same as ``'hhhh'``.
 
 Whitespace characters between formats are ignored; a count and its format must
 not contain whitespace though.
 
 For the ``'s'`` format character, the count is interpreted as the size of the
 string, not a repeat count like for the other format characters; for example,
 ``'10s'`` means a single 10-byte string, while ``'10c'`` means 10 characters.
 For packing, the string is truncated or padded with null bytes as appropriate to
 make it fit. For unpacking, the resulting string always has exactly the
 specified number of bytes.  As a special case, ``'0s'`` means a single, empty
 string (while ``'0c'`` means 0 characters).
 
 The ``'p'`` format character encodes a "Pascal string", meaning a short
-variable-length string stored in a fixed number of bytes. The count is the total
-number of bytes stored.  The first byte stored is the length of the string, or
-255, whichever is smaller.  The bytes of the string follow.  If the string
-passed in to :func:`pack` is too long (longer than the count minus 1), only the
-leading count-1 bytes of the string are stored.  If the string is shorter than
-count-1, it is padded with null bytes so that exactly count bytes in all are
-used.  Note that for :func:`unpack`, the ``'p'`` format character consumes count
-bytes, but that the string returned can never contain more than 255 characters.
+variable-length string stored in a *fixed number of bytes*, given by the count.
+The first byte stored is the length of the string, or 255, whichever is smaller.
+The bytes of the string follow.  If the string passed in to :func:`pack` is too
+long (longer than the count minus 1), only the leading ``count-1`` bytes of the
+string are stored.  If the string is shorter than ``count-1``, it is padded with
+null bytes so that exactly count bytes in all are used.  Note that for
+:func:`unpack`, the ``'p'`` format character consumes count bytes, but that the
+string returned can never contain more than 255 characters.
 
 For the ``'P'`` format character, the return value is a Python integer or long
 integer, depending on the size needed to hold a pointer when it has been cast to
 an integer type.  A *NULL* pointer will always be returned as the Python integer
 ``0``. When packing pointer-sized values, Python integer or long integer objects
 may be used.  For example, the Alpha and Merced processors use 64-bit pointer
 values, meaning a Python long integer will be used to hold the pointer; other
 platforms use 32-bit pointers and will use a Python integer.
 
 For the ``'?'`` format character, the return value is either :const:`True` or
 :const:`False`. When packing, the truth value of the argument object is used.
 Either 0 or 1 in the native or standard bool representation will be packed, and
@@ -289,25 +305,25 @@
    (1, 2, 3)
    >>> calcsize('hhl')
    8
 
 Unpacked fields can be named by assigning them to variables or by wrapping
 the result in a named tuple::
 
     >>> record = 'raymond   \x32\x12\x08\x01\x08'
     >>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)
 
     >>> from collections import namedtuple
     >>> Student = namedtuple('Student', 'name serialnum school gradelevel')
-    >>> Student._make(unpack('<10sHHb', s))
+    >>> Student._make(unpack('<10sHHb', record))
     Student(name='raymond   ', serialnum=4658, school=264, gradelevel=8)
 
 The ordering of format characters may have an impact on size since the padding
 needed to satisfy alignment requirements is different::
 
     >>> pack('ci', '*', 0x12131415)
     '*\x00\x00\x00\x12\x13\x14\x15'
     >>> pack('ic', 0x12131415, '*')
     '\x12\x13\x14\x15*'
     >>> calcsize('ci')
     8
     >>> calcsize('ic')

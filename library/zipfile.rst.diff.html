<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>library/zipfile.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -30,24 +30,25 @@</span>
 .. exception:: BadZipfile
 
    The error raised for bad ZIP files (old name: ``zipfile.error``).
 
 
 .. exception:: LargeZipFile
 
    The error raised when a ZIP file would require ZIP64 functionality but that has
    not been enabled.
 
 
 .. class:: ZipFile
<span class="gi">+   :noindex:</span>
 
    The class for reading and writing ZIP files.  See section
    :ref:`zipfile-objects` for constructor details.
 
 
 .. class:: PyZipFile
 
    Class for creating ZIP archives containing Python libraries.
 
 
 .. class:: ZipInfo([filename[, date_time]])
 
<span class="gu">@@ -55,26 +56,28 @@</span>
    of this class are returned by the :meth:`getinfo` and :meth:`infolist`
    methods of :class:`ZipFile` objects.  Most users of the :mod:`zipfile` module
    will not need to create these, but only use those created by this
    module. *filename* should be the full name of the archive member, and
    *date_time* should be a tuple containing six fields which describe the time
    of the last modification to the file; the fields are described in section
    :ref:`zipinfo-objects`.
 
 
 .. function:: is_zipfile(filename)
 
    Returns ``True`` if *filename* is a valid ZIP file based on its magic number,
<span class="gd">-   otherwise returns ``False``.</span>
<span class="gi">+   otherwise returns ``False``.  *filename* may be a file or file-like object too.</span>
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      Support for file and file-like objects.</span>
 
 .. data:: ZIP_STORED
 
    The numeric constant for an uncompressed archive member.
 
 
 .. data:: ZIP_DEFLATED
 
    The numeric constant for the usual ZIP compression method.  This requires the
    zlib module.  No other compression methods are currently supported.
 
 
<span class="gu">@@ -91,46 +94,58 @@</span>
 
 .. _zipfile-objects:
 
 ZipFile Objects
 ---------------
 
 
 .. class:: ZipFile(file[, mode[, compression[, allowZip64]]])
 
    Open a ZIP file, where *file* can be either a path to a file (a string) or a
    file-like object.  The *mode* parameter should be ``&#39;r&#39;`` to read an existing
    file, ``&#39;w&#39;`` to truncate and write a new file, or ``&#39;a&#39;`` to append to an
<span class="gd">-   existing file.  If *mode* is ``&#39;a&#39;`` and *file* refers to an existing ZIP file,</span>
<span class="gd">-   then additional files are added to it.  If *file* does not refer to a ZIP file,</span>
<span class="gd">-   then a new ZIP archive is appended to the file.  This is meant for adding a ZIP</span>
<span class="gd">-   archive to another file, such as :file:`python.exe`.  Using ::</span>
<span class="gd">-</span>
<span class="gd">-      cat myzip.zip &gt;&gt; python.exe</span>
<span class="gd">-</span>
<span class="gd">-   also works, and at least :program:`WinZip` can read such files. If *mode* is</span>
<span class="gd">-   ``a`` and the file does not exist at all, it is created. *compression* is the</span>
<span class="gd">-   ZIP compression method to use when writing the archive, and should be</span>
<span class="gd">-   :const:`ZIP_STORED` or :const:`ZIP_DEFLATED`; unrecognized values will cause</span>
<span class="gd">-   :exc:`RuntimeError` to be raised.  If :const:`ZIP_DEFLATED` is specified but the</span>
<span class="gd">-   :mod:`zlib` module is not available, :exc:`RuntimeError` is also raised.  The</span>
<span class="gd">-   default is :const:`ZIP_STORED`.  If *allowZip64* is ``True`` zipfile will create</span>
<span class="gd">-   ZIP files that use the ZIP64 extensions when the zipfile is larger than 2 GB. If</span>
<span class="gd">-   it is  false (the default) :mod:`zipfile` will raise an exception when the ZIP</span>
<span class="gd">-   file would require ZIP64 extensions. ZIP64 extensions are disabled by default</span>
<span class="gd">-   because the default :program:`zip` and :program:`unzip` commands on Unix (the</span>
<span class="gd">-   InfoZIP utilities) don&#39;t support these extensions.</span>
<span class="gi">+   existing file.  If *mode* is ``&#39;a&#39;`` and *file* refers to an existing ZIP</span>
<span class="gi">+   file, then additional files are added to it.  If *file* does not refer to a</span>
<span class="gi">+   ZIP file, then a new ZIP archive is appended to the file.  This is meant for</span>
<span class="gi">+   adding a ZIP archive to another file (such as :file:`python.exe`).</span>
 
    .. versionchanged:: 2.6
<span class="gd">-      If the file does not exist, it is created if the mode is &#39;a&#39;.</span>
<span class="gi">+      If *mode* is ``a`` and the file does not exist at all, it is created.</span>
<span class="gi">+</span>
<span class="gi">+   *compression* is the ZIP compression method to use when writing the archive,</span>
<span class="gi">+   and should be :const:`ZIP_STORED` or :const:`ZIP_DEFLATED`; unrecognized</span>
<span class="gi">+   values will cause :exc:`RuntimeError` to be raised.  If :const:`ZIP_DEFLATED`</span>
<span class="gi">+   is specified but the :mod:`zlib` module is not available, :exc:`RuntimeError`</span>
<span class="gi">+   is also raised. The default is :const:`ZIP_STORED`.  If *allowZip64* is</span>
<span class="gi">+   ``True`` zipfile will create ZIP files that use the ZIP64 extensions when</span>
<span class="gi">+   the zipfile is larger than 2 GB. If it is  false (the default) :mod:`zipfile`</span>
<span class="gi">+   will raise an exception when the ZIP file would require ZIP64 extensions.</span>
<span class="gi">+   ZIP64 extensions are disabled by default because the default :program:`zip`</span>
<span class="gi">+   and :program:`unzip` commands on Unix (the InfoZIP utilities) don&#39;t support</span>
<span class="gi">+   these extensions.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionchanged:: 2.7.1</span>
<span class="gi">+      If the file is created with mode ``&#39;a&#39;`` or ``&#39;w&#39;`` and then</span>
<span class="gi">+      :meth:`close`\ d without adding any files to the archive, the appropriate</span>
<span class="gi">+      ZIP structures for an empty archive will be written to the file.</span>
<span class="gi">+</span>
<span class="gi">+   ZipFile is also a context manager and therefore supports the</span>
<span class="gi">+   :keyword:`with` statement.  In the example, *myzip* is closed after the</span>
<span class="gi">+   :keyword:`with` statement&#39;s suite is finished---even if an exception occurs::</span>
<span class="gi">+</span>
<span class="gi">+      with ZipFile(&#39;spam.zip&#39;, &#39;w&#39;) as myzip:</span>
<span class="gi">+          myzip.write(&#39;eggs.txt&#39;)</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+      Added the ability to use :class:`ZipFile` as a context manager.</span>
 
 
 .. method:: ZipFile.close()
 
    Close the archive file.  You must call :meth:`close` before exiting your program
    or essential records will not be written.
 
 
 .. method:: ZipFile.getinfo(name)
 
    Return a :class:`ZipInfo` object with information about the archive member
    *name*.  Calling :meth:`getinfo` for a name not currently contained in the
<span class="gu">@@ -152,26 +167,26 @@</span>
 .. method:: ZipFile.open(name[, mode[, pwd]])
 
    Extract a member from the archive as a file-like object (ZipExtFile). *name* is
    the name of the file in the archive, or a :class:`ZipInfo` object. The *mode*
    parameter, if included, must be one of the following: ``&#39;r&#39;`` (the  default),
    ``&#39;U&#39;``, or ``&#39;rU&#39;``. Choosing ``&#39;U&#39;`` or  ``&#39;rU&#39;`` will enable universal newline
    support in the read-only object. *pwd* is the password used for encrypted files.
    Calling  :meth:`open` on a closed ZipFile will raise a  :exc:`RuntimeError`.
 
    .. note::
 
       The file-like object is read-only and provides the following methods:
<span class="gd">-      :meth:`read`, :meth:`readline`, :meth:`readlines`, :meth:`__iter__`,</span>
<span class="gd">-      :meth:`next`.</span>
<span class="gi">+      :meth:`!read`, :meth:`!readline`, :meth:`!readlines`, :meth:`!__iter__`,</span>
<span class="gi">+      :meth:`!next`.</span>
 
    .. note::
 
       If the ZipFile was created by passing in a file-like object as the  first
       argument to the constructor, then the object returned by :meth:`.open` shares the
       ZipFile&#39;s file pointer.  Under these  circumstances, the object returned by
       :meth:`.open` should not  be used after any additional operations are performed
       on the  ZipFile object.  If the ZipFile was created by passing in a string (the
       filename) as the first argument to the constructor, then  :meth:`.open` will
       create a new file object that will be held by the ZipExtFile, allowing it to
       operate independently of the  ZipFile.
 
<span class="gu">@@ -263,41 +278,48 @@</span>
 
    .. note::
 
       Archive names should be relative to the archive root, that is, they should not
       start with a path separator.
 
    .. note::
 
       If ``arcname`` (or ``filename``, if ``arcname`` is  not given) contains a null
       byte, the name of the file in the archive will be truncated at the null byte.
 
 
<span class="gd">-.. method:: ZipFile.writestr(zinfo_or_arcname, bytes)</span>
<span class="gi">+.. method:: ZipFile.writestr(zinfo_or_arcname, bytes[, compress_type])</span>
 
    Write the string *bytes* to the archive; *zinfo_or_arcname* is either the file
    name it will be given in the archive, or a :class:`ZipInfo` instance.  If it&#39;s
    an instance, at least the filename, date, and time must be given.  If it&#39;s a
    name, the date and time is set to the current date and time. The archive must be
    opened with mode ``&#39;w&#39;`` or ``&#39;a&#39;`` -- calling  :meth:`writestr` on a ZipFile
    created with mode ``&#39;r&#39;``  will raise a :exc:`RuntimeError`.  Calling
    :meth:`writestr` on a closed ZipFile will raise a :exc:`RuntimeError`.
 
<span class="gi">+   If given, *compress_type* overrides the value given for the *compression*</span>
<span class="gi">+   parameter to the constructor for the new entry, or in the *zinfo_or_arcname*</span>
<span class="gi">+   (if that is a :class:`ZipInfo` instance).</span>
<span class="gi">+</span>
    .. note::
 
<span class="gd">-      When passing a :class:`ZipInfo` instance as the *zinfo_or_acrname* parameter,</span>
<span class="gi">+      When passing a :class:`ZipInfo` instance as the *zinfo_or_arcname* parameter,</span>
       the compression method used will be that specified in the *compress_type*
       member of the given :class:`ZipInfo` instance.  By default, the
       :class:`ZipInfo` constructor sets this member to :const:`ZIP_STORED`.
 
<span class="gi">+   .. versionchanged:: 2.7</span>
<span class="gi">+      The *compression_type* argument.</span>
<span class="gi">+</span>
 The following data attributes are also available:
 
 
 .. attribute:: ZipFile.debug
 
    The level of debug output to use.  This may be set from ``0`` (the default, no
    output) to ``3`` (the most output).  Debugging information is written to
    ``sys.stdout``.
 
 .. attribute:: ZipFile.comment
 
    The comment text associated with the ZIP file.  If assigning a comment to a
</pre></div>

</body>
</html>
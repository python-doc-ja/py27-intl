
.. _tut-glossary:

******
用語集
******

.. % %% keep the entries sorted and include at least one \index{} item for each
.. % %% cross-references are marked with \emph{entry}

``>>>``
   典型的な対話シェルのプロンプトです。インタプリタ上ですぐ実行できる ようなプログラムコード例の中によく書かれています。

   .. index:: single: ...

``...``
   典型的な対話シェルのプロンプトです。インデントされたコードブロック 内のコードの入力を促す際に出力されます。

   .. index:: single: __future__

__future__
   互換性のない新たな機能を現在のインタプリタで有効にするために プログラマが利用できる擬似モジュールです。例えば、式 ``11/4``  は現状では ``2``
   になります。この式を実行しているモジュールで ::

      from __future__ import division

   を行って *真の除算操作 (true division)* を有効にすると、 式 ``11/4`` は ``2.75`` になります。実際に
   :mod:`__future__` (XXX reference: ../lib/module-future.html) モジュールを import
   してその変数を評価すれば、新たな機能が初めて追加されたのが いつで、いつデフォルトの機能になる予定かわかります::

      >>> import __future__
      >>> __future__.division
      _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)

   .. index:: single: __slots__

__slots__
   新スタイルクラス内で、インスタンス属性の記憶に必要な領域を あらかじめ定義しておき、それとひきかえにインスタンス辞書を
   排除してメモリの節約を行うための宣言です。これはよく使われる テクニックですが、正しく動作させるのには少々手際を要するので、
   例えばメモリが死活問題となるようなアプリケーション内に インスタンスが大量に存在するといった稀なケースを除き、 使わないのがベストです。

   .. index:: single: BDFL

BDFL
   慈悲ぶかき独裁者 (Benevolent Dictator For Life) の略です。 Python の作者、 `Guido van Rossum
   <http://www.python.org/~guido/>`_ のことです。

   .. index:: single: puck-typing

duck-typing
   Python 的なプログラムスタイルではオブジェクトの型を（型オブジェクトと の関係ではなく）メソッドや属性といったシグネチャを見ることで判断します。
   （「もしそれがガチョウのようにみえて、ガチョウのように鳴けば、それはガ チョウである」） インタフェースを型より重視することで、上手くデザインされたコードは
   (polymorphicな置換を許可することによって)柔軟性を増すことができます。 duck-typing は :func:`type` や
   :func:`isinstance`を避けます。 その代わりに :func:`hasattr` テストや *EAFP* プログラミング を利用します。

   .. index:: single: EAFP

EAFP
   「認可をとるより許しを請う方が容易  (easier to ask for forgiveness than permission、マーフィーの法則)」
   の略です。 Python で広く使われているコーディングスタイルでは、通常は有効な キーや属性が存在するものと仮定し、その仮定が誤っていた場合に例外を
   捕捉します。この簡潔で手早く書けるコーディングスタイルには、 :keyword:`try` 文および :keyword:`except` 文がたくさん
   あるのが特徴です。このテクニックは、C のような言語でよく使われている *LBYL* スタイルと対照的なものです。

   .. index:: single: GIL

GIL
   *グローバルインタプリタロック (global interpreter lock)*  を参照してください。

   .. index:: single: IDLE

IDLE
   Python の組み込み開発環境 (Integrated DeveLopment Environment) です。IDLE は Python
   の標準的な配布物についてくる基本的な機能の エディタとインタプリタ環境です。初心者に向いている点として、 IDLE
   はよく洗練され、複数プラットフォームで動作する GUI  アプリケーションを実装したい人むけの明解なコード例にもなっています。

   .. index:: single: Python3000

Python3000
   テレパシーインタフェースを持ち、後方互換性をもたなくてもよいとされて いる、架空の Python リリースのことです。

   .. index:: single: Zen of Python

Python の悟り (Zen of Python)
   Python を理解し利用する上での導きとなる、Python の設計原則と哲学を リストにしたものです。対話プロンプトで "``import this``"
   とすると、 リストを読めます。

   .. index:: single: iterator

イテレータ (iterator)
   一連のデータ列 (stream) を表現するオブジェクトです。 イテレータの :meth:`next` メソッドを繰り返し呼び出すと、
   データ列中の要素を一つづつ返します。後続のデータがなくなると、 データの代わりに :exc:`StopIteration` 例外を送出します。
   現時点では、イテレータオブジェクトが全てのオブジェクトを出し尽くすと、 それ以降は :meth:`next` を何度呼んでも
   :exc:`StopIteration`  を送出します。イテレータは、イテレータオブジェクト自体を返す :meth:`__iter__`
   メソッドを実装しなければならなくなっており、 そのため全てのイテレータは他の反復可能オブジェクトを受理できる ほとんどの場所で反復可能で利用できます。
   著しい例外は複数の反復を行うようなコードです。(:class:`list` のような) コンテナオブジェクトでは、:func:`iter` 関数にオブジェクトを
   渡したり、:keyword:`for` ループ内で使うたびに、新たな未使用の イテレータを生成します。
   このイテレータをさらに別の場所でイテレータとして使おうとすると、 前回のイテレーションパスで使用された同じイテレータオブジェクトを返す
   ため、空のコンテナのように見えます。

   .. index:: single: interpreted

インタプリタ形式の (interpreted)
   Python はインタプリタ形式の言語であり、コンパイラ言語の対極に位置します。 ここでのインタプリタ言語とは、ソースコードのファイルを、
   まず実行可能形式にしてから実行させるといった操作なしに、直接 実行できることを意味します。インタプリタ形式の言語は通常、
   コンパイラ形式の言語よりも開発／デバッグのサイクルは短いものの、プログ ラムの実行は一般に遅いです。 *対話的 (interactive)*
   も参照してください。

   .. index:: single: coercion

型強制 (coercion)
   同じ型の2つの引数を要する演算の最中に、ある型のインスタンスを別の型に 暗黙のうちに変換することです。 例えば、 ``int(3.15)``
   は浮動小数点数を整数の ``3`` にしま す。しかし、``3+4.5``の場合、各引数は型が異なっていて(一つは整数、
   一つは浮動小数点数)、加算をする前に同じ型に変換しなければいけません。 そうでないと、 ``TypeError`` 例外が投げられます。
   2つの被演算子間の型強制は組み込み関数の ``coerce`` を使って行えます。 従って、``3+4.5`` は
   ``operator.add(*coerce(3, 4.5))``を呼び 出すことに等しく、``operator.add(3.0, 4.5)``
   という結果になりま す。 型強制を行わない場合、たとえ互換性のある型であっても、すべての引数はプ ログラマーが、単に ``3+4.5`` とするのではなく、
   ``float(3)+4.5``というように、同じ型に正規化しなければいけません。

   .. index:: single: classic class

旧スタイルクラス (classic class)
   :class:`object` を継承していないクラス全てを指します。 *新スタイルクラス (new-style class)* も参照してください。

   .. index:: single: global interpreter lock

グローバルインタプリタロック (global interpreter lock)
   Python の実行スレッド間で使われているロックで、一度に一つのスレッド だけが動作するよう保証しています。このロックによって、同時に同じ
   メモリにアクセスする二つのプロセスは存在しないと保証されているので、 Python を単純な構造にできるのです。インタプリタ全体にロックをかけると、
   多重プロセサ計算機における並列性の恩恵と引き換えにインタプリタ の多重スレッド化を簡単に行えます。かつて "スレッド自由な (free-threaded)"
   インタプリタを作ろうと 努力したことがありましたが、広く使われている単一プロセサ の場合にはパフォーマンスが低下するという事態に悩まされました。

   .. index:: single: generator

ジェネレータ (generator)
   イテレータを返す関数です。:keyword:`return` 文の代わりに :keyword:`yield`
   文を使って呼び出し側に要素を返す他は、通常の関数と同じ に見えます。

   ジェネレータ関数は 一つまたはそれ以上の :keyword:`for` ループや :keyword:`while` ループ
   を含んでおり、ループの呼び出し側に要素を返す (:keyword:`yield`) ように なっています。ジェネレータが返すイテレータを使って関数を実行すると、
   関数は :keyword:`yield` キーワードで (値を返して) 一旦停止し、 :meth:`next`
   を呼んで次の要素を要求するたびに実行を再開します。

   .. index:: single: generator expression

ジェネレータ表現 (generator expression)
   ジェネレータを返す式です。 普通の式に続いてループ変数、範囲を定義している :keyword:`for` 式と場合 によっては :keyword:`if`
   式があるように見えます。 式を組み合わせると、内部関数の値を生成します。 ::

      >>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81
      285

   .. index:: single: dictionary

辞書 (dictionary)
   任意のキーを値に対応付ける連想配列です。:class:`dict` の使い方は :class:`list` に似ていますが、ゼロから始まる整数ではなく、
   :meth:`__hash__` 関数を実装している全てのオブジェクトを キーにできます。Perl ではハッシュ (hash) と呼ばれています。

   .. index:: single: new-style class

新スタイルクラス (new-style class)
   :class:`object` から継承したクラス全てを指します。これには :class:`list` や :class:`dict`
   のような全ての組み込み型が含まれます。 :meth:`__slots__` 、デスクリプタ、プロパティ、
   :meth:`__getattribute__`、クラスメソッド、静的メソッドといった、 Python の新しい精緻な機能を使えるのは新スタイルクラスだけです。

   .. index:: single: integer division

整数除算 (integer division)
   剰余を考慮しない数学的除算です。例えば、式 ``11/4`` は現状では ``2`` になりますが、浮動小数点数の除算では ``2.75`` を返します。
   *切り捨て除算 (floor division)* とも呼ばれます。 二つの整数間で除算を行うと、結果は (端数切捨て関数が適用されて)  常に整数になります。
   しかし、被演算子の一方が (:class:`float` のような) 別の数値型の 場合、演算の結果は共通の型に型強制されます (*型強制
   (coercion)* 参照)。例えば、浮動小数点数で整数を除算すると 結果は浮動小数点になり、場合によっては端数部分を伴います。 ``//`` 演算子を
   ``/`` の代わりに使うと、整数除算を 強制できます。*__future__* も参照してください。

   .. index:: single: interactive

対話的 (interactive)
   Python には対話的インタプリタがあり、何かを試してその結果を直接 見られます。``python`` を引数なしで起動 (場合によっては
   コンピュータのメインメニューから選んで起動) してください。 対話的インタプリタは新しいアイデアを試したり、モジュールや パッケージの中を調べてみたりする
   (``help(x)`` を思い出してください) ための強力な方法です。

   .. index:: single: descriptor

デスクリプタ (descriptor)
   メソッド :meth:`__get__`、 :meth:`__set__`、あるいは :meth:`__delete__` が定義されている *新スタイル*
   のオブジェクトです。 あるクラス属性がデスクリプタである場合、その属性を検索すると、 そのデスクリプタ固有に束縛されている動作を呼び出します。通常、 *a.b*
   と書くと、*a* のクラス辞書内でオブジェクト *b* を検索しますが、*b* がデスクリプタの場合には、デスクリプタで 定義されたメソッドを呼び出します。
   デスクリプタの理解は、 Python を深く理解する上で鍵となります。 というのは、デスクリプタこそが、関数、メソッド、プロパティ、
   クラスメソッド、静的メソッド、そしてスーパクラスの参照といった 多くの機能の基盤だからです。

   .. index:: single: namespace

名前空間 (namespace)
   変数を記憶している場所です。名前空間は複数の辞書を用いて実装しています。 名前空間には、ローカル、グローバル、組み込み名前空間、そして (メソッド内の)
   オブジェクトのネストされた名前空間があります。 例えば、関数 :func:`__builtin__.open` および :func:`os.open`
   は名前空間で区別します。名前空間はまた、ある関数をどのモジュールが 実装しているかをはっきりさせることで、可読性やメンテナンス性を
   与えます。例えば、:func:`random.seed` 、あるいは :func:`itertools.izip` と書くことで、これらの関数がそれぞれ
   :mod:`random` (XXX reference: ../lib/module-random.html) モジュールや :mod:`itertools`
   (XXX reference: ../lib/module-itertools.html)  モジュールで実装されていることがはっきりします。

   .. index:: single: nested scope

ネストされたスコープ (nested scope)
   ある文が何らかの定義に囲われているとき、定義の外で使われている変数を その文から参照できる機能です。例えば、ある関数が別の関数の中で定義
   されている場合、内側の関数は外側の関数中の変数を参照できます。 ネストされたスコープは変数の参照だけができ、変数の代入はできないので
   注意してください。変数の代入は、常に最も内側のスコープにある変数に 対する書き込みになります。
   対照的に、ローカル変数を使うと、常に最も内側のスコープで値を読み書き します。同様に、グローバル変数を使うと、グローバル名前空間の値を 読み書きします。

   .. index:: single: byte code

バイトコード (byte code)
   インタプリタ中の Python プログラムを表す内部表現です。 バイトコードはまた、 ``.pyc`` や ``.pyo`` ファイルに
   キャッシュされ、同じファイルを二度目に実行した際により高速に 実行できるようにします (ソースコードはバイトコードにコンパイルされて
   保存されます)。このバイトコードは、各々のバイトコードに 対応するサブルーチンを呼び出すような "仮想計算機 (virtual machine)"  で動作する
   "中間言語 (intermediate language)" といえます。

   .. index:: single: sequence

シーケンス (sequence)
   *反復可能なオブジェクト (iterable)* は、 特殊なメソッド :meth:`__getitem__` および :meth:`__len__` を
   介して整数インデクスを使った効率的な要素アクセスをサポートします。  組み込みシーケンス型には、:class:`list`、:class:`str`、
   :class:`tuple`、 および :class:`unicode` があります。 :class:`dict` は :meth:`__getitem__`
   と :meth:`__len__` もサポートしますが、検索の際に任意の *変更不能 (immutable)* な
   キーを使うため、シーケンスというよりもむしろマップ (mapping) とみなされて いるので注意してください。

   .. index:: single: iterable

反復可能オブジェクト (iterable)
   コンテナオブジェクトで、コンテナ内のメンバを一つづつ返せる ようになっているものです。反復可能オブジェクトの例には、
   (:class:`list`、:class:`str`、および :class:`tuple` といった)  全てのシーケンス型や、:class:`dict` や
   :class:`file` といった 非シーケンス型、あるいは :meth:`__iter__` や :meth:`__getitem__`
   メソッドを実装したクラスのインスタンスが含まれます。 反復可能オブジェクトは :keyword:`for` ループ内やその他多くの シーケンスが必要となる状況
   (:func:`zip`、 :func:`map`, ...) で利用できます。反復可能オブジェクトを組み込み関数 :func:`iter`
   の引数として渡すと、オブジェクトに対する イテレータを返します。このイテレータは一連の値を引き渡す際に便利
   です。反復可能オブジェクトを使う際には、通常:func:`iter`  を呼んだり、イテレータオブジェクトを自分で扱う必要はありません。 ``for``
   文ではこの操作を自動的に行い、無名の変数を作成して、 ループの間イテレータを記憶します。 *イテレータ (iterator)*、 *シーケンス
   (sequence)*、および *ジェネレータ (generator)* も参照してください。

   .. index:: single: complex number

複素数 (complex number)
   よく知られている実数系を拡張したもので、すべての数は実部と虚部の和とし て表されます。

   虚数は虚数単位元(``-1`` の平方根)に実数を掛けたもので、一般に 数学では ``i`` と書かれ、工業では ``j`` と書かれます。Python
   は複素数に組込みで対応し、後者の表記を取っています。

   虚部は末尾に ``j`` をつけて書きます。 ``3+1j`` 。 :mod:`math` モジュールの複素数版を利用するには、:mod:`cmath`を
   使います。

   複素数の使用はかなり高度な数学の機能です。 必要性を感じなければ、ほぼ間違いなく無視してしまってよいでしょう。

   .. index:: single: mutable

変更可能なオブジェクト (mutable)
   変更可能なオブジェクトは、:func:`id` を変えることなく値を変更 できます。 *変更不能 (immutable)* も参照してください。

   .. index:: single: immutable

変更不能なオブジェクト (immutable)
   固定の値を持ったオブジェクトです。変更不能なオブジェクトには、 数値、文字列、およびタプル (そしてその他) があります。これらの
   オブジェクトは値を変えられません。別の値を記憶させる際には、 新たなオブジェクトを作成しなければなりません。変更不能なオブジェクト
   は、固定値のハッシュ値が必要となる状況で重要な役割を果たします。 辞書におけるキーがその例です。

   .. index:: single: mapping

マップ (mapping)
   特殊メソッド :meth:`__getitem__` を使って、任意のキーに対する検索を サポートする (:class:`dict` のような)
   コンテナオブジェクトです。

   .. index:: single: metaclass

メタクラス (metaclass)
   何らかのクラスを生成するクラスです。クラス定義を行うと、クラス名、 クラス辞書、そして基底クラスからなるリストが生成されます。
   メタクラスはこれらの三つを引数として取り、メタクラスを生成する 働きをします。ほとんどのオブジェクト指向プログラム言語には、
   メタクラスに対するデフォルトの実装があります。Python の特徴的な点は、 自作のメタクラスを作成できることです。ほとんどのユーザにとって、
   このツールはまったく必要のないものですが、必要さえあれば、メタクラスは 強力でエレガントな問題解決手段になります。メタクラスは、属性への
   アクセスをログに記録したり、システムをスレッド安全にしたり、 オブジェクトの生成の追跡したり、単集合を実装したり、そしてその他
   多くのタスクで使われてきています。

   .. index:: single: LBYL

LBYL
   「ころばぬ先の杖」 (look before you leap) の略です。 このコーディングスタイルでは、呼び出しや検索を行う前に、明示的に 前提条件
   (pre-condition) 判定を行います。 *EAFP* アプローチと対照的で、:keyword:`if` 文がたくさん使われる のが特徴的です。

   .. index:: single: list comprehension

リストの内包表現 (list comprehension)
   シーケンス内の全ての要素、あるいはサブセットを処理してその結果からなる リストを返させるための、コンパクトなやりかたです。 ``result =
   ["0x%02x" % x for x in range(256) if x % 2 == 0]``  とすると、 0 から 255 までの偶数を 16進数表記
   (0x..) した 文字列からなるリストを生成します。 :keyword:`if` 節はオプションです。:keyword:`if` 節がない場合、
   ``range(256)`` の全ての要素が処理されます。


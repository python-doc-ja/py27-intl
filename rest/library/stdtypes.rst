
.. _types:

*****
組み込み型
*****

以下のセクションでは、インタプリタに組み込まれている標準の型に ついて記述します。

.. note::

   これまでの(リリース 2.2 までの) Python の歴史では、組み込み型は オブジェクト指向における継承を行う際に雛型にできないという点で、
   ユーザ定義型とは異なっていました。いまではこのような制限はなくなっています。

.. index:: pair: built-in; types

主要な組み込み型は数値型、シーケンス型、マッピング型、ファイル、クラス、 インスタンス型、および例外です。

.. index:: statement: print

演算によっては、複数の型でサポートされているものがあります; 特に、ほぼ全てのオブジェクトについて、比較、真値テスト、 (:func:`repr`
関数や、わずかに異なる :func:`str` 関数 による) 文字列への 変換を行うことができます。オブジェクトが:keyword:`print`
によって書かれていると、後の方の文字列への変換が暗黙に行われます (Information on :keyword:`print` 文 (XXX
reference: ../ref/print.html) やその他の文に関する情報は Python リファレンスマニュアル (XXX reference:
../ref/ref.html) および Python チュートリアル (XXX reference: ../tut/tut.html)
で見つけることができます。)


.. _truth:

真値テスト
=====

.. index::
   statement: if
   statement: while
   pair: truth; value
   pair: Boolean; operations
   single: false

どのオブジェクトも :keyword:`if` または :keyword:`while` 条件文の中や、
以下のブール演算における被演算子として真値テストを行うことができます。 以下の値は偽であると見なされます:

  .. index:: single: None (Built-in object)

* ``None``

  .. index:: single: False (Built-in object)

* ``False``

* 数値型におけるゼロ。例えば ``0`` 、 ``0L`` 、 ``0.0`` 、 ``0j`` 。

* 空のシーケンス型。例えば ``''`` 、 ``()`` 、 ``[]`` 。

* 空のマッピング型。例えば ``{}`` 。

* :meth:`__nonzero__` または :meth:`__len__` メソッドが
  定義されているようなユーザ定義クラスのインスタンスで、それらのメソッド が整数値ゼロまたは :class:`bool` 値の ``False`` を返すとき。
  [#]_

.. index:: single: true

それ以外の値は全て真であると見なされます --- 従って、ほとんどの型 のオブジェクトは常に真です。

.. index::
   operator: or
   operator: and
   single: False
   single: True

ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に 偽値として ``0`` または``False`` を返し、真値として ``1``  または
``True`` を返します (重要な例外: ブール演算 ``or`` および ``and`` は常に被演算子 の中の一つを返します)。


.. _boolean:

ブール演算 --- :keyword:`and`, :keyword:`or`, :keyword:`not`
=======================================================

.. index:: pair: Boolean; operations

以下にブール演算子を示します。優先度の低いものから順に並んでいます。:

+-------------+----------------------------+------+
| 演算          | 結果                         | 注釈   |
+=============+============================+======+
| ``x or y``  | *x* が偽なら *y* 、そうでなければ *x*  | \(1) |
+-------------+----------------------------+------+
| ``x and y`` | *x* が偽なら *x* 、そうでなければ *y*  | \(1) |
+-------------+----------------------------+------+
| ``not x``   | *x* が偽なら ``True`` 、そうでなければ | \(2) |
|             | ``False``                  |      |
+-------------+----------------------------+------+

.. index::
   operator: and
   operator: or
   operator: not

注釈:

(1)
   これらの演算子は、演算を行う上で必要がない限り、二つ目の引数を評価しません。

(2)
   ``not`` は非ブール演算子よりも低い演算優先度なので、 ``not a == b`` は ``not (a == b)``  と評価され、 ``a ==
   not b`` は構文エラーとなります。


.. _comparisons:

比較
==

.. index:: pair: chaining; comparisons

比較演算は全てのオブジェクトでサポートされています。比較演算子は 全て同じ演算優先度を持っています (ブール演算より高い演算優先度です)。
比較は任意の形で連鎖させることができます; 例えば、``x < y <= z`` は ``x < y および  y <= z`` と等価で、違うのは *y*
が一度だけしか評価 されないということです (どちらの場合でも、  ``x < y`` が偽となった場合には *z* は評価されません) 。

以下のテーブルに比較演算をまとめます:

+------------+--------------+------+
| 演算         | 意味           | 注釈   |
+============+==============+======+
| ``<``      | より小さい        |      |
+------------+--------------+------+
| ``<=``     | 以下           |      |
+------------+--------------+------+
| ``>``      | より大きい        |      |
+------------+--------------+------+
| ``>=``     | 以上           |      |
+------------+--------------+------+
| ``==``     | 等しい          |      |
+------------+--------------+------+
| ``!=``     | 等しくない        | \(1) |
+------------+--------------+------+
| ``<>``     | 等しくない        | \(1) |
+------------+--------------+------+
| ``is``     | 同一のオブジェクトである |      |
+------------+--------------+------+
| ``is not`` | 同一のオブジェクトでない |      |
+------------+--------------+------+

.. index::
   pair: operator; comparison
   operator: ==
   operator: is
   operator: is not

.. % XXX *All* others have funny characters < ! >

注釈:

(1)
   ``<>`` および ``!=`` は同じ演算子を別の書き方にしたものです。 ``!=`` のほうが望ましい書き方です; ``<>`` は廃止すべき書き方です。

.. index::
   pair: object; numeric
   pair: objects; comparing

数値型間の比較か文字列間の比較でないかぎり、異なる型のオブジェクトを 比較しても等価になることはありません; これらのオブジェクトの順番付けは
一貫してはいますが任意のものです (従って要素の型が一様でないシーケンスを ソートした結果は一貫したものになります)。
さらに、(例えばファイルオブジェクトのように) 型によっては、 その型の 2 つのオブジェクトの不等性だけの、縮退した比較の概念
しかサポートしないものもあります。繰り返しますが、 そのようなオブジェクトも任意の順番付けをされていますが、
それは一貫したものです。被演算子が複素数の場合、演算子 ``<`` 、 ``<=`` 、 ``>`` および ``>=`` は 例外
:exc:`TypeError` を送出します。

.. index:: single: __cmp__() (instance method)

あるクラスのインスタンス間の比較は、そのクラスで :meth:`__cmp__` メソッドが定義されていない限り等しくなりません。
このメソッドを使ってオブジェクトの比較方法に影響を及ぼすための 情報については Python リファレンスマニュアル (XXX reference:
../ref/customization.html)  を参照してください。

**実装に関する注釈:** 数値型を除き、異なる型のオブジェクトは 型の名前で順番付けされます; 適当な比較をサポートしていないある型の
オブジェクトはアドレスによって順番付けされます。

.. index::
   operator: in
   operator: not in

同じ優先度を持つ演算子としてさらに 2 つ、シーケンス型でのみ ``in`` および ``not in`` が サポートされています (以下を参照)。


.. _typesnumeric:

数値型 :class:`int`, :class:`float`, :class:`long`, :class:`complex`
=================================================================

4 つの異なる数値型があります: :dfn:`通常の整数型` 、 :dfn:`長整数型` 、:dfn:`浮動小数点型` 、および :dfn:`複素数型` です。

.. index::
   object: numeric
   object: Boolean
   object: integer
   object: long integer
   object: floating point
   object: complex number
   pair: C; language

さらに、ブール方は通常の整数型のサブタイプです。通常の整数 (単に :dfn:`整数型` とも呼ばれます) は C では :ctype:`long` を
使って実装されており、少なくとも 32 ビットの精度があります (``sys.maxint`` は常に通常の整数の各プラットフォームにおける
最大値にセットされており、最小値は ``-sys.maxint - 1`` になります)。 長整数型には精度の制限がありません。浮動小数点型は C では
:ctype:`double` を使って実装されています。しかし使っている計算機 が何であるか分からないなら、これらの数値型の精度に関して断言はできません。

複素数型は実数部と虚数部を持ち、それぞれの C では :ctype:`double` を 使って実装されています。複素数 *z* から実数および虚数部を取り出す
には、``z.real`` および ``z.imag`` を使います。

数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。 修飾のない整数リテラル (16 進表現や 8 進表現の値も含みます) は、
通常の整数値を表します。値が通常の整数で表すには大きすぎる場合、 ``'L'`` または ``'l'`` が末尾につく整数リテラル は長整数型を表します
(``'L'`` が望ましいです。というのは ``1l`` は 11 と非常に紛らわしいからです！) 小数点または
指数表記のある数値リテラルは浮動小数点数を表します。 数値リテラルに ``'j'`` または ``'J'`` をつけると
実数部がゼロの複素数を表します。複素数の数値リテラルは実数部と 虚数部を足したものです。

.. index::
   pair: numeric; literals
   pair: integer; literals
   triple: long; integer; literals
   pair: floating point; literals
   pair: complex number; literals
   pair: hexadecimal; literals
   pair: octal; literals

.. index::
   single: arithmetic
   builtin: int
   builtin: long
   builtin: float
   builtin: complex

Python は型混合の演算を完全にサポートします: ある 2 項演算子が 互いに異なる数値型の被演算子を持つ場合、より "制限された" 型の
被演算子は他方の型に合わせて広げられます。ここで通常の整数は 長整数より制限されており、長整数は浮動小数点数より制限されており、
浮動小数点は複素数より制限されています。 型混合の数値間での比較も同じ規則に従います。  [#]_ コンストラクタ :func:`int`
、:func:`long` 、:func:`float`、 および :func:`complex` を使って、特定の型の数を生成することが できます。

全ての数値型（complex は例外）は以下の演算をサポートします。これらの演算は 優先度の低いものから順に並べられています (同じボックスにある演算は
同じ優先度を持っています; 全ての数値演算は比較演算よりも 高い優先度を持っています):

+--------------------+-------------------------------+------+
| 演算                 | 結果                            | 注釈   |
+====================+===============================+======+
| ``x + y``          | *x* と *y* の和                  |      |
+--------------------+-------------------------------+------+
| ``x - y``          | *x* と *y* の差                  |      |
+--------------------+-------------------------------+------+
| ``x * y``          | *x* と *y* の積                  |      |
+--------------------+-------------------------------+------+
| ``x / y``          | *x* と *y* の商                  | \(1) |
+--------------------+-------------------------------+------+
| ``x // y``         | *x* と *y* の商(を切り下げたもの)        | \(5) |
+--------------------+-------------------------------+------+
| ``x % y``          | ``x / y`` の剰余                 | \(4) |
+--------------------+-------------------------------+------+
| ``-x``             | *x* の符号反転                     |      |
+--------------------+-------------------------------+------+
| ``+x``             | *x* の符号不変                     |      |
+--------------------+-------------------------------+------+
| ``abs(x)``         | *x* の絶対値または大きさ                |      |
+--------------------+-------------------------------+------+
| ``int(x)``         | *x* の通常整数への変換                 | \(2) |
+--------------------+-------------------------------+------+
| ``long(x)``        | *x* の長整数への変換                  | \(2) |
+--------------------+-------------------------------+------+
| ``float(x)``       | *x* の浮動小数点数への変換               |      |
+--------------------+-------------------------------+------+
| ``complex(re,im)`` | 実数部 *re* 、虚数部 *im* の複素数。 *im* |      |
|                    | のデフォルト値はゼロ。                   |      |
+--------------------+-------------------------------+------+
| ``c.conjugate()``  | 複素数 *c* の共役複素数                |      |
+--------------------+-------------------------------+------+
| ``divmod(x, y)``   | ``(x // y, x % y)`` からなるペア    | \(3) |
+--------------------+-------------------------------+------+
| ``pow(x, y)``      | *x* の *y* 乗                   |      |
+--------------------+-------------------------------+------+
| ``x ** y``         | *x* の *y* 乗                   |      |
+--------------------+-------------------------------+------+

.. index::
   triple: operations on; numeric; types
   single: conjugate() (complex number method)

注釈:

(1)
   .. index::
      pair: integer; division
      triple: long; integer; division

   (通常および長) 整数の割り算では、結果は整数になります。 この場合値は常にマイナス無限大の方向に丸められます: つまり、1/2 は 0、 (-1)/2 は
   -1、1/(-1) は -1、そして (-1)/(-2) は 0 になります。 被演算子の両方が長整数の場合、計算値に関わらず結果は長整数で返される
   ので注意してください。

(2)
   .. index::
      module: math
      single: floor() (in module math)
      single: ceil() (in module math)
      pair: numeric; conversions
      pair: C; language

   浮動小数点数から (通常または長) 整数への変換では、C におけるのと同様の 値の丸めまたは切り詰めが行われるかもしれません; きちんと定義された
   変換については、:mod:`math`  モジュールの :func:`floor` および :func:`ceil` を参照してください。

(3)
   完全な記述については、:ref:`built-in-funcs`、"組み込み関数"  を参照してください。

(4)
   複素数の切り詰め除算演算子、モジュロ演算子、および :func:`divmod`。

   .. deprecated:: 2.3
      適切であれば、:func:`abs` を使って浮動小数点に変換してください。

(5)
   整数の除算とも呼ばれます。結果の値は整数ですが、整数型(int)とは限りません。

.. % XXXJH exceptions: overflow (when? what operations?) zerodivision


.. _bitstring-ops:

整数型におけるビット列演算
-------------

.. _bit-string operations:

通常および長整数型ではさらに、ビット列に対してのみ意味のある 演算をサポートしています。負の数はその値の 2 の補数の値として扱われます
(長整数の場合、演算操作中にオーバフローが起こらないように十分なビット数 があるものと仮定します) 。

2 進のビット単位演算は全て、数値演算よりも低く、比較演算子よりも高い 優先度です; 単項演算 ```` は他の単項数値演算 (``\ +``および``\
-``) と同じ優先度です。

以下のテーブルでは、ビット列演算を優先度の低いものから順に並べています (同じボックス内の演算は同じ優先度です):

+------------+-------------------------------+----------+
| 演算         | 結果                            | 注釈       |
+============+===============================+==========+
| ``x | y``  | ビット単位の *x* と *y* の :dfn:`論理和` |          |
+------------+-------------------------------+----------+
| ``x ^ y``  | ビット単位の *x* と *y* の            |          |
|            | :dfn:`排他的論理和`                 |          |
+------------+-------------------------------+----------+
| ``x & y``  | ビット単位の *x* と *y* の :dfn:`論理積` |          |
+------------+-------------------------------+----------+
| ``x << n`` | *x* の *n* ビット左シフト             | (1), (2) |
+------------+-------------------------------+----------+
| ``x >> n`` | *x* の *n* ビット右シフト             | (1), (3) |
+------------+-------------------------------+----------+
| ``~x``     | *x* のビット反転                    |          |
+------------+-------------------------------+----------+

.. index::
   triple: operations on; integer; types
   pair: bit-string; operations
   pair: shifting; operations
   pair: masking; operations

注釈:

(1)
   負値のシフト数は不正であり、:exc:`ValueError` が送出 されます。

(2)
   *n* ビットの左シフトは、オーバフローチェックを行わない ``pow(2, n)`` による乗算と等価です。

(3)
   *n* ビットの右シフトは、オーバフローチェックを行わない ``pow(2, n)`` による除算と等価です。


.. _typeiter:

イテレータ型
======

.. versionadded:: 2.2

.. index::
   single: iterator protocol
   single: protocol; iterator
   single: sequence; iteration
   single: container; iteration over

Python はコンテナの内容にわたって反復処理を行う概念をサポートして います。この概念は 2 つの別々のメソッドを使って実装されています;
これらのメソッドはユーザ定義のクラスで反復を行えるようにするために 使われます。後に詳しく述べるシーケンス型はすべて反復処理メソッドを サポートしています。

以下はコンテナオブジェクトに反復処理をサポートさせるために定義しなければ ならないメソッドです:


.. method:: container.__iter__()

   イテレータオブジェクトを返します。イテレータオブジェクトは以下で述べる イテレータプロトコルをサポートする必要があります。あるコンテナが
   異なる形式の反復処理をサポートする場合、それらの反復処理形式 のイテレータを特定的に要求するようなメソッドを追加することができます
   (複数の形式での反復処理をサポートするようなオブジェクトとして 木構造の例があります。木構造は幅優先走査と深さ優先走査の両方を サポートします)。
   このメソッドは Python/C API において Python オブジェクトを表す 型構造体の :attr:`tp_iter` スロットに対応します。

イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要 があります。これらのメソッドは 2 つ合わせて :dfn:`イテレータプロトコル`
を成します:


.. method:: iterator.__iter__()

   イテレータオブジェクト自体を返します。このメソッドはコンテナとイテレータの 両方を:keyword:`for` および :keyword:`in`
   文で使えるようにするために 必要です。このメソッドは Python/C API において Python オブジェクトを表す 型構造体の
   :attr:`tp_iter` スロットに対応します。


.. method:: iterator.next()

   コンテナ内の次の要素を返します。もう要素が残っていない場合、 例外 :exc:`StopIteration` を送出します。このメソッドは Python/C
   API において Python オブジェクトを表す型構造体の  :attr:`tp_iternext` スロットに対応します。

Python では、いくつかのイテレータオブジェクトを定義しています。これらは 一般的および特殊化されたシーケンス型、辞書型、そして他のさらに特殊化
された形式をサポートします。特殊型であることはイテレータプロトコル の実装が特殊になること以外は重要なことではありません。

このプロトコルの趣旨は、 一度イテレータの :meth:`next` メソッドが :exc:`StopIteration`
例外を送出した場合、以降の呼び出しでもずっと例外を送出しつづける ところにあります。この特性に従わないような実装は変則であると みなされます (この制限は
Python 2.3 で追加されました; Python 2.2 では、この規則に従うと多くのイテレータが変則となります)。

Python におけるジェネレータ (generator) は、イテレータプロトコル を実装する簡便な方法を提供します。コンテナオブジェクトの
:meth:`__iter__` メソッドがジェネレータとして実装されて いれば、メソッドは :meth:`__iter__` および :meth:`next`
メソッドを提供するイテレータオブジェクト (技術的にはジェネレータ オブジェクト) を自動的に返します。


.. _typesseq:

シーケンス型 :class:`str`, :class:`unicode`, :class:`list`, :class:`tuple`, :class:`buffer`, :class:`xrange`
======================================================================================================

組み込み型には 6 つのシーケンス型があります: 文字列、ユニコード文字列、 リスト、タプル、バッファ、そして xrange オブジェクトです。

.. index::
   object: sequence
   object: string
   object: Unicode
   object: tuple
   object: list

文字列リテラルは ``'xyzzy'``、``"frobozz"`` といったように、 単引用符または二重引用符の中に書かれます。
文字列リテラルについての詳細はは、 Python リファレンスマニュアル (XXX reference: ../ref/strings.html) の第 2
章を読んで下さい。 Unicode 文字列はほとんど文字列と同じですが、``u'abc'`` 、 ``u"def"`` といったように先頭に文字 ``'u'``
を付けて 指定します。 リストは ``[a, b, c]`` のように要素をコンマで区切り角括弧で 囲って生成します。タプルは ``a, b, c``
のようにコンマ演算子で 区切って生成します (角括弧の中には入れません)。 丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは  ``()``
のように丸括弧で囲わなければなりません。 要素が一つのタプルでは、例えば ``(d,)`` のように、要素の後ろに コンマをつけなければなりません。

.. index::
   builtin: buffer
   object: buffer

バッファオブジェクトは Python の構文上では直接サポートされていませんが、 組み込み関数 :func:`buffer`
で生成することができます。バッファオブジェクトは結合や反復をサポート していません。

.. index::
   builtin: xrange
   object: xrange

xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない 点でバッファに似ていて、関数 :func:`xrange` で生成します。
xrange オブジェクトはスライス、結合、反復をサポートせず、 ``in`` 、 ``not in`` 、:func:`min` または
:func:`max`  は効率的ではありません。

ほとんどのシーケンス型は以下の演算操作をサポートします。``in`` および  ``not in`` は比較演算とおなじ優先度を持っています。 ``+``
および ``*`` は対応する数値演算とおなじ優先度です。  [#]_

以下のテーブルはシーケンス型の演算を優先度の低いものから順に挙げたものです (同じボックス内の演算は同じ優先度です)。テーブル内の *s* および *t*
は同じ型のシーケンスです; *n*、*i* および *j* は整数です:

+------------------+---------------------------------+----------+
| 演算               | 結果                              | 注釈       |
+==================+=================================+==========+
| ``x in s``       | *s* のある要素 *x* と等しい場合 ``True``   | \(1)     |
|                  | 、そうでない場合 ``False``              |          |
+------------------+---------------------------------+----------+
| ``x not in s``   | *s* のある要素が *x* と等しい場合 ``False`` | \(1)     |
|                  | 、そうでない場合 ``True``               |          |
+------------------+---------------------------------+----------+
| ``s + t``        | *s* および *t* の結合                 | \(6)     |
+------------------+---------------------------------+----------+
| ``s * n, n * s`` | *s* の浅いコピー *n* 個からなる結合          | \(2)     |
+------------------+---------------------------------+----------+
| ``s[i]``         | *s* の 0 から数えて *i* 番目の要素         | \(3)     |
+------------------+---------------------------------+----------+
| ``s[i:j]``       | *s* の *i* 番目から *j* 番目までのスライス    | (3), (4) |
+------------------+---------------------------------+----------+
| ``s[i:j:k]``     | *s* の *i* 番目から *j*  番目まで、*k*    | (3), (5) |
|                  | 毎のスライス                          |          |
+------------------+---------------------------------+----------+
| ``len(s)``       | *s* の長さ                         |          |
+------------------+---------------------------------+----------+
| ``min(s)``       | *s* の最小の要素                      |          |
+------------------+---------------------------------+----------+
| ``max(s)``       | *s* の最大の要素                      |          |
+------------------+---------------------------------+----------+

.. index::
   triple: operations on; sequence; types
   builtin: len
   builtin: min
   builtin: max
   pair: concatenation; operation
   pair: repetition; operation
   pair: subscript; operation
   pair: slice; operation
   pair: extended slice; operation
   operator: in
   operator: not in

注釈:

(1)
   *s* が文字列または Unicode 文字列の場合、  演算操作 ``in`` および ``not in`` は部分文字列の一致テスト
   と同じように動作します。バージョン 2.3 以前の Python では、 *x* は長さ 1 の文字列でした。Python 2.3 以降では、*x*
   はどの長さでもかまいません。

(2)
   *n* が ``0`` 以下の値の場合、``0`` として 扱われます (これは *s* と同じ型の空のシーケンスを表します)。
   コピーは浅いコピーなので注意してください; 入れ子になったデータ 構造はコピーされません。これは Python に慣れていないプログラマを
   よく悩ませます。例えば以下のコードを考えます::

      >>> lists = [[]] * 3
      >>> lists
      [[], [], []]
      >>> lists[0].append(3)
      >>> lists
      [[3], [3], [3]]

   上のコードでは、 ``lists`` はリスト ``[[]]`` (空のリストを唯一の 要素として含んでいるリスト) の3つのコピーを要素とするリストです。
   しかし、リスト内の要素に含まれているリストは各コピー間で共有されています。 以下のようにすると、異なるリストを要素とするリストを生成できます:
   上のコードで、``[[]]`` は空のリストを要素として含んでいるリストですから、 ``[[]] * 3``
   の3つの要素の全てが、空のリスト（への参照）になります。 ``lists``
   のいずれかの要素を修正することでこの単一のリストが変更されます。以下のようにすると、異なる個別のリストを生成できます::

      >>> lists = [[] for i in range(3)]
      >>> lists[0].append(3)
      >>> lists[1].append(5)
      >>> lists[2].append(7)
      >>> lists
      [[3], [5], [7]]

(3)
   *i* または *j* が負の数の場合、インデクスは文字列の 末端からの相対インデクスになります: ``len(s) + i``  または ``len(s) +
   j`` が代入されます。 しかし ``-0`` は ``0`` のままなので注意してください。

(4)
   *s* の *i* から *j* へのスライスは ``i <= k < j`` となるようなインデクス *k*
   を持つ要素からなるシーケンスとして定義されます。*i* または *j* が ``len(s)`` よりも大きい場合、``len(s)`` を使います。 *i*
   が省略されるか ``None`` だった場合、``0`` を使います。 *j* が省略されるか ``None`` だった場合、``len(s)`` を使います。
   *i* が *j* 以上の場合、スライスは空のシーケンスになります。

(5)
   *s* の *i* 番目から *j* 番目まで  *k* 毎のスライスは、$0 ≤n < (j-i)/(k) となるような、 インデクス``x = i +
   n*k`` を持つ要素からなる シーケンスとして定義されます。言い換えるとインデクスは ``i``、``i+k``、 ``i+2*k``、``i+3*k``
   などであり、*j* に達したところ (しかし *j* は含みません)でストップします。 *i* または *j* が ``len(s)``
   より大きい場合、``len(s)``  を使います。*i* または *j* を省略するか ``None`` だった場合、"最後" (*k*
   の符号に依存)を示す値を使います。*k* はゼロにできないので 注意してください。*k* が ``None`` だった場合、``1`` として扱われます。

(6)
   *s* と *t* の両者が文字列であるとき、CPythonのような実装では、  ``s=s+t`` や ``s+=t``という書式で 代入をするのにin-
   place optimizationが働きます。このような時、最適化は二 乗の実行時間の低減をもたらします。この最適化はバージョンや実装に依存し
   ます。実行効率が必要なコードでは、バージョンと実装が変わっても、直線的 な連結の実行効率を保証する:meth:`str.join` を使うのがより望ましいで
   しょう。

   .. versionchanged:: 2.4
      以前、文字列の連結はin-placeで再帰されませんでした.


.. _string-methods:

文字列メソッド
-------

.. index:: pair: string; methods

以下は 8 ビット文字列および Unicode オブジェクトでサポートされる メソッドです:


.. method:: string.capitalize()

   最初の文字を大文字にした文字列のコピーを返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.center(width[, fillchar])

   *width* の長さをもつ中央寄せされた文字列を返します。パディングには *fillchar* で指定された値（デフォルトではスペース）が使われます。

   .. versionchanged:: 2.4
      引数 *fillchar* に対応.


.. method:: string.count(sub[, start[, end]])

   文字列 S\ ``[start:end]`` 中に部分文字列 *sub*  が出現する回数を返します。オプション引数 *start* および *end*
   はスライス表記と同じように解釈されます。


.. method:: string.decode([encoding[, errors]])

   codec に登録された文字コード系 *encoding* を使って文字列をデコード します。*encoding* は標準でデフォルトの文字列エンコーディング
   になります。標準とは異なるエラー処理を行うために *errors* を 与えることができます。標準のエラー処理は ``'strict'`` で、エンコード
   に関するエラーは :exc:`UnicodeError` を送出します。 他に利用できる値は ``'ignore'`` 、 ``'replace'`` および
   関数 :func:`codecs.register_error` によって登録された名前です。 これについてはセクション
   :ref:`codec-base-classes`節を参照してください。

   .. versionadded:: 2.2

   .. versionchanged:: 2.3
      その他のエラーハンドリングスキーマがサポートされました.


.. method:: string.encode([encoding[,errors]])

   文字列のエンコードされたバージョンを返します。標準のエンコーディング は現在のデフォルト文字列エンコーディングです。 標準とは異なるエラー処理を行うために
   *errors* を 与えることができます。標準のエラー処理は ``'strict'`` で、エンコード に関するエラーは
   :exc:`UnicodeError` を送出します。 他に利用できる値は ``'ignore'`` 、 ``'replace'`` 、
   ``'xmlcharrefreplace'``、 ``'backslashreplace'`` および 関数
   :func:`codecs.register_error` によって登録された名前です。 これについてはセクション
   :ref:`codec-base-classes`を参照してください。 利用可能なエンコーディングの一覧は、セクション
   :ref:`standard-encodings` を参照してください。

   .. versionadded:: 2.0

   .. versionchanged:: 2.3
      ``'xmlcharrefreplace'`` 、 ``'backslashreplace'``
      およびその他のエラーハンドリングスキーマがサポートされました.


.. method:: string.endswith(suffix[, start[, end]])

   文字列の一部が *suffix* で終わるときに ``True`` を返します。そう でない場合 ``False`` を返します。*suffix*
   は見つけたい複数の接尾語 のタプルでも構いません。オプション引数 *start* がある場 合、文字列の *start* から比較を始めます。*end*
   がある場合、文字 列の *end* で比較を終えます。

   .. versionchanged:: 2.5
      *suffix* でタプルを受け付けるようになりました.


.. method:: string.expandtabs([tabsize])

   全てのタブ文字が空白で展開された文字列のコピーを返します。 *tabsize* が与えられていない場合、タブ幅は ``8`` 文字分 と仮定します。


.. method:: string.find(sub[, start[, end]])

   文字列中の領域 [*start*, *end*] に *sub* が含まれる場合、 その最小のインデクスを返します。 オプション引数 *start* および
   *end* はスライス表記と 同様に解釈されます。*sub* が見つからなかった場合 ``-1``  を返します。

   .. % [\var{start}, \var{end}) をなぜ [\var{start}, \var{end}] に直すのか?


.. method:: string.index(sub[, start[, end]])

   :meth:`find` と同様ですが、*sub* が見つからなかった場合 :exc:`ValueError` を送出します。


.. method:: string.isalnum()

   文字列中の全ての文字が英数文字で、かつ 1 文字以上ある場合には真を返し、 そうでない場合は偽を返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.isalpha()

   文字列中の全ての文字が英文字で、かつ 1 文字以上ある場合には真を返し、 そうでない場合はを返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.isdigit()

   文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.islower()

   文字列中の大小文字の区別のある文字全てが小文字で、かつ 1 文字以上 ある場合には真を返し、そうでない場合は偽を返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.isspace()

   文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、 そうでない場合は偽を返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.istitle()

   文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、 例えば大文字は大小文字の区別のない文字の後にのみ続き、
   小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。 そうでない場合は偽を返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.isupper()

   文字列中の大小文字の区別のある文字全てが大文字で、かつ 1 文字以上 ある場合には真を返し、そうでない場合は偽を返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.join(seq)

   シーケンス *seq* 中の文字列を結合した文字列を返します。文字列を 結合するときの区切り文字は、このメソッドを適用する対象の文字列に なります。


.. method:: string.ljust(width[, fillchar])

   *width* の長さをもつ左寄せした文字列を返します。 パディングには *fillchar* で指定された文字(デフォルトではスペース）
   が使われます。*width* が ``len(s)`` よりも小さい場合、元の文字列が返されます。

   .. versionchanged:: 2.4
      引数 *fillchar* が追加されました.


.. method:: string.lower()

   文字列をコピーし、小文字に変換して返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.lstrip([chars])

   文字列の先頭部分を除去したコピーを返します。 引数 *chars* は除去される文字集合を指定する文字列です。 *chars* が省略されるか ``None``
   の場合、空白文字が 除去されます。*chars* 文字列は接頭語ではなく、そこに 含まれる文字の組み合わせ全てがはぎ取られます。  ::

      >>> '   spacious   '.lstrip()
      'spacious   '
      >>> 'www.example.com'.lstrip('cmowz.')
      'example.com'

   .. versionchanged:: 2.2.2
      引数 *chars* をサポートしました.


.. method:: string.partition(sep)

   文字列を *sep* の最初の出現位置で区切り、3要素のタプルを返します。
   タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。
   もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字列が入ります。

   .. versionadded:: 2.5


.. method:: string.replace(old, new[, count])

   文字列をコピーし、部分文字列 *old* のある部分全てを *new* に置換して返します。オプション引数 *count* が与えられて いる場合、先頭から
   *count* 個の *old* だけを置換します。


.. method:: string.rfind(sub [,start [,end]])

   文字列中の領域 [*start*, *end*) に *sub* が含まれる場合、 その最大のインデクスを返します。 オプション引数 *start* および
   *end* はスライス表記と 同様に解釈されます。*sub* が見つからなかった場合 ``-1``  を返します。


.. method:: string.rindex(sub[, start[, end]])

   :meth:`find` と同様ですが、*sub* が見つからなかった場合 :exc:`ValueError` を送出します。


.. method:: string.rjust(width[, fillchar])

   *width* の長さをもつ右寄せした文字列を返します。 パディングには *fillchar* で指定された文字(デフォルトではスペース）
   が使われます。*width* が ``len(s)`` よりも小さい場合、元の文字列が返されます。

   .. versionchanged:: 2.4
      引数 *fillchar* が追加されました.


.. method:: string.rpartition(sep)

   文字列を *sep* の最後の出現位置で区切り、3要素のタプルを返します。
   タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。
   もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのものが入ります。

   .. versionadded:: 2.5


.. method:: string.rsplit([sep [,maxsplit]])

   *sep* を区切り文字とした、文字列中の単語のリストを返します。 *maxsplit* が与えられた場合、最大で *maxsplit* 個になるように
   分割が行なわれます、*最も右側* （の単語）は1つになります。 *sep* が指定されていない、あるいは ``None``のとき、全ての
   空白文字が区切り文字となります。右から分割していくことを除けば、 :meth:`rsplit` は後ほど詳しく述べる :meth:`split`
   と同様に振る舞います。

   .. versionadded:: 2.4


.. method:: string.rstrip([chars])

   文字列の末尾部分を除去したコピーを返します。 引数 *chars* は除去される文字集合を指定する文字列です。 *chars* が省略されるか ``None``
   の場合、空白文字が 除去されます。*chars* 文字列は接尾語ではなく、そこに 含まれる文字の組み合わせ全てがはぎ取られます。  ::

      >>> '   spacious   '.rstrip()
      '   spacious'
      >>> 'mississippi'.rstrip('ipz')
      'mississ'

   .. versionchanged:: 2.2.2
      引数 *chars* をサポートしました.


.. method:: string.split([sep [,maxsplit]])

   *sep* を単語の境界として文字列を単語に分割し、分割された単語 からなるリストを返します。 (したがって返されるリストは``maxsplit+1``
   の要素を持ちます） *maxsplit* が与えられていない場合、無制限に分割が行なわれます
   （全ての可能な分割が行なわれる）。連続した区切り文字はグループ化されず、 空の文字列を区切っていると判断されます(例えば
   ``'1,,2'.split(',')`` は ``['1', '', '2']`` を返します)。引数 *sep* は複数の文字にも できます(例えば
   ``'1, 2, 3'.split(', ')`` は ``['1', '2', '3']`` を返します)。区切り文字を指定して空の文字列を
   分割すると、``['']`` を返します。

   *sep* が指定されていないか ``None`` が指定されている場合、異なる分割
   アルゴリズムが適用されます。最初に空白文字（スペース、タブ、改行(newline)、 復帰(return)、改ページ(formfeed))
   が文字列の両端から除去されます。 次に任意の長さの空白文字列によって単語に分割されます。 連続した空白の区切り文字は単一の区切り文字として扱われます （``'1
   2  3'.split()`` は ``['1', '2', '3']`` を返します）。
   空の文字列や空白文字だけから成る文字列を分割する場合には空のリストを返します。


.. method:: string.splitlines([keepends])

   文字列を改行部分で分解し、各行からなるリストを返します。 *keepends* が与えられていて、かつその値が真でない限り、
   返されるリストには改行文字は含まれません。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.startswith(prefix[, start[, end]])

   文字列の一部が *prefix* で始まるときに ``True`` を返します。そう でない場合 ``False`` を返します。*prefix*
   は複数の接頭語の タプルにしても構いません。オプション引数 *start* がある場 合、文字列の *start* から比較を始めます。*end*
   がある場合、文字 列の *end* で比較を終えます。

   .. versionchanged:: 2.5
      *prefix* でタプルを受け付けるようになりました.


.. method:: string.strip([chars])

   文字列の先頭および末尾部分を除去したコピーを返します。 引数 *chars* は除去される文字集合を指定する文字列です。 *chars* が省略されるか
   ``None`` の場合、空白文字が 除去されます。*chars* 文字列は接頭語でも接尾語でもなく、 そこに含まれる文字の組み合わせ全てがはぎ取られます。
   ::

      >>> '   spacious   '.strip()
      'spacious'
      >>> 'www.example.com'.strip('cmowz.')
      'example'

   .. versionchanged:: 2.2.2
      引数 *chars* をサポートしました.


.. method:: string.swapcase()

   文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。


.. method:: string.title()

   文字列をタイトルケースにして返します: 大文字から始まり、残りの 文字のうち大小文字の区別があるものは全て小文字にします。


.. method:: string.translate(table[, deletechars])

   文字列をコピーし、オプション引数の文字列 *deletechars* の中に 含まれる文字を全て除去します。その後、残った文字を変換テーブル *table*
   に従ってマップして返します。変換テーブルは長さ 256  の文字列でなければなりません。

   Unicode オブジェクトの場合、:meth:`translate` メソッドはオプションの *deletechars*
   引数を受理しません。その代わり、メソッドは すべての文字が与えられた変換テーブルで対応付けされている *s* の コピーを返します。この変換テーブルは
   Unicode 順 (ordinal) から Unicode 順、Unicode 文字列、または ``None`` への対応付け
   でなくてはなりません。対応付けされていない文字は何もせず放置されます。 ``None`` に対応付けられた文字は削除されます。ちなみに、
   より柔軟性のあるアプローチは、自作の文字対応付けを行う codec を :mod:`codecs` モジュールを使って作成することです  (例えば
   :mod:`encodings.cp1251` を参照してください。


.. method:: string.upper()

   文字列をコピーし、大文字に変換して返します。

   8ビット文字列では、メソッドはロケール依存になります。


.. method:: string.zfill(width)

   数値文字列の左側をゼロ詰めし、幅 *width* にして返します。 *width* が ``len(s)`` よりも短い場合もとの文字列自体が 返されます。

   .. versionadded:: 2.2.2


.. _typesseq-strings:

文字列フォーマット操作
-----------

.. index::
   single: formatting, string (%)
   single: interpolation, string (%)
   single: string; formatting
   single: string; interpolation
   single: printf-style formatting
   single: sprintf-style formatting
   single: % formatting
   single: % interpolation

文字列および Unicode オブジェクトには固有の操作: ``%`` 演算子  (モジュロ) があります。この演算子は文字列 *フォーマット化*  または
*補間* 演算としても知られています。 ``format % values`` (*format* は文字列または Unicode
オブジェクト)とすると、*format* 中の ``%`` 変換指定は  *values* 中のゼロ個またはそれ以上の要素で置換されます。 この動作は C
言語における :cfunc:`sprintf` に似ています。 *format* が Unicode オブジェクトであるか、または ``%s``  変換を使って
Unicode オブジェクトが変換される場合、その結果も Unicode オブジェクトになります。

*format* が単一の引数しか要求しない場合、*values* は タプルでない単一のオブジェクトでもかまいません。  [#]_
それ以外の場合、*values* はフォーマット文字列中で指定された項目と 正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければ なりません。

一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は 以下からなりますが、示した順に出現しなければなりません:

#. 変換指定子が開始することを示す文字 ``'%'``。

#. マップキー (オプション)。 丸括弧で囲った文字列からなります (例えば ``(someone)``) 。

#. 変換フラグ (オプション)。一部の変換型の結果に影響します。

#. 最小のフィールド幅 (オプション).  ``'*'`` (アスタリスク)  を指定した場合、実際の文字列幅が *values* タプルの次の要素から読み
   出されます。タプルには最小フィールド幅やオプションの精度指定の後に 変換したいオブジェクトがくるようにします。

#. 精度 (オプション)。``'.'`` (ドット) とその後に続く精度 で与えられます。``'*'`` (アスタリスク) を指定した場合、精度
   の桁数はタプルの次の要素から読み出されます。タプルには精度指定の 後に変換したい値がくるようにします。

#. 精度長変換子 (オプション)。

#. 変換型。

``%`` 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合)、 文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字
``'%'`` の直後にくるようにしたものが含まれていなければ *なりません* 。マップキーはフォーマット化したい値をマップから 選び出します。例えば::

   >>> print '%(language)s has %(#)03d quote types.' % \
             {'language': "Python", "#": 2}
   Python has 002 quote types.

この場合、 ``*`` 指定子をフォーマットに含めてはいけません (``*`` 指定子は順番付けされたパラメタのリストが必要だからです。)

変換フラグ文字を以下に示します:

+---------+-----------------------------------------------+
| フラグ     | 意味                                            |
+=========+===============================================+
| ``'#'`` | 値の変換に (下で定義されている) "別の形式" を使います。               |
+---------+-----------------------------------------------+
| ``'0'`` | 数値型に対してゼロによるパディングを行います。                       |
+---------+-----------------------------------------------+
| ``'-'`` | 変換された値を左寄せにします (``'0'`` と同時に与えた 場合、``'0'``    |
|         | を上書きします) 。                                    |
+---------+-----------------------------------------------+
| ``' '`` | (スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます           |
|         | (そうでない場合は空文字になります)  。                         |
+---------+-----------------------------------------------+
| ``'+'`` | 変換の先頭に符号文字 (``'+'`` または ``'-'``) を付けます("スペース" |
|         | フラグを上書きします) 。                                 |
+---------+-----------------------------------------------+

精度長変換子(``h`` 、 ``l`` 、または ``L``) を使う ことができますが、Python では必要ないため無視されます。

変換型を以下に示します:

+---------+---------------------------------+------+
| 変換      | 意味                              | 注釈   |
+=========+=================================+======+
| ``'d'`` | 符号付き 10 進整数。                    |      |
+---------+---------------------------------+------+
| ``'i'`` | 符号付き 10 進整数。                    |      |
+---------+---------------------------------+------+
| ``'o'`` | 符号なし 8 進数。                      | \(1) |
+---------+---------------------------------+------+
| ``'u'`` | 符号なし 10 進数。                     |      |
+---------+---------------------------------+------+
| ``'x'`` | 符号なし 16 進数 (小文字)。               | \(2) |
+---------+---------------------------------+------+
| ``'X'`` | 符号なし 16 進数 (大文字)。               | \(2) |
+---------+---------------------------------+------+
| ``'e'`` | 指数表記の浮動小数点数 (小文字)。              | \(3) |
+---------+---------------------------------+------+
| ``'E'`` | 指数表記の浮動小数点数 (大文字)。              | \(3) |
+---------+---------------------------------+------+
| ``'f'`` | 10 進浮動小数点数。                     | \(3) |
+---------+---------------------------------+------+
| ``'F'`` | 10 進浮動小数点数。                     | \(3) |
+---------+---------------------------------+------+
| ``'g'`` | 浮動小数点数。指数部が -4 以上または精度以下の場合には   | \(4) |
|         | 指数表記、それ以外の場合には10進表記。            |      |
+---------+---------------------------------+------+
| ``'G'`` | 浮動小数点数。指数部が -4 以上または精度以下の場合には   | \(4) |
|         | 指数表記、それ以外の場合には10進表記。            |      |
+---------+---------------------------------+------+
| ``'c'`` | 文字一文字 (整数または一文字からなる文字列を受理します)。  |      |
+---------+---------------------------------+------+
| ``'r'`` | 文字列 (python オブジェクトを             | \(5) |
|         | :func:`repr` で変換します)。           |      |
+---------+---------------------------------+------+
| ``'s'`` | 文字列 (python オブジェクトを :func:`str` | \(6) |
|         | で変換します)。                        |      |
+---------+---------------------------------+------+
| ``'%'`` | 引数を変換せず、返される文字列中では文字 ``'%'``    |      |
|         | になります。                          |      |
+---------+---------------------------------+------+

注釈:

(1)
   この形式の出力にした場合、変換結果の先頭の数字がゼロ (``'0'``)  でないときには、数字の先頭と左側のパディングとの間にゼロを挿入します。

(2)
   この形式にした場合、変換結果の先頭の数字がゼロでないときには、 数字の先頭と左側のパディングとの間に ``'0x'`` または ``'0X'``
   (フォーマット文字が ``'x'`` か ``'X'`` かに依存します) が挿入されます。

(3)
   この形式にした場合、変換結果には常に小数点が含まれ、 それはその後ろに数字が続かない場合にも適用されます。

   指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。

(4)
   この形式にした場合、変換結果には常に小数点が含まれ 他の形式とは違って末尾の 0 は取り除かれません。

   指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。

(5)
   ``%r`` 変換は Python 2.0 で追加されました。

   指定精度は最大文字数を決定します。

(6)
   オブジェクトや与えられた書式が :class:`unicode` 文字列の場合、変換後の文字列も :class:`unicode` になります。

   指定精度は最大文字数を決定します。

Python 文字列には明示的な長さ情報があるので、``%s`` 変換において ``'\0'`` を文字列の末端と仮定したりはしません。

.. % XXX Examples?

安全上の理由から、浮動小数点数の精度は 50 桁でクリップされます;  絶対値が 1e25 を超える値の ``%f`` による変換は ``%g``
変換で置換されます  [#]_ その他のエラーは例外を送出します。

.. index::
   module: string
   module: re

その他の文字列操作は標準モジュール :mod:`string`  および :mod:`re`. で定義されています。


.. _typesseq-xrange:

XRange 型
--------

.. index:: object: xrange

:class:`xrange` 型は値の変更不能なシーケンスで、広範なループ処理に 使われています。:class:`xrange` 型の利点は、
:class:`xrange` オブジェクトは 表現する値域の大きさにかかわらず常に同じ量のメモリしか占めないということです。
はっきりしたパフォーマンス上の利点はありません。

XRange オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反復、 :func:`len` 関数のみをサポートしています。


.. _typesseq-mutable:

変更可能なシーケンス型
-----------

.. index::
   triple: mutable; sequence; types
   object: list

リストオブジェクトはオブジェクト自体の変更を可能にする追加の操作を サポートします。他の変更可能なシーケンス型 (を言語に追加する場合) も、
それらの操作をサポートしなければなりません。 文字列およびタプルは変更不可能なシーケンス型です: これらのオブジェクトは
一度生成されたらそのオブジェクト自体を変更することができません。 以下の操作は変更可能なシーケンス型で定義されています (ここで *x* は
任意のオブジェクトとします):

+------------------------------+---------------------------------+---------------------+
| 操作                           | 結果                              | 注釈                  |
+==============================+=================================+=====================+
| ``s[i] = x``                 | *s* の要素 *s* を *x* と入れ替えます       |                     |
+------------------------------+---------------------------------+---------------------+
| ``s[i:j] = t``               | *s* の *i* から *j* 番目までのスライスを     |                     |
|                              | イテラブル *t* の内容に入れ替えます            |                     |
+------------------------------+---------------------------------+---------------------+
| ``del s[i:j]``               | ``s[i:j] = []`` と同じです           |                     |
+------------------------------+---------------------------------+---------------------+
| ``s[i:j:k] = t``             | ``s[i:j:k]`` の要素を *t* と入れ替えます   | \(1)                |
+------------------------------+---------------------------------+---------------------+
| ``del s[i:j:k]``             | リストから ``s[i:j:k]`` の要素を削除します    |                     |
+------------------------------+---------------------------------+---------------------+
| ``s.append(x)``              | ``s[len(s):len(s)] = [x]``      | \(2)                |
|                              | と同じです                           |                     |
+------------------------------+---------------------------------+---------------------+
| ``s.extend(x)``              | ``s[len(s):len(s)] = x`` と同じです  | \(3)                |
+------------------------------+---------------------------------+---------------------+
| ``s.count(x)``               | ``s[i] == x`` となる *i* の個数を返します  |                     |
+------------------------------+---------------------------------+---------------------+
| ``s.index(x[, *i*[, *j*]])`` | ``s[k] == x`` かつ ``i <= k < j`` | \(4)                |
|                              | となる最小の *k* を返します。               |                     |
+------------------------------+---------------------------------+---------------------+
| ``s.insert(i, x)``           | ``i >= 0`` の場合の ``s[i:i] =      | \(5)                |
|                              | [x]`` と同じです                     |                     |
+------------------------------+---------------------------------+---------------------+
| ``s.pop([*i*])``             | ``x = s[i]; del s[i]; return    | \(6)                |
|                              | x`` と同じです                       |                     |
+------------------------------+---------------------------------+---------------------+
| ``s.remove(x)``              | ``del s[s.index(x)]`` と同じです     | \(4)                |
+------------------------------+---------------------------------+---------------------+
| ``s.reverse()``              | *s* の値の並びを反転します                 | \(7)                |
+------------------------------+---------------------------------+---------------------+
| ``s.sort([*cmp*[, *key*[,    | *s* の要素を並べ替えます                  | (7), (8), (9), (10) |
| *reverse*]]])``              |                                 |                     |
+------------------------------+---------------------------------+---------------------+

.. index::
   quadruple: operations on; mutable; sequence; types
   triple: operations on; sequence; types
   triple: operations on; list; type
   pair: subscript; assignment
   pair: slice; assignment
   pair: extended slice; assignment
   statement: del
   single: append() (list method)
   single: extend() (list method)
   single: count() (list method)
   single: index() (list method)
   single: insert() (list method)
   single: pop() (list method)
   single: remove() (list method)
   single: reverse() (list method)
   single: sort() (list method)

Notes:

(1)
   *t* は入れ替えるスライスと同じ長さでなければいけません。

(2)
   かつての Python の C 実装では、複数パラメタを受理し、 非明示的にそれらをタプルに結合していました。この間違った機能は Python 1.4
   で廃用され、Python 2.0 の導入とともにエラーにする ようになりました。

(3)
   *x* は任意のイテラブル(繰り返し可能オブジェクト)にできます。

(4)
   *x* が *s* 中に見つからなかった場合 :exc:`ValueError` を送出します。　 負のインデクスが二番目または三番目のパラメタとして
   :meth:`index` メソッドに渡されると、これらの値にはスライスのインデクスと同様に リストの長さが加算されます。加算後もまだ負の場合、その値はスライス
   のインデクスと同様にゼロに切り詰められます。

   .. versionchanged:: 2.3
      以前は、:meth:`index` は開始位置や終了位置を 指定するのに負の数を使うことができませんでした.

(5)
   :meth:`insert`
   の最初のパラメタとして負のインデクスが渡された場合、スライスのインデクスと同じく、リストの長さが加算されます。それでも負の値を取る場合、スライスのインデクスと同じく、0
   に丸められます。

   .. versionchanged:: 2.3
      以前は、すべての負値は 0 に丸められていました。.

(6)
   :meth:`pop` メソッドはリストおよびアレイ型のみでサポート されています。オプションの引数 *i* は標準で ``-1`` なので、
   標準では最後の要素をリストから除去して返します。

(7)
   :meth:`sort` および :meth:`reverse` メソッドは 大きなリストを並べ替えたり反転したりする際、容量の節約のために
   リストを直接変更します。副作用があることをユーザに思い出させるために、 これらの操作は並べ替えまたは反転されたリストを返しません。

(8)
   :meth:`sort` メソッドは、比較を制御するためにオプションの 引数をとります。

   *cmp* は2つの引数(list items)からなるカスタムの比較関数を指定します。 これは始めの引数が2つ目の引数に比べて小さい、等しい、大きいかに応じて
   負数、ゼロ、正数を返します。 ``cmp=lambda x,y: cmp(x.lower(), y.lower())``

   *key* は1つの引数からなる関数を指定します。これは個々のリストの要素から 比較のキーを取り出すのに使われます。 ``key=str.lower``

   *reverse* は真偽値です。 ``True`` がセットされた場合、リストの要素は 個々の比較が反転したものとして並び替えられます。

   一般的に、 *key* および *reverse* の変換プロセスは同等の *cmp* 関数を 指定するより早く動作します。これは *key* および
   *reverse* がそれぞれの要素に 一度だけ触れる間に、*cmp* はリストのそれぞれの要素に対して複数回呼ばれることに よるものです。

   .. versionchanged:: 2.3
      ``None`` を渡すのと、*cmp* を省略した場合とで、 同等に扱うサポートを追加.

   .. versionchanged:: 2.4
      *key* および *reverse* のサポートを追加.

(9)
   Python2.3 以降、:meth:`sort` メソッドは安定していることが 保証されています。
   ソートは等しいとされた要素の相対オーダーが変更されないことが 保証されれば、安定しています --- これは複合的なパス（例えば部署ごとにソートして、
   それを給与の等級）でソートを行なうのに役立ちます。

(10)
   リストが並べ替えられている間は、リストの変更はもとより、 その値の閲覧すらその結果は未定義です。 Python 2.3以降 の C
   実装では、この間リストは空に見えるようになり、 並べ替え中にリストが変更されたことが検出されると :exc:`ValueError` が送出されます。


.. _types-set:

set（集合）型 --- :class:`set`, :class:`frozenset`
=============================================

.. index:: object: set

:dfn:`set` オブジェクトは順序付けされていない変更不可能な値のコレクションです。 よくある使い方には、メンバーシップのテスト、数列から重複を削除する、
そして論理積、論理和、差集合、対称差など数学的演算の計算が含まれます。

.. versionadded:: 2.4

他のコレクションと同様、 setsは ``x in set``、 ``len(set)``および ``for x in set``
をサポートします。順序を持たないコレクションとして、setsは要素の位置と （要素の）挿入位置を保持しません。したがって、setsはインデックス、スライス、
その他のシーケンス的な振る舞いをサポートしません。

:class:`set` および :class:`frozenset`という、2つの組み込みset型があります。 :class:`set` は変更可能な ---
:meth:`add` や :meth:`remove`のような メソッドを使って内容を変更できます。変更可能なため、ハッシュ値を持たず、また
辞書のキーや他のsetの要素として用いることができません。:class:`frozenset` 型は 変更不能であり、ハッシュ化可能で ---
一度作成されると内容を改変することが できません。一方で辞書のキーや他のsetの要素として用いることができます。

:class:`set` および :class:`frozenset` のインスタンスは、以下の演算を提供します。

+-------------------------------+------------+---------------------------------+
| Operation                     | Equivalent | Result                          |
+===============================+============+=================================+
| ``len(s)``                    |            | set *s* の基数                     |
+-------------------------------+------------+---------------------------------+
| ``x in s``                    |            | *s* のメンバに *x* があるか調べる           |
+-------------------------------+------------+---------------------------------+
| ``x not in s``                |            | *s* のメンバに *x* がないか調べる           |
+-------------------------------+------------+---------------------------------+
| ``s.issubset(t)``             | ``s <= t`` | *t* に *s* の全ての要素が含まれるか調べる       |
+-------------------------------+------------+---------------------------------+
| ``s.issuperset(t)``           | ``s >= t`` | *s* に *t* の全ての要素が含まれるか調べる       |
+-------------------------------+------------+---------------------------------+
| ``s.union(t)``                | *s* \| *t* | *s* と                           |
|                               |            | *t*に含まれるすべての要素を持った新しいsetを作成     |
+-------------------------------+------------+---------------------------------+
| ``s.intersection(t)``         | *s* & *t*  | *s* と *t*共通に含まれる要素を持った新しいsetを作成 |
+-------------------------------+------------+---------------------------------+
| ``s.difference(t)``           | *s* - *t*  | *s* には含まれるが                     |
|                               |            | *t*には含まれない要素を持った新しいsetを作成       |
+-------------------------------+------------+---------------------------------+
| ``s.symmetric_difference(t)`` | *s* ^ *t*  | *s* と                           |
|                               |            | *t*のうち、両者には含まれない要素を持った新しいsetを作成 |
+-------------------------------+------------+---------------------------------+
| ``s.copy()``                  |            | *s*の浅いコピーを持った新しいsetを作成          |
+-------------------------------+------------+---------------------------------+

注意すべき点として、演算子ではないバージョンのメソッド :meth:`union`、
:meth:`intersection`、+:meth:`difference`、:meth:`symmetric_difference`、
:meth:`issubset`および :meth:`issuperset`はどの種類のiterableでも引数として
受け入れます。対照的に、（それぞれのメソッドに）対応する演算子は引数にsetsを
要求します。これはより読みやすい``set('abc').intersection('cbs')`` という構文を 優先して ``set('abc') &
'cbs'`` というような、エラーになりがちな構文を除外します。

:class:`set` と :class:`frozenset`の両者とも、setsとsetsの比較をサポートしています。
もし、あるいは少なくともそれぞれのsetsの全ての要素が他のsetsに含まれている
（それぞれのsetsがもう片方のサブセットである）場合、2つのsetsは等しいと言えます。
もし、あるいは少なくとも1つめのsetが2つめのsetの厳密なサブセットである （サブセットではあるが等しくない）場合、setは他のsetより小さいと言えます。
もし、あるいは少なくとも1つめのsetが2つめのsetの厳密なスーパーセットである
（スーパーセットではあるが等しくない）場合、setは他のsetより大きいと言えます。

:class:`set` のインスタンスは:class:`frozenset` のインスタンスと、そのメンバを基に 比較されます。例えば
``set('abc') == frozenset('abc')`` は ``True``を返します。

サブセットと同一性の比較は完全な順序付け関数によって一般化されません。
例えば、どのような共通部分も持たない2つのsetsは、等しくもなく、互いのサブセットでもないので、 以下のコードの *全て* に``False``を返します。
``a<b``、 ``a==b``、 ``a>b``。 それに応じて、setsは :meth:`__cmp__` メソッドを実装していません。

setsが部分的な順序付け（サブセットの関係）しか定義していないことから、 :meth:`list.sort`
メソッドの結果は不確定のsetsのリストとなります。

set の要素は辞書のキーと同様に :meth:`__hash__` と :meth:`__eq__` の 両方を定義していることが必要です。

:class:`set` と:class:`frozenset`のインスタンスを混在させたバイナリ演算は 結果を1つめのオペランドの型で返します。例えば
``frozenset('ab') | set('bc')`` は、:class:`frozenset`のインスタンスを返します。

以下の表は:class:`set`で可能なリスト操作です。これらの操作は変更不能な :class:`frozenset` のインスタンスには適用されません。

+--------------------------------------+-------------+-------------------------------+
| Operation                            | Equivalent  | Result                        |
+======================================+=============+===============================+
| ``s.update(t)``                      | *s* \|= *t* | set *s* を *t* の要素を追加して更新します   |
+--------------------------------------+-------------+-------------------------------+
| ``s.intersection_update(t)``         | *s* &= *t*  | set *s* を *s* と *t*           |
|                                      |             | の両方に属する要素だけ残すように更新します         |
+--------------------------------------+-------------+-------------------------------+
| ``s.difference_update(t)``           | *s* -= *t*  | set *s* を *t*                 |
|                                      |             | に属する要素を削除するように更新します           |
+--------------------------------------+-------------+-------------------------------+
| ``s.symmetric_difference_update(t)`` | *s* ^= *t*  | set *s* を *s* か *t*           |
|                                      |             | に属するが両方には属さない要素を持つように更新します    |
+--------------------------------------+-------------+-------------------------------+
| ``s.add(x)``                         |             | set *s* に要素 *x* を追加します        |
+--------------------------------------+-------------+-------------------------------+
| ``s.remove(x)``                      |             | set *s* から要素 *x*              |
|                                      |             | を削除します。要素が存在しない場合は            |
|                                      |             | :exc:`KeyError` を送出します        |
+--------------------------------------+-------------+-------------------------------+
| ``s.discard(x)``                     |             | set *s* に要素 *x* が存在していれば削除します |
+--------------------------------------+-------------+-------------------------------+
| ``s.pop()``                          |             | *s*                           |
|                                      |             | から、任意の要素を返してその要素を削除します。空の場合は  |
|                                      |             | :exc:`KeyError` を送出します        |
+--------------------------------------+-------------+-------------------------------+
| ``s.clear()``                        |             | set *s* から全ての要素を削除します         |
+--------------------------------------+-------------+-------------------------------+

注意すべき点として、演算子ではないバージョンのメソッド :meth:`update`、 :meth:`intersection_update`、
:meth:`difference_update` および :meth:`symmetric_difference_update`
は、どんなiterableでも引数として 受け入れます。

set 型のデザインは :mod:`sets` で学んだことに基づいています。


.. seealso::

   `Comparison to the built-in set types <comparison-to-builtin-set.html>`_
      :mod:`sets` モジュールと組み込み set 型の違い


.. _typesmapping:

マップ型
====

.. index::
   object: mapping
   object: dictionary

:dfn:`マップ型` (:dfn:`mapping`) オブジェクトは変更不可能な値を任意の オブジェクトに
対応付けます。対応付け自体は変更可能なオブジェクトです。 現在のところは標準のマップ型、:dfn:`dictionary` だけです。
辞書のキーにはほとんど任意の値をつかうことができます。使うことが できないのはリスト、辞書、その他の変更可能な型 (オブジェクトの一致
ではなく、その値で比較されるような型) です。 キーに使われた数値型は通常の数値比較規則に従います: 二つの数字を 比較した時等価であれば (例えば ``1``
と ``1.0`` のように)、 これらの値はお互いに同じ辞書のエントリを示すために使うことが できます。

辞書は ``key: value`` からなるペアを カンマで区切ったリストを波括弧の中に入れて作ります。 例えば: ``{'jack': 4098,
'sjoerd': 4127}`` または ``{4098: 'jack', 4127: 'sjoerd'}`` です。

以下の操作がマップ型で定義されています (ここで、*a* および *b* はマップ型で、*k* はキー、 *v* および *x* は任意の オブジェクトです):

.. index::
   triple: operations on; mapping; types
   triple: operations on; dictionary; type
   statement: del
   builtin: len
   single: clear() (dictionary method)
   single: copy() (dictionary method)
   single: has_key() (dictionary method)
   single: fromkeys() (dictionary method)
   single: items() (dictionary method)
   single: keys() (dictionary method)
   single: update() (dictionary method)
   single: values() (dictionary method)
   single: get() (dictionary method)
   single: setdefault() (dictionary method)
   single: pop() (dictionary method)
   single: popitem() (dictionary method)
   single: iteritems() (dictionary method)
   single: iterkeys() (dictionary method)
   single: itervalues() (dictionary method)

+--------------------------------+-------------------------------+-----------+
| 操作                             | 結果                            | 注釈        |
+================================+===============================+===========+
| ``len(a)``                     | *a* 内の要素の数です                  |           |
+--------------------------------+-------------------------------+-----------+
| ``a[k]``                       | キー *k* を持つ*a* の要素です           | (1), (10) |
+--------------------------------+-------------------------------+-----------+
| ``a[k] = v``                   | ``a[k]`` を *v* に設定します         |           |
+--------------------------------+-------------------------------+-----------+
| ``del a[k]``                   | *a* から ``a[k]`` を削除します        | \(1)      |
+--------------------------------+-------------------------------+-----------+
| ``a.clear()``                  | ``a`` から全ての要素を削除します           |           |
+--------------------------------+-------------------------------+-----------+
| ``a.copy()``                   | ``a`` の(浅い)コピーです              |           |
+--------------------------------+-------------------------------+-----------+
| ``k in a``                     | *a* にキー *k* があれば ``True`` 、   | \(2)      |
|                                | そうでなければ ``False`` です          |           |
+--------------------------------+-------------------------------+-----------+
| ``k not in a``                 | ``not`` *k* in *a* と同じです      | \(2)      |
+--------------------------------+-------------------------------+-----------+
| ``a.has_key(k)``               | *k* ``in`` *a*                |           |
|                                | と同じなので、新しく書くコードではその形を使ってください  |           |
+--------------------------------+-------------------------------+-----------+
| ``a.items()``                  | *a* における (*key*, *value*)     | \(3)      |
|                                | ペアのリストのコピーです                  |           |
+--------------------------------+-------------------------------+-----------+
| ``a.keys()``                   | *a* におけるキーのリストのコピーです          | \(3)      |
+--------------------------------+-------------------------------+-----------+
| ``a.update([*b*])``            | *b* によって key/value ペアを更新（上書き） | \(9)      |
+--------------------------------+-------------------------------+-----------+
| ``a.fromkeys(seq[, *value*])`` | *seq* からキーを作り、値が *value*      | \(7)      |
|                                | であるような、新しい辞書を作成します            |           |
+--------------------------------+-------------------------------+-----------+
| ``a.values()``                 | *a* における値のリストのコピーです           | \(3)      |
+--------------------------------+-------------------------------+-----------+
| ``a.get(k[, *x*])``            | もし ``k in a``なら``a[k]``、      | \(4)      |
|                                | そうでなければ *x*を返します              |           |
+--------------------------------+-------------------------------+-----------+
| ``a.setdefault(k[, *x*])``     | もし ``k in a``なら``a[k]``、      | \(5)      |
|                                | そうでなければ *x* (が与えられていた場合)を返します |           |
+--------------------------------+-------------------------------+-----------+
| ``a.pop(k[, *x*])``            | もし ``k in a`` なら ``a[k]`` 、   | \(8)      |
|                                | そうでなければ *x* を返して kを除去します      |           |
+--------------------------------+-------------------------------+-----------+
| ``a.popitem()``                | 任意の (*key*, *value*)          | \(6)      |
|                                | ペアを除去して返します                   |           |
+--------------------------------+-------------------------------+-----------+
| ``a.iteritems()``              | (*key*, *value*)              | (2), (3)  |
|                                | ペアにわたるイテレータを返します              |           |
+--------------------------------+-------------------------------+-----------+
| ``a.iterkeys()``               | マップのキー列にわたるイテレータを返します         | (2), (3)  |
+--------------------------------+-------------------------------+-----------+
| ``a.itervalues()``             | マップの値列にわたるイテレータを返します          | (2), (3)  |
+--------------------------------+-------------------------------+-----------+

注釈:

(1)
   *k* がマップ内にない場合、例外 :exc:`KeyError` を 送出します。

(2)
   .. versionadded:: 2.2

(3)
   キーおよび値は任意の順序でリスト化されています。この順序は ランダムではなく、Pythonの実装によって異なり、辞書の挿入、削除の履歴に 依存します。
   :meth:`items`、 :meth:`keys`、 :meth:`values`、 :meth:`iteritems`、
   :meth:`iterkeys`および :meth:`itervalues`が 途中で辞書を変更せずに呼ばれた場合、リストも直接対応するでしょう。
   これにより、``(value, key)`` のペアを :func:`zip` を 使って: ``pairs = zip(a.values(),
   a.keys())``  のように生成することができます。:meth:`iterkeys` および :meth:`itervalues`
   メソッドの間でも同じ関係が成り立ちます: ``pairs = zip(a.itervalues(), a.iterkeys())``  は ``pairs``
   と同じ値になります。 同じリストを生成するもう一つの方法は ``pairs = [(v, k) for (k, v) in a.iteritems()]``
   です。

(4)
   *k* がマップ中になくても例外を送出せず、代わりに *x* を返します。*x* はオプションです; *x* が与えられて おらず、かつ *k*
   がマップ中になければ、 ``None`` が返されます。

(5)
   :func:`setdefault` は :func:`get` に似ていますが、 *k* が見つからなかった場合、*x* が返されると同時に辞書の *k*
   に対する値として挿入されます。デフォルトで *x* は *None*です。

(6)
   :func:`popitem` は、集合アルゴリズムでよく行われる ような、辞書を取り崩しながらの反復を行うのに便利です。もし辞書が空なら
   :func:`popitem` の呼び出しは :exc:`KeyError` の送出を引き起こします。

(7)
   :func:`fromkeys` は、新しい辞書を返すクラスメソッドです。 *value* のデフォルト値は ``None`` です。

   .. versionadded:: 2.3

(8)
   :func:`pop` は、デフォルト値が渡されず、かつ、キーが見つからない場合に、 :exc:`KeyError` を送出します。

   .. versionadded:: 2.3

(9)
   :func:`update` はその他のマッピングオブジェクトや反復可能な キー/値のペア（タプルやその他2つの要素を持つ反復可能な要素）を受け入れます。
   キーワードとなる引数が指定されている場合、マッピングはそれらのキー/値のペアで 更新されます。 ``d.update(red=1, blue=2)``

   .. versionchanged:: 2.4
      キー／値のペアでできたイテレーション可能オブジェクトを引数に取るようになりました。また、キーワード引数をとるようになりました。.

(10)
   dict のサブクラスが :meth:`__missing__` メソッドを定義しているならば、 キー *k* が無ければ *a*[*k*] は *k*
   を引数にそのメソッドを 呼び出します。したがってキーが無いときに *a*[*k*] が結果を返すのも
   例外を送出するのも、:meth:`__missing__`\ (*k*) が結果を返すか 例外を送出するかで決まります。他のどんなメソッドも演算も
   :meth:`__missing__`\ () を呼び出すことはありません。このような :meth:`__missing__`
   が定義されていなければ、:exc:`KeyError` が送出されます。 :meth:`__missing__`
   はメソッドでなければならず、インスタンス変数では駄目です。 例として :mod:`collections`.\ :class:`defaultdict`
   を見てください。

   .. versionadded:: 2.5


.. _bltin-file-objects:

ファイルオブジェクト
==========

.. index::
   object: file
   builtin: file
   module: os
   module: socket

ファイルオブジェクト  は C の``stdio`` パッケージを使って実装されており、 :ref:`built-in-funcs` 節の  "組み込み関数"
で解説されている組み込みのコンストラクタ :func:`file` で生成することができます。  [#]_
ファイルオブジェクトはまた、:func:`os.popen` や :func:`os.fdopen` 、ソケットオブジェクトの :meth:`makefile`
メソッドのような、他の組み込み関数およびメソッドによっても返されます。

ファイル操作が I/O 関連の理由で失敗した場合例外 :exc:`IOError`        が送出されます。この理由には例えば :meth:`seek`
を端末デバイスに 行ったり、読み出し専用で開いたファイルに書き込みを行うといった、 何らかの理由によってそのファイルで定義されていない操作を行った
ような場合も含まれます。

ファイルは以下のメソッドを持ちます:


.. method:: file.close()

   ファイルを閉じます。閉じられたファイルはそれ以後読み書きすることは できません。ファイルが開かれていることが必要な操作は、ファイルが 閉じられた後はすべて
   :exc:`ValueError` を送出します。 :meth:`close` を一度以上呼び出してもかまいません。

   Python 2.5 から :keyword:`with` 文を使えばこのメソッドを直接呼び出す必要 はなくなりました。たとえば、以下のコードは ``f`` を
   :keyword:`with` ブロックを抜ける際に自動的に閉じます。 ::

      from __future__ import with_statement

      with open("hello.txt") as f:
          for line in f:
              print line

   古いバージョンの Python では同じ効果を得るために次のようにしなければい けませんでした。 ::

      f = open("hello.txt")
      try:
          for line in f:
              print line
      finally:
          f.close()

   .. note::

      全ての Python の "ファイル的" 型が :keyword:`with` 文用の コンテキスト・マネージャとして使えるわけではありません。もし、全ての
      ファイル的オブジェクトで動くようにコードを書きたいのならば、オブジェクトを 直接使うのではなく :mod:`contextlib` にある
      :func:`closing` を 使うと良いでしょう。詳細はセクション :ref:`context-closing` を参照してください。


.. method:: file.flush()

   ``stdio`` の :cfunc:`fflush` のように、内部バッファを フラッシュします。ファイル類似のオブジェクトによっては、この
   操作は何も行いません。


.. method:: file.fileno()

   .. index::
      single: file descriptor
      single: descriptor, file
      module: fcntl

   背後にある実装系がオペレーティングシステムに I/O 操作を要求するために 用いる、整数の "ファイル記述子" を返します。この値は他の用途として、
   :mod:`fcntl` モジュールや :func:`os.read` やその仲間のような、ファイル記述子を必要とする低レベルのインタフェース で役に立ちます。

   .. note::

      ファイル類似のオブジェクトが実際のファイルに関連付けられていない 場合、このメソッドを提供すべきでは*ありません。*


.. method:: file.isatty()

   ファイルが tty (または類似の) デバイスに接続されている場合  ``True`` を返し、そうでない場合 ``False`` を返します。

   .. note::

      ファイル類似のオブジェクトが実際のファイルに関連付けられていない 場合、このメソッドを実装*すべきではありません。*


.. method:: file.next()

   ファイルオブジェクトはそれ自身がイテレータです。すなわち、 ``iter(f)`` は (*f* が閉じられていない限り)  *f*
   を返します。:keyword:`for` ループ (例えば  ``for line in f: print line``) のようにファイルがイテレータとして
   使われた場合、:meth:`next` メソッドが繰り返し呼び出されます。 個のメソッドは次の入力行を返すか、または EOF に到達したときに
   :exc:`StopIteration` を送出します。ファイル内の各行に対する :keyword:`for` ループ (非常によくある操作です)
   を効率的な方法で 行うために、:meth:`next` メソッドは隠蔽された先読みバッファ
   を使います。先読みバッファを使った結果として、(:meth:`readline`  のような) 他のファイルメソッドと :meth:`next`
   を組み合わせて使うと うまく動作しません。しかし、:meth:`seek` を使ってファイル位置 を絶対指定しなおすと、先読みバッファはフラッシュされます。

   .. versionadded:: 2.3


.. method:: file.read([size])

   最大で *size* バイトをファイルから読み込みます (*size* バイト を取得する前に EOF に到達した場合、それ以下の長さになります) *size*
   引数が負であるか省略された場合、EOF に到達するまでの 全てのデータを読み込みます。読み出されたバイト列は文字列オブジェクト として返されます。直後に EOF
   に到達した場合、空の文字列が返されます。 (端末のようなある種のファイルでは、 EOF に到達した後でファイルを 読みつづけることにも意味があります。)
   このメソッドは、*size*  バイトに可能な限り近くデータを取得するために、背後の C 関数 :cfunc:`fread` を 1
   度以上呼び出すかもしれないので注意してください。 また、非ブロック・モードでは、*size* パラメータが与えられなくても、
   要求されたよりも少ないデータが返される場合があることに注意してください。


.. method:: file.readline([size])

   ファイルから一行を読み出します。末尾の改行文字は文字列中に 残されます（ですが、ファイルが不完全な行で終わっている場合は 何も残らないかもしれません）。
   [#]_ 引数 *size* が指定されていて負数でない場合、 (末尾の改行を含めて) 読み込む最大のバイト数です。この場合、
   不完全な行が返されるかもしれません。空文字列が返されるのは、 直後に EOF に到達した場合 *だけ* です。

   .. note::

      ``stdio`` の :cfunc:`fgets` と違い、入力中に ヌル文字 (``'\0'``) が含まれていれば、ヌル文字を含んだ 文字列が返されます。


.. method:: file.readlines([sizehint])

   :meth:`readline` を使ってに到達するまで読み出し、EOF 読み出された行を含むリストを返します。オプションの  *sizehint*
   引数が存在すれば、EOFまで読み出す代わりに 完全な行を全体で大体 *sizehint* バイトになるように (おそらく内部バッファサイズを切り詰めて)
   読み出します。 ファイル類似のインタフェースを実装しているオブジェクトは、 *sizehint* を実装できないか効率的に実装できない場合には
   無視してもかまいません。


.. method:: file.xreadlines()

   個のメソッドは ``iter(f)`` と同じ結果を返します。

   .. versionadded:: 2.1

   .. deprecated:: 2.3
      代わりに ``for line in file`` を使ってください。


.. method:: file.seek(offset[, whence])

   ``stdio`` の :cfunc:`fseek` と同様に、ファイルの現在位置を 返します。*whence* 引数はオプションで、標準の値は ``0``
   (絶対位置指定) です; 他に取り得る値は ``1`` (現在のファイル位置 から相対的に seek する) および ``2`` (ファイルの末端から相対的に
   seek する) です。戻り値はありません。ファイルを追記モード (モード ``'a'`` または ``'a+'``) で開いた場合、書き込みを行う
   までに行った:meth:`seek` 操作はすべて元に戻されるので注意してください。 ファイルが追記のみの書き込みモード (``'a'``) で開かれた場合、
   このメソッドは実質何も行いませんが、読み込みが可能な追記モード (``'a+'``) で開かれたファイルでは役に立ちます。 ファイルをテキストモードで
   (``'b'`` なしで) 開いた場合、 :meth:`tell` が返すオフセットのみが正しい値になります。
   他のオフセット値を使った場合、その振る舞いは未定義です。

   全てのファイルオブジェクトが seek できるとは限らないので注意してください。


.. method:: file.tell()

   ``stdio`` の :cfunc:`ftell` と同様、ファイルの現在位置を 返します。

   .. note::

      Windows では、(:cfunc:`fgets` の後で) Unix-スタイルの改行 のファイルを読むときに:meth:`tell`
      が不正な値を返すことがあります。 この問題に遭遇しないためにはバイナリーモード (``'rb'``) を使うよう にしてください。


.. method:: file.truncate([size])

   ファイルのサイズを切り詰めます。オプションの *size* が存在 すれば、ファイルは (最大で) 指定されたサイズに切り詰められます。
   標準設定のサイズの値は、現在のファイル位置までのファイルサイズです。 現在のファイル位置は変更されません。指定されたサイズがファイルの
   現在のサイズを越える場合、その結果はプラットフォーム依存なので 注意してください: 可能性としては、ファイルは変更されないか、
   指定されたサイズまでゼロで埋められるか、指定されたサイズまで 未定義の新たな内容で埋められるか、があります。 利用可能な環境:  Windows, 多くの
   Unix 系。


.. method:: file.write(str)

   文字列をファイルに書き込みます。戻り値はありません。バッファリング によって、:meth:`flush` または :meth:`close` が呼び出されるまで
   実際にファイル中に文字列が書き込まれないこともあります。


.. method:: file.writelines(sequence)

   文字列からなるシーケンスをファイルに書き込みます。シーケンスは文字列を生成 する反復可能なオブジェクトなら何でもかまいません。よくあるのは
   文字列からなるリストです。戻り値はありません。 (関数の名前は :meth:`readlines` と対応づけてつけられました;
   :meth:`writelines` は行間の区切りを追加しません)

ファイルはイテレータプロトコルをサポートします。各反復操作では  ``file.readline()`` と同じ結果を返し、反復は
:meth:`readline` メソッドが空文字列を返した際に終了します。

ファイルオブジェクトはまた、多くの興味深い属性を提供します。 これらはファイル類似オブジェクトでは必要ではありませんが、
特定のオブジェクトにとって意味を持たせたいなら実装しなければ なりません。


.. attribute:: file.closed

   現在のファイルオブジェクトの状態を示すブール値です。この値は 読み出し専用の属性です; :meth:`close` メソッドがこの値を
   変更します。全てのファイル類似オブジェクトで利用可能とは 限りません。


.. attribute:: file.encoding

   このファイルが使っているエンコーディングです。Unicode 文字列が ファイルに書き込まれる際、Unicode 文字列はこのエンコーディングを
   使ってバイト文字列に変換されます。さらに、ファイルが端末に 接続されている場合、この属性は端末が使っているとおぼしきエンコーディング
   (この情報は端末がうまく設定されていない場合には不正確なこともあります) を与えます。この属性は読み出し専用で、すべてのファイル類似オブジェクト
   にあるとは限りません。またこの値は ``None`` のこともあり、 この場合、ファイルはUnicode 文字列の変換のためにシステムのデフォルト
   エンコーディングを使います。

   .. versionadded:: 2.3


.. attribute:: file.mode

   ファイルの I/O モードです。ファイルが組み込み関数 :func:`open`  で作成された場合、この値は引数 *mode* の値になります。
   この値は読み出し専用の属性で、全てのファイル類似オブジェクトに 存在するとは限りません。


.. attribute:: file.name

   ファイルオブジェクトが :func:`open` を使って生成された時の ファイルの名前です。そうでなければ、ファイルオブジェクト生成の
   起源を示す何らかの文字列になり、``<...>`` の形式を とります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに 存在するとは限りません。


.. attribute:: file.newlines

   Python をビルドするとき、:option:`--with-universal-newlines`  オプションが:program:`configure`
   に指定された場合（デフォルト）、 この読み出し専用の属性が存在します。一般的な 改行に変換する読み出しモードで開かれたファイルにおいて、この属性はファイ
   ルの読み出し中に遭遇した改行コードを追跡します。取り得る値は ``'\ r'``、``'\n'``、``'\r\n'``、``None``
   (不明または、まだ改行 していない）、見つかった全ての改行文字を含むタプルのいずれかです。最後の
   タプルは、複数の改行慣例に遭遇したことを示します。一般的な改行文字を使う 読み出しモードで開かれていないファイルの場合、この属性の値は ``None``
   です。


.. attribute:: file.softspace

   :keyword:`print` 文を使った場合、他の値を出力する前にスペース文字を 出力する必要があるかどうかを示すブール値です。
   ファイルオブジェクトをシミュレート仕様とするクラスは書き込み可能な :attr:`softspace` 属性を持たなければならず、この値はゼロに初期化
   されなければなりません。この値は Python で実装されているほとんどの クラスで自動的に初期化されます (属性へのアクセス手段を上書きする
   ようなオブジェクトでは注意が必要です); C で実装された型では、 書き込み可能な :attr:`softspace` 属性を提供しなければなりません。

   .. note::

      この属性は :keyword:`print` 文を制御するために用いられますが、 :keyword:`print`
      の内部状態を乱さないために、その実装を行うことは できません。


.. _typecontextmanager:

コンテキストマネージャ型
============

.. versionadded:: 2.5

.. index::
   single: context manager
   single: context management protocol
   single: protocol; context management

Python の :keyword:`with` 文はコンテキストマネージャによって定義される
実行時コンテキストの概念をサポートします。これは、ユーザ定義クラスが文の本体 が実行される前に進入し文の終わりで脱出する実行時コンテキストを定義することを許す
二つの別々のメソッドを使って実装されます。

:dfn:`コンテキスト管理プロトコル` (:dfn:`context management protocol`) は
実行時コンテキストを定義するコンテキストマネージャオブジェクトが提供すべき 一対のメソッドから成ります。


.. method:: context manager.__enter__()

   実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連した オブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャを使う
   :keyword:`with` 文の :keyword:`as` 節の識別子に束縛されます。

   自分自身を返すコンテキストマネージャの例としてファイルオブジェクトがあります。 ファイルオブジェクトは :meth:`__enter__` から自分自身を返して
   :func:`open` が :keyword:`with` 文のコンテキスト式として使われる ようにします。

   関連オブジェクトを返すコンテキストマネージャの例としては ``decimal.localcontext()`` が返すものがあります。
   このマネージャはアクティブな10進数コンテキストをオリジナルのコンテキストのコピーに
   セットしてそのコピーを返します。こうすることで、:keyword:`with` 文の本体の
   内部で、外側のコードに影響を与えずに、10進数コンテキストを変更できます。


.. method:: context manager.__exit__(exc_type, exc_val, exc_tb)

   実行時コンテキストから抜け、例外(がもし起こっていたとしても)を抑制することを示す ブール値フラグを返します。:keyword:`with`
   文の本体を実行中に例外が起こったならば、引数には その例外の型と値とトレースバック情報を渡します。そうでなければ、引数は全て *None* です。

   このメソッドから真となる値が返されると :keyword:`with` 文は例外の発生を抑え、 :keyword:`with`
   文の直後の文に実行を続けます。そうでなければ、このメソッドの実行を 終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は
   :keyword:`with` 文の本体の実行中に起こった例外を置き換えてしまいます。

   渡された例外を直接的に再送出すべきではありません。その代わりに、このメソッドが偽の
   値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝えるべきです。 このようにすれば(``contextlib.nested``
   のような)コンテキストマネージャは :meth:`__exit__` メソッド自体が失敗したのかどうかを簡単に見分けることができます。

Python は幾つかのコンテキストマネージャを、易しいスレッド同期・ファイル などのオブジェクトの即時クローズ・単純化されたアクティブな10進算術コン
テキストのサポートのために用意しています。各型はコンテキスト管理プロトコル を実装しているという以上の特別の取り扱いを受けるわけではありません。

Python のジェネレータと ``contextlib.contextfactory`` デコレータはこの
プロトコルの簡便な実装方法を提供します。ジェネレータ関数を ``contextlib.contextfactory`` でデコレートすると、デコレートしなければ
返されるイテレータを返す代わりに、必要な :meth:`__enter__` および :meth:`__exit__`
メソッドを実装したコンテキストマネージャを返すようになります。

これらのメソッドのために Python/C API の中の Python オブジェクトの型構
造体に特別なスロットが作られたわけではないことに注意してください。これ らのメソッドを定義したい拡張型については通常の Python からアクセスでき
るメソッドとして提供しなければなりません。実行時コンテキストを準備する ことに比べたら、一つのクラスの辞書引きは無視できるオーバーヘッドです。


.. _typesother:

他の組み込み型
=======

インタプリタはその他の種類のオブジェクトをいくつかサポート します。これらのほとんどは 1 または 2 つの演算だけをサポート します。


.. _typesmodules:

モジュール
-----

モジュールに対する唯一の特殊な演算は属性へのアクセス: ``m.name`` です。ここで *m* はモジュールで、 *name* は *m*
のシンボルテーブル上に定義された名前に アクセスします。モジュール属性も代入することができます。 (:keyword:`import`
文は、厳密にいえば、モジュールオブジェクトに 対する演算です; ``import foo`` は *foo* と名づけられた
モジュールオブジェクトが存在することを必要とはせず、 むしろ *foo* と名づけられた (外部の) モジュールの*定義*  を必要とします。)

各モジュールの特殊なメンバは :attr:`__dict__` です。 これはモジュールのシンボルテーブルを含む辞書です。
この辞書を修正すると、実際にはモジュールのシンボルテーブルを変更 しますが、:attr:`__dict__` 属性を直接代入することはできません
(``m.__dict__['a'] = 1`` と書いて ``m.a`` を ``1`` に定義することはできますが、``m.__dict__ = {}``
と 書くことはできません) 。 :attr:`__dict__` を直接編集するのは推奨されません。

インタプリタ内に組み込まれたモジュールは、 ``<module 'sys' (built-in)>`` のように書かれます。 ファイルから読み出された場合、
``<module 'os' from '/usr/local/lib/python|version|/os.pyc'>`` と書かれます。


.. _typesobjects:

クラスおよびクラスインスタンス
---------------

.. _classes and instances:

これらに関しては、Python リファレンスマニュアル (XXX reference: ../ref/ref.html)  の 3 章および 7
章を読んで下さい。


.. _typesfunctions:

関数
--

関数オブジェクトは関数定義によって生成されます。関数オブジェクトに 対する唯一の操作は、それを呼び出すことです:
``func(argument-list)``.

関数オブジェクトには実際には 2 つの種: 組み込み関数とユーザ定義関数 があります。両方とも同じ操作 (関数の呼び出し) をサポートしますが、
実装は異なるので、オブジェクトの型も異なります。

より詳しい情報は Python リファレンスマニュアル (XXX reference: ../ref/ref.html) を 参照してください。


.. _typesmethods:

メソッド
----

.. index:: object: method

メソッドは属性表記を使って呼び出される関数です。メソッドには二つの 種類があります: (リストへの:meth:`append`のような) 組み込みメソッド
と、クラスインスタンスのメソッドです。組み込みメソッドはそれをサポート する型と一緒に記述されています。

実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性 を追加しています: ``m.im_self`` はメソッドが操作するオブジェクト
で、``m.im_func`` はメソッドを実装している関数です。 ``m(arg-1, arg-2, ..., arg-n)``
の呼び出しは、``m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)`` の呼び出しと完全に等価です。

クラスインスタンスメソッドには、 メソッドがインスタンスからアクセス されるかクラスからアクセスされるかによって、それぞれ*バインド*  または
*非バインド*　があります。メソッドが非バインドメソッドの 場合、``im_self`` 属性は ``None`` になるため、呼び出す際 には
``self`` オブジェクトを明示的に第一引数として指定しなければ なりません。この場合、``self`` は非バインドメソッドのクラス (サブクラス)
のインスタンスでなければならず、そうでなければ :exc:`TypeError` が送出されます。

関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得 できます。しかし、メソッド属性は実際には背後の関数オブジェクト
(``meth.im_func``) に記憶されているので、バインド、ヒバインド メソッドへのメソッド属性の設定は許されていません。
メソッド属性の設定を試みると :exc:`TypeError` が送出されます。 メソッド属性を設定するためには、その背後の関数オブジェクトで 明示的に::

   class C:
       def method(self):
           pass

   c = C()
   c.method.im_func.whoami = 'my name is c'

のように設定しなければなりません。 詳しくは Python リファレンスマニュアル (XXX reference: ../ref/ref.html)
を読んで下さい。


.. _bltin-code-objects:

コードオブジェクト
---------

.. index:: object: code

.. index::
   builtin: compile
   single: func_code (function object attribute)

コードオブジェクトは、関数本体のような "擬似コンパイルされた" Python の実行可能コードを表すために実装系によって使われます。
コードオブジェクトはグローバルな実行環境への参照を持たない点で 関数オブジェクトとは異なります。コードオブジェクトは 組み込み関数
:func:`compile` によって返され、関数オブジェクト の :attr:`func_code` 属性として取り出すことができます。

.. index::
   statement: exec
   builtin: eval

コードオブジェクトは :keyword:`exec` 文や組み込み関数 :func:`eval` に(ソースコード文字列の代わりに)
渡すことで、実行したり値評価したり することができます。

詳しくは Python リファレンスマニュアル (XXX reference: ../ref/ref.html)  を読んで下さい。


.. _bltin-type-objects:

型オブジェクト
-------

.. index::
   builtin: type
   module: types

型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は 組み込み関数 :func:`type` でアクセスされます。型オブジェクトには
特有の操作はありません。標準モジュール :mod:`types` には全ての 組み込み型名が定義されています。

型は ``<type 'int'>`` のように書き表されます。


.. _bltin-null-object:

ヌルオブジェクト
--------

このオブジェクトは明示的に値を返さない関数によって返されます。 このオブジェクトには特有の操作はありません。ヌルオブジェクト は一つだけで、``None``
(組み込み名) と名づけられています。

``None`` と書き表されます。


.. _bltin-ellipsis-object:

省略表記オブジェクト
----------

このオブジェクトは拡張スライス表記によって使われます  (Python Reference Manual (XXX reference:
../ref/ref.html) を参照して ください)。特殊な操作は何もサポートしていません。省略表記オブジェクト は一つだけで、その名前は
:const:`Ellipsis` (組み込み名) です。

``Ellipsis`` と書き表されます。


ブール値
----

ブール値とは二つの定数オブジェクト ``False`` および ``True`` です。 これらは真偽値を表すために使われます (他の値も偽または真とみなされ
ます) 数値処理のコンテキスト (例えば算術演算子の引数として使われた 場合) では、これらはそれぞれ 0 および 1 と同様に振舞います。
任意の値に対して真偽値を変換できる場合、組み込み関数 :func:`bool` は 値をブール値にキャストするのに使われます (真値テストの節を参照
してください)

.. index::
   single: False
   single: True
   pair: Boolean; values

これらはそれぞれ ``False`` および ``True`` と書き表されます。


.. _typesinternal:

内部オブジェクト
--------

この情報については Python リファレンスマニュアル (XXX reference: ../ref/ref.html) を読んで
下さい。このオブジェクトではスタックフレーム、トレースバック、 スライスオブジェクトを記述しています。


.. _specialattrs:

特殊な属性
=====

実装では、いくつかのオブジェクト型に対して、数個の読み出し専用の特殊な 属性を追加しています。それぞれ:


.. attribute:: object.__dict__

   オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書または 他のマップ型オブジェクトです。


.. attribute:: object.__methods__

   .. deprecated:: 2.2
      オブジェクトの属性からなるリストを取得するには、 組み込み関数 :func:`dir` を使ってください。この属性はもう 利用できません。


.. attribute:: object.__members__

   .. deprecated:: 2.2
      オブジェクトの属性からなるリストを取得するには、 組み込み関数 :func:`dir` を使ってください。この属性はもう 利用できません。


.. attribute:: instance.__class__

   クラスインスタンスが属しているクラスです。


.. attribute:: class.__bases__

   クラスオブジェクトの基底クラスからなるタプルです。基底クラスを 持たない場合、空のタプルになります。

.. rubric:: Footnotes

.. [#] これらの特殊なメソッドに関する追加情報は Python リファレンスマニュアル (XXX reference:
   ../ref/ref.html)に記載されています。

.. [#] この結果として、リスト ``[1, 2]`` は ``[1.0, 2.0]`` と等しいと見なされます。タプルの場合も同様です

.. [#] パーザが被演算子の型を識別できるようにするために、このような優先度でなければならないのです。

.. [#] 従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを *values* に与えなくてはなりません。

.. [#] この範囲に関する値はかなり適当なものです。 この仕様は、正しい使い方では障害とならず、かつ特定のマシンにおける
   浮動小数点数の正確な精度を知らなくても、際限なく長くて意味のない数字から なる文字列を印字しないですむようにするためのものです。

.. [#] :func:`file` は Python 2.2 で新しく追加されました。 古いバージョンの組み込み関数 :func:`open` は
   :func:`file` の別名です。

.. [#] 改行を残す利点は、空の文字列が返ると EOF を示し、紛らわしくなくなるからです。また、ファイルの最後の行 が改行で終わっているかそうでない
   (ありえることです！) か (例えば、ファイルを行単位で読みながらその完全なコピーを作成 した場合には問題になります) を調べることができます。



:mod:`bsddb` --- Berkeley DB ライブラリへのインタフェース
===========================================

.. module:: bsddb
   :platform: Unix, Windows
   :synopsis: Berkeley DB ライブラリへのインタフェース
.. sectionauthor:: Skip Montanaro <skip@mojam.com>


:mod:`bsddb` モジュールは Berkeley DB ライブラリへのインタフェース を提供します。ユーザは適当な :func:`open`
呼び出しを使うことで、 ハッシュ、B-Tree、 またはレコードに基づくデータベースファイルを生成 することができます。bsddb
オブジェクトは辞書と大体同じように振る舞い ます。しかし、キー及び値は文字列でなければならないので、
他のオブジェクトをキーとして使ったり、他の種のオブジェクトを記録 したい場合、それらのデータを何らかの方法で直列化しなければなりません。 これには通常
:func:`marshal.dumps` や :func:`pickle.dumps` が使われます。

:mod:`bsddb` モジュールは、バージョン 3.3 から 4.4 までの間の Berkeley DB ライブラリを必要とします。


.. seealso::

   http://pybsddb.sourceforge.net/
      Berkeley DBインターフェース :mod:`bsddb.db` のドキュメントがあります。新しいインターフェースは、Berkeley DB
      3と4でSleepycatが提供しているオブジェクト指向インターフェースとほぼ 同じインターフェースとなっています。

   http://www.sleepycat.com/
      Sleepycat Software は、 Berkeley DBライブラリを開発しています。

より新しい DB である DBEnv や DBSequence オブジェクトのインターフェースも :mod:`bsddb.db`
モジュールで使用できます。これは、上の URL で説明されている Sleepycat Berkeley DB C API
によりマッチしています。:mod:`bsddb.db` API が提供する追加機能には、チューニングやトランザクション、
ログ出力、マルチプロセス環境でのデータベースへの同時アクセスなどがあります。

以下では、従来のbsddbモジュールと互換性のある、古いインターフェースを解 説しています。Python 2.5
以降、このインターフェースはマルチスレッドに対応しています。 マルチスレッドを使用する場合は :mod:`bsddb.db` API を推奨します。
こちらのほうがスレッドをよりうまく制御できるからです。

:mod:`bsddb` モジュールでは、適切な形式の Berkeley DB ファイルに アクセスするオブジェクトを生成する以下の関数を定義しています。
各関数の最初の二つの引数は同じです。可搬性のために、ほとんどの インスタンスでは最初の二つの引数だけが使われているはずです。


.. function:: hashopen(filename[, flag[, mode[, bsize[, ffactor[, nelem[, cachesize[, hash[, lorder]]]]]]]])

   *filename* と名づけられたハッシュ形式のファイルを開きます。 *filename* に ``None`` を指定することで、ディスクに保存する
   つもりがないファイルを生成することもできます。 オプションの *flag* には、ファイルを開くためのモードを指定します。 このモードは ``'r'``
   (読み出し専用), ``'w'`` (読み書き可能)、 ``'c'`` (読み書き可能 - 必要ならファイルを生成 … これがデフォルトです) または
   ``'n'`` (読み書き可能 - ファイル長を 0 に切り詰め)、にすることが できます。他の引数はほとんど使われることはなく、下位レベルの
   :cfunc:`dbopen` 関数に渡されるだけです。他の引数の使い方 およびその解釈については Berkeley DB のドキュメントを読んで下さい。


.. function:: btopen(filename[, flag[, mode[, btflags[, cachesize[, maxkeypage[, minkeypage[, pgsize[, lorder]]]]]]]])

   *filename* と名づけられた B-Tree 形式のファイルを開きます。 *filename* に ``None`` を指定することで、ディスクに保存する
   つもりがないファイルを生成することもできます。 オプションの *flag* には、ファイルを開くためのモードを指定します。 このモードは ``'r'``
   (読み出し専用)、 ``'w'`` (読み書き可能)、 ``'c'`` (読み書き可能 - 必要ならファイルを生成 … これがデフォルトです)、または
   ``'n'`` (読み書き可能 - ファイル長を 0 に切り詰め)、にすることが できます。他の引数はほとんど使われることはなく、下位レベルの
   :cfunc:`dbopen` 関数に渡されるだけです。他の引数の使い方 およびその解釈については Berkeley DB のドキュメントを読んで下さい。


.. function:: rnopen(filename[, flag[, mode[, rnflags[, cachesize[, pgsize[, lorder[, reclen[, bval[, bfname]]]]]]]]])

   *filename* と名づけられた DB レコード形式のファイルを開きます、 *filename* に ``None`` を指定することで、ディスクに保存する
   つもりがないファイルを生成することもできます、 オプションの *flag* には、ファイルを開くためのモードを指定します、 このモードは ``'r'``
   (読み出し専用), ``'w'`` (読み書き可能)、 ``'c'`` (読み書き可能 - 必要ならファイルを生成 … これがデフォルトです)、または
   ``'n'`` (読み書き可能 - ファイル長を 0 に切り詰め)、にすることが できます。他の引数はほとんど使われることはなく、下位レベルの
   :cfunc:`dbopen` 関数に渡されるだけです、他の引数の使い方 およびその解釈については Berkeley DB のドキュメントを読んで下さい。

.. note::

   2.3以降の Unix 版Pythonには、:mod:`bsddb185`モジュールが存在する場合があ ります。このモジュールは古いBerkeley DB
   1.85データベースライブラリを持つ システムをサポートするため*だけ*に存在しています。新規に開発する
   コードでは、:mod:`bsddb185`を直接使用しないで下さい。


.. seealso::

   Module :mod:`dbhash`
      :mod:`bsddb` への DBM 形式のインタフェース


.. _bsddb-objects:

ハッシュ、BTree、およびレコードオブジェクト
------------------------

インスタンス化したハッシュ、B-Tree, およびレコードオブジェクトは 辞書型と同じメソッドをサポートするようになります。加えて、以下に
列挙したメソッドもサポートします。

.. versionchanged:: 2.3.1
   辞書型メソッドを追加しました.


.. method:: bsddbobject.close()

   データベースの背後にあるファイルを閉じます。オブジェクトはアクセスできなく なります。これらのオブジェクトには :meth:`oepn` メソッドがないため、
   再度ファイルを開くためには、新たな :mod:`bsddb` モジュールを開く 関数を呼び出さなくてはなりません。


.. method:: bsddbobject.keys()

   DB ファイルに収められているキーからなるリストを返します。リスト内の キーの順番は決まっておらず、あてにはなりません。特に、異なるファイル 形式の DB
   間では返されるリストの順番が異なります。


.. method:: bsddbobject.has_key(key)

   引数 *key* が DB ファイルにキーとして含まれている場合 ``1``  を返します。


.. method:: bsddbobject.set_location(key)

   カーソルを *key* で示される要素に移動し、キー及び値からなる タプルを返します。(:func:`bopen` を使って開かれる) B-Tree
   データベースでは、*key* が実際にはデータベース内に存在しなかった 場合、カーソルは並び順が *key* の次に来るような要素を指し、
   その場所のキー及び値が返されます。 他のデータベースでは、データベース中に *key* が見つからなかった 場合 :exc:`KeyError`
   が送出されます。


.. method:: bsddbobject.first()

   カーソルを DB ファイルの最初の要素に設定し、その要素を返します。 B-Tree データベースの場合を除き、ファイル中のキーの順番は決まっていません。
   データベースが空の場合、このメソッドは :exc:`bsddb.error` を発生させます。


.. method:: bsddbobject.next()

   カーソルを DB ファイルの次の要素に設定し、その要素を返します。 B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって いません。


.. method:: bsddbobject.previous()

   カーソルを DB ファイルの直前の要素に設定し、その要素を返します。 B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって いません。
   (:func:`hashopen` で開かれるような)  ハッシュ表データベース ではサポートされていません。


.. method:: bsddbobject.last()

   カーソルを DB ファイルの最後の要素に設定し、その要素を返します。 ファイル中のキーの順番は決まっていません。 (:func:`hashopen`
   で開かれるような)  ハッシュ表データベース ではサポートされていません。 データベースが空の場合、このメソッドは :exc:`bsddb.error`
   を発生させます。


.. method:: bsddbobject.sync()

   ディスク上のファイルをデータベースに同期させます。

以下はプログラム例です::

   >>> import bsddb
   >>> db = bsddb.btopen('/tmp/spam.db', 'c')
   >>> for i in range(10): db['%d'%i] = '%d'% (i*i)
   ... 
   >>> db['3']
   '9'
   >>> db.keys()
   ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
   >>> db.first()
   ('0', '0')
   >>> db.next()
   ('1', '1')
   >>> db.last()
   ('9', '81')
   >>> db.set_location('2')
   ('2', '4')
   >>> db.previous() 
   ('1', '1')
   >>> for k, v in db.iteritems():
   ...     print k, v
   0 0
   1 1
   2 4
   3 9
   4 16
   5 25
   6 36
   7 49
   8 64
   9 81
   >>> '8' in db
   True
   >>> db.sync()
   0



.. _built-in-funcs:

組み込み関数
============

Python インタプリタは数多くの組み込み関数を持っていて、いつでも利用 することができます。それらの関数をアルファベット順に挙げます。


.. function:: __import__(name[, globals[, locals[, fromlist[, level]]]])

   .. index::
      statement: import
      module: ihooks
      module: rexec
      module: imp

   この関数は :keyword:`import` 文によって呼び出され ます。この関数の主な意義は、同様のインタフェースを持つ関数で
   この関数を置き換え、:keyword:`import` 文の意味を変更できるように することです。これを行う理由とやり方の例については、標準ライブラリ
   モジュール  :mod:`ihooks` および :mod:`rexec` を読んで下さい。また、 組み込みモジュール :mod:`imp` についても
   読んでみて下さい。自分で関数 :func:`__import__` を構築する 際に便利な操作が定義されています。

   例えば、文 ``import spam`` は結果として以下の呼び出し: ``__import__('spam',`` ``globals(),``
   ``locals(), [], -1)`` になります; 文 ``from spam.ham import eggs`` は
   ``__import__('spam.ham', globals(), locals(), ['eggs'], -1)`` です。 ``locals()``
   および ``['eggs']`` が引数で与えられますが、 関数 :func:`__import__` は ``eggs`` という名のローカル変数
   を設定しないので注意してください; この操作はそれ以後の import 文の ために生成されたコードで行われます。(実際、標準の実装では *locals*
   引数を全く使わず、:keyword:`import` 文のパッケージ文脈を決定するため だけに *globals* を使います。)

   変数 *name* が ``package.module`` の形式であった場合、 通常、*name* という名のモジュール *ではなく* トップレベルの
   パッケージ (最初のドットまでの名前) が返されます。しかし、 空でない *fromlist* 引数が与えられていれば、*name*
   と名づけられたモジュールが返されます。これは異なる種類の import 文に対して生成されたバイトコードと互換性をもたせるために行われます; ``import
   spam.ham.eggs`` とすると、トップレベルのパッケージ :mod:`spam` はインポートする名前空間に置かれなければなりませんが、 ``from
   spam.ham import eggs`` とすると、変数 ``eggs`` を 見つけるためには ``spam.ham`` サブパッケージを使わなくては
   なりません。この振る舞いを回避するために、:func:`getattr` を 使って必要なコンポーネントを展開してください。例えば、
   以下のようなヘルパー関数::

      def my_import(name):
          mod = __import__(name)
          components = name.split('.')
          for comp in components[1:]:
              mod = getattr(mod, comp)
          return mod

   *level* で絶対インポートを使うか相対インポートを使うかを指定します。 デフォルトは ``-1``
   で、この値は絶対と相対の両インポートを試すことを示します。 ``0`` を指定すると、絶対インポートだけ行なう、という意味になります。 *level*
   が正の値ならば、:func:`__import__` を呼び出すモジュールの ディレクトリから幾つ上の親ディレクトリまで探索するか、を意味します。

   .. versionchanged:: 2.5
      level パラメータが追加されました.

   .. versionchanged:: 2.5
      引数のキーワードサポートが追加されました.


.. function:: abs(x)

   数値の絶対値を返します。引数として通常の整数、長整数、浮動小数点数を とることができます。引数が複素数の場合、その大きさ (magnitude) が 返されます


.. function:: all(iterable)

   *iterable* の全ての要素が真ならば :const:`True` を返します。 以下のコードと等価です。  ::

      def all(iterable):
          for element in iterable:
              if not element:
                  return False
          return True

   .. versionadded:: 2.5


.. function:: any(iterable)

   *iterable* のいずれかの要素が真ならば :const:`True` を返します。 以下のコードと等価です。  ::

      def any(iterable):
          for element in iterable:
              if element:
                  return True
          return False

   .. versionadded:: 2.5


.. function:: basestring()

   この抽象型は、 :class:`str` および :class:`unicode` のスーパクラスです。
   この型は呼び出したりインスタンス化したりはできませんが、オブジェクトが :class:`str` や :class:`unicode`
   のインスタンスであるかどうかを調べる際に 利用できます。 ``isinstance(obj, basestring)`` は ``isinstance(obj,
   (str, unicode))`` と同じです。

   .. versionadded:: 2.3


.. function:: bool([x])

   標準の真値テストを使って、値をブール値に変換します。*x* が偽なら、:const:`False` を返します; そうでなければ :const:`True`
   を返します。``bool`` はクラスでも あり、``int`` のサブクラスになります。``bool`` クラスは
   それ以上サブクラス化できません。このクラスのインスタンス は:const:`False` および :const:`True`　だけです。

   .. index:: pair: Boolean; type

   .. versionadded:: 2.2.1

   .. versionchanged:: 2.3
      引数が与えられなかった場合、この関数は :const:`False` を返 します。.


.. function:: callable(object)

   *object* 引数が呼び出し可能なオブジェクトの場合、真を返します。 そうでなければ偽を返します。この関数が真を返しても *object*
   の呼び出しは失敗する可能性がありますが、偽を返した場合は決して 成功することはありません。クラスは呼び出し可能 (クラスを呼び出すと
   新しいインスタンスを返します) なことと、クラスのインスタンスが メソッド :meth:`__call__` を持つ場合には呼び出しが可能なので
   注意してください。


.. function:: chr(i)

   ASCII コードが整数 *i* となるような文字 1 字からなる文字列を 返します。例えば、``chr(97)`` は文字列 ``'a'`` を返します。
   この関数は :func:`ord` の逆です。引数は [0..255] の両端を含む 範囲内に収まらなければなりません; *i* が範囲外の値のときには
   :exc:`ValueError` が送出されます。


.. function:: classmethod(function)

   *function* のクラスメソッドを返します。

   クラスメソッドは、インスタンスメソッドが暗黙の第一引数として インスタンスをとるように、第一引数としてクラスをとります。
   クラスメソッドを宣言するには、以下の書きならわしを使います::

      class C:
          @classmethod
          def f(cls, arg1, arg2, ...): ...

   ``@classmethod`` は関数デコレータ形式です。詳しくは ../ref/ref.htmlPython リファレンスマニュアル の 7
   章にある関数定義についての説明を参照してください。

   このメソッドはクラスで呼び出すこと (例えば C.f() ) も、 インスタンスとして呼び出すこと (例えば C().f()) もできます。
   インスタンスはそのクラスが何であるかを除いて無視されます。 クラスメソッドが導出クラスに対して呼び出された場合、
   導出されたクラスオブジェクトが暗黙の第一引数として渡されます。

   クラスメソッドは C++ や Java における静的メソッドとは異なります。 そのような機能を求めているなら、:func:`staticmethod`
   を参照してくだ さい。

   もっとクラスメソッドについての情報が必要ならば、 Python リファレンスマニュアル (XXX reference: ../ref/types.html)
   の3章にある標準型階層についてのドキュメントを繙いてください。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      関数デコレータ構文を追加しました.


.. function:: cmp(x, y)

   二つのオブジェクト *x* および *y* を比較し、その結果に従って 整数を返します。戻り値は ``x`` < ``y`` のときには負、 ``x ==
   y`` の時にはゼロ、``x > y`` には 厳密に正の値になります。


.. function:: compile(string, filename, kind[, flags[, dont_inherit]])

   *string* をコードオブジェクトにコンパイルします。コードオブジェク トは :keyword:`exec` 文で実行したり、 :func:`eval`
   を呼び出して評 価できます。*filename* 引数にはコードの読み出し元のファイル名を指
   定します。コードをファイルから読み出したのでない場合には、それとわかる ような値を渡します (一般的には ``'<string>'`` を使います)。引数
   *kind* には、どの種類のコードをコンパイルするかを指定します。 *string* が命令文の列からなる場合には ``'exec'`` 、単一の式から
   なる場合には ``'eval'`` 、単一の対話的な命令文からなる場合には ``'single'`` にします (最後のケースでは、式の評価結果が
   ``None`` 以外の場合に値を出力します)。

   複数行の命令文をコンパイルする時には、2 つの注意点があります: 行末は単 一の改行文字 (``'\n'``) で表さねばなりません。また、入力行は少な くとも
   1 つの改行文字で終端せねばなりません。行末が ``'\r\n'`` で表現されている場合、文字列に :meth:`replace` メソッドを使って
   ``'\n'`` に変換してください。

   オプションの引数 *flags* および *dont_inherit* (Python 2.2 で 新たに追加) は、 *string* のコンパイル時にどの
   future 文 (:pep:`236` 参照) の影響を及ぼすかを制御します。どちらも省略した場合
   (または両方ともゼロの場合)、コンパイルを呼び出している側のコードで有効  になっている future 文の内容を有効にして *string* をコンパイルしま
   す。*flags* が指定されていて、かつ *dont_inherit* が指定されて いない (またはゼロ) の場合、上の場合に加えて *flags*
   に指定された future 文をいます。*dont_inherit* がゼロでない整数の場合、 *flags* の値そのものを使い、この関数呼び出し周辺での
   future 文の効 果は無視します。

   future 文はビットで指定され、互いにビット単位の論理和を取って複数の文 を指定できます。ある機能を指定するために必要なビットフィールドは、
   :mod:`__future__` モジュールの :class:`_Feature` インスタンスにおける :attr:`compiler_flag`
   属性で得られます。


.. function:: complex([real[, imag]])

   値 *real* + *imag*\*j の複素数型数を生成するか、文字列または 数値を複素数型に変換します。最初の引数が文字列の場合、文字列を
   複素数として変換します。この場合関数は二つ目の引数無しで呼び出さ なければなりません。二つ目の引数は文字列であってはなりません。 それぞれの引数は
   (複素数を含む) 任意の数値型をとることができます。 *imag* が省略された場合、標準の値はゼロで、関数は :func:`int` 、
   :func:`long` および :func:`float` のような数値型への 変換関数として動作します。 全ての引数が省略された場合、``0j``
   を返します。


.. function:: delattr(object, name)

   :func:`setattr` の親戚となる関数です。引数はオブジェクトと 文字列です。文字列はオブジェクトの属性のどれか一つの名前でなければ
   なりません。この関数は与えられた名前の属性を削除しますが、オブジェクト がそれを許す場合に限ります。例えば、 ``delattr(x, 'foobar')``
   は ``del x.foobar`` と等価です。


.. function:: dict([mapping-or-sequence])

   オプションの場所にある引数か、キーワード引数の集合から、 新しく辞書オブジェクトを初期化して返します。 引数が指定されていなければ、新しい空の辞書を返します。
   オプションの場所にある引数がマップ型のオブジェクトの場合、 そのマップ型オブジェクトと同じキーと値を持つ辞書を返します。
   それ以外の場合、オプションの場所にある引数はシーケンス型か、 反復をサポートするコンテナ型か、イテレータオブジェクトでなければなりません。
   この場合引数中の要素もまた、上に挙げた型のどれかでなくてはならず、 加えて正確に 2 個のオブジェクトを持っていなくてはなりません。
   最初の要素は新たな辞書のキーとして、二つ目の要素は辞書の値として 使われます。同じキーが一度以上与えられた場合、新たな辞書中には
   最後に与えた値だけが関連付けられます。

   キーワード引数が与えられた場合、キーワードとそれに関連付けられた 値が辞書の要素として追加されます。オプションの場所にある
   オブジェクト内とキーワード引数の両方で同じキーが指定されていた場合、 辞書中にはキーワード引数の設定値の方が残されます。

   例えば、以下のコードはどれも、``{"one": 2, "two": 3}`` と同じ辞書を返します:

* ``dict({'one': 2, 'two': 3})``

* ``dict({'one': 2, 'two': 3}.items())``

* ``dict({'one': 2, 'two': 3}.iteritems())``

* ``dict(zip(('one', 2), ('two', 3)))``

* ``dict([['two', 3], ['one', 2]])``

* ``dict(one=2, two=3)``

* ``dict([(['one', 'two'][i-2], i) for i in (2, 3)])``

   .. versionadded:: 2.2

   .. versionchanged:: 2.3
      キーワード引数から辞書を構築する機能が追加されました.


.. function:: dir([object])

   引数がない場合、現在のローカルシンボルテーブルにある名前のリストを 返します。引数がある場合、そのオブジェクトの有効な属性からなるリスト
   を返そうと試みます。この情報はオブジェクトの :attr:`__dict__` 属性が定義されている場合、そこから収集されます。また、
   クラスまたは型オブジェクトからも集められます。リストは完全なものに なるとは限りません。 オブジェクトがモジュールオブジェクトの場合、リストにはモジュール属性
   の名前も含まれます。 オブジェクトが型オブジェクトやクラスオブジェクトの場合、 リストにはそれらの属性が含まれ、かつそれらの基底クラスの属性も
   再帰的にたどられて含まれます。 それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、 再帰的にたどった基底クラスの属性名が含まれます。
   返されるリストはアルファベット順に並べられています。 例えば::

      >>> import struct
      >>> dir()
      ['__builtins__', '__doc__', '__name__', 'struct']
      >>> dir(struct)
      ['__doc__', '__name__', 'calcsize', 'error', 'pack', 'unpack']

   .. note::

      :func:`dir` は第一に対話プロンプトのために提供されているので、 厳密さや一貫性をもって定義された名前のセットよりも、むしろ興味深い名前
      のセットを与えようとします。また、この関数の細かい動作はリリース間で 変わる可能性があります。


.. function:: divmod(a, b)

   2 つの (複素数でない) 数値を引数として取り、長除法を行って その商と剰余からなるペアを返します。被演算子が型混合である場合、 2
   進算術演算子での規則が適用されます。通常の整数と長整数の場合、 結果は  ``(a // b, a % b)`` と同じ です。浮動小数点数の場合、結果は
   ``(q, a % b)`` であり、 *q* は通常 ``math.floor(a / b)`` ですが、 そうではなく 1 になることもあります。
   いずれにせよ、``q * b + a % b``  は *a* に非常に近い値になり、 ``a % b``  がゼロでない値の場合、その符号は *b*
   と同じで、  ``0 <= abs(a % b) < abs(b)`` になります。

   .. versionchanged:: 2.3
      複素数に対する :func:`divmod`  の使用は廃用されました。.


.. function:: enumerate(iterable)

   列挙オブジェクトを返します。*iterable* はシーケンス型、イテレータ型、 あるいは反復をサポートする他のオブジェクト型でなければなりません。
   :func:`enumerate` が返すイテレータの :meth:`next` メソッドは、 (ゼロから始まる) カウント値と、値だけ *iterable*
   を反復操作して 得られる、対応するオブジェクトを含むタプルを返します。 :func:`enumerate` はインデクス付けされた値の列: ``(0,
   seq[0])``, ``(1, seq[1])``, ``(2, seq[2])``, ... を得るのに便利です。

   .. versionadded:: 2.3


.. function:: eval(expression[, globals[, locals]])

   文字列とオプションの引数 *globals*、*locals* をとります。 *globals* を指定する場合には辞書でなくてはなりません。 *locals*
   は任意のマップ型にできます。

   .. versionchanged:: 2.4
      以前は *locals* も辞書でなければなりませんでした.

   引数 *expression*は Python の表現式 (技術的にいうと、条件のリストです)  として構文解釈され、 評価されます。このとき辞書
   *globals* および *locals* はそれぞれ グローバルおよびローカルな名前空間として使われます。 *locals*
   辞書が存在するが、'__builtins__' が欠けている場合、 *expression* を解析する前に現在のグローバル変数を *globals*
   にコピーします。このことから、*expression* は通常 標準の :mod:`__builtin__` モジュールへの完全なアクセス
   を有し、制限された環境が伝播するようになっています。 *locals* 辞書が省略された場合、標準の値として *globals* に
   設定されます。辞書が両方とも省略された場合、表現式は :keyword:`eval` が
   呼び出されている環境の下で実行されます。構文エラーは例外として報告されます。

   以下に例を示します::

      >>> x = 1
      >>> print eval('x+1')
      2

   この関数は (:func:`compile` で生成されるような) 任意の コードオブジェクトを実行するために利用することもできます。
   この場合、文字列の代わりにコードオブジェクトを渡します。 このコードオブジェクトは引数 *kind* を ``'eval'`` にして
   コンパイルされていなければなりません。

   ヒント: 文の動的な実行は :keyword:`exec` 文でサポートされています。 ファイルからの文の実行は関数 :func:`execfile`
   でサポートされて います。関数 :func:`globals` および :func:`locals` は
   それぞれ現在のグローバルおよびローカルな辞書を返すので、 :func:`eval` や :func:`execfile` で使うことができます。


.. function:: execfile(filename[, globals[, locals]])

   この関数は :keyword:`exec` 文に似ていますが、文字列の代わりにファイルに 対して構文解釈を行います。:keyword:`import`
   文と違って、モジュール管理 機構を使いません --- この関数はファイルを無条件に読み込み、 新たなモジュールを生成しません。 [#]_

   引数は文字列とオプションの 2 つの辞書からなります。*file*  は読み込まれ、(モジュールのように) Python 文の列として評価されます。 このとき
   *globals* および *locals* がそれぞれグローバル およびローカルな名前空間として使われます。 *locals*
   は任意のマップ型に指定できます。

   .. versionchanged:: 2.4
      以前は *locals* も辞書でなければなりませんでした.

   *locals* 辞書が 省略された場合、標準の値として *globals* に設定されます。辞書が 両方とも省略された場合、表現式は
   :func:`execfiles` が呼び出されている 環境の下で実行されます。戻り値は ``None`` です。

   .. warning::

      標準では *locals* は後に述べる関数 :func:`locals`  のように動作します: 標準の *locals* 辞書に対する変更を試みては
      いけません。:func:`execfile` の呼び出しが返る時にコードが *locals* に与える影響を知りたいなら、明示的に *loacals* 辞書を
      渡してください。:func:`execfile` は関数のローカルを変更するための 信頼性のある方法として使うことはできません


.. function:: file(filename[, mode[, bufsize]])

   :class:`file` 型のコンストラクタです。詳しくは :ref:`bltin-file-objects`節 "ファイルオブジェクト (XXX
   reference: bltin-file-objects.html)" を参照してください。 コンストラクタの引数は後述の :func:`open`
   組み込み関数と同じです。

   ファイルを開くときは、このコンストラクタを直接呼ばずに :func:`open` を 呼び出すのが望ましい方法です。:class:`file`
   は型テストにより適しています (たとえば ``isinstance(f, file)`` と書くような)。

   .. versionadded:: 2.2


.. function:: filter(function, list)

   *list* のうち、*function* が真を返すような要素からなる リストを構築します。*list* はシーケンスか、反復をサポートするコンテナか、
   イテレータです。*list* が文字列型かタプル型の場合、結果も同じ型に なります。*function* が ``None`` の場合、恒等関数を仮定
   します。すなわち、*list* の偽となる要素 は除去されます。

   function が ``None`` ではない場合、``filter(function, list)``  は ``[item for item in
   list if function(item)]`` と同等です。 function が ``None`` の場合 ``[item for item in
   list if  item]`` と同等です。


.. function:: float([x])

   文字列または数値を浮動小数点数に変換します。引数が文字列の場合、 十進の数または浮動小数点数を含んでいなければなりません。符号が
   付いていてもかまいません。また、空白文字中に埋め込まれていても かまいません。それ以外の場合、引数は通常整数、長整数、または浮動小数点
   数をとることができ、同じ値の浮動小数点数が (Python の浮動小数点 精度で) 返されます。 引数が指定されなかった場合、``0.0`` を返します。

   .. note::

      .. index::
         single: NaN
         single: Infinity

      文字列で値を渡す際、背後の C ライブラリによって NaN および Infinity が返されるかもしれません。これらの
      値を返すような特殊な文字列のセットは完全に C ライブラリに依存しており、 バリエーションがあることが知られています。


.. function:: frozenset([iterable])

   :class:`frozenset` オブジェクトを返します。要素は*iterable* から 取得します。:class:`frozenset`
   型は、update メソッドを持たない代わりに ハッシュ化でき、他の :class:`set` 型の要素にしたり辞書型のキーに
   したりできます。:class:`frozenset` の要素自体は変更不能でなければ なりません。集合 (set) 型の集合を表現するためには、内集合も
   :class:`frozenset` オブジェクトでなければなりません。*iterable* を 指定しない場合には空の集合 ``frozenset([])``
   を返します。

   .. versionadded:: 2.4


.. function:: getattr(object, name[, default])

   指定された *object* の属性を返します。*name* は文字列で なくてはなりません。文字列がオブジェクトの属性名の一つであった
   場合、戻り値はその属性の値になります。例えば、 ``getattr(x, 'foobar')`` は ``x.foobar`` と等価です。
   指定された属性が存在しない場合、*default* が与えられている 場合にはしれが返されます。そうでない場合には :exc:`AttributeError`
   が送出されます。


.. function:: globals()

   現在のグローバルシンボルテーブルを表す辞書を返します。 常に現在のモジュールの辞書になります (関数またはメソッドの中では
   それらを定義しているモジュールを指し、この関数を呼び出したモジュール ではありません)。


.. function:: hasattr(object, name)

   引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つ であった場合 ``True`` を、そうでない場合 ``False`` を返します
   (この関数は ``getattr(object, name)`` を呼び出し、 例外を送出するかどうかを調べることで実装しています)。


.. function:: hash(object)

   オブジェクトのハッシュ値を (存在すれれば) 返します。ハッシュ値は 整数です。これらは辞書を検索する際に辞書のキーを高速に比較するために
   使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と 1.0 のように型が異なっていてもです)。


.. function:: help([object])

   組み込みヘルプシステムを起動します (この関数は対話的な使用のための ものです)。引数が与えられていない場合、対話的ヘルプシステムは
   インタプリタコンソール上で起動します。引数が文字列の場合、文字列は モジュール、関数、クラス、メソッド、キーワード、またはドキュメント
   の項目名として検索され、ヘルプページがコンソール上に印字されます。 引数が何らかのオブジェクトの場合、そのオブジェクトに関するヘルプ ページが生成されます。

   .. versionadded:: 2.2


.. function:: hex(x)

   (任意のサイズの) 整数 を16進の文字列に変換します。 結果は Python の式としても使える形式になります。

   .. versionchanged:: 2.4
      以前は符号なしのリテラルしか返しませんでした.


.. function:: id(object)

   オブジェクトの "識別値" を返します。この値は整数 (または長整数) で、このオブジェクトの有効期間は一意かつ定数であることが保証されて います。
   オブジェクトの有効期間が重ならない 2 つのオブジェクトは 同じ :func:`id` 値を持つかもしれません。 (実装に関する注釈:
   この値はオブジェクトのアドレスです。)


.. function:: input([prompt])

   ``eval(raw_input(prompt))`` と同じです。

   .. warning::

      この関数はユーザのエラーに対して安全ではありません! この関数 では、入力は有効な Python の式であると期待しています; 入力が
      構文的に正しくない場合、:exc:`SyntaxError` が送出されます。 式を評価する際にエラーが生じた場合、他の例外も送出されるかもしれません。
      (一方、この関数は時に、熟練者がすばやくスクリプトを書く際に必要なまさに そのものです)

   :mod:`readline` モジュールが読み込まれていれば、:func:`input` は精緻な行編集およびヒストリ機能を提供します。

   一般的なユーザからの入力のための関数としては :func:`raw_input`  を使うことを検討してください。


.. function:: int([x[, radix]])

   文字列または数値を通常の整数に変換します。引数が文字列の場合、 Python 整数として表現可能な十進の数でなければなりません。
   符号が付いていてもかまいません。また、空白文字中に埋め込まれていても かまいません。*radix* 引数は変換の基数を表し、範囲 [2, 36] の
   整数またはゼロをとることができます。*radix* がゼロの場合、文字列の 内容から適切な基数を推測します; 変換は整数リテラルと同じです。 *radix*
   が指定されており、*x* が文字列でない場合、 :exc:`TypeError` が送出されます。 それ以外の場合、引数は通常整数、長整数、または浮動小数点
   数をとることができます。浮動小数点数から整数へ変換では (ゼロ方向に) 値を丸めます。 引数が通常整数の範囲を超えている場合、長整数が代わりに返されます。
   引数が与えられなかった場合、``0`` を返します。


.. function:: isinstance(object, classinfo)

   引数 *object* が引数 *classinfo* のインスタンスであるか、 (直接または間接的な) サブクラスのインスタンスの場合に真を返します。
   また、*classinfo* が型オブジェクトであり、*object* がその 型のオブジェクトである場合にも真を返します。*object* が
   クラスインスタンスや与えられた型のオブジェクトでない場合、 この関数は常に偽を返します。*classinfo* をクラスオブジェクト
   でも型オブジェクトにもせず、クラスや型オブジェクトからなる タプルや、そういったタプルを再帰的に含むタプル (他のシーケンス型は 受理されません)
   でもかまいません。*classinfo* がクラス、型、 クラスや型からなるタプル、そういったタプルが再帰構造をとっている タプルのいじれでもない場合、例外
   :exc:`TypeError` が送出 されます。

   .. versionchanged:: 2.2
      型情報をタプルにした形式のサポートが追加されました。.


.. function:: issubclass(class, classinfo)

   *class* が *classinfo* の (直接または間接的な) サブクラスで ある場合に真を返します。クラスはそのクラス自体のサブクラスと
   *clasinfo* はクラスオブジェクトからなるタプルでもよく、 この場合には *classinfo* のすべてのエントリが調べ られます。その他の場合では、
   例外 :exc:`TypeError` が送出されます。

   .. versionchanged:: 2.3
      型情報からなるタプルへのサポートが追加されました.


.. function:: iter(o[, sentinel])

   イテレータオブジェクトを返します。2 つ目の引数があるかどうかで、 最初の引数の解釈は非常に異なります。2 つ目の引数がない場合、 *o* は反復プロトコル
   (:meth:`__iter__` メソッド) か、 シーケンス型プロトコル (引数が ``0`` から開始する :meth:`__getitem__`
   メソッド) をサポートする集合オブジェクト でなければなりません。これらのプロトコルが両方ともサポート されていない場合、 :exc:`TypeError`
   が送出されます。 2 つ目の引数 *sentinel* が与えられていれば、*o* は呼び出し可能なオブジェクトでなければなりません。この場合に
   生成されるイテレータは、:meth:`next` を呼ぶ毎に *o* を引数無し で呼び出します。返された値が *sentinel* と等しければ、
   :exc:`StopIteration` が送出されます。そうでない場合、 戻り値がそのまま返されます。

   .. versionadded:: 2.2


.. function:: len(s)

   オブジェクトの長さ (要素の数) を返します。引数はシーケンス型 (文字列、 タプル、またはリスト) か、マップ型 (辞書) です。


.. function:: list([sequence])

   *sequence* の要素と同じ要素をもち、かつ順番も同じなリストを 返します。*sequence* はシーケンス、反復処理をサポートするコンテナ、
   あるいはイテレータオブジェクトです。*sequence* がすでにリストの 場合、``sequence[:]`` と同様にコピーを作成して返します。
   例えば、``list('abc')`` は ``['a', 'b', 'c']`` および ``list((1, 2, 3))`` は ``[1, 2,
   3]`` を返します。 引数が与えられなかった場合、新しい空のリスト ``[]`` を返します。


.. function:: locals()

   現在のローカルシンボルテーブルを表す辞書を更新して返します。

   .. warning::

      この辞書の内容は変更してはいけません; 値を変更しても、 インタプリタが使うローカル変数の値には影響しません。


.. function:: long([x[, radix]])

   文字列または数値を長整数値に変換します。引数が文字列の場合、 Python 整数として表現可能な十進の数でなければなりません。
   符号が付いていてもかまいません。また、空白文字中に埋め込まれていても かまいません。*radix* 引数は :func:`int` と同じように
   解釈され、*x* が文字列の時だけ与えることができます。 それ以外の場合、引数は通常整数、長整数、または浮動小数点
   数をとることができ、同じ値の長整数が返されます。浮動小数点数から 整数へ変換では (ゼロ方向に) 値を丸めます。 引数が与えられなかった場合、``0L``
   を返します。


.. function:: map(function, list, ...)

   *function* を *list* の全ての要素に適用し、返された 値からなるリストを返します。追加の *list* 引数を与えた場合、
   *function* はそれらを引数として取らなければならず、関数は そのリストの全ての要素について個別に適用されます; 他のリストより
   短いリストがある場合、要素 ``None`` で延長されます。*function* が ``None`` の場合、恒等関数であると仮定されます; すなわち、
   複数のリスト引数が存在する場合、:func:`map` は全てのリスト引数に 対し、対応する要素からなるタプルからなるリストを返します (転置操作の
   ようなものです)。*list* 引数はどのようなシーケンス型でもかまいません; 結果は常にリストになります。


.. function:: max(s[, args...][key])

   単一の引数 *s* の場合、空でないシーケンス (文字列、タプルまたはリスト) の要素のうち最大のものを返します。1 個よりも引数が多い場合、引数
   間で最大のものを返します。

   オプションの *key* 引数には :meth:`list.sort` で使われるのと同じ ような1引数の順序付け関数を指定します。*key*
   を指定する場合はキーワー ド形式でなければなりません (たとえば ``max(a,b,c,key=func)``)。

   .. versionchanged:: 2.5
      オプションの *key* 引数が追加されました.


.. function:: min(s[, args...][key])

   単一の引数 *s* の場合、空でないシーケンス (文字列、タプルまたはリスト) の要素のうち最小のものを返します。1 個よりも引数が多い場合、引数
   間で最小のものを返します。

   オプションの *key* 引数には :meth:`list.sort` で使われるのと同じ ような1引数の順序付け関数を指定します。*key*
   を指定する場合はキーワー ド形式でなければなりません (たとえば ``min(a,b,c,key=func)``)。

   .. versionchanged:: 2.5
      オプションの *key* 引数が追加されました.


.. function:: object()

   ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。 :class:`object()` は新スタイルのクラスの、基底クラスです。これは、新ス
   タイルのクラスのインスタンスに共通のメソッド群を持ちます。

   .. versionadded:: 2.2

   .. versionchanged:: 2.3
      この関数はいかなる引数も受け付けません。 以前は、引数を受理しましたが無視していました。.


.. function:: oct(x)

   (任意のサイズの) 整数を 8 進の文字列に変換します。 結果は Python の式としても使える形式になります。

   .. versionchanged:: 2.4
      以前は符号なしのリテラルしか返しませんでした.


.. function:: open(filename[, mode[, bufsize]])

   ファイルを開いて、:ref:`bltin-file-objects`節 "ファイルオブジェクト (XXX reference: bltin-file-
   objects.html)" に記述されている :class:`file` 型のオブジェクトを返します。ファイルが開けなければ、 :exc:`IOError`
   が送出されます。ファイルを開くときは :class:`file` のコンストラクタを直接呼ばずに :func:`open` を 使うのが望ましい方法です。

   最初の 2 つの引数は ``studio`` の :cfunc:`fopen` と同じです: *filename* は開きたいファイルの名前で、 *mode*
   はファイルをどのようにして開くかを指定します。

   最もよく使われる *mode* の値は、読み出しの ``'r'``、 書き込み (ファイルがすでに存在すれば切り詰め られます) の
   ``'w'``、追記書き込みの ``'a'`` です  (*いくつかの* Unix システムでは、*全て* の書き込みが
   現在のファイルシーク位置に関係なくファイルの末尾に追加されます) 。 *mode* が省略された場合、標準の値は ``'r'`` になります。
   移植性を高めるためには、バイナリファイルを開くときには、*mode*  の値に ``'b'`` を追加しなければなりません。(バイナリファイルと
   テキストファイルを区別なく扱うようなシステムでも、ドキュメンテーション の代わりになるので便利です。) 他に *mode*
   に与えられる可能性のある値については後述します。

   .. index::
      single: line-buffered I/O
      single: unbuffered I/O
      single: buffer size, I/O
      single: I/O control; buffering

   オプションの *bufsize* 引数は、ファイルのために必要とする バッファのサイズを指定します: 0 は非バッファリング、 1 は行単位
   バッファリング、その他の正の値は指定した値 (の近似値) のサイズを もつバッファを使用することを意味します。*bufsize* の値が負の
   場合、システムの標準を使います。通常、端末は行単位のバッファリング であり、その他のファイルは完全なバッファリングです。省略された
   場合、システムの標準の値が使われます。  [#]_

   ``'r+'``、``'w+'``、および ``'a+'`` はファイルを更新 モードで開きます (``'w+'`` はファイルがすでに存在すれば切り詰め
   るので注意してください) 。バイナリとテキストファイルを区別する システムでは、ファイルをバイナリモードで開くためには ``'b'`` を追加してください
   (区別しないシステムでは ``'b'`` は無視されます)。

   標準の :cfunc:`fopen` における *mode* の値に加えて、 ``'U'`` または ``'rU'`` を使うことができます。 Python
   が全改行文字サポートを行っている (標準ではしています)　場合, ファイルがテキストファイルで開かれますが、行末文字として Unix における 慣行である
   ``'\n'`` 、Macintosh における慣行である ``'\r'``、 Windows における慣行である ``'\r\n'`` のいずれを使うことも
   できます。これらの改行文字の外部表現はどれも、Python プログラムからは ``'\n'`` に見えます。Python が全改行文字サポートなしで構築
   されている場合、*mode* ``'U'`` は通常のテキストモードと 同様になります。開かれたファイルオブジェクトはまた、:attr:`newlines`
   と呼ばれる属性を持っており、その値は ``None`` (改行が見つから なかった場合)、``'\n'``、``'\r'``、 ``'\r\n'``、
   または見つかった全ての改行タイプを含むタプルになります。

   ``'U'`` を取り除いた後のモードは ``'r'``、``'w'``、``'a'`` の いずれかで始まる、というのが Python における規則です。

   .. versionchanged:: 2.5
      モード文字列の先頭についての制限が導入されました.


.. function:: ord(c)

   長さ 1 の与えられた文字列に対し、その文字列が unicode オブジェクトならば Unicode
   コードポイントを表す整数を、8ビット文字列ならばそのバイトの値を返します。 たとえば、``ord('a')`` は整数 ``97`` を返し、
   ``ord(u'\u2020')`` は ``8224`` を返します。この値は 8ビット文字列に対する :func:`chr` の逆であり、unicode
   オブジェクトに対する :func:`unichr` の逆です。引数が unicode で Python が UCS2 Unicode
   対応版ならば、その文字のコードポイントは両端を含めて [0..65535] の範囲に 入っていなければなりません。この範囲から外れると文字列の長さが 2
   になり、 :exc:`TypeError` が送出されることになります。


.. function:: pow(x, y[, z])

   *x* の *y* 乗を返します; *z* があれば、 *x*  の *y* 乗に対する *z* のモジュロを返します  (``pow(x, y)% z``
   より効率よく計算 されます)。引数二つの ``pow(x, y)`` という形式は、 冪乗演算子を使った ``x**y`` と等価です。

   引数は数値型でなくてはなりません。型混合の場合、 2 進算術演算における型強制規則が適用されます。通常整数
   および長整数の被演算子に対しては、二つ目の引数が負の数でない 限り、結果は (型強制後の)被演算子と同じ型になります;
   負の場合、全ての引数は浮動小数点型に変換され、浮動小数点 型の結果が返されます。例えば、 ``10**2`` は ``100``  を返しますが、
   ``100**-2`` は ``0.01`` を返します。 (最後に述べた機能は Python 2.2 で追加されたものです。 Python 2.1
   以前では、双方の引数が整数で二つ目の値が負の 場合、例外が送出されます。) 二つ目の引数が負の場合、 三つめの引数は無視されます。*z* がある場合、*x*
   および *y* は整数型でなければならず、*y* は非負 の値でなくてはなりません。(この制限は Python 2.2 で追加 されました。 Python
   2.1 以前では、3 つの浮動小数点引数を 持つ ``pow()`` は浮動小数点の丸めに関する偶発誤差 により、プラットフォーム依存の結果を返します。)


.. function:: property([fget[, fset[, fdel[, doc]]]])

   新しい形式のクラス (:class:`object` から導出されたクラス) における プロパティ属性を返します。

   *fget* は属性値を取得するための関数で、同様に *fset* は 属性値を設定するための関数です。また、*fdel* は属性を
   削除するための関数です。以下に属性 x を扱う典型的な利用法を示します::

      class C(object):
          def __init__(self): self._x = None
          def getx(self): return self._x
          def setx(self, value): self._x = value
          def delx(self): del self._x
          x = property(getx, setx, delx, "I'm the 'x' property.")

   *doc* がもし与えられたならばそれがプロパティ属性のドキュメント文字列になります。 与えられない場合、プロパティは *fget*
   のドキュメント文字列(がもしあれば)を コピーします。これにより、読み取り専用プロパティを :func:`property` を
   デコレータとして使って容易に作れるようになります。 ::

      class Parrot(object):
          def __init__(self):
              self._voltage = 100000

          @property
          def voltage(self):
              """Get the current voltage."""
              return self._voltage

   のようにすると、:meth:`voltage` が同じ名前の読み取り専用属性 の "getter" になります。

   .. versionadded:: 2.2

   .. versionchanged:: 2.5
      *doc* が与えられない場合に *fget* の ドキュメント文字列を使う .


.. function:: range([start,] stop[, step])

   数列を含むリストを生成するための多機能関数です。:keyword:`for`  ループでよく使われます。引数は通常の整数でなければなりません。 *step*
   引数が無視された場合、標準の値 ``1`` になります。 *start* 引数が蒸しされた場合標準の値 ``0`` になります。 完全な形式では、通常の整数列
   ``[start, start + step, start + 2 * step, ...]`` を返します。 *step* が正の値の場合、最後の要素は
   *stop* よりも小さい ``start + i * step`` の最大値になります; *step* が負の値の場合、最後の要素は *stop*
   よりも大きい ``start + i * step`` の最小値になります。 *step* はゼロであってはなりません (さもなければ
   :exc:`ValueError` が送出されます)。以下に例を示します::

      >>> range(10)
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      >>> range(1, 11)
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      >>> range(0, 30, 5)
      [0, 5, 10, 15, 20, 25]
      >>> range(0, 10, 3)
      [0, 3, 6, 9]
      >>> range(0, -10, -1)
      [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
      >>> range(0)
      []
      >>> range(1, 0)
      []


.. function:: raw_input([prompt])

   引数 *proompt* が存在する場合、末尾の改行を除いて標準出力に出力 されます。次に、この関数は入力から 1 行を読み込んで文字列に変換して
   (末尾の改行を除いて) 返します。EOF が読み込まれると :exc:`EOFError` が送出されます。以下に例を示します::

      >>> s = raw_input('--> ')
      --> Monty Python's Flying Circus
      >>> s
      "Monty Python's Flying Circus"

   :mod:`readline` モジュールが読み込まれていれば、:func:`input` は精緻な行編集およびヒストリ機能を提供します。


.. function:: reduce(function, sequence[, initializer])

   *sequence* の要素に対して、シーケンスを単一の値に短縮するような形で 2 つの引数をもつ *function* を左から右に累積的に適用します。
   例えば、``reduce(labmda x, y: x+y, [1, 2, 3, 4, 5])`` は ``((((1+2)+3)+4)+5)``
   を計算します。左引数*x* は累計の値になり、右引数 *y* は``sequence`` から取り出した 更新値になります。オプションの
   *initializer* が存在する場合、計算の際にシーケンスの先頭に置かれます。また、
   シーケンスが空の場合には標準の値になります。*initializer* が与えられて おらず、*sequence* が単一の要素しか持っていない場合、
   最初の要素が返されます。


.. function:: reload(module)

   すでにインポートされた *module* を再解釈し、再初期化します。 引数はモジュールオブジェクトでなければならないので、予めインポート
   に成功していなければなりません。この関数はモジュールのソースコード ファイルを外部エディタで編集して、Python インタプリタから
   離れることなく新しいバージョンを試したい際に有効です。 戻り値は (*module* 引数と同じ) モジュールオブジェクトです。

   ``reload(module)`` を実行すると、以下の処理が行われます:

* Python モジュールのコードは再コンパイルされ、 モジュールレベルのコードは再度実行されます。モジュールの辞書中に
     ある、何らかの名前に結び付けられたオブジェクトを新たに定義します。 拡張モジュール中の``init`` 関数が二度呼び出されることはありません。

* Python における他のオブジェクトと同様、以前のオブジェクトの メモリ領域は、参照カウントがゼロにならないかぎり再利用されません。

* モジュール名前空間内の名前は新しいオブジェクト (または更新された オブジェクト) を指すよう更新されます。

* 以前のオブジェクトが (外部の他のモジュールなどからの) 参照を 受けている場合、それらを新たなオブジェクトにバインドし直すことは
     ないので、必要なら自分で名前空間を更新せねばなりません。

   いくつか補足説明があります:

   モジュールは文法的に正しいが、その初期化には失敗した場合、 そのモジュールの最初の :keyword:`import` 文はモジュール名を
   ローカルにはバインドしませんが、(部分的に初期化された) モジュール オブジェクトを ``sys.modules`` に記憶します。従って、モジュールを
   ロードしなおすには、:func:`reload` する前にまず :keyword:`import`
   (モジュールの名前を部分的に初期化されたオブジェクトにバインドします) を再度行わなければなりません。

   モジュールが再ロードされた再、その辞書 (モジュールのグローバル変数を 含みます) はそのまま残ります。名前の再定義を行うと、以前の定義を
   上書きするので、一般的には問題はありません。新たなバージョンのモジュール が古いバージョンで定義された名前を定義していない場合、古い定義が そのまま残ります。
   辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、 この機能をモジュールを有効性を引き出すために使うことができます --- つまり、
   :keyword:`try` 文を使えば、必要に応じてテーブルがあるかどうかをテストし、 その初期化を飛ばすことができます::

      try:
          cache
      except NameError:
          cache = {}

   組み込みモジュールや動的にロードされるモジュールを再ロードする ことは、不正なやり方ではありませんが、一般的にそれほど便利では ありません。例外は
   :mod:`sys`、:mod:`__main__` および :mod:`__builtin__` です。 しかしながら、多くの場合、拡張モジュールは 1
   度以上初期化される ようには設計されておらず、再ロードされた場合には何らかの理由で 失敗するかもしれません。

   一方のモジュールが :keyword:`from` ... :keyword:`import` ...
   を使って、オブジェクトを他方のモジュールからインポートしているなら、 他方のモジュールを :func:`reload` で呼び出しても、その
   モジュールからインポートされたオブジェクトを再定義することは できません --- この問題を回避する一つの方法は、:keyword:`from` 文を
   再度実行することで、もう一つの方法は :keyword:`from` 文の代わりに :keyword:`import` と限定的な名前
   (*module*.*name*) を使うことです。

   あるモジュールがクラスのインスタンスを生成している場合、その クラスを定義しているモジュールの再ロードはそれらインスタンスの メソッド定義に影響しません ---
   それらは古いクラス定義を使いつづけ ます。これは導出クラスの場合でも同じです。


.. function:: repr(object)

   オブジェクトの印字可能な表現を含む文字列を返します。これは 型変換で得られる (逆クオートの) 値と同じです。通常の関数として
   この操作にアクセスできるとたまに便利です。この関数は多くの型について、 :func:`eval` に渡されたときに同じ値を持つようなオブジェクトを
   表す文字列を生成しようとします。


.. function:: reversed(seq)

   要素を逆順に取り出すイテレータ (reverse iterator) を返します。 *seq* はシーケンス型プロトコル (:meth:`__len__`
   メソッド、および ``0`` から始まる整数を引数にとる:meth:`__getitem__` メソッド) をサポートしていなければなりません。

   .. versionadded:: 2.4


.. function:: round(x[, n])

   *x* を小数点以下 *n* 桁で丸めた浮動小数点数の値を返します。 *n* が省略されると、標準の値はゼロになります。結果は浮動小数点 数です。値は最も近い
   10 のマイナス *n* の倍数に丸められます。 二つの倍数との距離が等しい場合、ゼロから離れる方向に丸められます (従って、例えば
   ``round(0.5)`` は ``1.0`` になり、 ``round(-0.5)`` は ``-1.0`` になります)。


.. function:: set([iterable])

   集合を表現する:class:`set` 型オブジェクトを返します。要素は  *iterable* から取得します。要素は変更不能でなければなりません。
   集合の集合を表現するには、内集合は :class:`frozenset` オブジェクト でなければなりません。*iterable* を指定しない場合、
   新たな空の :class:`set` 型オブジェクト、``set([])`` を返します。

   .. versionadded:: 2.4


.. function:: setattr(object, name, value)

   :func:`getattr` と対をなす関数です。引数はそれぞれオブジェクト、 文字列、そして任意の値です。文字列はすでに存在する属性の名前でも、
   新たな属性の名前でもかまいません。この関数は指定した値を指定した属性に 関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。
   例えば、``setattr(x, 'foobar', 123)`` は ``x.foobar = 123`` と等価です。


.. function:: sorted(iterable[, cmp[, key[, reverse]]])

   *iterable* の要素をもとに、並べ替え済みの新たなリストを 生成して返します。 オプション引数*cmp*、*key*、および *reverse*
   の意味は :meth:`list.sort` メソッドと同じです。 (:ref:`typesseq-mutable`節に説明があります。)

   *cmp* は2つの引数(iterable の要素)からなるカスタムの比較関数を指定します。
   これは始めの引数が2つ目の引数に比べて小さい、等しい、大きいかに応じて 負数、ゼロ、正数を返します。 ``cmp=lambda x,y:
   cmp(x.lower(), y.lower())``

   *key* は1つの引数からなる関数を指定します。これは個々のリストの要素から 比較のキーを取り出すのに使われます。 ``key=str.lower``

   *reverse* は真偽値です。 ``True`` がセットされた場合、リストの要素は 個々の比較が反転したものとして並び替えられます。

   一般的に、 *key* および *reverse* の変換プロセスは同等の *cmp* 関数を 指定するより早く動作します。これは *key* および
   *reverse* がそれぞれの要素に 一度だけ触れる間に、*cmp* はリストのそれぞれの要素に対して複数回呼ばれることに よるものです。

   .. versionadded:: 2.4


.. function:: slice([start,] stop[, step])

   .. index:: single: Numerical Python

   ``range(start, stop, step)`` で指定される インデクスの集合を表すスライスオブジェクトを返します。
   ``range(start)``スライスオブジェクトを返します。 引数 *start* および *step* は標準では ``None`` です。
   スライスオブジェクトは読み出し専用の属性 :attr:`start`、:attr:`stop` および :attr:`step`
   を持ち、これらは単に引数で使われた値 (または 標準の値) を返します。これらの値には、その他のはっきりとした機能は ありません; しかしながら、これらの値は
   Numerical Python   およびその他のサードパーティによる拡張 で利用されています。スライスオブジェクトは拡張されたインデクス指定
   構文が使われる際にも生成されます。例えば: ``a[start:stop:step]``  や ``a[start:stop, i]`` です。


.. function:: staticmethod(function)

   *function* の静的メソッドを返します。

   静的メソッドは暗黙の第一引数を受け取りません。 静的メソッドの宣言は、以下のように書き慣わされます::

      class C:
          @staticmethod
          def f(arg1, arg2, ...): ...

   ``@staticmethod`` は関数デコレータ形式です。詳しくは ../ref/function.htmlPython リファレンスマニュアル の 7
   章にある関数定義についての説明を参照してください。

   このメソッドはクラスで呼び出すこと (例えば C.f() ) も、 インスタンスとして呼び出すこと (例えば C().f()) もできます。
   インスタンスはそのクラスが何であるかを除いて無視されます。

   Python における静的メソッドは Java や C++ における静的メソッドと 類似しています。より進んだ概念については、
   :func:`classmethod` を参照してください。

   もっと静的メソッドについての情報が必要ならば、 Python リファレンスマニュアル (XXX reference: ../ref/types.html)
   の3章にある標準型階層についてのドキュメントを繙いてください。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      関数デコレータ構文を追加しました.


.. function:: str([object])

   オブジェクトをうまく印字可能な形に表現したものを含む文字列を返します。 文字列に対してはその文字列自体を返します。``repr(object)``
   との違いは、``str(object)`` は常に :func:`eval` が 受理できるような文字列を返そうと試みるわけではないという点です;
   この関数の目的は印字可能な文字列を返すところにあります。 引数が与えられなかった場合、空の文字列 ``''`` を返します。


.. function:: sum(sequence[, start])

   *start* と *sequence* の要素を左から右へ加算してゆき、 総和を返します。*start* はデフォルトで ``0`` です。
   *sequence* の要素は通常は数値で、文字列であってはなりません。 文字列からなるシーケンスを結合する高速かつ正しい方法は
   ``''.join(sequence)`` です。 ``sum(range(n), m)`` は ``reduce(operator.add,
   range(n), m)`` と同等です。

   .. versionadded:: 2.3


.. function:: super(type[, object-or-type])

   *type* の上位クラスを返します。返された上位クラスオブジェクトが非バ インドの場合、二つめの引数は省略されます。二つめの引数がオブジェクトの場
   合、``isinstance(obj, type)`` は真でなくてはなりません。 二つ目の引数が型オブジェクトの場合、``issubclass(type2,
   type)`` は真でなくてはなりません。 :func:`super` は新スタイルのクラスにのみ機能します。

   協調する上位クラスのメソッドを呼び出す典型的な利用法を以下に示します::

      class C(B):
          def meth(self, arg):
              super(C, self).meth(arg)

   :func:`super` は``super(C, self).__getitem__(name)`` のような
   明示的なドット表記の属性参照の一部として使われているので注意してください。 これに伴って、:func:`super` は``super(C,
   self)[name]`` のような 文や演算子を使った非明示的な属性参照向けには定義されていないので 注意してください。

   .. versionadded:: 2.2


.. function:: tuple([sequence])

   *sequence* の要素と要素が同じで、かつ順番も同じになるタプルを 返します。*sequence* はシーケンス、反復をサポートするコンテナ、
   およびイテレータオブジェクトをとることができます。 *sequence* がすでにタプルの場合、そのタプルを変更せずに返します。
   例えば、``tuple('abc')`` は ``('a', 'b', 'c')`` を返し、 ``tuple([1, 2, 3])`` は ``(1, 2,
   3)`` を返します。


.. function:: type(object)

   *object* の型を返します。オブジェクトの型の検査には :func:`isinstance` 組み込み関数を使うことが推奨されます。

   3 引数で呼び出された場合には :func:`type` 関数は後述するように コンストラクタとして働きます。


.. function:: type(name, bases, dict)

   新しい型オブジェクトを返します。本質的には :keyword:`class` 文の動的な形です。 *name*
   文字列はクラス名で、:attr:`__name__` 属性になります。 *bases* タプルは基底クラスの羅列で、:attr:`__bases__`
   属性になります。 *dict* 辞書はクラス本体の定義を含む名前空間で、:attr:`__dict__` 属性になります。 たとえば、以下の二つの文は同じ
   :class:`type` オブジェクトを作ります::

      >>> class X(object):
      ...     a = 1
      ...     
      >>> X = type('X', (object,), dict(a=1))

   .. versionadded:: 2.2


.. function:: unichr(i)

   Unicode におけるコードが整数 *i* になるような文字 1 文字からなる Unicode 文字列を返します。例えば、``unichr(97)``
   は文字列 ``u'a'`` を返します。この関数は Unicode 文字列に対する :func:`ord` の逆 です。引数の正当な範囲は Python
   がどのように構成されているかに依存しています --- UCS2 ならば [0..0xFFFF] であり UCS4 ならば [0..0x10FFFF] であり、
   このどちらかです。 それ以外の値に対しては  :exc:`ValueError` が送出されます。

   .. versionadded:: 2.0


.. function:: unicode([object[, encoding [, errors]]])

   以下のモードのうち一つを使って、*object* のUnicode 文字列 バージョンを返します:

   もし *encoding* かつ/または *errors* が与えられていれば、 ``unicode()`` は 8
   ビットの文字列または文字列バッファになっている オブジェクトを *encoding* の codec を使ってデコードします。 *encoding*
   パラメタはエンコーディング名を与える文字列です; 未知のエンコーディングの場合、:exc:`LookupError` が送出されます。 エラー処理は
   *errors* に従って行われます; このパラメタは 入力エンコーディング中で無効な文字の扱い方を指定します。*errors* が ``'strict'``
   (標準の設定です) の場合、エラー発生時には :exc:`ValueError` が送出されます。一方、``'ignore'`` では、
   エラーは暗黙のうちに無視されるようになり、``'replace'`` では 公式の置換文字、``U+FFFD`` を使って、デコードできなかった
   文字を置き換えます。:mod:`codecs` モジュールについても参照して ください。

   オプションのパラメタが与えられていない場合、 ``unicode()`` は ``str()`` の動作をまねます。ただし、8 ビット文字列ではなく、
   Unicode 文字列を返します。もっと詳しくいえば、 *object* が Unicode 文字列かそのサブクラスなら、デコード処理を一切介する ことなく
   Unicode 文字列を返すということです。

   :meth:`__unicode__` メソッドを提供しているオブジェクトの場合、 :func:`unicode` はこのメソッドを引数なしで呼び出して
   Unicode 文字列を生成します。それ以外のオブジェクトの場合、 8 ビットの文字列か、オブジェクトのデータ表現 (representation)
   を呼び出し、その後デフォルトエンコーディングで ``'strict'`` モードの codec を使って Unicode 文字列に変換します。

   .. versionadded:: 2.0

   .. versionchanged:: 2.2
      :meth:`__unicode__` のサポートが追加されました.


.. function:: vars([object])

   引数無しでは、現在のローカルシンボルテーブルに対応する辞書を 返します。モジュール、クラス、またはクラスインスタンスオブジェクト (またはその他
   :attr:`__dict__` 属性を持つもの) を引数として与えた場合、 そのオブジェクトのシンボルテーブルに対応する辞書を返します。
   返される辞書は変更すべきではありません: 変更が対応するシンボルテーブル にもたらす影響は未定義です。 [#]_


.. function:: xrange([start,] stop[, step])

   この関数は :func:`range` に非常によく似ていますが、リストの代わり に "xrange オブジェクト" を返します。このオブジェクトは不透明な
   シーケンス型で、対応するリストと同じ値を持ちますが、それらの値全てを 同時に記憶しません。:func:`ragne` に対する :func:`xrange`
   の利点は微々たるものです (:func:`xrange` は要求に応じて 値を生成するからです) ただし、メモリ量の厳しい計算機で
   巨大な範囲の値を使う時や、(ループがよく :keyword:`break` で中断 されるといったように) 範囲中の全ての値を使うとは限らない場合は
   その限りではありません。

   .. note::

      :func:`xrange` はシンプルさと速度のために定義されている 関数であり、その実現のために実装上の制限を課している場合があります。 Python の
      C 実装では、全ての引数をネイティブの C long 型 (Python の "short" 整数型) に制限しており、要素数がネイティブの C long 型の
      範囲内に収まるよう要求しています。


.. function:: zip([iterable, ...])

   この関数はタプルのリストを返します。このリストの *i* 番目のタプルは 各引数のシーケンスまたはイテレート可能オブジェクト中の *i* 番目の要素を含みます。
   返されるリストは引数のシーケンスのうち長さが最小のものの 長さに切り詰められます。引数が全て同じ長さの際には、 :func:`zip` は初期値引数が
   ``None`` の :func:`map`  と似ています。引数が単一のシーケンスの場合、1 要素のタプルからなる
   リストを返します。引数を指定しない場合、空のリストを返します。

   .. versionadded:: 2.0

   .. versionchanged:: 2.4
      これまでは、:func:`zip` は少なくとも一つの引数を 要求しており、空のリストを返す代わりに :exc:`TypeError` を送出 していました.

.. % ---------------------------------------------------------------------------


.. _non-essential-built-in-funcs:

非必須組み込み関数 (Non-essential Built-in Functions)
=====================================================

いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、 必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。
こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性を 維持するだけの目的で残されています。

Python のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ばしても かまわず、その際に何か重要なことを忘れていると思う必要もありません。


.. function:: apply(function, args[, keywords])

   引数 *function* は呼び出しができるオブジェクト (ユーザ定義 および組み込みの関数またはメソッド、またはクラスオブジェクト)
   でなければなりません。*args* はシーケンス型でなくてはなりません。 *function* は引数リスト *args* を使って呼び出されます;
   引数の数はタプルの長さになります。オプションの引数 *keywords*  を与える場合、 *keywords* は文字列のキーを持つ辞書で
   なければなりません。これは引数リストの最後に追加されるキーワード 引数です。 :func:`apply` の呼び出しは、単なる
   ``function(args)`` の呼び出しとは異なります。 というのは、:func:`apply` の場合、引数は常に一つだから
   です。:func:`apply` は ``function(*args, **keywords)`` を 使うのと等価です。 上のような
   "拡張された関数呼び出し構文" は :func:`apply`  と全く等価なので、必ずしも :func:`apply` を使う必要はありません。

   .. deprecated:: 2.3
      上で述べられたような拡張呼び出し構文を使って ください。


.. function:: buffer(object[, offset[, size]])

   引数 *object* を参照する新たなバッファオブジェクトが生成されます。 引数 *object* は (文字列、アレイ、バッファといった) バッファ
   呼び出しインタフェースをサポートするオブジェクトでなければなりません。 返されるバッファオブジェクトは *object* の先頭 (または *offset*)
   からのスライスになります。スライスの末端は *object* の末端まで (または引数 *size* で与えられた長さになるまで) です。


.. function:: coerce(x, y)

   二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを 返します。変換に使われる規則は算術演算における規則と同じです。
   型変換が不可能である場合、:exc:`TypeError` を送出します。


.. function:: intern(string)

   *string* を "隔離" された文字列のテーブルに入力し、隔離された 文字列を返します -- この文字列は *string* 自体かコピーです。
   隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに 有効です -- 辞書中のキーが隔離されており、検索するキーが隔離されて
   いる場合、(ハッシュ化後の) キーの比較は文字列の比較ではなくポインタ の比較で行うことができるからです。通常、Python プログラム内で
   利用されている名前は自動的に隔離され、モジュール、クラス、 またはインスタンス属性を保持するための辞書は隔離されたキーを持って います。

   .. versionchanged:: 2.3
      隔離された文字列の有効期限は (Python 2.2  またはそれ以前は永続的でしたが) 永続的ではなくなりました; :func:`intern`
      の恩恵を受けるためには、:func:`intern` の返す値に対する参照を保持しなければなりません.

.. rubric:: Footnotes

.. [#] この関数は比較利用されない 方なので、将来構文にするかどうかは保証できません。

.. [#] 現状では、:cfunc:`setvbuf` を持っていないシステムでは、 バッファサイズを指定しても効果はありません。バッファサイズを指定
   するためのインタフェースは :cfunc:`setvbuf` を使っては 行われていません。 何らかの I/O
   が実行された後で呼び出されるとコアダンプすることが あり、どのような場合にそうなるかを決定する信頼性のある方法が ないからです。

.. [#] 現在の実装では、ローカルな値 のバインディングは通常は影響を受けませんが、(モジュールのような) 他のスコープから取り出した値は影響を受けるかもしれません。また
   この実装は変更されるかもしれません。



:mod:`re` --- 正規表現操作
====================

.. module:: re
.. moduleauthor:: Fredrik Lundh <fredrik@pythonware.com>
.. sectionauthor:: Andrew M. Kuchling <amk@amk.ca>




このモジュールでは、Perl で見られるものと同様な正規表現マッチング操作 を提供しています。正規表現のパターン文字列にはヌルバイトを含められませ
んが、``\number`` 記法を使えばヌルバイトを指定できます。 パターンと検索対象文字列の両方について、 8 ビット文字列と Unicode 文字
列を同じように扱えます。:mod:`re` モジュールはいつでも利用できます。

正規表現では、特殊な形式を表したり、特殊文字の持つ特別な意味を呼び出さ ずにその特殊な文字を使えるようにするために、バックスラッシュ文字 (``'\'``)
を使います。こうしたバックスラッシュの使い方は、 Python の文字列リテラルにおける同じバックスラッシュ文字と衝突を起こし
ます。例えば、バックスラッシュ自体にマッチさせるには、パターン文字列と して``'\\\\'`` と書かなければなりません、というのも、正規表現は ``\\``
でなければならず、さらに正規な Python 文字列リテラルでは各々 のバックスラッシュを ``\\`` と表現せねばならないからです。

正規表現パターンに Python の raw string 記法を使えばこの問題を解決でき
ます。``'r'``を前置した文字列リテラル内ではバックスラッシュを特 別扱いしません。従って、``"\n"`` が改行一文字の入った文字列になる
のに対して、``r"\n"`` は ``'\'`` と``'n'``という二つ の文字の入った文字列になります。通常、 Python コード中では、パターンを
この raw string 記法を使って表現します。


.. seealso::

   Mastering Regular Expressions 詳説 正規表現
      Jeffrey Friedl 著、O'Reilly 刊の正規表現に関する本です。この本の第2版
      ではPyhonについては触れていませんが、良い正規表現パターンの書き方を非 常にくわしく説明しています。

      .. % 


.. _re-syntax:

正規表現のシンタクス
----------

正規表現 (すなわち RE) は、表現にマッチ (match) する文字列の集合を表し ています。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッ
チするか (または指定の正規表現がある文字列にマッチするか、つまりは同じ ことですが) を検査できます。

正規表現を連結すると新しい正規表現を作れます。*A* と *B* が ともに正規表現であれば *AB* も正規表現です。一般的に、文字列 *p* が A
とマッチし、別の文字列 *q* が B とマッチすれば、文 字列 *pq*は AB にマッチします。ただし、この状況が成り立つのは、 *A* と *B*
との間に境界条件がある場合や、番号付けされたグルー プ参照のような、優先度の低い演算を*A* や *B* が含まない場合 だけです。
かくして、ここで述べるような、より簡単でプリミティブな正規表現から、 複雑な正規表現を容易に構築できます。正規表現に関する理論と実装の詳細に ついては上記の
Friedl 本か、コンパイラの構築に関する教科書を調べて下さ い。

以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な情報や
よりやさしい説明に関しては、`<http://www.python.org/doc/howto/>`_ からアクセスできる正規表現ハウツウを調べて下さい。

正規表現には、特殊文字と通常文字の両方を含められます。``'A'``、 ``'a'``、あるいは ``'0'``のようなほとんどの通常文字は最も
簡単な正規表現になります。こうした文字は、単純にその文字自体にマッチし ます。通常の文字は連結できるので、``last`` は文字列
``'last'``とマッチします。(この節の以降の説明では、正規表現を引用符 を使わずに``この表示スタイル: special style``
で書き、マッチ対象 の文字列は、``'引用符で括って'`` 書きます。)

``'|'`` や ``'('`` といったいくつかの文字は特殊文字です。 特殊文字は通常の文字の種別を表したり、あるいは特殊文字の周辺にある通常
の文字に対する解釈方法に影響します。

特殊文字を以下に示します:

.. % 

``'.'``
   (ドット)  デフォルトのモードでは改行以外の任意の文字にマッチします。 :const:`DOTALL` フラグが指定されていれば改行も含むすべての文字にマッ
   チします。

``'^'``
   (キャレット)  文字列の先頭とマッチします。:const:`MULTILINE` モードでは各改行の直 後にマッチします。

``'$'``
   文字列の末尾、あるいは文字列の末尾の改行の直前にマッチします。例えば、 ``foo`` は 'foo' と 'foobar'
   の両方にマッチします。一方、正規表現 ``foo$``は 'foo' だけとマッチします。興味深いことに、 'foo1\\nfoo2\\n' を
   ``foo.$`` で検索し た場合、通常のモードでは 'foo2' だけにマッチし、:const:`MULTILINE` モードでは 'foo1'
   にもマッチします。

``'*'``
   直前にある RE に作用して、 RE を 0 回以上できるだけ多く繰り返したもの にマッチさせるようにします。例えば ``ab*`` は
   'a'、'ab'、あるいは 'a' に任意個数の'b' を続けたものにマッチします。

``'+'``
   直前にある RE に作用して、 RE を、1 回以上繰り返したものにマッチさせる ようにします。例えば ``ab+`` は 'a' に一つ以上の 'b'
   が続いたも のにマッチし、 'a' 単体にはマッチしません。

``'?'``
   直前にある RE に作用して、 RE を 0 回か 1 回繰り返したものにマッチさせ るようにします。例えば ``ab?`` は 'a' あるいは 'ab'
   にマッチしま す。

``*?``, ``+?``, ``??``
   ``'*'``、``'+'``、 ``'?'`` といった修飾子は、すべて :dfn:`貪欲 (greedy)`
   マッチ、すなわちできるだけ多くのテキストにマッチす るようになっています。時にはこの動作が望ましくない場合もあります。例え ば正規表現 ``<.*>`` を
   ``'<H1>title</H1>'`` にマッチさせると、 ``'<H1>'`` だけにマッチするのではなく全文字列にマッチしてしまいます。
   ``'?'``を修飾子の後に追加すると、:dfn:`非貪欲 (non-greedy)` ある いは :dfn:`最小一致 (minimal)`
   のマッチになり、できるだけ *少ない* 文字数のマッチになります。例えば上の式で ``.*?``を使うと ``'<H1>'`` だけにマッチします。

``{m}``
   前にある RE の *m* 回の正確なコピーとマッチすべきであることを指定 します；マッチ回数が少なければ、RE 全体ではマッチしません。例えば、
   ``a{6}`` は、正確に 6個の ``'a'`` 文字とマッチしますが、 5個ではマッチしません。

``{m,n}``
   結果の RE は、前にある RE を、 *m*回から*n* 回まで繰り返したもので、 できるだけ多く繰り返したものとマッチするように、マッチします。
   例えば、``a{3,5}``は、3個から 5個の ``'a'`` 文字とマッチします。 *m*を省略するとマッチ回数の下限として0を指定した事になり、 *n*
   を省略することは、上限が無限であることを指定します； ``a{4,}b`` は ``aaaab``や、千個の ``'a'`` 文字に ``b``が
   続いたものとマッチしますが、``aaab``とはマッチしません。 コンマは省略できません、そうでないと修飾子が上で述べた形式と混同されてしまうからです。

``{m,n}?``
   結果の RE は、前にある RE の *m*回から*n* 回まで繰り返したもので、できるだけ*少なく*
   繰り返したものとマッチするように、マッチします。これは、前の修飾子の 控え目バージョンです。 例えば、 6文字 文字列
   ``'aaaaaa'``では、``a{3,5}`` は、5個の ``'a'`` 文字とマッチしますが、``a{3,5}?`` は3個の文字と
   マッチするだけです。

``'\'``
   特殊文字をエスケープする( ``'*'``や ``'?'``等のような文字との マッチをできるようにする)か、あるいは、特殊シーケンスの合図です;
   特殊シーケンスは後で議論します。

   もしパターンを表現するのに raw string を使用していないのであれば、 Python も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして
   使っていることを覚えていて下さい；もしエスケープシーケンスを Python の構文解析器が認識して処理しなければ、そのバックスラッシュと
   それに続く文字は、結果の文字列にそのまま含まれます。しかし、もし Python が 結果のシーケンスを認識するのであれば、バックスラッシュを 2回
   繰り返さなければ いけません。このことは複雑で理解しにくいので、 最も簡単な表現以外は、 すべて raw string を使うことをぜひ勧めます。

``[]``
   文字の集合を指定するのに使用します。文字は個々に リストするか、文字の範囲を、2つの文字と``'-'``でそれらを分離
   して指定することができます。特殊文字は集合内では有効ではありません。 例えば、``[akm$]``は、文字 ``'a'``、``'k'``、
   ``'m'``、あるいは ``'$'``のどれかとマッチします； ``[a-z]`` は、任意の小文字と、``[a-zA-Z0-9]`` は、
   任意の文字や数字とマッチします。 (以下で定義する) ``\w`` や``\S``のような 文字クラスも、範囲に含めることができます。もし文字集合に
   ``']'`` や ``'-'`` を含めたいのなら、その前にバックスラッシュを 付けるか、それを最初の文字として指定します。たとえば、パターン ``[]]``
   は ``']'`` とマッチします。

   範囲内にない文字とは、その集合の:dfn:`補集合をとること`で マッチすることができます。これは、集合の最初の文字として ``'^'``
   を含めることで表すことができます； 他の場所にある ``'^'``は、単純に ``'^'``文字とマッチするだけです。例えば、 ``[^5]`` は、
   ``'5'``以外の任意の文字とマッチし、 ``[^^]`` は、 ``'^'`` 以外の任意の文字とマッチします。

``'|'``
   ``A|B`` は、ここで A と B は任意の RE ですが、 A か B のどちらかとマッチする正規表現を作成します。任意個数の RE を、 こういう風に
   ``'|'`` で分離することができます。これはグループ (以下参照) 内部でも同様に使えます。検査対象文字列をスキャンする中で、 ``'|'`` で分離された
   RE は左から右への順に検査されます。 一つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。 このことは、もし ``A``
   がマッチすれば、たとえ``B`` によるマッチが 全体としてより長いマッチになったとしても、``B`` を決して検査しないことを 意味します。
   言いかえると、``'|'`` 演算子は決して貪欲 (greedy) ではありません。 文字通りの ``'|'``とマッチするには、``\|`` を使うか、
   あるいはそれを ``[|]`` のように文字クラス内に入れます。

``(...)``
   丸括弧の中にどのような正規表現があってもマッチし、 またグループの先頭と末尾を表します；グループの中身は、マッチが 実行された後に検索され、後述する
   ``\number`` 特殊シーケンス付きの文字列内で、後でマッチされます。 文字通りの ``'('`` や ``')'``とマッチするには、 ``\(``
   あるいは ``\)`` を 使うか、それらを文字クラス内に入れます： ``[(] [)]``。

``(?...)``
   これは拡張記法です( ``'('`` に続く``'?'``は他には意味がありません)。 ``'?'``の後の最初の文字が、この構造の意味とこれ以上の
   シンタクスがどういうものであるかを決定します。 拡張記法は普通新しいグループを作成しません； ``(?P<name>...)``がこの規則の唯一の例外です。
   以下に現在サポートされている拡張記法を示します。

``(?iLmsux)``
   ( 集合 ``'i'``、``'L'``、 ``'m'``、 ``'s'``、``'u'``、``'x'``
   から1文字以上)。グループは空文字列ともマッチします；文字は、 正規表現全体の対応するフラグ (:const:`re.I`、 :const:`re.L`、
   :const:`re.M`、 :const:`re.S`、 :const:`re.U`、 :const:`re.X` ) を設定します。 これはもし*flag*
   引数を:func:`compile` 関数に渡さずに、そのフラグを正規表現の一 部として含めたいならば 役に立ちます。

   ``(?x)`` フラグは、式が構文解析される 方法を変更することに注意して下さい。 これは式文字列内の最初か、あるいは1つ以上の空白文字の後で使うべきです。
   もしこのフラグの前に非空白文字があると、その結果は未定義です。

``(?:...)``
   正規表現の丸括弧の非グループ化バージョンです。 どのような正規表現が丸括弧内にあってもマッチしますが、 グループによってマッチされたサブ文字列は、
   マッチを実行したあと検索されることも、あるいは後でパターンで 参照されることも *できません*。

``(?P<name>...)``
   正規表現の丸括弧と同様ですが、 グループによってマッチされたサブ文字列は、記号グループ名 *name*を介してアクセスできます。グループ名は、正しい
   Python 識別子でなければならず、各グループ名は、正規表現内で一度だけ定義され
   なければなりません。記号グループは、グループに名前が付けられていない場合のように、 番号付けされたグループでもあります。そこで上の例で
   'id'という名前がついた グループは、番号グループ 1 として参照することもできます。

   たとえば、もしパターンが ``(?P<id>[a-zA-Z_]\w*)``であれば、このグループは、 マッチオブジェクトのメソッドへの引数に、
   ``m.group('id')`` あるいは ``m.end('id')``のような名前で、 またパターンテキスト内(例えば、 ``(?P=id)``) や
   置換テキスト内( ``\g<id>``のように) で名前で参照することができます。

``(?P=name)``
   前に *name* と名前付けされたグループに マッチした、いかなるテキストにもマッチします。

``(?#...)``
   コメントです；括弧の内容は 単純に無視されます。

``(?=...)``
   もし ``...``が次に続くものとマッチすればマッチしますが、 文字列をまったく消費しません。これは先読みアサーション(lookahead
   assertion)と呼ばれます。 例えば、``Isaac (?=Asimov)`` は、``'Isaac '``に
   ``'Asimov'``が続く場合だけ、``'Isaac '``とマッチします。

``(?!...)``
   もし ``...`` が次に続くものとマッチしなければマッチします。 これは否定先読みアサーション(negative lookahead
   assertion)です。例えば、 ``Isaac (?!Asimov)``は、``'Isaac '`` に
   ``'Asimov'``が続か*ない*場合のみマッチします。

``(?<=...)``
   もし文字列内の現在位置の前に、 現在位置で終わる ``...`` とのマッチがあれば、マッチします。 これは
   :dfn:`肯定後読みアサーション(positive lookbehind assertion)`と呼ばれます。 ``(?<=abc)def``
   は、``abcdef`` にマッチを見つけます、 というのは後読みが3文字をバックアップして、含まれているパターンと
   マッチするかどうか検査するからです。含まれるパターンは、 固定長の文字列にのみマッチしなければなりません、ということは、 ``abc`` や ``a|b``
   は許されますが、 ``a*`` や ``a{3,4}`` は許されないことを意味します。 肯定後読みアサーションで始まるパターンは、検索される文字列の
   先頭とは決してマッチしないことに注意して下さい； 多分、:func:`match` 関数よりは :func:`search`関数を使いたいでしょう： ::

      >>> import re
      >>> m = re.search('(?<=abc)def', 'abcdef')
      >>> m.group(0)
      'def'

   この例ではハイフンに続く単語を探します： ::

      >>> m = re.search('(?<=-)\w+', 'spam-egg')
      >>> m.group(0)
      'egg'

``(?<!...)``
   もし文字列内の現在位置の前に ``...``との マッチがないならば、マッチします。これは :dfn:`否定後読みアサーション(negative
   lookbehind assertion)`と呼ばれます。 肯定後読みアサーションと同様に、含まれるパターンは固定長さの文字列だけに
   マッチしなければいけません。否定後読みアサーションで始まるパターンは、 検索される文字列の先頭とマッチすることができます。

``(?(id/name)yes-pattern|no-pattern)``
   グループに *id* が与えられている、もしくは *name* があるとき、``yes-pattern``  とマッチします。存在しないときには
   ``no-pattern`` とマッチします。 ``|no-pattern`` はオプションで省略できます。例えば
   ``(<)?(\w+@\w+(?:\.\w+)+)(?(1)>)``  はemailアドレスとマッチする 最低限のパターンです。これは
   ``'<user@host.com>'`` や ``'user@host.com'`` にはマッチしますが、 ``'<user@host.com'``
   にはマッチしません。

   .. versionadded:: 2.4

特殊シーケンスは ``'\'`` と以下のリストにある文字から 構成されます。もしリストにあるのが通常文字でないならば、結果の RE は
2番目の文字とマッチします。例えば、 ``\$`` は文字 ``'$'``とマッチします。

.. % 

``\number``
   同じ番号のグループの中身とマッチします。 グループは1から始まる番号をつけられます。例えば、 ``(.+) \1`` は、``'the the'`` あるいは
   ``'55 55'``とマッチしますが、 ``'the end'``とはマッチしません(グループの後のスペースに注意して下さい)。 この特殊シーケンスは最初の
   99 グループのうちの一つとマッチするのに使うことが できるだけです。もし *number*の最初の桁が 0 である、すなわち *number*が 3
   桁の8進数であれば、それはグループのマッチとは解釈されず、 8進数値 *number* を持つ文字として解釈されます。 文字クラスの ``'['``と
   ``']'``の中の数値エスケープは、文字として 扱われます。

``\A``
   文字列の先頭だけにマッチします。

``\b``
   空文字列とマッチしますが、単語の先頭か末尾の時だけです。 単語は英数字あるいは下線文字の並んだものとして定義されていますので、単語の末尾は
   空白あるいは非英数字、非下線文字によって表されます。 ``\b`` は、``\w`` と ``\W``の間の境界として定義されているので、
   英数字であると見なされる文字の正確な集合は、``UNICODE``と``LOCALE``フラグの 値に依存することに注意して下さい。
   文字の範囲の中では、``\b`` は、 Python の文字列リテラルと互換性を持たせるために、 後退(backspace)文字を表します。

``\B``
   空文字列とマッチしますが、それが単語の先頭あるいは末尾に *ない*時だけです。これは ``\b``のちょうど反対ですので、 ``LOCALE``
   と``UNICODE``の設定にも影響されます。

``\d``
   :const:`UNICODE` フラグが指定されていない場合、 任意の十進数とマッチします；これは集合 ``[0-9]`` と同じ意味です。
   :const:`UNICODE` がある場合、Unicode 文字特性データベースで 数字と分類されているものにマッチします。

``\D``
   :const:`UNICODE` フラグが指定されていない場合、 任意の非数字文字とマッチします；これは集合 ``[^0-9]`` と
   同じ意味です。:const:`UNICODE` がある場合、これは Unicode 文字 特性データベースで数字とマーク付けされている文字以外にマッチします。

``\s``
   :const:`LOCALE` と :const:`UNICODE` フラグが 指定されていない場合、任意の空白文字とマッチします；これは 集合 ``[
   \t\n\r\f\v]``と同じ意味です。

   :const:`LOCALE` がある場合、これはこの集合に加えて現在のロケールで 空白と定義されている全てにマッチします。:const:`UNICODE`
   が設定されると、 これは ``[ \t\n\r\f\v]`` と Unicode 文字特性データベースで 空白と分類されている全てにマッチします。

``\S``
   :const:`LOCALE` と :const:`UNICDOE` がフラグが 指定されていない場合、任意の非空白文字とマッチします；これは 集合 ``[^
   \t\n\r\f\v]`` と同じ意味です。 :const:`LOCALE` がある場合、これはこの集合に無い文字と、現在の
   ロケールで空白と定義されていない文字にマッチします。:const:`UNICODE` が 設定されていると、``[ \t\n\r\f\v]`` でない文字と、
   Unicode 文字特性データベースで空白とマーク付けされていないものに マッチします。

``\w``
   :const:`LOCALE` と:const:`UNICODE` フラグが 指定されていない時は、任意の英数文字および下線とマッチします；これは、集合
   ``[a-zA-Z0-9_]``と同じ意味です。:const:`LOCALE`が設定されていると、 集合 ``[0-9_]`` プラス
   現在のロケール用に英数字として定義されている任意の 文字とマッチします。 もし :const:`UNICODE` が設定されていれば、 文字
   ``[0-9_]`` プラス Unicode 文字特性データベースで英数字として分類されて いるものとマッチします。

``\W``
   :const:`LOCALE`と :const:`UNICODE` フラグが 指定されていない時、任意の非英数文字とマッチします；これは 集合
   ``[^a-zA-Z0-9_]``と同じ意味です。 :const:`LOCALE`が指定されていると、 集合 ``[0-9_]``になく、
   現在のロケールで英数字として定義されていない任意の文字とマッチします。 もし :const:`UNICODE`がセットされていれば、これは ``[0-9_]``
   および Unicode 文字特性データベースで 英数字として表されている文字以外のものとマッチします。

``\Z``
   文字列の末尾とのみマッチします。

Python 文字列リテラルによってサポートされている標準エスケープの ほとんども、正規表現パーザに認識されます： ::

   \a      \b      \f      \n
   \r      \t      \v      \x
   \\

8進エスケープは制限された形式で含まれています：もし第1桁が 0 であるか、もし8進3桁であれば、それは8進エスケープとみなされます。
そうでなければ、それはグループ参照です。文字列リテラルについて、 8進エスケープはほとんどの場合3桁長になります。

.. % セクションタイトルにピリオドがないことに注意すること；それがあると
.. % GNU info バージョンの読者に問題が発生します。http://www.python.org/sf/581414 を見て下さい。


.. _matching-searching:

マッチング vs 検索
-----------

.. sectionauthor:: Fred L. Drake, Jr. <fdrake@acm.org>


Python は、正規表現に基づく、2つの異なるプリミティブな操作を 提供しています：マッチと検索です。もしあなたが Perl の記号に慣れているのであれば、
検索操作があなたの求めるものです。 :func:`search` 関数と、 コンパイルされた正規表現オブジェクトでの 対応するメソッドを見て下さい。

マッチは、``'^'``で始まる正規表現を使うと、検索とは 異なるかもしれないことに注意して下さい： ``'^'`` は文字列の先頭でのみ、あるいは
:const:`MULTILINE` モードでは改行の直後ともマッチします。 "マッチ" 操作は 、もしそのパターンが、モードに拘らず文字列の先頭とマッチ
するか、あるいは改行がその前にあるかどうかに拘らず、省略可能な *pos* 引数によって 与えられる先頭位置でマッチする場合のみ成功します。

.. % Tim Peters の例題：

::

   re.compile("a").match("ba", 1)           # 成功
   re.compile("^a").search("ba", 1)         # 失敗； 'a' は先頭にない
   re.compile("^a").search("\na", 1)        # 失敗； 'a' は先頭にない
   re.compile("^a", re.M).search("\na", 1)  # 成功
   re.compile("^a", re.M).search("ba", 1)   # 失敗； \n が前にない


モジュール コンテンツ
-----------

.. _contents of module re:

このモジュールは幾つかの関数、定数、例外を定義します。この関数のいくつかは コンパイル済み正規表現向けの完全版のメソッドを簡略化したバージョンです。
それなりのアプリケーションのほとんどで、コンパイルされた形式が用いられる のが普通です。


.. function:: compile(pattern[, flags])

   正規表現パターンを正規表現オブジェクトにコンパイルします。 このオブジェクトは、以下で述べる :func:`match` と :func:`search`
   メソッドを使って、マッチングに使うことが できます。

   式の動作は、*flags*の値を指定することで加減することが できます。値は以下の変数を、ビットごとの OR ( ``|`` 演算子)を
   使って組み合わせることができます。

   シーケンス ::

      prog = re.compile(pat)
      result = prog.match(str)

   は、 ::

      result = re.match(pat, str)

   と同じ意味ですが、:func:`compile` を使うバージョンの方が、 その式を一つのプログラムで何回も使う時にはより効率的です。

   .. % ( \function{re.match()} あるいは \function{re.search()}へ渡す
   .. % 最後のパターンをコンパイルしたバージョンはキャッシュされます。だから
   .. % 一度に一つの正規表現だけしか使用しないプログラムは、正規表現の
   .. % コンパイルについて心配する必要はありません。)


.. data:: I
          IGNORECASE

   大文字・小文字を区別しないマッチングを実行します； ``[A-Z]``のような式は、 小文字にもマッチします。これは現在のロケールには 影響されません。


.. data:: L
          LOCALE

   ``\w``、 ``\W``、 ``\b``および、``\B``、 ``\s`` と ``\S`` を、現在のロケールに従わさせます。


.. data:: M
          MULTILINE

   指定されると、パターン文字 ``'^'`` は、 文字列の先頭および各行の先頭(各改行の直後)とマッチします；そして パターン文字 ``'$'``
   は文字列の末尾および各行の末尾 (改行の直前)とマッチします。デフォールトでは、 ``'^'`` は、 文字列の先頭とだけマッチし、
   ``'$'``は、文字列の末尾および文字列の末尾の 改行の直前(がもしあれば)とマッチします。


.. data:: S
          DOTALL

   特殊文字 ``'.'`` を、改行をを含む任意の文字と、とにかくマッチ させます；このフラグがなければ、``'.'`` は、改行 *以外の*
   任意の文字とマッチします。


.. data:: U
          UNICODE

   ``\w``、 ``\W``、 ``\b``、 ``\B``、 ``\d``、 ``\D``、 ``\s`` と ``\S`` を、 Unicode
   文字特性データベースに従わさせます。

   .. versionadded:: 2.0


.. data:: X
          VERBOSE

   このフラグによって、より見やすく正規表現を書くことができます。 パターン内の空白は、文字クラス内にあるか、エスケープされていない
   バックスラッシュが前にある時以外は無視されます。 また、行に、文字クラス内にもなく、エスケープされていない バックスラッシュが前にもない ``'#'``
   がある時は、 そのような ``'#'``の左端から その行の末尾までが無視されます。

   .. % XXX はここに例題を追加すべきです。


.. function:: search(pattern, string[, flags])

   *string*全体を走査して、正規表現 *pattern* がマッチを発生する 位置を探して、対応する :class:`MatchObject`
   インスタンスを返します。 もし文字列内に、そのパターンとマッチする位置がないならば、 ``None`` を返します； これは、文字列内のある点で長さゼロのマッチ
   を探すこととは異なることに注意して下さい。


.. function:: match(pattern, string[, flags])

   もし *string* の先頭で0 個以上の文字が正規表現 *pattern* と マッチすれば、対応する :class:`MatchObject`
   インスタンスを返します。 もし文字列がパターンとマッチしなければ、 ``None`` を返します； これは長さゼロのマッチとは異なることに 注意して下さい。

   .. note::

      もし *string* のどこかにマッチを位置付けたいのであれば、 代わりに :meth:`search` を使って下さい。


.. function:: split(pattern, string[, maxsplit\ ``= 0``])

   *string*を、 *pattern*があるたびに分割します。もし 括弧のキャプチャが *pattern*で使われていれば、パターン内の
   すべてのグループのテキストも結果のリストの一部として返されます。 *maxsplit* がゼロでなければ、高々  *maxsplit*個の分割が
   発生し、文字列の残りは、リストの最終要素として返されます。 (非互換性ノート：オリジナルの Python 1.5 リリースでは、
   *maxsplit*は無視されていました。これはその後のリリースでは 修正されました。) ::

      >>> re.split('\W+', 'Words, words, words.')
      ['Words', 'words', 'words', '']
      >>> re.split('(\W+)', 'Words, words, words.')
      ['Words', ', ', 'words', ', ', 'words', '.', '']
      >>> re.split('\W+', 'Words, words, words.', 1)
      ['Words', 'words, words.']


.. function:: findall(pattern, string[, flags])

   *pattern* の*string* へのマッチのうち、重複しない全てのマッチ からなるリストを返します。パターン中に何らかのグループがある場合、グルー
   プのリストを返します。グループが複数定義されていた場合、タプルのリスト になります。他のマッチの開始部分に接触しないかぎり、空のマッチも結果に 含められます。

   .. versionadded:: 1.5.2

   .. versionchanged:: 2.4
      オプションの flags 引数を追加しました.


.. function:: finditer(pattern, string[, flags])

   *string* 内の RE *pattern*の重複しないマッチのすべての イテレータを返します。各マッチごとに、イテレータはマッチ
   オブジェクトを返します。他にマッチがなければ、 空のマッチも結果に入ります。

   .. versionadded:: 2.2

   .. versionchanged:: 2.4
      Added the optional flags argument.


.. function:: sub(pattern, repl, string[, count])

   *string* 内で、 *pattern*と重複しないマッチの内、一番左にあるものを 置換 *repl* で置換して得られた文字列を返します。もしパターンが
   見つからなければ、*string* を変更せずに返します。 *repl* は文字列でも関数でも構いません；もしそれが文字列であれば、
   それにある任意のバックスラッシュエスケープは処理されます。すなわち、 ``\n`` は単一の改行文字に変換され、``\r``は、
   行送りコードに変換されます、等々。 ``\j`` のような未知のエスケープはそのままにされます。
   ``\6``のような後方参照(backreference)は、パターンのグループ 6 とマッチ したサブ文字列で置換されます。 例えば： ::

      >>> re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
      ...        r'static PyObject*\npy_\1(void)\n{',
      ...        'def myfunc():')
      'static PyObject*\npy_myfunc(void)\n{'

   もし *repl* が関数であれば、重複しない *pattern*が発生する たびにその関数が呼ばれます。この関数は一つのマッチオブジェクト
   引数を取り、置換文字列を返します。例えば： ::

      >>> def dashrepl(matchobj):
      ...     if matchobj.group(0) == '-': return ' '
      ...     else: return '-'
      >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')
      'pro--gram files'

   パターンは、文字列でも RE でも構いません；もし正規表現フラグを指定する 必要があれば、RE オブジェクトを使うか、パターンに埋込み修飾子を使わ
   なければなりません；たとえば、``sub("(?i)b+", "x", "bbbb BBBB")`` は ``'x x'`` を返します。

   省略可能な引数 *count* は、置換されるパターンの出現回数の 最大値です；*count* は非負の整数でなければなりません。
   もし省略されるかゼロであれば、出現したものがすべて置換されます。 パターンのマッチが空であれば、以前のマッチと隣合わせでない時だけ
   置換されますので、``sub('x*', '-', 'abc')`` は ``'-a-b-c-'`` を 返します。

   上で述べた文字エスケープや後方参照の他に、 ``\g<name>`` は、 ``(?P<name>...)`` のシンタクスで定義されているように、
   ``name`` という名前のグループとマッチしたサブ文字列を 使います。``\g<number>`` は対応するグループ番号を使います； それゆえ
   ``\g<2>`` は ``\2``と同じ意味ですが、 ``\g<2>0`` のような置換でもあいまいではありません。 ``\20`` は、 グループ 20
   への参照として解釈されますが、グループ 2 にリテラル文字 ``'0'`` が続いたものへの参照としては解釈されません。 後方参照  ``\g<0>`` は、
   RE とマッチするサブ文字列全体を置き換えます。


.. function:: subn(pattern, repl, string[, count])

   :func:`sub` と同じ操作を行いますが、タプル ``(new_string、 number_of_subs_made)``を返します。


.. function:: escape(string)

   バックスラッシュにすべての非英数字をつけた*string*を返します；これは もし、その中に正規表現のメタ文字を持つかもしれない任意のリテラル文字列と
   マッチしたいとき、役に立ちます。


.. exception:: error

   ここでの関数の一つに渡された文字列が、正しい正規表現ではない時 (例えば、その括弧が対になっていなかった)、あるいはコンパイルや
   マッチングの間になんらかのエラーが発生したとき、発生する例外です。 たとえ文字列がパターンとマッチしなくても、 決してエラーではありません。


.. _re-objects:

正規表現オブジェクト
----------

コンパイルされた正規表現オブジェクトは、以下のメソッドと属性をサポート します：


.. method:: RegexObject.match(string[, pos[, endpos]])

   もし *string*の先頭の 0 個以上の文字がこの正規表現とマッチすれば、 対応する :class:`MatchObject` インスタンスを返します。
   もし文字列がパタンーとマッチしなければ、``None`` を返します； これは長さゼロのマッチとは異なることに 注意して下さい。

   .. note::

      もしマッチを *string* のどこかに位置付けたければ、 代わりに :meth:`search` を使って下さい。

   省略可能な第2のパラメータ *pos*は、文字列内の検索を始めるインデッスクを 与えます；デフォールトでは ``0`` です。これは、文字列のスライシングと
   完全に同じ意味だというわけではありません；``'^'`` パターン文字は、 文字列の実際の先頭と改行の直後とマッチしますが、
   それが必ずしも検索が開始するインデックスであるわけでは ないからです。

   省略可能なパラメータ *endpos*は、どこまで文字列が検索されるかを 制限します；あたかもその文字列が *endpos* 文字長であるかのように
   しますので、 *pos* から ``endpos - 1`` までの文字が、 マッチのために検索されます。もし *endpos* が *pos*より小さければ、
   マッチは見つかりませんが、そうでなくて、もし*rx* がコンパイルされた 正規表現オブジェクトであれば、 ``rx.match(string, 0, 50)``
   は ``rx.match(string[:50], 0)``と同じ意味になります。


.. method:: RegexObject.search(string[, pos[, endpos]])

   *string*全体を走査して、この正規表現がマッチする位置を探して、 対応する :class:`MatchObject`
   インスタンスを返します。もし文字列内に パターンとマッチする位置がないならば、``None`` を返します；
   これは文字列内のある点で長さゼロのマッチを探すこととは異なることに 注意して下さい。

   省略可能な *pos* と *endpos* パラメータは、 :meth:`match` メソッドのものと同じ意味を持ちます。


.. method:: RegexObject.split(string[, maxsplit\ ``= 0``])

   :func:`split` 関数と同様で、コンパイルしたパターンを使います。


.. method:: RegexObject.findall(string[, pos[, endpos]])

   :func:`findall` 関数と同様で、コンパイルしたパターンを使います。


.. method:: RegexObject.finditer(string[, pos[, endpos]])

   :func:`finditer` 関数と同様で、コンパイルしたパターンを使います。


.. method:: RegexObject.sub(repl, string[, count\ ``= 0``])

   :func:`sub` 関数と同様で、コンパイルしたパターンを使います。


.. method:: RegexObject.subn(repl, string[, count\ ``= 0``])

   :func:`subn` 関数と同様で、コンパイルしたパターンを使います。


.. attribute:: RegexObject.flags

   flags 引数は、RE オブジェクトがコンパイルされたとき使われ、 もし flags が何も提供されなければ ``0`` です。


.. attribute:: RegexObject.groupindex

   ``(?P<id>)``で定義された任意の記号グループ名の、グループ番号 への辞書マッピングです。もし記号グループが
   パターン内で何も使われていなければ、辞書は空です。


.. attribute:: RegexObject.pattern

   RE オブジェクトがそれからコンパイルされたパターン文字列です。


.. _match-objects:

MatchObject オブジェクト
------------------

:class:`MatchObject` インスタンスは以下のメソッドと属性を サポートします：


.. method:: MatchObject.expand(template)

   テンプレート文字列 *template* に、:meth:`sub` メソッドがするような バックスラッシュ置換をして得られる文字列を返します。
   ``\n``のようなエスケープは適当な文字に変換され、数値の後方参照 (``\1``、 ``\2``) と名前付きの後方参照 (``\g<1>``、
   ``\g<name>``) は、対応するグループの 内容で置き換えられます。


.. method:: MatchObject.group([group1, ...])

   マッチした1個以上のサブグループを返します。もし引数で一つであれば、 その結果は一つの文字列です；複数の引数があれば、その結果は、
   引数ごとに一項目を持つタプルです。引数がなければ、 *group1* はデフォールトでゼロです(マッチしたものすべてが 返されます)。 もし *groupN*
   引数がゼロであれば、対応する戻り値は、マッチ する文字列全体です；もしそれが範囲 [1..99] 内であれば、それは、対応する
   丸括弧つきグループとマッチする文字列です。もしグループ番号が負であるか、 あるいはパターンで定義されたグループの数より大きければ、
   :exc:`IndexError` 例外が発生します。もしグループがマッチしなかった パターンの一部に含まれていれば、対応する結果は ``None`` です。
   もしグループが、複数回マッチしたパターンの一部に 含まれていれば、 最後のマッチが返されます。

   もし正規表現が ``(?P<name>...)`` シンタクスを使うならば、
   *groupN*引数は、それらのグループ名によってグループを識別する文字列であっても 構いません。もし文字列引数がパターンのグループ名として使われていないもので
   あれば、:exc:`IndexError` 例外が発生します。

   適度に複雑な例題： ::

      m = re.match(r"(?P<int>\d+)\.(\d*)", '3.14')

   このマッチを実行したあとでは、``m.group(1)`` は ``m.group('int')`` と同じく、``'3'``
   であり、そして``m.group(2)`` は ``'14'`` です。


.. method:: MatchObject.groups([default])

   1からどれだけ多くであろうがパターン内にあるグループ数までの、 マッチの、すべてのサブグループを含むタプルを返します。 *default*
   引数は、マッチに加わらなかったグループ用に使われます； それはデフォールトでは ``None`` です。 (非互換性ノート：オリジナルの Python 1.5
   リリースでは、たとえタプルが一要素長で あっても、その代わりに文字列を返すことはありません。(1.5.1 以降の)後のバージョンでは、
   そのような場合には、シングルトンタプルが返されます。)


.. method:: MatchObject.groupdict([default])

   すべての *名前つきの*サブグループを含む、マッチの、 サブグループ名でキー付けされた辞書を返します。 *default*
   引数はマッチに加わらなかったグループ用に 使われます；それはデフォールトでは ``None``です。


.. method:: MatchObject.start([group])
            MatchObject.end([group])

   *group*とマッチしたサブ文字列の先頭と末尾のインデックスを 返します；*group* は、デフォールトでは (マッチしたサブ文字列
   全体を意味する）ゼロです。 *group* が存在してもマッチに寄与しなかった場合は、 ``-1`` を返します。マッチオブジェクト *m* および
   マッチに寄与しなかったグループ *g*があって、 グループ *g* とマッチしたサブ文字列 ( ``m.group(g)``と同じ意味ですが) は、 ::

      m.string[m.start(g):m.end(g)]

   です。 もし *group*がヌル文字列とマッチすれば、 ``m.start(group)``が ``m.end(group)`` と等しくなろことに
   注意して下さい。例えば、 ``m = re.search('b(c?)', 'cba')`` の後では、``m.start(0)``は 1 で、
   ``m.end(0)`` は 2 であり、 ``m.start(1)`` と ``m.end(1)`` はともに 2 であり、 ``m.start(2)`` は
   :exc:`IndexError`例外を発生します。


.. method:: MatchObject.span([group])

   :class:`MatchObject` *m* については、 2-タプル ``(m.start(group)、 m.end(group))``を
   返します。もし *group* がマッチに寄与しなかったら、これは ``(-1, -1)`` です。また *group* はデフォールトでゼロです。


.. attribute:: MatchObject.pos

   :class:`RegexObject` の :func:`search` あるいは :func:`match`  メソッドに渡された *pos*の値です。
   これは RE エンジンがマッチを探し始める位置の文字列のインデックスです。


.. attribute:: MatchObject.endpos

   :class:`RegexObject` の :func:`search` あるいは :func:`match`  メソッドに渡された
   *endpos*の値です。 これは RE エンジンがそれ以上は進まない位置の文字列のインデックスです。


.. attribute:: MatchObject.lastindex

   最後にマッチした取り込みグループの整数インデックスです。もしどのグループも 全くマッチしなければ ``None``
   です。例えば、``(a)b``、``((a)(b))`` や  ``((ab))`` といった表現が ``'ab'`` に適用された場合、``lastindex
   == 1``  となり、同じ文字列に ``(a)(b)`` が適用された場合には ``lastindex == 2`` となるでしょう。


.. attribute:: MatchObject.lastgroup

   最後にマッチした取り込みグループの名前です。もしグループに名前がないか、 あるいはどのグループも全くマッチしなければ ``None`` です。


.. attribute:: MatchObject.re

   その :meth:`match`あるいは :meth:`search` メソッドが、この :class:`MatchObject`
   インスタンスを生成した正規表現オブジェクトです。


.. attribute:: MatchObject.string

   :func:`match` あるいは :func:`search`に渡された文字列です。


例
-

**scanf()をシミュレートする**

.. index:: single: scanf()

Python には現在のところ、:cfunc:`scanf`に相当するものがありません。  正規表現は、
:cfunc:`scanf`のフォーマット文字列よりも、一般的に より強力であり、また冗長でもあります。以下の表に、 :cfunc:`scanf`
のフォーマットトークンと正規表現の 大体同等な対応付けを示します。

+--------------------------------+---------------------------------------------+
| :cfunc:`scanf` トークン            | 正規表現                                        |
+================================+=============================================+
| ``%c``                         | ``.``                                       |
+--------------------------------+---------------------------------------------+
| ``%5c``                        | ``.{5}``                                    |
+--------------------------------+---------------------------------------------+
| ``%d``                         | ``[-+]?\d+``                                |
+--------------------------------+---------------------------------------------+
| ``%e``, ``%E``, ``%f``, ``%g`` | ``[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?`` |
+--------------------------------+---------------------------------------------+
| ``%i``                         | ``[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)``     |
+--------------------------------+---------------------------------------------+
| ``%o``                         | ``0[0-7]*``                                 |
+--------------------------------+---------------------------------------------+
| ``%s``                         | ``\S+``                                     |
+--------------------------------+---------------------------------------------+
| ``%u``                         | ``\d+``                                     |
+--------------------------------+---------------------------------------------+
| ``%x``, ``%X``                 | ``0[xX][\dA-Fa-f]+``                        |
+--------------------------------+---------------------------------------------+

::

   /usr/sbin/sendmail - 0 errors, 4 warnings

のような文字列からファイル名と数値を抽出するには、 ::

   %s - %d errors, %d warnings

のように :cfunc:`scanf`フォーマットを使うでしょう。 それと同等な正規表現は ::

   (\S+) - (\d+) errors, (\d+) warnings

**再帰を避ける**

エンジンに大量の再帰を要求するような正規表現を作成すると、 ``maximum recursion limit exceeded(最大再帰制限を超過した)``
というメッセージを持つ :exc:`RuntimeError` 例外に出くわすかもしれません。たとえば、 ::

   >>> import re
   >>> s = "Begin" + 1000 * 'a very long string' + 'end'
   >>> re.match('Begin (\w| )*? end', s).end()
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
     File "/usr/local/lib/python2.5/re.py", line 132, in match
       return _compile(pattern, flags).match(string)
   RuntimeError: maximum recursion limit exceeded

再帰を避けるように正規表現を組みなおせることはよくあります。

Python 2.3 からは、再帰を避けるために ``*?`` パターンの利用が 特別扱いされるようになりました。したがって、上の正規表現は ``Begin
[a-zA-Z0-9_ ]*?end`` に書き直すことで再帰を防ぐことが できます。それ以上の恩恵として、そのような正規表現は、
再帰的な同等のものよりもより速く動作します。


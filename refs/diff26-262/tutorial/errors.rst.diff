--- rest26/tutorial/errors.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/tutorial/errors.rst	2009-04-05 05:01:50.000000000 +0900
@@ -82,25 +82,25 @@
 It is possible to write programs that handle selected exceptions. Look at the
 following example, which asks the user for input until a valid integer has been
 entered, but allows the user to interrupt the program (using :kbd:`Control-C` or
 whatever the operating system supports); note that a user-generated interruption
 is signalled by raising the :exc:`KeyboardInterrupt` exception. ::
 
    >>> while True:
    ...     try:
    ...         x = int(raw_input("Please enter a number: "))
    ...         break
    ...     except ValueError:
    ...         print "Oops!  That was no valid number.  Try again..."
-   ...     
+   ...
 
 The :keyword:`try` statement works as follows.
 
 * First, the *try clause* (the statement(s) between the :keyword:`try` and
   :keyword:`except` keywords) is executed.
 
 * If no exception occurs, the *except clause* is skipped and execution of the
   :keyword:`try` statement is finished.
 
 * If an exception occurs during execution of the try clause, the rest of the
   clause is skipped.  Then if its type matches the exception named after the
   :keyword:`except` keyword, the except clause is executed, and then execution
@@ -190,30 +190,30 @@
    x = spam
    y = eggs
 
 If an exception has an argument, it is printed as the last part ('detail') of
 the message for unhandled exceptions.
 
 Exception handlers don't just handle exceptions if they occur immediately in the
 try clause, but also if they occur inside functions that are called (even
 indirectly) in the try clause. For example::
 
    >>> def this_fails():
    ...     x = 1/0
-   ... 
+   ...
    >>> try:
    ...     this_fails()
    ... except ZeroDivisionError as detail:
    ...     print 'Handling run-time error:', detail
-   ... 
+   ...
    Handling run-time error: integer division or modulo by zero
 
 
 .. _tut-raising:
 
 Raising Exceptions
 ==================
 
 The :keyword:`raise` statement allows the programmer to force a specified
 exception to occur. For example::
 
    >>> raise NameError, 'HiThere'
@@ -247,30 +247,30 @@
 User-defined Exceptions
 =======================
 
 Programs may name their own exceptions by creating a new exception class.
 Exceptions should typically be derived from the :exc:`Exception` class, either
 directly or indirectly.  For example::
 
    >>> class MyError(Exception):
    ...     def __init__(self, value):
    ...         self.value = value
    ...     def __str__(self):
    ...         return repr(self.value)
-   ... 
+   ...
    >>> try:
    ...     raise MyError(2*2)
    ... except MyError as e:
    ...     print 'My exception occurred, value:', e.value
-   ... 
+   ...
    My exception occurred, value: 4
    >>> raise MyError, 'oops!'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    __main__.MyError: 'oops!'
 
 In this example, the default :meth:`__init__` of :class:`Exception` has been
 overridden.  The new behavior simply creates the *value* attribute.  This
 replaces the default behavior of creating the *args* attribute.
 
 Exception classes can be defined which do anything any other class can do, but
 are usually kept simple, often only offering a number of attributes that allow
@@ -322,25 +322,25 @@
 
 Defining Clean-up Actions
 =========================
 
 The :keyword:`try` statement has another optional clause which is intended to
 define clean-up actions that must be executed under all circumstances.  For
 example::
 
    >>> try:
    ...     raise KeyboardInterrupt
    ... finally:
    ...     print 'Goodbye, world!'
-   ... 
+   ...
    Goodbye, world!
    Traceback (most recent call last):
      File "<stdin>", line 2, in ?
    KeyboardInterrupt
 
 A *finally clause* is always executed before leaving the :keyword:`try`
 statement, whether an exception has occurred or not. When an exception has
 occurred in the :keyword:`try` clause and has not been handled by an
 :keyword:`except` clause (or it has occurred in a :keyword:`except` or
 :keyword:`else` clause), it is re-raised after the :keyword:`finally` clause has
 been executed.  The :keyword:`finally` clause is also executed "on the way out"
 when any other clause of the :keyword:`try` statement is left via a

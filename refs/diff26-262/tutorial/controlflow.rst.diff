--- rest26/tutorial/controlflow.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/tutorial/controlflow.rst	2009-04-05 05:01:50.000000000 +0900
@@ -53,38 +53,38 @@
 iterates over the items of any sequence (a list or a string), in the order that
 they appear in the sequence.  For example (no pun intended):
 
 .. One suggestion was to give a real C example here, but that may only serve to
    confuse non-C programmers.
 
 ::
 
    >>> # Measure some strings:
    ... a = ['cat', 'window', 'defenestrate']
    >>> for x in a:
    ...     print x, len(x)
-   ... 
+   ...
    cat 3
    window 6
    defenestrate 12
 
 It is not safe to modify the sequence being iterated over in the loop (this can
 only happen for mutable sequence types, such as lists).  If you need to modify
 the list you are iterating over (for example, to duplicate selected items) you
 must iterate over a copy.  The slice notation makes this particularly
 convenient::
 
    >>> for x in a[:]: # make a slice copy of the entire list
    ...    if len(x) > 6: a.insert(0, x)
-   ... 
+   ...
    >>> a
    ['defenestrate', 'cat', 'window', 'defenestrate']
 
 
 .. _tut-range:
 
 The :func:`range` Function
 ==========================
 
 If you do need to iterate over a sequence of numbers, the built-in function
 :func:`range` comes in handy.  It generates lists containing arithmetic
 progressions::
@@ -95,37 +95,40 @@
 The given end point is never part of the generated list; ``range(10)`` generates
 a list of 10 values, the legal indices for items of a sequence of length 10.  It
 is possible to let the range start at another number, or to specify a different
 increment (even negative; sometimes this is called the 'step')::
 
    >>> range(5, 10)
    [5, 6, 7, 8, 9]
    >>> range(0, 10, 3)
    [0, 3, 6, 9]
    >>> range(-10, -100, -30)
    [-10, -40, -70]
 
-To iterate over the indices of a sequence, combine :func:`range` and :func:`len`
-as follows::
+To iterate over the indices of a sequence, you can combine :func:`range` and
+:func:`len` as follows::
 
    >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
    >>> for i in range(len(a)):
    ...     print i, a[i]
-   ... 
+   ...
    0 Mary
    1 had
    2 a
    3 little
    4 lamb
 
+In most such cases, however, it is convenient to use the :func:`enumerate`
+function, see :ref:`tut-loopidioms`.
+
 
 .. _tut-break:
 
 :keyword:`break` and :keyword:`continue` Statements, and :keyword:`else` Clauses on Loops
 =========================================================================================
 
 The :keyword:`break` statement, like in C, breaks out of the smallest enclosing
 :keyword:`for` or :keyword:`while` loop.
 
 The :keyword:`continue` statement, also borrowed from C, continues with the next
 iteration of the loop.
 
@@ -134,63 +137,76 @@
 condition becomes false (with :keyword:`while`), but not when the loop is
 terminated by a :keyword:`break` statement.  This is exemplified by the
 following loop, which searches for prime numbers::
 
    >>> for n in range(2, 10):
    ...     for x in range(2, n):
    ...         if n % x == 0:
    ...             print n, 'equals', x, '*', n/x
    ...             break
    ...     else:
    ...         # loop fell through without finding a factor
    ...         print n, 'is a prime number'
-   ... 
+   ...
    2 is a prime number
    3 is a prime number
    4 equals 2 * 2
    5 is a prime number
    6 equals 2 * 3
    7 is a prime number
    8 equals 2 * 4
    9 equals 3 * 3
 
 
 .. _tut-pass:
 
 :keyword:`pass` Statements
 ==========================
 
 The :keyword:`pass` statement does nothing. It can be used when a statement is
 required syntactically but the program requires no action. For example::
 
    >>> while True:
    ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
-   ... 
+   ...
+
+This is commonly used for creating minimal classes::
 
+   >>> class MyEmptyClass:
+   ...     pass
+   ...
+
+Another place :keyword:`pass` can be used is as a place-holder for a function or
+conditional body when you are working on new code, allowing you to keep thinking
+at a more abstract level.  The :keyword:`pass` is silently ignored::
+
+   >>> def initlog(*args):
+   ...     pass   # Remember to implement this!
+   ...
 
 .. _tut-functions:
 
 Defining Functions
 ==================
 
 We can create a function that writes the Fibonacci series to an arbitrary
 boundary::
 
    >>> def fib(n):    # write Fibonacci series up to n
    ...     """Print a Fibonacci series up to n."""
    ...     a, b = 0, 1
    ...     while b < n:
    ...         print b,
    ...         a, b = b, a+b
-   ... 
+   ...
    >>> # Now call the function we just defined:
    ... fib(2000)
    1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
 
 .. index::
    single: documentation strings
    single: docstrings
    single: strings, documentation
 
 The keyword :keyword:`def` introduces a function *definition*.  It must be
 followed by the function name and the parenthesized list of formal parameters.
 The statements that form the body of the function start at the next line, and
@@ -243,25 +259,25 @@
 
 It is simple to write a function that returns a list of the numbers of the
 Fibonacci series, instead of printing it::
 
    >>> def fib2(n): # return Fibonacci series up to n
    ...     """Return a list containing the Fibonacci series up to n."""
    ...     result = []
    ...     a, b = 0, 1
    ...     while b < n:
    ...         result.append(b)    # see below
    ...         a, b = b, a+b
    ...     return result
-   ... 
+   ...
    >>> f100 = fib2(100)    # call it
    >>> f100                # write the result
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
 
 This example, as usual, demonstrates some new Python features:
 
 * The :keyword:`return` statement returns with a value from a function.
   :keyword:`return` without an expression argument returns ``None``. Falling off
   the end of a function also returns ``None``.
 
 * The statement ``result.append(b)`` calls a *method* of the list object
   ``result``.  A method is a function that 'belongs' to an object and is named
@@ -378,25 +394,25 @@
    parrot(110, voltage=220)     # duplicate value for argument
    parrot(actor='John Cleese')  # unknown keyword
 
 In general, an argument list must have any positional arguments followed by any
 keyword arguments, where the keywords must be chosen from the formal parameter
 names.  It's not important whether a formal parameter has a default value or
 not.  No argument may receive a value more than once --- formal parameter names
 corresponding to positional arguments cannot be used as keywords in the same
 calls. Here's an example that fails due to this restriction::
 
    >>> def function(a):
    ...     pass
-   ... 
+   ...
    >>> function(0, a=0)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: function() got multiple values for keyword argument 'a'
 
 When a final formal parameter of the form ``**name`` is present, it receives a
 dictionary (see :ref:`typesmapping`) containing all keyword arguments except for
 those corresponding to a formal parameter.  This may be combined with a formal
 parameter of the form ``*name`` (described in the next subsection) which
 receives a tuple containing the positional arguments beyond the formal parameter
 list.  (``*name`` must occur before ``**name``.) For example, if we define a
 function like this::
@@ -431,25 +447,25 @@
 
 Note that the :meth:`sort` method of the list of keyword argument names is
 called before printing the contents of the ``keywords`` dictionary; if this is
 not done, the order in which the arguments are printed is undefined.
 
 
 .. _tut-arbitraryargs:
 
 Arbitrary Argument Lists
 ------------------------
 
 .. index::
-  statement: *  
+  statement: *
 
 Finally, the least frequently used option is to specify that a function can be
 called with an arbitrary number of arguments.  These arguments will be wrapped
 up in a tuple (see :ref:`tut-tuples`).  Before the variable number of arguments,
 zero or more normal arguments may occur. ::
 
    def write_multiple_items(file, separator, *args):
        file.write(separator.join(args))
 
 
 .. _tut-unpacking-arguments:
 
@@ -540,29 +556,29 @@
 the entire documentation string.  (We can't use the first line since it is
 generally adjacent to the string's opening quotes so its indentation is not
 apparent in the string literal.)  Whitespace "equivalent" to this indentation is
 then stripped from the start of all lines of the string.  Lines that are
 indented less should not occur, but if they occur all their leading whitespace
 should be stripped.  Equivalence of whitespace should be tested after expansion
 of tabs (to 8 spaces, normally).
 
 Here is an example of a multi-line docstring::
 
    >>> def my_function():
    ...     """Do nothing, but document it.
-   ... 
+   ...
    ...     No, really, it doesn't do anything.
    ...     """
    ...     pass
-   ... 
+   ...
    >>> print my_function.__doc__
    Do nothing, but document it.
 
        No, really, it doesn't do anything.
 
 
 .. _tut-codingstyle:
 
 Intermezzo: Coding Style
 ========================
 
 .. sectionauthor:: Georg Brandl <georg@python.org>

--- rest26/tutorial/introduction.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/tutorial/introduction.rst	2009-04-07 00:06:52.000000000 +0900
@@ -75,25 +75,25 @@
    >>> x
    0
    >>> y
    0
    >>> z
    0
 
 Variables must be "defined" (assigned a value) before they can be used, or an
 error will occur::
 
    >>> # try to access an undefined variable
    ... n
-   Traceback (most recent call last):   
+   Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'n' is not defined
 
 There is full support for floating point; operators with mixed type operands
 convert the integer operand to floating point::
 
    >>> 3 * 3.75 / 1.5
    7.5
    >>> 7.0 / 2
    3.5
 
 Complex numbers are also supported; imaginary numbers are written with a suffix
@@ -190,55 +190,54 @@
     significant."
 
    print hello
 
 Note that newlines still need to be embedded in the string using ``\n``; the
 newline following the trailing backslash is discarded.  This example would print
 the following::
 
    This is a rather long string containing
    several lines of text just as you would do in C.
        Note that whitespace at the beginning of the line is significant.
 
-If we make the string literal a "raw" string, however, the ``\n`` sequences are
-not converted to newlines, but the backslash at the end of the line, and the
-newline character in the source, are both included in the string as data.  Thus,
-the example::
-
-   hello = r"This is a rather long string containing\n\
-   several lines of text much as you would do in C."
-
-   print hello
-
-would print::
-
-   This is a rather long string containing\n\
-   several lines of text much as you would do in C.
-
 Or, strings can be surrounded in a pair of matching triple-quotes: ``"""`` or
 ``'''``.  End of lines do not need to be escaped when using triple-quotes, but
 they will be included in the string. ::
 
    print """
-   Usage: thingy [OPTIONS] 
+   Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
    """
 
 produces the following output::
 
-   Usage: thingy [OPTIONS] 
+   Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
 
+If we make the string literal a "raw" string, ``\n`` sequences are not converted
+to newlines, but the backslash at the end of the line, and the newline character
+in the source, are both included in the string as data.  Thus, the example::
+
+   hello = r"This is a rather long string containing\n\
+   several lines of text much as you would do in C."
+
+   print hello
+
+would print::
+
+   This is a rather long string containing\n\
+   several lines of text much as you would do in C.
+
 The interpreter prints the result of string operations in the same way as they
 are typed for input: inside quotes, and with quotes and other funny characters
 escaped by backslashes, to show the precise value.  The string is enclosed in
 double quotes if the string contains a single quote and no double quotes, else
 it's enclosed in single quotes.  (The :keyword:`print` statement, described
 later, can be used to write strings without quotes or escapes.)
 
 Strings can be concatenated (glued together) with the ``+`` operator, and
 repeated with ``*``::
 
    >>> word = 'Help' + 'A'
    >>> word
@@ -341,28 +340,28 @@
    >>> word[-100:]
    'HelpA'
    >>> word[-10]    # error
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    IndexError: string index out of range
 
 One way to remember how slices work is to think of the indices as pointing
 *between* characters, with the left edge of the first character numbered 0.
 Then the right edge of the last character of a string of *n* characters has
 index *n*, for example::
 
-    +---+---+---+---+---+ 
+    +---+---+---+---+---+
     | H | e | l | p | A |
-    +---+---+---+---+---+ 
-    0   1   2   3   4   5 
+    +---+---+---+---+---+
+    0   1   2   3   4   5
    -5  -4  -3  -2  -1
 
 The first row of numbers gives the position of the indices 0...5 in the string;
 the second row gives the corresponding negative indices. The slice from *i* to
 *j* consists of all characters between the edges labeled *i* and *j*,
 respectively.
 
 For non-negative indices, the length of a slice is the difference of the
 indices, if both are within bounds.  For example, the length of ``word[1:3]`` is
 2.
 
 The built-in function :func:`len` returns the length of a string::
@@ -586,25 +585,25 @@
 ===============================
 
 Of course, we can use Python for more complicated tasks than adding two and two
 together.  For instance, we can write an initial sub-sequence of the *Fibonacci*
 series as follows::
 
    >>> # Fibonacci series:
    ... # the sum of two elements defines the next
    ... a, b = 0, 1
    >>> while b < 10:
    ...     print b
    ...     a, b = b, a+b
-   ... 
+   ...
    1
    1
    2
    3
    5
    8
 
 This example introduces several new features.
 
 * The first line contains a *multiple assignment*: the variables ``a`` and ``b``
   simultaneously get the new values 0 and 1.  On the last line this is used again,
   demonstrating that the expressions on the right-hand side are all evaluated
@@ -636,17 +635,17 @@
   between items, so you can format things nicely, like this::
 
      >>> i = 256*256
      >>> print 'The value of i is', i
      The value of i is 65536
 
   A trailing comma avoids the newline after the output::
 
      >>> a, b = 0, 1
      >>> while b < 1000:
      ...     print b,
      ...     a, b = b, a+b
-     ... 
+     ...
      1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
 
   Note that the interpreter inserts a newline before it prints the next prompt if
   the last line was not completed.

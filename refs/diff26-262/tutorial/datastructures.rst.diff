--- rest26/tutorial/datastructures.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/tutorial/datastructures.rst	2009-04-07 00:06:52.000000000 +0900
@@ -205,25 +205,25 @@
 
 If there's only one item in the sequence, its value is returned; if the sequence
 is empty, an exception is raised.
 
 A third argument can be passed to indicate the starting value.  In this case the
 starting value is returned for an empty sequence, and the function is first
 applied to the starting value and the first sequence item, then to the result
 and the next item, and so on.  For example, ::
 
    >>> def sum(seq):
    ...     def add(x,y): return x+y
    ...     return reduce(add, seq, 0)
-   ... 
+   ...
    >>> sum(range(1, 11))
    55
    >>> sum([])
    0
 
 Don't use this example's definition of :func:`sum`: since summing numbers is
 such a common need, a built-in function ``sum(sequence)`` is already provided,
 and works exactly like this.
 
 .. versionadded:: 2.3
 
 
@@ -242,25 +242,25 @@
    >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
    >>> [weapon.strip() for weapon in freshfruit]
    ['banana', 'loganberry', 'passion fruit']
    >>> vec = [2, 4, 6]
    >>> [3*x for x in vec]
    [6, 12, 18]
    >>> [3*x for x in vec if x > 3]
    [12, 18]
    >>> [3*x for x in vec if x < 2]
    []
    >>> [[x,x**2] for x in vec]
    [[2, 4], [4, 16], [6, 36]]
-   >>> [x, x**2 for x in vec]	# error - parens required for tuples
+   >>> [x, x**2 for x in vec]  # error - parens required for tuples
      File "<stdin>", line 1, in ?
        [x, x**2 for x in vec]
                   ^
    SyntaxError: invalid syntax
    >>> [(x, x**2) for x in vec]
    [(2, 4), (4, 16), (6, 36)]
    >>> vec1 = [2, 4, 6]
    >>> vec2 = [4, 3, -9]
    >>> [x*y for x in vec1 for y in vec2]
    [8, 6, -18, 16, 12, -36, 24, 18, -54]
    >>> [x+y for x in vec1 for y in vec2]
    [6, 5, -7, 8, 7, -5, 10, 9, -3]
@@ -272,52 +272,52 @@
 
    >>> [str(round(355/113.0, i)) for i in range(1,6)]
    ['3.1', '3.14', '3.142', '3.1416', '3.14159']
 
 
 Nested List Comprehensions
 --------------------------
 
 If you've got the stomach for it, list comprehensions can be nested. They are a
 powerful tool but -- like all powerful tools -- they need to be used carefully,
 if at all.
 
-Consider the following example of a 3x3 matrix held as a list containing three 
+Consider the following example of a 3x3 matrix held as a list containing three
 lists, one list per row::
 
     >>> mat = [
     ...        [1, 2, 3],
     ...        [4, 5, 6],
     ...        [7, 8, 9],
     ...       ]
 
-Now, if you wanted to swap rows and columns, you could use a list 
+Now, if you wanted to swap rows and columns, you could use a list
 comprehension::
 
     >>> print [[row[i] for row in mat] for i in [0, 1, 2]]
     [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
 
 Special care has to be taken for the *nested* list comprehension:
 
     To avoid apprehension when nesting list comprehensions, read from right to
     left.
 
 A more verbose version of this snippet shows the flow explicitly::
 
     for i in [0, 1, 2]:
         for row in mat:
             print row[i],
         print
 
-In real world, you should prefer builtin functions to complex flow statements. 
+In real world, you should prefer builtin functions to complex flow statements.
 The :func:`zip` function would do a great job for this use case::
 
     >>> zip(*mat)
     [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
 
 See :ref:`tut-unpacking-arguments` for details on the asterisk in this line.
 
 .. _tut-del:
 
 The :keyword:`del` statement
 ============================
 
@@ -392,31 +392,29 @@
    0
    >>> len(singleton)
    1
    >>> singleton
    ('hello',)
 
 The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple packing*:
 the values ``12345``, ``54321`` and ``'hello!'`` are packed together in a tuple.
 The reverse operation is also possible::
 
    >>> x, y, z = t
 
-This is called, appropriately enough, *sequence unpacking*. Sequence unpacking
-requires the list of variables on the left to have the same number of elements
-as the length of the sequence.  Note that multiple assignment is really just a
-combination of tuple packing and sequence unpacking!
-
-There is a small bit of asymmetry here:  packing multiple values always creates
-a tuple, and unpacking works for any sequence.
+This is called, appropriately enough, *sequence unpacking* and works for any
+sequence on the right-hand side.  Sequence unpacking requires the list of
+variables on the left to have the same number of elements as the length of the
+sequence.  Note that multiple assignment is really just a combination of tuple
+packing and sequence unpacking.
 
 .. XXX Add a bit on the difference between tuples and lists.
 
 
 .. _tut-sets:
 
 Sets
 ====
 
 Python also includes a data type for *sets*.  A set is an unordered collection
 with no duplicate elements.  Basic uses include membership testing and
 eliminating duplicate entries.  Set objects also support mathematical operations
@@ -542,48 +540,48 @@
    ...
    0 tic
    1 tac
    2 toe
 
 To loop over two or more sequences at the same time, the entries can be paired
 with the :func:`zip` function. ::
 
    >>> questions = ['name', 'quest', 'favorite color']
    >>> answers = ['lancelot', 'the holy grail', 'blue']
    >>> for q, a in zip(questions, answers):
    ...     print 'What is your {0}?  It is {1}.'.format(q, a)
-   ...	
+   ...
    What is your name?  It is lancelot.
    What is your quest?  It is the holy grail.
    What is your favorite color?  It is blue.
 
 To loop over a sequence in reverse, first specify the sequence in a forward
 direction and then call the :func:`reversed` function. ::
 
    >>> for i in reversed(xrange(1,10,2)):
    ...     print i
    ...
    9
    7
    5
    3
    1
 
 To loop over a sequence in sorted order, use the :func:`sorted` function which
 returns a new sorted list while leaving the source unaltered. ::
 
    >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
    >>> for f in sorted(set(basket)):
    ...     print f
-   ... 	
+   ...
    apple
    banana
    orange
    pear
 
 
 .. _tut-conditions:
 
 More on Conditions
 ==================
 
 The conditions used in ``while`` and ``if`` statements can contain any

--- rest26/c-api/exceptions.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/c-api/exceptions.rst	2009-04-05 05:01:43.000000000 +0900
@@ -32,30 +32,39 @@
    single: exc_value (in module sys)
    single: exc_traceback (in module sys)
 
 The error indicator consists of three Python objects corresponding to   the
 Python variables ``sys.exc_type``, ``sys.exc_value`` and ``sys.exc_traceback``.
 API functions exist to interact with the error indicator in various ways.  There
 is a separate error indicator for each thread.
 
 .. XXX Order of these should be more thoughtful.
    Either alphabetical or some kind of structure.
 
 
-.. cfunction:: void PyErr_Print()
+.. cfunction:: void PyErr_PrintEx(int set_sys_last_vars)
 
    Print a standard traceback to ``sys.stderr`` and clear the error indicator.
    Call this function only when the error indicator is set.  (Otherwise it will
    cause a fatal error!)
 
+   If *set_sys_last_vars* is nonzero, the variables :data:`sys.last_type`,
+   :data:`sys.last_value` and :data:`sys.last_traceback` will be set to the
+   type, value and traceback of the printed exception, respectively.
+
+
+.. cfunction:: void PyErr_Print()
+
+   Alias for ``PyErr_PrintEx(1)``.
+
 
 .. cfunction:: PyObject* PyErr_Occurred()
 
    Test whether the error indicator is set.  If set, return the exception *type*
    (the first argument to the last call to one of the :cfunc:`PyErr_Set\*`
    functions or to :cfunc:`PyErr_Restore`).  If not set, return *NULL*.  You do not
    own a reference to the return value, so you do not need to :cfunc:`Py_DECREF`
    it.
 
    .. note::
 
       Do not compare the return value to a specific exception; use
@@ -64,29 +73,28 @@
       case of a class exception, or it may the a subclass of the expected exception.)
 
 
 .. cfunction:: int PyErr_ExceptionMatches(PyObject *exc)
 
    Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This
    should only be called when an exception is actually set; a memory access
    violation will occur if no exception has been raised.
 
 
 .. cfunction:: int PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)
 
-   Return true if the *given* exception matches the exception in *exc*.  If *exc*
-   is a class object, this also returns true when *given* is an instance of a
-   subclass.  If *exc* is a tuple, all exceptions in the tuple (and recursively in
-   subtuples) are searched for a match.  If *given* is *NULL*, a memory access
-   violation will occur.
+   Return true if the *given* exception matches the exception in *exc*.  If
+   *exc* is a class object, this also returns true when *given* is an instance
+   of a subclass.  If *exc* is a tuple, all exceptions in the tuple (and
+   recursively in subtuples) are searched for a match.
 
 
 .. cfunction:: void PyErr_NormalizeException(PyObject**exc, PyObject**val, PyObject**tb)
 
    Under certain circumstances, the values returned by :cfunc:`PyErr_Fetch` below
    can be "unnormalized", meaning that ``*exc`` is a class object but ``*val`` is
    not an instance of the  same class.  This function can be used to instantiate
    the class in that case.  If the values are already normalized, nothing happens.
    The delayed normalization is implemented to improve performance.
 
 
 .. cfunction:: void PyErr_Clear()

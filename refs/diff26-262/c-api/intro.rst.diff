--- rest26/c-api/intro.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/c-api/intro.rst	2009-04-05 05:01:43.000000000 +0900
@@ -178,25 +178,25 @@
 in terms of *ownership of references*.  Ownership pertains to references, never
 to objects (objects are not owned: they are always shared).  "Owning a
 reference" means being responsible for calling Py_DECREF on it when the
 reference is no longer needed.  Ownership can also be transferred, meaning that
 the code that receives ownership of the reference then becomes responsible for
 eventually decref'ing it by calling :cfunc:`Py_DECREF` or :cfunc:`Py_XDECREF`
 when it's no longer needed---or passing on this responsibility (usually to its
 caller). When a function passes ownership of a reference on to its caller, the
 caller is said to receive a *new* reference.  When no ownership is transferred,
 the caller is said to *borrow* the reference. Nothing needs to be done for a
 borrowed reference.
 
-Conversely, when a calling function passes it a reference to an  object, there
+Conversely, when a calling function passes in a reference to an  object, there
 are two possibilities: the function *steals* a  reference to the object, or it
 does not.  *Stealing a reference* means that when you pass a reference to a
 function, that function assumes that it now owns that reference, and you are not
 responsible for it any longer.
 
 .. index::
    single: PyList_SetItem()
    single: PyTuple_SetItem()
 
 Few functions steal references; the two notable exceptions are
 :cfunc:`PyList_SetItem` and :cfunc:`PyTuple_SetItem`, which  steal a reference
 to the item (but not to the tuple or list into which the item is put!).  These

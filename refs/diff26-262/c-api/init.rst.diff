--- rest26/c-api/init.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/c-api/init.rst	2009-04-07 00:06:52.000000000 +0900
@@ -344,53 +344,71 @@
    The returned string points into static storage; the caller should not modify its
    value.  The value is available to Python code as part of the variable
    ``sys.version``.
 
 
 .. cfunction:: void PySys_SetArgv(int argc, char **argv)
 
    .. index::
       single: main()
       single: Py_FatalError()
       single: argv (in module sys)
 
-   Set ``sys.argv`` based on *argc* and *argv*.  These parameters are similar to
-   those passed to the program's :cfunc:`main` function with the difference that
-   the first entry should refer to the script file to be executed rather than the
-   executable hosting the Python interpreter.  If there isn't a script that will be
-   run, the first entry in *argv* can be an empty string.  If this function fails
-   to initialize ``sys.argv``, a fatal condition is signalled using
-   :cfunc:`Py_FatalError`.
+   Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are
+   similar to those passed to the program's :cfunc:`main` function with the
+   difference that the first entry should refer to the script file to be
+   executed rather than the executable hosting the Python interpreter.  If there
+   isn't a script that will be run, the first entry in *argv* can be an empty
+   string.  If this function fails to initialize :data:`sys.argv`, a fatal
+   condition is signalled using :cfunc:`Py_FatalError`.
+
+   This function also prepends the executed script's path to :data:`sys.path`.
+   If no script is executed (in the case of calling ``python -c`` or just the
+   interactive interpreter), the empty string is used instead.
 
    .. XXX impl. doesn't seem consistent in allowing 0/NULL for the params;
       check w/ Guido.
 
 
+.. cfunction:: void Py_SetPythonHome(char *home)
+
+   Set the default "home" directory, that is, the location of the standard
+   Python libraries.  The libraries are searched in
+   :file:`{home}/lib/python{version}` and :file:`{home}/lib/python{version}`.
+
+
+.. cfunction:: char* Py_GetPythonHome()
+
+   Return the default "home", that is, the value set by a previous call to
+   :cfunc:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME`
+   environment variable if it is set.
+
+
 .. _threads:
 
 Thread State and the Global Interpreter Lock
 ============================================
 
 .. index::
    single: global interpreter lock
    single: interpreter lock
    single: lock, interpreter
 
 The Python interpreter is not fully thread safe.  In order to support
-multi-threaded Python programs, there's a global lock that must be held by the
-current thread before it can safely access Python objects. Without the lock,
-even the simplest operations could cause problems in a multi-threaded program:
-for example, when two threads simultaneously increment the reference count of
-the same object, the reference count could end up being incremented only once
-instead of twice.
+multi-threaded Python programs, there's a global lock, called the :dfn:`global
+interpreter lock` or :dfn:`GIL`, that must be held by the current thread before
+it can safely access Python objects. Without the lock, even the simplest
+operations could cause problems in a multi-threaded program: for example, when
+two threads simultaneously increment the reference count of the same object, the
+reference count could end up being incremented only once instead of twice.
 
 .. index:: single: setcheckinterval() (in module sys)
 
 Therefore, the rule exists that only the thread that has acquired the global
 interpreter lock may operate on Python objects or call Python/C API functions.
 In order to support multi-threaded Python programs, the interpreter regularly
 releases and reacquires the lock --- by default, every 100 bytecode instructions
 (this can be changed with  :func:`sys.setcheckinterval`).  The lock is also
 released and reacquired around potentially blocking I/O operations like reading
 or writing a file, so that other threads can run while the thread that requests
 the I/O is waiting for the I/O operation to complete.
 
@@ -401,44 +419,44 @@
 The Python interpreter needs to keep some bookkeeping information separate per
 thread --- for this it uses a data structure called :ctype:`PyThreadState`.
 There's one global variable, however: the pointer to the current
 :ctype:`PyThreadState` structure.  While most thread packages have a way to
 store "per-thread global data," Python's internal platform independent thread
 abstraction doesn't support this yet.  Therefore, the current thread state must
 be manipulated explicitly.
 
 This is easy enough in most cases.  Most code manipulating the global
 interpreter lock has the following simple structure::
 
    Save the thread state in a local variable.
-   Release the interpreter lock.
+   Release the global interpreter lock.
    ...Do some blocking I/O operation...
-   Reacquire the interpreter lock.
+   Reacquire the global interpreter lock.
    Restore the thread state from the local variable.
 
 This is so common that a pair of macros exists to simplify it::
 
    Py_BEGIN_ALLOW_THREADS
    ...Do some blocking I/O operation...
    Py_END_ALLOW_THREADS
 
 .. index::
    single: Py_BEGIN_ALLOW_THREADS
    single: Py_END_ALLOW_THREADS
 
 The :cmacro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a
 hidden local variable; the :cmacro:`Py_END_ALLOW_THREADS` macro closes the
 block.  Another advantage of using these two macros is that when Python is
 compiled without thread support, they are defined empty, thus saving the thread
-state and lock manipulations.
+state and GIL manipulations.
 
 When thread support is enabled, the block above expands to the following code::
 
    PyThreadState *_save;
 
    _save = PyEval_SaveThread();
    ...Do some blocking I/O operation...
    PyEval_RestoreThread(_save);
 
 Using even lower level primitives, we can get roughly the same effect as
 follows::
 
@@ -452,25 +470,25 @@
 
 .. index::
    single: PyEval_RestoreThread()
    single: errno
    single: PyEval_SaveThread()
    single: PyEval_ReleaseLock()
    single: PyEval_AcquireLock()
 
 There are some subtle differences; in particular, :cfunc:`PyEval_RestoreThread`
 saves and restores the value of the  global variable :cdata:`errno`, since the
 lock manipulation does not guarantee that :cdata:`errno` is left alone.  Also,
 when thread support is disabled, :cfunc:`PyEval_SaveThread` and
-:cfunc:`PyEval_RestoreThread` don't manipulate the lock; in this case,
+:cfunc:`PyEval_RestoreThread` don't manipulate the GIL; in this case,
 :cfunc:`PyEval_ReleaseLock` and :cfunc:`PyEval_AcquireLock` are not available.
 This is done so that dynamically loaded extensions compiled with thread support
 enabled can be loaded by an interpreter that was compiled with disabled thread
 support.
 
 The global interpreter lock is used to protect the pointer to the current thread
 state.  When releasing the lock and saving the thread state, the current thread
 state pointer must be retrieved before the lock is released (since another
 thread could immediately acquire the lock and store its own thread state in the
 global variable). Conversely, when acquiring the lock and restoring the thread
 state, the lock must be acquired before storing the thread state pointer.
 
@@ -535,45 +553,45 @@
    main thread before creating a second thread or engaging in any other thread
    operations such as :cfunc:`PyEval_ReleaseLock` or
    ``PyEval_ReleaseThread(tstate)``. It is not needed before calling
    :cfunc:`PyEval_SaveThread` or :cfunc:`PyEval_RestoreThread`.
 
    .. index:: single: Py_Initialize()
 
    This is a no-op when called for a second time.  It is safe to call this function
    before calling :cfunc:`Py_Initialize`.
 
    .. index:: module: thread
 
-   When only the main thread exists, no lock operations are needed. This is a
+   When only the main thread exists, no GIL operations are needed. This is a
    common situation (most Python programs do not use threads), and the lock
-   operations slow the interpreter down a bit. Therefore, the lock is not created
-   initially.  This situation is equivalent to having acquired the lock:  when
-   there is only a single thread, all object accesses are safe.  Therefore, when
-   this function initializes the lock, it also acquires it.  Before the Python
-   :mod:`thread` module creates a new thread, knowing that either it has the lock
-   or the lock hasn't been created yet, it calls :cfunc:`PyEval_InitThreads`.  When
-   this call returns, it is guaranteed that the lock has been created and that the
-   calling thread has acquired it.
+   operations slow the interpreter down a bit. Therefore, the lock is not
+   created initially.  This situation is equivalent to having acquired the lock:
+   when there is only a single thread, all object accesses are safe.  Therefore,
+   when this function initializes the global interpreter lock, it also acquires
+   it.  Before the Python :mod:`thread` module creates a new thread, knowing
+   that either it has the lock or the lock hasn't been created yet, it calls
+   :cfunc:`PyEval_InitThreads`.  When this call returns, it is guaranteed that
+   the lock has been created and that the calling thread has acquired it.
 
    It is **not** safe to call this function when it is unknown which thread (if
    any) currently has the global interpreter lock.
 
    This function is not available when thread support is disabled at compile time.
 
 
 .. cfunction:: int PyEval_ThreadsInitialized()
 
    Returns a non-zero value if :cfunc:`PyEval_InitThreads` has been called.  This
-   function can be called without holding the lock, and therefore can be used to
+   function can be called without holding the GIL, and therefore can be used to
    avoid calls to the locking API when running single-threaded.  This function is
    not available when thread support is disabled at compile time.
 
    .. versionadded:: 2.4
 
 
 .. cfunction:: void PyEval_AcquireLock()
 
    Acquire the global interpreter lock.  The lock must have been created earlier.
    If this thread already has the lock, a deadlock ensues.  This function is not
    available when thread support is disabled at compile time.
 
@@ -595,38 +613,38 @@
 .. cfunction:: void PyEval_ReleaseThread(PyThreadState *tstate)
 
    Reset the current thread state to *NULL* and release the global interpreter
    lock.  The lock must have been created earlier and must be held by the current
    thread.  The *tstate* argument, which must not be *NULL*, is only used to check
    that it represents the current thread state --- if it isn't, a fatal error is
    reported. This function is not available when thread support is disabled at
    compile time.
 
 
 .. cfunction:: PyThreadState* PyEval_SaveThread()
 
-   Release the interpreter lock (if it has been created and thread support is
-   enabled) and reset the thread state to *NULL*, returning the previous thread
-   state (which is not *NULL*).  If the lock has been created, the current thread
-   must have acquired it.  (This function is available even when thread support is
-   disabled at compile time.)
+   Release the global interpreter lock (if it has been created and thread
+   support is enabled) and reset the thread state to *NULL*, returning the
+   previous thread state (which is not *NULL*).  If the lock has been created,
+   the current thread must have acquired it.  (This function is available even
+   when thread support is disabled at compile time.)
 
 
 .. cfunction:: void PyEval_RestoreThread(PyThreadState *tstate)
 
-   Acquire the interpreter lock (if it has been created and thread support is
-   enabled) and set the thread state to *tstate*, which must not be *NULL*.  If the
-   lock has been created, the current thread must not have acquired it, otherwise
-   deadlock ensues.  (This function is available even when thread support is
-   disabled at compile time.)
+   Acquire the global interpreter lock (if it has been created and thread
+   support is enabled) and set the thread state to *tstate*, which must not be
+   *NULL*.  If the lock has been created, the current thread must not have
+   acquired it, otherwise deadlock ensues.  (This function is available even
+   when thread support is disabled at compile time.)
 
 
 .. cfunction:: void PyEval_ReInitThreads()
 
    This function is called from :cfunc:`PyOS_AfterFork` to ensure that newly
    created child processes don't hold locks referring to threads which
    are not running in the child process.
 
 
 The following macros are normally used without a trailing semicolon; look for
 example usage in the Python source distribution.
 
@@ -652,78 +670,79 @@
    This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to
    :cmacro:`Py_END_ALLOW_THREADS` without the closing brace.  It is a no-op when
    thread support is disabled at compile time.
 
 
 .. cmacro:: Py_UNBLOCK_THREADS
 
    This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to
    :cmacro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable
    declaration.  It is a no-op when thread support is disabled at compile time.
 
 All of the following functions are only available when thread support is enabled
-at compile time, and must be called only when the interpreter lock has been
-created.
+at compile time, and must be called only when the global interpreter lock has
+been created.
 
 
 .. cfunction:: PyInterpreterState* PyInterpreterState_New()
 
-   Create a new interpreter state object.  The interpreter lock need not be held,
-   but may be held if it is necessary to serialize calls to this function.
+   Create a new interpreter state object.  The global interpreter lock need not
+   be held, but may be held if it is necessary to serialize calls to this
+   function.
 
 
 .. cfunction:: void PyInterpreterState_Clear(PyInterpreterState *interp)
 
-   Reset all information in an interpreter state object.  The interpreter lock must
-   be held.
+   Reset all information in an interpreter state object.  The global interpreter
+   lock must be held.
 
 
 .. cfunction:: void PyInterpreterState_Delete(PyInterpreterState *interp)
 
-   Destroy an interpreter state object.  The interpreter lock need not be held.
-   The interpreter state must have been reset with a previous call to
+   Destroy an interpreter state object.  The global interpreter lock need not be
+   held.  The interpreter state must have been reset with a previous call to
    :cfunc:`PyInterpreterState_Clear`.
 
 
 .. cfunction:: PyThreadState* PyThreadState_New(PyInterpreterState *interp)
 
-   Create a new thread state object belonging to the given interpreter object.  The
-   interpreter lock need not be held, but may be held if it is necessary to
-   serialize calls to this function.
+   Create a new thread state object belonging to the given interpreter object.
+   The global interpreter lock need not be held, but may be held if it is
+   necessary to serialize calls to this function.
 
 
 .. cfunction:: void PyThreadState_Clear(PyThreadState *tstate)
 
-   Reset all information in a thread state object.  The interpreter lock must be
-   held.
+   Reset all information in a thread state object.  The global interpreter lock
+   must be held.
 
 
 .. cfunction:: void PyThreadState_Delete(PyThreadState *tstate)
 
-   Destroy a thread state object.  The interpreter lock need not be held.  The
-   thread state must have been reset with a previous call to
+   Destroy a thread state object.  The global interpreter lock need not be held.
+   The thread state must have been reset with a previous call to
    :cfunc:`PyThreadState_Clear`.
 
 
 .. cfunction:: PyThreadState* PyThreadState_Get()
 
-   Return the current thread state.  The interpreter lock must be held.  When the
-   current thread state is *NULL*, this issues a fatal error (so that the caller
-   needn't check for *NULL*).
+   Return the current thread state.  The global interpreter lock must be held.
+   When the current thread state is *NULL*, this issues a fatal error (so that
+   the caller needn't check for *NULL*).
 
 
 .. cfunction:: PyThreadState* PyThreadState_Swap(PyThreadState *tstate)
 
    Swap the current thread state with the thread state given by the argument
-   *tstate*, which may be *NULL*.  The interpreter lock must be held.
+   *tstate*, which may be *NULL*.  The global interpreter lock must be held.
 
 
 .. cfunction:: PyObject* PyThreadState_GetDict()
 
    Return a dictionary in which extensions can store thread-specific state
    information.  Each extension should use a unique key to use to store state in
    the dictionary.  It is okay to call this function when no current thread state
    is available. If this function returns *NULL*, no exception has been raised and
    the caller should assume no current thread state is available.
 
    .. versionchanged:: 2.3
       Previously this could only be called when a current thread is active, and *NULL*
@@ -736,39 +755,40 @@
    id of the target thread; *exc* is the exception object to be raised. This
    function does not steal any references to *exc*. To prevent naive misuse, you
    must write your own C extension to call this.  Must be called with the GIL held.
    Returns the number of thread states modified; this is normally one, but will be
    zero if the thread id isn't found.  If *exc* is :const:`NULL`, the pending
    exception (if any) for the thread is cleared. This raises no exceptions.
 
    .. versionadded:: 2.3
 
 
 .. cfunction:: PyGILState_STATE PyGILState_Ensure()
 
-   Ensure that the current thread is ready to call the Python C API regardless of
-   the current state of Python, or of its thread lock. This may be called as many
-   times as desired by a thread as long as each call is matched with a call to
-   :cfunc:`PyGILState_Release`. In general, other thread-related APIs may be used
-   between :cfunc:`PyGILState_Ensure` and :cfunc:`PyGILState_Release` calls as long
-   as the thread state is restored to its previous state before the Release().  For
-   example, normal usage of the :cmacro:`Py_BEGIN_ALLOW_THREADS` and
-   :cmacro:`Py_END_ALLOW_THREADS` macros is acceptable.
+   Ensure that the current thread is ready to call the Python C API regardless
+   of the current state of Python, or of the global interpreter lock. This may
+   be called as many times as desired by a thread as long as each call is
+   matched with a call to :cfunc:`PyGILState_Release`. In general, other
+   thread-related APIs may be used between :cfunc:`PyGILState_Ensure` and
+   :cfunc:`PyGILState_Release` calls as long as the thread state is restored to
+   its previous state before the Release().  For example, normal usage of the
+   :cmacro:`Py_BEGIN_ALLOW_THREADS` and :cmacro:`Py_END_ALLOW_THREADS` macros is
+   acceptable.
 
    The return value is an opaque "handle" to the thread state when
-   :cfunc:`PyGILState_Acquire` was called, and must be passed to
+   :cfunc:`PyGILState_Ensure` was called, and must be passed to
    :cfunc:`PyGILState_Release` to ensure Python is left in the same state. Even
    though recursive calls are allowed, these handles *cannot* be shared - each
-   unique call to :cfunc:`PyGILState_Ensure` must save the handle for its call to
-   :cfunc:`PyGILState_Release`.
+   unique call to :cfunc:`PyGILState_Ensure` must save the handle for its call
+   to :cfunc:`PyGILState_Release`.
 
    When the function returns, the current thread will hold the GIL. Failure is a
    fatal error.
 
    .. versionadded:: 2.3
 
 
 .. cfunction:: void PyGILState_Release(PyGILState_STATE)
 
    Release any resources previously acquired.  After this call, Python's state will
    be the same as it was prior to the corresponding :cfunc:`PyGILState_Ensure` call
    (but generally this state will be unknown to the caller, hence the use of the
@@ -893,25 +913,25 @@
 
 
 .. cfunction:: void PyEval_SetTrace(Py_tracefunc func, PyObject *obj)
 
    Set the tracing function to *func*.  This is similar to
    :cfunc:`PyEval_SetProfile`, except the tracing function does receive line-number
    events.
 
 .. cfunction:: PyObject* PyEval_GetCallStats(PyObject *self)
 
    Return a tuple of function call counts.  There are constants defined for the
    positions within the tuple:
-   
+
    +-------------------------------+-------+
    | Name                          | Value |
    +===============================+=======+
    | :const:`PCALL_ALL`            | 0     |
    +-------------------------------+-------+
    | :const:`PCALL_FUNCTION`       | 1     |
    +-------------------------------+-------+
    | :const:`PCALL_FAST_FUNCTION`  | 2     |
    +-------------------------------+-------+
    | :const:`PCALL_FASTER_FUNCTION`| 3     |
    +-------------------------------+-------+
    | :const:`PCALL_METHOD`         | 4     |
@@ -919,25 +939,25 @@
    | :const:`PCALL_BOUND_METHOD`   | 5     |
    +-------------------------------+-------+
    | :const:`PCALL_CFUNCTION`      | 6     |
    +-------------------------------+-------+
    | :const:`PCALL_TYPE`           | 7     |
    +-------------------------------+-------+
    | :const:`PCALL_GENERATOR`      | 8     |
    +-------------------------------+-------+
    | :const:`PCALL_OTHER`          | 9     |
    +-------------------------------+-------+
    | :const:`PCALL_POP`            | 10    |
    +-------------------------------+-------+
-   
+
    :const:`PCALL_FAST_FUNCTION` means no argument tuple needs to be created.
    :const:`PCALL_FASTER_FUNCTION` means that the fast-path frame setup code is used.
 
    If there is a method call where the call can be optimized by changing
    the argument tuple and calling the function directly, it gets recorded
    twice.
 
    This function is only present if Python is compiled with :const:`CALL_PROFILE`
    defined.
 
 .. _advanced-debugging:
 

--- rest26/c-api/arg.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/c-api/arg.rst	2009-04-05 05:01:43.000000000 +0900
@@ -23,51 +23,56 @@
 the format unit; and the entry in [square] brackets is the type of the C
 variable(s) whose address should be passed.
 
 ``s`` (string or Unicode object) [const char \*]
    Convert a Python string or Unicode object to a C pointer to a character string.
    You must not provide storage for the string itself; a pointer to an existing
    string is stored into the character pointer variable whose address you pass.
    The C string is NUL-terminated.  The Python string must not contain embedded NUL
    bytes; if it does, a :exc:`TypeError` exception is raised. Unicode objects are
    converted to C strings using the default encoding.  If this conversion fails, a
    :exc:`UnicodeError` is raised.
 
-``s#`` (string, Unicode or any read buffer compatible object) [const char \*, int]
+``s#`` (string, Unicode or any read buffer compatible object) [const char \*, int (or :ctype:`Py_ssize_t`, see below)]
    This variant on ``s`` stores into two C variables, the first one a pointer to a
    character string, the second one its length.  In this case the Python string may
    contain embedded null bytes.  Unicode objects pass back a pointer to the default
    encoded string version of the object if such a conversion is possible.  All
    other read-buffer compatible objects pass back a reference to the raw internal
    data representation.
 
+   Starting with Python 2.5 the type of the length argument can be
+   controlled by defining the macro :cmacro:`PY_SSIZE_T_CLEAN` before
+   including :file:`Python.h`.  If the macro is defined, length is a
+   :ctype:`Py_ssize_t` rather than an int.
+
 ``s*`` (string, Unicode, or any buffer compatible object) [Py_buffer \*]
-  Similar to ``s#``, this code fills a Py_buffer structure provided by the caller.
-  The buffer gets locked, so that the caller can subsequently use the buffer even
-  inside a ``Py_BEGIN_ALLOW_THREADS`` block; the caller is responsible for calling
-  ``PyBuffer_Release`` with the structure after it has processed the data.
+   Similar to ``s#``, this code fills a Py_buffer structure provided by the caller.
+   The buffer gets locked, so that the caller can subsequently use the buffer even
+   inside a ``Py_BEGIN_ALLOW_THREADS`` block; the caller is responsible for calling
+   ``PyBuffer_Release`` with the structure after it has processed the data.
 
-  .. versionadded:: 2.6
+   .. versionadded:: 2.6
 
 ``z`` (string or ``None``) [const char \*]
    Like ``s``, but the Python object may also be ``None``, in which case the C
    pointer is set to *NULL*.
 
 ``z#`` (string or ``None`` or any read buffer compatible object) [const char \*, int]
    This is to ``s#`` as ``z`` is to ``s``.
 
 ``z*`` (string or ``None`` or any buffer compatible object) [Py_buffer*]
    This is to ``s*`` as ``z`` is to ``s``.
 
-  .. versionadded:: 2.6
+   .. versionadded:: 2.6
 
 ``u`` (Unicode object) [Py_UNICODE \*]
    Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of
    16-bit Unicode (UTF-16) data.  As with ``s``, there is no need to provide
    storage for the Unicode data buffer; a pointer to the existing Unicode data is
    stored into the :ctype:`Py_UNICODE` pointer variable whose address you pass.
 
 ``u#`` (Unicode object) [Py_UNICODE \*, int]
    This variant on ``u`` stores into two C variables, the first one a pointer to a
    Unicode data buffer, the second one its length. Non-Unicode objects are handled
    by interpreting their read-buffer pointer as pointer to a :ctype:`Py_UNICODE`
    array.
@@ -122,26 +127,27 @@
    initial value of *\*buffer_length* as the buffer size.  It will then copy the
    encoded data into the buffer and NUL-terminate it.  If the buffer is not large
    enough, a :exc:`ValueError` will be set.
 
    In both cases, *\*buffer_length* is set to the length of the encoded data
    without the trailing NUL byte.
 
 ``et#`` (string, Unicode object or character buffer compatible object) [const char \*encoding, char \*\*buffer]
    Same as ``es#`` except that string objects are passed through without recoding
    them. Instead, the implementation assumes that the string object uses the
    encoding passed in as parameter.
 
-``b`` (integer) [char]
-   Convert a Python integer to a tiny int, stored in a C :ctype:`char`.
+``b`` (integer) [unsigned char]
+   Convert a nonnegative Python integer to an unsigned tiny int, stored in a C
+   :ctype:`unsigned char`.
 
 ``B`` (integer) [unsigned char]
    Convert a Python integer to a tiny int without overflow checking, stored in a C
    :ctype:`unsigned char`.
 
    .. versionadded:: 2.3
 
 ``h`` (integer) [short int]
    Convert a Python integer to a C :ctype:`short int`.
 
 ``H`` (integer) [unsigned short int]
    Convert a Python integer to a C :ctype:`unsigned short int`, without overflow
@@ -237,33 +243,34 @@
    Like ``s#``, but accepts any object which implements the read-only buffer
    interface.  The :ctype:`char\*` variable is set to point to the first byte of
    the buffer, and the :ctype:`int` is set to the length of the buffer.  Only
    single-segment buffer objects are accepted; :exc:`TypeError` is raised for all
    others.
 
 ``w`` (read-write character buffer) [char \*]
    Similar to ``s``, but accepts any object which implements the read-write buffer
    interface.  The caller must determine the length of the buffer by other means,
    or use ``w#`` instead.  Only single-segment buffer objects are accepted;
    :exc:`TypeError` is raised for all others.
 
-``w#`` (read-write character buffer) [char \*, int]
+``w#`` (read-write character buffer) [char \*, Py_ssize_t]
    Like ``s#``, but accepts any object which implements the read-write buffer
    interface.  The :ctype:`char \*` variable is set to point to the first byte of
    the buffer, and the :ctype:`int` is set to the length of the buffer.  Only
    single-segment buffer objects are accepted; :exc:`TypeError` is raised for all
    others.
 
 ``w*`` (read-write byte-oriented buffer) [Py_buffer \*]
    This is to ``w`` what ``s*`` is to ``s``.
+
    .. versionadded:: 2.6
 
 ``(items)`` (tuple) [*matching-items*]
    The object must be a Python sequence whose length is the number of format units
    in *items*.  The C arguments must correspond to the individual format units in
    *items*.  Format units for sequences may be nested.
 
    .. note::
 
       Prior to Python version 1.5.2, this format specifier only accepted a tuple
       containing the individual parameters, not an arbitrary sequence.  Code which
       previously caused :exc:`TypeError` to be raised here may now proceed without an
@@ -283,26 +290,26 @@
    The C variables corresponding to optional arguments should be initialized to
    their default value --- when an optional argument is not specified,
    :cfunc:`PyArg_ParseTuple` does not touch the contents of the corresponding C
    variable(s).
 
 ``:``
    The list of format units ends here; the string after the colon is used as the
    function name in error messages (the "associated value" of the exception that
    :cfunc:`PyArg_ParseTuple` raises).
 
 ``;``
    The list of format units ends here; the string after the semicolon is used as
-   the error message *instead* of the default error message.  Clearly, ``:`` and
-   ``;`` mutually exclude each other.
+   the error message *instead* of the default error message.  ``:`` and ``;``
+   mutually exclude each other.
 
 Note that any Python object references which are provided to the caller are
 *borrowed* references; do not decrement their reference count!
 
 Additional arguments passed to these functions must be addresses of variables
 whose type is determined by the format string; these are used to store values
 from the input tuple.  There are a few cases, as described in the list of format
 units above, where these parameters are used as input values; they should match
 what is specified for the corresponding format unit in that case.
 
 For the conversion to succeed, the *arg* object must match the format
 and the format must be exhausted.  On success, the
@@ -519,12 +526,17 @@
       Convert a sequence of C values to a Python tuple with the same number of items.
 
    ``[items]`` (list) [*matching-items*]
       Convert a sequence of C values to a Python list with the same number of items.
 
    ``{items}`` (dictionary) [*matching-items*]
       Convert a sequence of C values to a Python dictionary.  Each pair of consecutive
       C values adds one item to the dictionary, serving as key and value,
       respectively.
 
    If there is an error in the format string, the :exc:`SystemError` exception is
    set and *NULL* returned.
+
+.. cfunction:: PyObject* Py_VaBuildValue(const char *format, va_list vargs)
+
+   Identical to :cfunc:`Py_BuildValue`, except that it accepts a va_list
+   rather than a variable number of arguments.

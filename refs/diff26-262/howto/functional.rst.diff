--- rest26/howto/functional.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/howto/functional.rst	2009-04-05 05:01:49.000000000 +0900
@@ -136,25 +136,25 @@
 
 
 Modularity
 ----------
 
 A more practical benefit of functional programming is that it forces you to
 break apart your problem into small pieces.  Programs are more modular as a
 result.  It's easier to specify and write a small function that does one thing
 than a large function that performs a complicated transformation.  Small
 functions are also easier to read and to check for errors.
 
 
-Ease of debugging and testing 
+Ease of debugging and testing
 -----------------------------
 
 Testing and debugging a functional-style program is easier.
 
 Debugging is simplified because functions are generally small and clearly
 specified.  When a program doesn't work, each function is an interface point
 where you can check that the data are correct.  You can look at the intermediate
 inputs and outputs to quickly isolate the function that's responsible for a bug.
 
 Testing is easier because each function is a potential subject for a unit test.
 Functions don't depend on system state that needs to be replicated before
 running a test; instead you only have to synthesize the right input and then
@@ -204,25 +204,25 @@
     >>> print it
     <...iterator object at ...>
     >>> it.next()
     1
     >>> it.next()
     2
     >>> it.next()
     3
     >>> it.next()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     StopIteration
-    >>>      
+    >>>
 
 Python expects iterable objects in several different contexts, the most
 important being the ``for`` statement.  In the statement ``for X in Y``, Y must
 be an iterator or some object for which ``iter()`` can create an iterator.
 These two statements are equivalent::
 
     for i in iter(obj):
         print i
 
     for i in obj:
         print i
 
@@ -353,25 +353,25 @@
 
 With a list comprehension, you get back a Python list; ``stripped_list`` is a
 list containing the resulting lines, not an iterator.  Generator expressions
 return an iterator that computes the values as necessary, not needing to
 materialize all the values at once.  This means that list comprehensions aren't
 useful if you're working with iterators that return an infinite stream or a very
 large amount of data.  Generator expressions are preferable in these situations.
 
 Generator expressions are surrounded by parentheses ("()") and list
 comprehensions are surrounded by square brackets ("[]").  Generator expressions
 have the form::
 
-    ( expression for expr in sequence1 
+    ( expression for expr in sequence1
                  if condition1
                  for expr2 in sequence2
                  if condition2
                  for expr3 in sequence3 ...
                  if condition3
                  for exprN in sequenceN
                  if conditionN )
 
 Again, for a list comprehension only the outside brackets are different (square
 brackets instead of parentheses).
 
 The elements of the generated output will be the successive values of
@@ -395,40 +395,40 @@
 
     for expr1 in sequence1:
         if not (condition1):
             continue   # Skip this element
         for expr2 in sequence2:
             if not (condition2):
                 continue    # Skip this element
             ...
             for exprN in sequenceN:
                  if not (conditionN):
                      continue   # Skip this element
 
-                 # Output the value of 
+                 # Output the value of
                  # the expression.
 
 This means that when there are multiple ``for...in`` clauses but no ``if``
 clauses, the length of the resulting output will be equal to the product of the
 lengths of all the sequences.  If you have two lists of length 3, the output
 list is 9 elements long:
 
 .. doctest::
     :options: +NORMALIZE_WHITESPACE
 
     >>> seq1 = 'abc'
     >>> seq2 = (1,2,3)
     >>> [(x,y) for x in seq1 for y in seq2]
-    [('a', 1), ('a', 2), ('a', 3), 
-     ('b', 1), ('b', 2), ('b', 3), 
+    [('a', 1), ('a', 2), ('a', 3),
+     ('b', 1), ('b', 2), ('b', 3),
      ('c', 1), ('c', 2), ('c', 3)]
 
 To avoid introducing an ambiguity into Python's grammar, if ``expression`` is
 creating a tuple, it must be surrounded with parentheses.  The first list
 comprehension below is a syntax error, while the second one is correct::
 
     # Syntax error
     [ x,y for x in seq1 for y in seq2]
     # Correct
     [ (x,y) for x in seq1 for y in seq2]
 
 
@@ -576,25 +576,25 @@
 
     >>> it = counter(10)
     >>> print it.next()
     0
     >>> print it.next()
     1
     >>> print it.send(8)
     8
     >>> print it.next()
     9
     >>> print it.next()
     Traceback (most recent call last):
-      File ``t.py'', line 15, in ?
+      File "t.py", line 15, in ?
         print it.next()
     StopIteration
 
 Because ``yield`` will often be returning ``None``, you should always check for
 this case.  Don't just use its value in expressions unless you're sure that the
 ``send()`` method will be the only method used resume your generator function.
 
 In addition to ``send()``, there are two other new methods on generators:
 
 * ``throw(type, value=None, traceback=None)`` is used to raise an exception
   inside the generator; the exception is raised by the ``yield`` expression
   where the generator's execution is paused.
@@ -719,25 +719,25 @@
     (0, 'subject')
     (1, 'verb')
     (2, 'object')
 
 :func:`enumerate` is often used when looping through a list and recording the
 indexes at which certain conditions are met::
 
     f = open('data.txt', 'r')
     for i, line in enumerate(f):
         if line.strip() == '':
             print 'Blank line at line #%i' % i
 
-``sorted(iterable, [cmp=None], [key=None], [reverse=False)`` collects all the
+``sorted(iterable, [cmp=None], [key=None], [reverse=False])`` collects all the
 elements of the iterable into a list, sorts the list, and returns the sorted
 result.  The ``cmp``, ``key``, and ``reverse`` arguments are passed through to
 the constructed list's ``.sort()`` method. ::
 
     >>> import random
     >>> # Generate 8 random numbers between [0, 10000)
     >>> rand_list = random.sample(range(10000), 8)
     >>> rand_list
     [769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]
     >>> sorted(rand_list)
     [769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]
     >>> sorted(rand_list, reverse=True)
@@ -750,25 +750,25 @@
 iterable's contents.  :func:`any` returns True if any element in the iterable is
 a true value, and :func:`all` returns True if all of the elements are true
 values:
 
     >>> any([0,1,0])
     True
     >>> any([0,0,0])
     False
     >>> any([1,1,1])
     True
     >>> all([0,1,0])
     False
-    >>> all([0,0,0]) 
+    >>> all([0,0,0])
     False
     >>> all([1,1,1])
     True
 
 
 Small functions and the lambda expression
 =========================================
 
 When writing functional-style programs, you'll often need little functions that
 act as predicates or that combine elements in some way.
 
 If there's a Python built-in or a module function that's suitable, you don't
@@ -836,25 +836,25 @@
 Many uses of :func:`reduce` are clearer when written as ``for`` loops.
 
 Fredrik Lundh once suggested the following set of rules for refactoring uses of
 ``lambda``:
 
 1) Write a lambda function.
 2) Write a comment explaining what the heck that lambda does.
 3) Study the comment for a while, and think of a name that captures the essence
    of the comment.
 4) Convert the lambda to a def statement, using that name.
 5) Remove the comment.
 
-I really like these rules, but you're free to disagree 
+I really like these rules, but you're free to disagree
 about whether this lambda-free style is better.
 
 
 The itertools module
 ====================
 
 The :mod:`itertools` module contains a number of commonly-used iterators as well
 as functions for combining several iterators.  This section will introduce the
 module's contents by showing small examples.
 
 The module's functions fall into a few broad classes:
 
@@ -961,25 +961,25 @@
 
     itertools.imap(operator.add, [5, 6, 5], [1, 2, 3]) =>
       6, 8, 8
 
 The ``operator`` module contains a set of functions corresponding to Python's
 operators.  Some examples are ``operator.add(a, b)`` (adds two values),
 ``operator.ne(a, b)`` (same as ``a!=b``), and ``operator.attrgetter('id')``
 (returns a callable that fetches the ``"id"`` attribute).
 
 ``itertools.starmap(func, iter)`` assumes that the iterable will return a stream
 of tuples, and calls ``f()`` using these tuples as the arguments::
 
-    itertools.starmap(os.path.join, 
+    itertools.starmap(os.path.join,
                       [('/usr', 'bin', 'java'), ('/bin', 'python'),
                        ('/usr', 'bin', 'perl'),('/usr', 'bin', 'ruby')])
     =>
       /usr/bin/java, /bin/python, /usr/bin/perl, /usr/bin/ruby
 
 
 Selecting elements
 ------------------
 
 Another group of functions chooses a subset of an iterator's elements based on a
 predicate.
 
@@ -1030,42 +1030,42 @@
 
 The last function I'll discuss, ``itertools.groupby(iter, key_func=None)``, is
 the most complicated.  ``key_func(elem)`` is a function that can compute a key
 value for each element returned by the iterable.  If you don't supply a key
 function, the key is simply each element itself.
 
 ``groupby()`` collects all the consecutive elements from the underlying iterable
 that have the same key value, and returns a stream of 2-tuples containing a key
 value and an iterator for the elements with that key.
 
 ::
 
-    city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'), 
+    city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),
                  ('Anchorage', 'AK'), ('Nome', 'AK'),
-                 ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'), 
+                 ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),
                  ...
                 ]
 
     def get_state ((city, state)):
         return state
 
     itertools.groupby(city_list, get_state) =>
       ('AL', iterator-1),
       ('AK', iterator-2),
       ('AZ', iterator-3), ...
 
     where
     iterator-1 =>
       ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')
-    iterator-2 => 
+    iterator-2 =>
       ('Anchorage', 'AK'), ('Nome', 'AK')
     iterator-3 =>
       ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')
 
 ``groupby()`` assumes that the underlying iterable's contents will already be
 sorted based on the key.  Note that the returned iterators also use the
 underlying iterable, so you have to consume the results of iterator-1 before
 requesting iterator-2 and its corresponding key.
 
 
 The functools module
 ====================
@@ -1141,95 +1141,95 @@
     ...     return a + b
     ...
     >>> def double(a):
     ...     return 2 * a
     ...
     >>> compose(double, add)(5, 6)
     22
 
 is equivalent to ::
 
     >>> double(add(5, 6))
     22
-                    
+
 The ``unpack`` keyword is provided to work around the fact that Python functions
 are not always `fully curried <http://en.wikipedia.org/wiki/Currying>`__.  By
 default, it is expected that the ``inner`` function will return a single object
 and that the ``outer`` function will take a single argument. Setting the
 ``unpack`` argument causes ``compose`` to expect a tuple from ``inner`` which
 will be expanded before being passed to ``outer``. Put simply, ::
 
     compose(f, g)(5, 6)
-                    
+
 is equivalent to::
 
     f(g(5, 6))
-                    
+
 while ::
 
     compose(f, g, unpack=True)(5, 6)
-                    
+
 is equivalent to::
 
     f(*g(5, 6))
 
 Even though ``compose()`` only accepts two functions, it's trivial to build up a
 version that will compose any number of functions. We'll use ``reduce()``,
 ``compose()`` and ``partial()`` (the last of which is provided by both
 ``functional`` and ``functools``). ::
 
     from functional import compose, partial
-        
+
     multi_compose = partial(reduce, compose)
-        
-    
+
+
 We can also use ``map()``, ``compose()`` and ``partial()`` to craft a version of
 ``"".join(...)`` that converts its arguments to string::
 
     from functional import compose, partial
-        
+
     join = compose("".join, partial(map, str))
 
 
 ``flip(func)``
-                    
+
 ``flip()`` wraps the callable in ``func`` and causes it to receive its
 non-keyword arguments in reverse order. ::
 
     >>> def triple(a, b, c):
     ...     return (a, b, c)
     ...
     >>> triple(5, 6, 7)
     (5, 6, 7)
     >>>
     >>> flipped_triple = flip(triple)
     >>> flipped_triple(5, 6, 7)
     (7, 6, 5)
 
 ``foldl(func, start, iterable)``
-                    
+
 ``foldl()`` takes a binary function, a starting value (usually some kind of
 'zero'), and an iterable.  The function is applied to the starting value and the
 first element of the list, then the result of that and the second element of the
 list, then the result of that and the third element of the list, and so on.
 
 This means that a call such as::
 
     foldl(f, 0, [1, 2, 3])
 
 is equivalent to::
 
     f(f(f(0, 1), 2), 3)
 
-    
+
 ``foldl()`` is roughly equivalent to the following recursive function::
 
     def foldl(func, start, seq):
         if len(seq) == 0:
             return start
 
         return foldl(func, func(start, seq[0]), seq[1:])
 
 Speaking of equivalence, the above ``foldl`` call can be expressed in terms of
 the built-in ``reduce`` like so::
 
     reduce(f, [1, 2, 3], 0)
@@ -1289,25 +1289,25 @@
 
 http://en.wikipedia.org/wiki/Currying: Entry for the concept of currying.
 
 Python-specific
 ---------------
 
 http://gnosis.cx/TPiP/: The first chapter of David Mertz's book
 :title-reference:`Text Processing in Python` discusses functional programming
 for text processing, in the section titled "Utilizing Higher-Order Functions in
 Text Processing".
 
 Mertz also wrote a 3-part series of articles on functional programming
-for IBM's DeveloperWorks site; see 
+for IBM's DeveloperWorks site; see
 `part 1 <http://www-128.ibm.com/developerworks/library/l-prog.html>`__,
 `part 2 <http://www-128.ibm.com/developerworks/library/l-prog2.html>`__, and
 `part 3 <http://www-128.ibm.com/developerworks/linux/library/l-prog3.html>`__,
 
 
 Python documentation
 --------------------
 
 Documentation for the :mod:`itertools` module.
 
 Documentation for the :mod:`operator` module.
 

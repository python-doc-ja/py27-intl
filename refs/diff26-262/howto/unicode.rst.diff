--- rest26/howto/unicode.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/howto/unicode.rst	2009-04-05 05:01:49.000000000 +0900
@@ -21,26 +21,26 @@
 
 ASCII was an American-developed standard, so it only defined unaccented
 characters.  There was an 'e', but no 'é' or 'Í'.  This meant that languages
 which required accented characters couldn't be faithfully represented in ASCII.
 (Actually the missing accents matter for English, too, which contains words such
 as 'naïve' and 'café', and some publications have house styles which require
 spellings such as 'coöperate'.)
 
 For a while people just wrote programs that didn't display accents.  I remember
 looking at Apple ][ BASIC programs, published in French-language publications in
 the mid-1980s, that had lines like these::
 
-	PRINT "FICHER EST COMPLETE."
-	PRINT "CARACTERE NON ACCEPTE."
+   PRINT "FICHIER EST COMPLETE."
+   PRINT "CARACTERE NON ACCEPTE."
 
 Those messages should contain accents, and they just look wrong to someone who
 can read French.
 
 In the 1980s, almost all personal computers were 8-bit, meaning that bytes could
 hold values ranging from 0 to 255.  ASCII codes only went up to 127, so some
 machines assigned values between 128 and 255 to accented characters.  Different
 machines had different codes, however, which led to problems exchanging files.
 Eventually various commonly used sets of values for the 128-255 range emerged.
 Some were true standards, defined by the International Standards Organization,
 and some were **de facto** conventions that were invented by one company or
 another and managed to catch on.
@@ -80,29 +80,29 @@
 abstractions, and vary depending on the language or context you're talking
 about.  For example, the symbol for ohms (Ω) is usually drawn much like the
 capital letter omega (Ω) in the Greek alphabet (they may even be the same in
 some fonts), but these are two different characters that have different
 meanings.
 
 The Unicode standard describes how characters are represented by **code
 points**.  A code point is an integer value, usually denoted in base 16.  In the
 standard, a code point is written using the notation U+12ca to mean the
 character with value 0x12ca (4810 decimal).  The Unicode standard contains a lot
 of tables listing characters and their corresponding code points::
 
-	0061    'a'; LATIN SMALL LETTER A
-	0062    'b'; LATIN SMALL LETTER B
-	0063    'c'; LATIN SMALL LETTER C
-        ...
-	007B	'{'; LEFT CURLY BRACKET
+   0061    'a'; LATIN SMALL LETTER A
+   0062    'b'; LATIN SMALL LETTER B
+   0063    'c'; LATIN SMALL LETTER C
+   ...
+   007B    '{'; LEFT CURLY BRACKET
 
 Strictly, these definitions imply that it's meaningless to say 'this is
 character U+12ca'.  U+12ca is a code point, which represents some particular
 character; in this case, it represents the character 'ETHIOPIC SYLLABLE WI'.  In
 informal contexts, this distinction between code points and characters will
 sometimes be forgotten.
 
 A character is represented on a screen or on paper by a set of graphical
 elements that's called a **glyph**.  The glyph for an uppercase A, for example,
 is two diagonal strokes and a horizontal stroke, though the exact details will
 depend on the font being used.  Most Python code doesn't need to worry about
 glyphs; figuring out the correct glyph to display is generally the job of a GUI
@@ -113,26 +113,26 @@
 ---------
 
 To summarize the previous section: a Unicode string is a sequence of code
 points, which are numbers from 0 to 0x10ffff.  This sequence needs to be
 represented as a set of bytes (meaning, values from 0-255) in memory.  The rules
 for translating a Unicode string into a sequence of bytes are called an
 **encoding**.
 
 The first encoding you might think of is an array of 32-bit integers.  In this
 representation, the string "Python" would look like this::
 
        P           y           t           h           o           n
-    0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00 
-       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 
+    0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00
+       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 
 This representation is straightforward but using it presents a number of
 problems.
 
 1. It's not portable; different processors order the bytes differently.
 
 2. It's very wasteful of space.  In most texts, the majority of the code points
    are less than 127, or less than 255, so a lot of space is occupied by zero
    bytes.  The above string takes 24 bytes compared to the 6 bytes needed for an
    ASCII representation.  Increased RAM usage doesn't matter too much (desktop
    computers have megabytes of RAM, and strings aren't usually that large), but
    expanding our usage of disk and network bandwidth by a factor of 4 is
@@ -172,25 +172,25 @@
 internal detail.
 
 UTF-8 is one of the most commonly used encodings.  UTF stands for "Unicode
 Transformation Format", and the '8' means that 8-bit numbers are used in the
 encoding.  (There's also a UTF-16 encoding, but it's less frequently used than
 UTF-8.)  UTF-8 uses the following rules:
 
 1. If the code point is <128, it's represented by the corresponding byte value.
 2. If the code point is between 128 and 0x7ff, it's turned into two byte values
    between 128 and 255.
 3. Code points >0x7ff are turned into three- or four-byte sequences, where each
    byte of the sequence is between 128 and 255.
-    
+
 UTF-8 has several convenient properties:
 
 1. It can handle any Unicode code point.
 2. A Unicode string is turned into a string of bytes containing no embedded zero
    bytes.  This avoids byte-ordering issues, and means UTF-8 strings can be
    processed by C functions such as ``strcpy()`` and sent through protocols that
    can't handle zero bytes.
 3. A string of ASCII text is also valid UTF-8 text.
 4. UTF-8 is fairly compact; the majority of code points are turned into two
    bytes, and values less than 128 occupy only a single byte.
 5. If bytes are corrupted or lost, it's possible to determine the start of the
    next UTF-8-encoded code point and resynchronize.  It's also unlikely that
@@ -243,37 +243,37 @@
 is converted to Unicode using the specified encoding; if you leave off the
 ``encoding`` argument, the ASCII encoding is used for the conversion, so
 characters greater than 127 will be treated as errors::
 
     >>> unicode('abcdef')
     u'abcdef'
     >>> s = unicode('abcdef')
     >>> type(s)
     <type 'unicode'>
     >>> unicode('abcdef' + chr(255))
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
-    UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 6: 
+    UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 6:
                         ordinal not in range(128)
 
 The ``errors`` argument specifies the response when the input string can't be
 converted according to the encoding's rules.  Legal values for this argument are
 'strict' (raise a ``UnicodeDecodeError`` exception), 'replace' (add U+FFFD,
 'REPLACEMENT CHARACTER'), or 'ignore' (just leave the character out of the
 Unicode result).  The following examples show the differences::
 
     >>> unicode('\x80abc', errors='strict')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
-    UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: 
+    UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0:
                         ordinal not in range(128)
     >>> unicode('\x80abc', errors='replace')
     u'\ufffdabc'
     >>> unicode('\x80abc', errors='ignore')
     u'abc'
 
 Encodings are specified as strings containing the encoding's name.  Python 2.4
 comes with roughly 100 different encodings; see the Python Library Reference at
 :ref:`standard-encodings` for a list.  Some encodings
 have multiple names; for example, 'latin-1', 'iso_8859_1' and '8859' are all
 synonyms for the same encoding.
 
@@ -341,127 +341,127 @@
     '&#40960;abcd&#1972;'
 
 Python's 8-bit strings have a ``.decode([encoding], [errors])`` method that
 interprets the string using the given encoding::
 
     >>> u = unichr(40960) + u'abcd' + unichr(1972)   # Assemble a string
     >>> utf8_version = u.encode('utf-8')             # Encode as UTF-8
     >>> type(utf8_version), utf8_version
     (<type 'str'>, '\xea\x80\x80abcd\xde\xb4')
     >>> u2 = utf8_version.decode('utf-8')            # Decode using UTF-8
     >>> u == u2                                      # The two strings match
     True
- 
+
 The low-level routines for registering and accessing the available encodings are
 found in the :mod:`codecs` module.  However, the encoding and decoding functions
 returned by this module are usually more low-level than is comfortable, so I'm
 not going to describe the :mod:`codecs` module here.  If you need to implement a
 completely new encoding, you'll need to learn about the :mod:`codecs` module
 interfaces, but implementing encodings is a specialized task that also won't be
 covered here.  Consult the Python documentation to learn more about this module.
 
 The most commonly used part of the :mod:`codecs` module is the
 :func:`codecs.open` function which will be discussed in the section on input and
 output.
-            
-            
+
+
 Unicode Literals in Python Source Code
 --------------------------------------
 
 In Python source code, Unicode literals are written as strings prefixed with the
 'u' or 'U' character: ``u'abcdefghijk'``.  Specific code points can be written
 using the ``\u`` escape sequence, which is followed by four hex digits giving
 the code point.  The ``\U`` escape sequence is similar, but expects 8 hex
 digits, not 4.
 
 Unicode literals can also use the same escape sequences as 8-bit strings,
 including ``\x``, but ``\x`` only takes two hex digits so it can't express an
 arbitrary code point.  Octal escapes can go up to U+01ff, which is octal 777.
 
 ::
 
     >>> s = u"a\xac\u1234\u20ac\U00008000"
                ^^^^ two-digit hex escape
-                   ^^^^^^ four-digit Unicode escape 
+                   ^^^^^^ four-digit Unicode escape
                                ^^^^^^^^^^ eight-digit Unicode escape
     >>> for c in s:  print ord(c),
-    ... 
+    ...
     97 172 4660 8364 32768
 
 Using escape sequences for code points greater than 127 is fine in small doses,
 but becomes an annoyance if you're using many accented characters, as you would
 in a program with messages in French or some other accent-using language.  You
 can also assemble strings using the :func:`unichr` built-in function, but this is
 even more tedious.
 
 Ideally, you'd want to be able to write literals in your language's natural
 encoding.  You could then edit Python source code with your favorite editor
 which would display the accented characters naturally, and have the right
 characters used at runtime.
 
 Python supports writing Unicode literals in any encoding, but you have to
 declare the encoding being used.  This is done by including a special comment as
 either the first or second line of the source file::
 
     #!/usr/bin/env python
     # -*- coding: latin-1 -*-
-    
+
     u = u'abcdé'
     print ord(u[-1])
-    
+
 The syntax is inspired by Emacs's notation for specifying variables local to a
 file.  Emacs supports many different variables, but Python only supports
-'coding'.  The ``-*-`` symbols indicate that the comment is special; within
-them, you must supply the name ``coding`` and the name of your chosen encoding,
-separated by ``':'``.
+'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is special;
+they have no significance to Python but are a convention.  Python looks for
+``coding: name`` or ``coding=name`` in the comment.
 
 If you don't include such a comment, the default encoding used will be ASCII.
 Versions of Python before 2.4 were Euro-centric and assumed Latin-1 as a default
 encoding for string literals; in Python 2.4, characters greater than 127 still
 work but result in a warning.  For example, the following program has no
 encoding declaration::
 
     #!/usr/bin/env python
     u = u'abcdé'
     print ord(u[-1])
 
 When you run it with Python 2.4, it will output the following warning::
 
     amk:~$ python p263.py
-    sys:1: DeprecationWarning: Non-ASCII character '\xe9' 
-         in file p263.py on line 2, but no encoding declared; 
+    sys:1: DeprecationWarning: Non-ASCII character '\xe9'
+         in file p263.py on line 2, but no encoding declared;
          see http://www.python.org/peps/pep-0263.html for details
-  
+
 
 Unicode Properties
 ------------------
 
 The Unicode specification includes a database of information about code points.
 For each code point that's defined, the information includes the character's
 name, its category, the numeric value if applicable (Unicode has characters
 representing the Roman numerals and fractions such as one-third and
 four-fifths).  There are also properties related to the code point's use in
 bidirectional text and other display-related properties.
 
 The following program displays some information about several characters, and
 prints the numeric value of one particular character::
 
     import unicodedata
-    
+
     u = unichr(233) + unichr(0x0bf2) + unichr(3972) + unichr(6000) + unichr(13231)
-    
+
     for i, c in enumerate(u):
         print i, '%04x' % ord(c), unicodedata.category(c),
         print unicodedata.name(c)
-    
+
     # Get numeric value of second character
     print unicodedata.numeric(u[1])
 
 When run, this prints::
 
     0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE
     1 0bf2 No TAMIL NUMBER ONE THOUSAND
     2 0f84 Mn TIBETAN MARK HALANTA
     3 1770 Lo TAGBANWA LETTER SA
     4 33af So SQUARE RAD OVER S SQUARED
     1000.0
 
@@ -588,43 +588,43 @@
 Functions in the :mod:`os` module such as :func:`os.stat` will also accept Unicode
 filenames.
 
 :func:`os.listdir`, which returns filenames, raises an issue: should it return
 the Unicode version of filenames, or should it return 8-bit strings containing
 the encoded versions?  :func:`os.listdir` will do both, depending on whether you
 provided the directory path as an 8-bit string or a Unicode string.  If you pass
 a Unicode string as the path, filenames will be decoded using the filesystem's
 encoding and a list of Unicode strings will be returned, while passing an 8-bit
 path will return the 8-bit versions of the filenames.  For example, assuming the
 default filesystem encoding is UTF-8, running the following program::
 
-	fn = u'filename\u4500abc'
-	f = open(fn, 'w')
-	f.close()
-
-	import os
-	print os.listdir('.')
-	print os.listdir(u'.')
+   fn = u'filename\u4500abc'
+   f = open(fn, 'w')
+   f.close()
+
+   import os
+   print os.listdir('.')
+   print os.listdir(u'.')
 
 will produce the following output::
 
-	amk:~$ python t.py
-	['.svn', 'filename\xe4\x94\x80abc', ...]
-	[u'.svn', u'filename\u4500abc', ...]
+   amk:~$ python t.py
+   ['.svn', 'filename\xe4\x94\x80abc', ...]
+   [u'.svn', u'filename\u4500abc', ...]
 
 The first list contains UTF-8-encoded filenames, and the second list contains
 the Unicode versions.
 
 
-	
+
 Tips for Writing Unicode-aware Programs
 ---------------------------------------
 
 This section provides some suggestions on writing software that deals with
 Unicode.
 
 The most important tip is:
 
     Software should only work with Unicode strings internally, converting to a
     particular encoding on output.
 
 If you attempt to write processing functions that accept both Unicode and 8-bit
@@ -652,25 +652,25 @@
 encodings such as ``'base64'`` that modify every single character.
 
 For example, let's say you have a content management system that takes a Unicode
 filename, and you want to disallow paths with a '/' character.  You might write
 this code::
 
     def read_file (filename, encoding):
         if '/' in filename:
             raise ValueError("'/' not allowed in filenames")
         unicode_name = filename.decode(encoding)
         f = open(unicode_name, 'r')
         # ... return contents of file ...
-        
+
 However, if an attacker could specify the ``'base64'`` encoding, they could pass
 ``'L2V0Yy9wYXNzd2Q='``, which is the base-64 encoded form of the string
 ``'/etc/passwd'``, to read a system file.  The above code looks for ``'/'``
 characters in the encoded form and misses the dangerous character in the
 resulting decoded form.
 
 References
 ----------
 
 The PDF slides for Marc-André Lemburg's presentation "Writing Unicode-aware
 Applications in Python" are available at
 <http://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf>
@@ -688,41 +688,41 @@
 Version 1.0: posted August 5 2005.
 
 Version 1.01: posted August 7 2005.  Corrects factual and markup errors; adds
 several links.
 
 Version 1.02: posted August 16 2005.  Corrects factual errors.
 
 
 .. comment Additional topic: building Python w/ UCS2 or UCS4 support
 .. comment Describe obscure -U switch somewhere?
 .. comment Describe use of codecs.StreamRecoder and StreamReaderWriter
 
-.. comment 
+.. comment
    Original outline:
 
    - [ ] Unicode introduction
        - [ ] ASCII
        - [ ] Terms
-	   - [ ] Character
-	   - [ ] Code point
-	 - [ ] Encodings
-	    - [ ] Common encodings: ASCII, Latin-1, UTF-8
+           - [ ] Character
+           - [ ] Code point
+         - [ ] Encodings
+            - [ ] Common encodings: ASCII, Latin-1, UTF-8
        - [ ] Unicode Python type
-	   - [ ] Writing unicode literals
-	       - [ ] Obscurity: -U switch
-	   - [ ] Built-ins
-	       - [ ] unichr()
-	       - [ ] ord()
-	       - [ ] unicode() constructor
-	   - [ ] Unicode type
-	       - [ ] encode(), decode() methods
+           - [ ] Writing unicode literals
+               - [ ] Obscurity: -U switch
+           - [ ] Built-ins
+               - [ ] unichr()
+               - [ ] ord()
+               - [ ] unicode() constructor
+           - [ ] Unicode type
+               - [ ] encode(), decode() methods
        - [ ] Unicodedata module for character properties
        - [ ] I/O
-	   - [ ] Reading/writing Unicode data into files
-	       - [ ] Byte-order marks
-	   - [ ] Unicode filenames
+           - [ ] Reading/writing Unicode data into files
+               - [ ] Byte-order marks
+           - [ ] Unicode filenames
        - [ ] Writing Unicode programs
-	   - [ ] Do everything in Unicode
-	   - [ ] Declaring source code encodings (PEP 263)
+           - [ ] Do everything in Unicode
+           - [ ] Declaring source code encodings (PEP 263)
        - [ ] Other issues
-	   - [ ] Building Python (UCS2, UCS4)
+           - [ ] Building Python (UCS2, UCS4)

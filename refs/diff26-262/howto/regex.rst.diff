--- rest26/howto/regex.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/howto/regex.rst	2009-04-07 00:06:52.000000000 +0900
@@ -1,19 +1,19 @@
 .. _regex-howto:
 
 ****************************
-  Regular Expression HOWTO  
+  Regular Expression HOWTO
 ****************************
 
-:Author: A.M. Kuchling
+:Author: A.M. Kuchling <amk@amk.ca>
 :Release: 0.05
 
 .. TODO:
    Document lookbehind assertions
    Better way of displaying a RE, a string, and what it matches
    Mention optional argument to match.groups()
    Unicode (at least a reference)
 
 
 .. topic:: Abstract
 
    This document is an introductory tutorial to using regular expressions in Python
@@ -531,24 +531,28 @@
 |                                 | newlines                                   |
 +---------------------------------+--------------------------------------------+
 | :const:`IGNORECASE`, :const:`I` | Do case-insensitive matches                |
 +---------------------------------+--------------------------------------------+
 | :const:`LOCALE`, :const:`L`     | Do a locale-aware match                    |
 +---------------------------------+--------------------------------------------+
 | :const:`MULTILINE`, :const:`M`  | Multi-line matching, affecting ``^`` and   |
 |                                 | ``$``                                      |
 +---------------------------------+--------------------------------------------+
 | :const:`VERBOSE`, :const:`X`    | Enable verbose REs, which can be organized |
 |                                 | more cleanly and understandably.           |
 +---------------------------------+--------------------------------------------+
+| :const:`UNICODE`, :const:`U`    | Makes several escapes like ``\w``, ``\b``, |
+|                                 | ``\s`` and ``\d`` dependent on the Unicode |
+|                                 | character database.                        |
++---------------------------------+--------------------------------------------+
 
 
 .. data:: I
           IGNORECASE
    :noindex:
 
    Perform case-insensitive matching; character class and literal strings will
    match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase
    letters, too, and ``Spam`` will match ``Spam``, ``spam``, or ``spAM``. This
    lowercasing doesn't take the current locale into account; it will if you also
    set the :const:`LOCALE` flag.
 
@@ -585,42 +589,50 @@
    the end of the string and at the end of each line (immediately preceding each
    newline).
 
 
 .. data:: S
           DOTALL
    :noindex:
 
    Makes the ``'.'`` special character match any character at all, including a
    newline; without this flag, ``'.'`` will match anything *except* a newline.
 
 
+.. data:: U
+          UNICODE
+   :noindex:
+
+   Make ``\w``, ``\W``, ``\b``, ``\B``, ``\d``, ``\D``, ``\s`` and ``\S``
+   dependent on the Unicode character properties database.
+
+
 .. data:: X
           VERBOSE
    :noindex:
 
    This flag allows you to write regular expressions that are more readable by
    granting you more flexibility in how you can format them.  When this flag has
    been specified, whitespace within the RE string is ignored, except when the
    whitespace is in a character class or preceded by an unescaped backslash; this
    lets you organize and indent the RE more clearly.  This flag also lets you put
    comments within a RE that will be ignored by the engine; comments are marked by
    a ``'#'`` that's neither in a character class or preceded by an unescaped
    backslash.
 
    For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier it
    is to read? ::
 
       charref = re.compile(r"""
-       &[#]		     # Start of a numeric entity reference
+       &[#]                # Start of a numeric entity reference
        (
            0[0-7]+         # Octal form
          | [0-9]+          # Decimal form
          | x[0-9a-fA-F]+   # Hexadecimal form
        )
        ;                   # Trailing semicolon
       """, re.VERBOSE)
 
    Without the verbose setting, the RE would look like this::
 
       charref = re.compile("&#(0[0-7]+"
                            "|[0-9]+"
@@ -723,25 +735,25 @@
 
    There are two subtleties you should remember when using this special sequence.
    First, this is the worst collision between Python's string literals and regular
    expression sequences.  In Python's string literals, ``\b`` is the backspace
    character, ASCII value 8.  If you're not using raw strings, then Python will
    convert the ``\b`` to a backspace, and your RE won't match as you expect it to.
    The following example looks the same as our previous RE, but omits the ``'r'``
    in front of the RE string. ::
 
       >>> p = re.compile('\bclass\b')
       >>> print p.search('no class at all')
       None
-      >>> print p.search('\b' + 'class' + '\b')  
+      >>> print p.search('\b' + 'class' + '\b')
       <re.MatchObject instance at 80c3ee0>
 
    Second, inside a character class, where there's no use for this assertion,
    ``\b`` represents the backspace character, for compatibility with Python's
    string literals.
 
 ``\B``
    Another zero-width assertion, this is the opposite of ``\b``, only matching when
    the current position is not at a word boundary.
 
 
 Grouping
@@ -908,25 +920,25 @@
    >>> m = p.search( '(((( Lots of punctuation )))' )
    >>> m.group('word')
    'Lots'
    >>> m.group(1)
    'Lots'
 
 Named groups are handy because they let you use easily-remembered names, instead
 of having to remember numbers.  Here's an example RE from the :mod:`imaplib`
 module::
 
    InternalDate = re.compile(r'INTERNALDATE "'
            r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'
-   	r'(?P<year>[0-9][0-9][0-9][0-9])'
+           r'(?P<year>[0-9][0-9][0-9][0-9])'
            r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'
            r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'
            r'"')
 
 It's obviously much easier to retrieve ``m.group('zonem')``, instead of having
 to remember to retrieve group 9.
 
 The syntax for backreferences in an expression such as ``(...)\1`` refers to the
 number of the group.  There's naturally a variant that uses the group name
 instead of the number. This is another Python extension: ``(?P=name)`` indicates
 that the contents of the group called *name* should again be matched at the
 current point.  The regular expression for finding doubled words,
@@ -1227,27 +1239,27 @@
 can be solved with a faster and simpler string method.
 
 
 match() versus search()
 -----------------------
 
 The :func:`match` function only checks if the RE matches at the beginning of the
 string while :func:`search` will scan forward through the string for a match.
 It's important to keep this distinction in mind.  Remember,  :func:`match` will
 only report a successful match which will start at 0; if the match wouldn't
 start at zero,  :func:`match` will *not* report it. ::
 
-   >>> print re.match('super', 'superstition').span()  
+   >>> print re.match('super', 'superstition').span()
    (0, 5)
-   >>> print re.match('super', 'insuperable')    
+   >>> print re.match('super', 'insuperable')
    None
 
 On the other hand, :func:`search` will scan forward through the string,
 reporting the first match it finds. ::
 
    >>> print re.search('super', 'superstition').span()
    (0, 5)
    >>> print re.search('super', 'insuperable').span()
    (2, 7)
 
 Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``.*``
 to the front of your RE.  Resist this temptation and use :func:`re.search`

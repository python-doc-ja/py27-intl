--- rest26/howto/sockets.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/howto/sockets.rst	2009-04-05 05:01:49.000000000 +0900
@@ -1,14 +1,14 @@
 ****************************
-  Socket Programming HOWTO  
+  Socket Programming HOWTO
 ****************************
 
 :Author: Gordon McMillan
 
 
 .. topic:: Abstract
 
    Sockets are used nearly everywhere, but are one of the most severely
    misunderstood technologies around. This is a 10,000 foot overview of sockets.
    It's not really a tutorial - you'll still have work to do in getting things
    operational. It doesn't cover the fine points (and there are a lot of them), but
    I hope it will give you enough background to begin using them decently.
@@ -54,40 +54,40 @@
 (at least compared to other schemes).
 
 
 Creating a Socket
 =================
 
 Roughly speaking, when you clicked on the link that brought you to this page,
 your browser did something like the following::
 
    #create an INET, STREAMing socket
    s = socket.socket(
        socket.AF_INET, socket.SOCK_STREAM)
-   #now connect to the web server on port 80 
+   #now connect to the web server on port 80
    # - the normal http port
    s.connect(("www.mcmillan-inc.com", 80))
 
 When the ``connect`` completes, the socket ``s`` can now be used to send in a
 request for the text of this page. The same socket will read the reply, and then
 be destroyed. That's right - destroyed. Client sockets are normally only used
 for one exchange (or a small set of sequential exchanges).
 
 What happens in the web server is a bit more complex. First, the web server
 creates a "server socket". ::
 
    #create an INET, STREAMing socket
    serversocket = socket.socket(
        socket.AF_INET, socket.SOCK_STREAM)
-   #bind the socket to a public host, 
+   #bind the socket to a public host,
    # and a well-known port
    serversocket.bind((socket.gethostname(), 80))
    #become a server socket
    serversocket.listen(5)
 
 A couple things to notice: we used ``socket.gethostname()`` so that the socket
 would be visible to the outside world. If we had used ``s.bind(('', 80))`` or
 ``s.bind(('localhost', 80))`` or ``s.bind(('127.0.0.1', 80))`` we would still
 have a "server" socket, but one that was only visible within the same machine.
 
 A second thing to note: low number ports are usually reserved for "well known"
 services (HTTP, SNMP etc). If you're playing around, use a nice high number (4
@@ -176,56 +176,56 @@
 broken.  If the connection has *not* been broken, you may wait on a ``recv``
 forever, because the socket will *not* tell you that there's nothing more to
 read (for now).  Now if you think about that a bit, you'll come to realize a
 fundamental truth of sockets: *messages must either be fixed length* (yuck), *or
 be delimited* (shrug), *or indicate how long they are* (much better), *or end by
 shutting down the connection*. The choice is entirely yours, (but some ways are
 righter than others).
 
 Assuming you don't want to end the connection, the simplest solution is a fixed
 length message::
 
    class mysocket:
-       '''demonstration class only 
+       '''demonstration class only
          - coded for clarity, not efficiency
        '''
 
        def __init__(self, sock=None):
-   	if sock is None:
-   	    self.sock = socket.socket(
-   		socket.AF_INET, socket.SOCK_STREAM)
-   	else:
-   	    self.sock = sock
+           if sock is None:
+               self.sock = socket.socket(
+                   socket.AF_INET, socket.SOCK_STREAM)
+           else:
+               self.sock = sock
 
        def connect(self, host, port):
-   	self.sock.connect((host, port))
+           self.sock.connect((host, port))
 
        def mysend(self, msg):
-   	totalsent = 0
-   	while totalsent < MSGLEN:
-   	    sent = self.sock.send(msg[totalsent:])
-   	    if sent == 0:
-   		raise RuntimeError, \
-   		    "socket connection broken"
-   	    totalsent = totalsent + sent
+           totalsent = 0
+           while totalsent < MSGLEN:
+               sent = self.sock.send(msg[totalsent:])
+               if sent == 0:
+                   raise RuntimeError, \
+                       "socket connection broken"
+               totalsent = totalsent + sent
 
        def myreceive(self):
-   	msg = ''
-   	while len(msg) < MSGLEN:
-   	    chunk = self.sock.recv(MSGLEN-len(msg))
-   	    if chunk == '':
-   		raise RuntimeError, \
-   		    "socket connection broken"
-   	    msg = msg + chunk
-   	return msg
+           msg = ''
+           while len(msg) < MSGLEN:
+               chunk = self.sock.recv(MSGLEN-len(msg))
+               if chunk == '':
+                   raise RuntimeError, \
+                       "socket connection broken"
+               msg = msg + chunk
+           return msg
 
 The sending code here is usable for almost any messaging scheme - in Python you
 send strings, and you can use ``len()`` to determine its length (even if it has
 embedded ``\0`` characters). It's mostly the receiving code that gets more
 complex. (And in C, it's not much worse, except you can't use ``strlen`` if the
 message has embedded ``\0``\ s.)
 
 The easiest enhancement is to make the first character of the message an
 indicator of message type, and have the type determine the length. Now you have
 two ``recv``\ s - the first to get (at least) that first character so you can
 look up the length, and the second in a loop to get the rest. If you decide to
 go the delimited route, you'll be receiving in some arbitrary chunk size, (4096
@@ -334,27 +334,27 @@
 yourself crazy. If you don't believe me, try it sometime. Your app will grow
 large, buggy and suck CPU. So let's skip the brain-dead solutions and do it
 right.
 
 Use ``select``.
 
 In C, coding ``select`` is fairly complex. In Python, it's a piece of cake, but
 it's close enough to the C version that if you understand ``select`` in Python,
 you'll have little trouble with it in C. ::
 
    ready_to_read, ready_to_write, in_error = \
                   select.select(
-                     potential_readers, 
-                     potential_writers, 
-                     potential_errs, 
+                     potential_readers,
+                     potential_writers,
+                     potential_errs,
                      timeout)
 
 You pass ``select`` three lists: the first contains all sockets that you might
 want to try reading; the second all the sockets you might want to try writing
 to, and the last (normally left empty) those that you want to check for errors.
 You should note that a socket can go into more than one list. The ``select``
 call is blocking, but you can give it a timeout. This is generally a sensible
 thing to do - give it a nice long timeout (say a minute) unless you have good
 reason to do otherwise.
 
 In return, you will get three lists. They have the sockets that are actually
 readable, writable and in error. Each of these lists is a subset (possibly

--- rest26/extending/extending.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/extending/extending.rst	2009-04-07 00:06:52.000000000 +0900
@@ -456,108 +456,109 @@
    }
 
 This function must be registered with the interpreter using the
 :const:`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The
 :cfunc:`PyArg_ParseTuple` function and its arguments are documented in section
 :ref:`parsetuple`.
 
 The macros :cfunc:`Py_XINCREF` and :cfunc:`Py_XDECREF` increment/decrement the
 reference count of an object and are safe in the presence of *NULL* pointers
 (but note that *temp* will not be  *NULL* in this context).  More info on them
 in section :ref:`refcounts`.
 
-.. index:: single: PyEval_CallObject()
+.. index:: single: PyObject_CallObject()
 
 Later, when it is time to call the function, you call the C function
-:cfunc:`PyEval_CallObject`.  This function has two arguments, both pointers to
+:cfunc:`PyObject_CallObject`.  This function has two arguments, both pointers to
 arbitrary Python objects: the Python function, and the argument list.  The
 argument list must always be a tuple object, whose length is the number of
-arguments.  To call the Python function with no arguments, pass in NULL, or 
+arguments.  To call the Python function with no arguments, pass in NULL, or
 an empty tuple; to call it with one argument, pass a singleton tuple.
 :cfunc:`Py_BuildValue` returns a tuple when its format string consists of zero
 or more format codes between parentheses.  For example::
 
    int arg;
    PyObject *arglist;
    PyObject *result;
    ...
    arg = 123;
    ...
    /* Time to call the callback */
    arglist = Py_BuildValue("(i)", arg);
-   result = PyEval_CallObject(my_callback, arglist);
+   result = PyObject_CallObject(my_callback, arglist);
    Py_DECREF(arglist);
 
-:cfunc:`PyEval_CallObject` returns a Python object pointer: this is the return
-value of the Python function.  :cfunc:`PyEval_CallObject` is
+:cfunc:`PyObject_CallObject` returns a Python object pointer: this is the return
+value of the Python function.  :cfunc:`PyObject_CallObject` is
 "reference-count-neutral" with respect to its arguments.  In the example a new
 tuple was created to serve as the argument list, which is :cfunc:`Py_DECREF`\
 -ed immediately after the call.
 
-The return value of :cfunc:`PyEval_CallObject` is "new": either it is a brand
+The return value of :cfunc:`PyObject_CallObject` is "new": either it is a brand
 new object, or it is an existing object whose reference count has been
 incremented.  So, unless you want to save it in a global variable, you should
 somehow :cfunc:`Py_DECREF` the result, even (especially!) if you are not
 interested in its value.
 
 Before you do this, however, it is important to check that the return value
 isn't *NULL*.  If it is, the Python function terminated by raising an exception.
-If the C code that called :cfunc:`PyEval_CallObject` is called from Python, it
+If the C code that called :cfunc:`PyObject_CallObject` is called from Python, it
 should now return an error indication to its Python caller, so the interpreter
 can print a stack trace, or the calling Python code can handle the exception.
 If this is not possible or desirable, the exception should be cleared by calling
 :cfunc:`PyErr_Clear`.  For example::
 
    if (result == NULL)
        return NULL; /* Pass error back */
    ...use result...
-   Py_DECREF(result); 
+   Py_DECREF(result);
 
 Depending on the desired interface to the Python callback function, you may also
-have to provide an argument list to :cfunc:`PyEval_CallObject`.  In some cases
+have to provide an argument list to :cfunc:`PyObject_CallObject`.  In some cases
 the argument list is also provided by the Python program, through the same
 interface that specified the callback function.  It can then be saved and used
 in the same manner as the function object.  In other cases, you may have to
 construct a new tuple to pass as the argument list.  The simplest way to do this
 is to call :cfunc:`Py_BuildValue`.  For example, if you want to pass an integral
 event code, you might use the following code::
 
    PyObject *arglist;
    ...
    arglist = Py_BuildValue("(l)", eventcode);
-   result = PyEval_CallObject(my_callback, arglist);
+   result = PyObject_CallObject(my_callback, arglist);
    Py_DECREF(arglist);
    if (result == NULL)
        return NULL; /* Pass error back */
    /* Here maybe use the result */
    Py_DECREF(result);
 
 Note the placement of ``Py_DECREF(arglist)`` immediately after the call, before
 the error check!  Also note that strictly speaking this code is not complete:
 :cfunc:`Py_BuildValue` may run out of memory, and this should be checked.
 
-You may also call a function with keyword arguments by using 
-:cfunc:`PyEval_CallObjectWithKeywords`.  As in the above example, we use
-:cfunc:`Py_BuildValue` to construct the dictionary. ::
+You may also call a function with keyword arguments by using
+:cfunc:`PyObject_Call`, which supports arguments and keyword arguments.  As in
+the above example, we use :cfunc:`Py_BuildValue` to construct the dictionary. ::
 
    PyObject *dict;
    ...
    dict = Py_BuildValue("{s:i}", "name", val);
-   result = PyEval_CallObjectWithKeywords(my_callback, NULL, dict);
+   result = PyObject_Call(my_callback, NULL, dict);
    Py_DECREF(dict);
    if (result == NULL)
        return NULL; /* Pass error back */
    /* Here maybe use the result */
    Py_DECREF(result);
 
+
 .. _parsetuple:
 
 Extracting Parameters in Extension Functions
 ============================================
 
 .. index:: single: PyArg_ParseTuple()
 
 The :cfunc:`PyArg_ParseTuple` function is declared as follows::
 
    int PyArg_ParseTuple(PyObject *arg, char *format, ...);
 
 The *arg* argument must be a tuple object containing an argument list passed
@@ -662,37 +663,37 @@
    passed in which are not present in the *kwlist* will cause :exc:`TypeError` to
    be raised.
 
 .. index:: single: Philbrick, Geoff
 
 Here is an example module which uses keywords, based on an example by Geoff
 Philbrick (philbrick@hks.com)::
 
    #include "Python.h"
 
    static PyObject *
    keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)
-   {  
+   {
        int voltage;
        char *state = "a stiff";
        char *action = "voom";
        char *type = "Norwegian Blue";
 
        static char *kwlist[] = {"voltage", "state", "action", "type", NULL};
 
-       if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist, 
+       if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist,
                                         &voltage, &state, &action, &type))
-           return NULL; 
+           return NULL;
 
-       printf("-- This parrot wouldn't %s if you put %i Volts through it.\n", 
+       printf("-- This parrot wouldn't %s if you put %i Volts through it.\n",
               action, voltage);
        printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);
 
        Py_INCREF(Py_None);
 
        return Py_None;
    }
 
    static PyMethodDef keywdarg_methods[] = {
        /* The cast of the function is necessary since PyCFunction values
         * only take two PyObject* parameters, and keywdarg_parrot() takes
         * three.
@@ -856,25 +857,25 @@
 dispose of an owned reference: pass it on, store it, or call :cfunc:`Py_DECREF`.
 Forgetting to dispose of an owned reference creates a memory leak.
 
 It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The
 borrower of a reference should not call :cfunc:`Py_DECREF`.  The borrower must
 not hold on to the object longer than the owner from which it was borrowed.
 Using a borrowed reference after the owner has disposed of it risks using freed
 memory and should be avoided completely. [#]_
 
 The advantage of borrowing over owning a reference is that you don't need to
 take care of disposing of the reference on all possible paths through the code
 --- in other words, with a borrowed reference you don't run the risk of leaking
-when a premature exit is taken.  The disadvantage of borrowing over leaking is
+when a premature exit is taken.  The disadvantage of borrowing over owning is
 that there are some subtle situations where in seemingly correct code a borrowed
 reference can be used after the owner from which it was borrowed has in fact
 disposed of it.
 
 A borrowed reference can be changed into an owned reference by calling
 :cfunc:`Py_INCREF`.  This does not affect the status of the owner from which the
 reference was borrowed --- it creates a new owned reference, and gives full
 owner responsibilities (the new owner must dispose of the reference properly, as
 well as the previous owner).
 
 
 .. _ownershiprules:

--- rest26/reference/expressions.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/reference/expressions.rst	2009-04-05 05:01:44.000000000 +0900
@@ -551,25 +551,25 @@
    object: sequence
    object: string
    object: tuple
    object: list
 
 A slicing selects a range of items in a sequence object (e.g., a string, tuple
 or list).  Slicings may be used as expressions or as targets in assignment or
 :keyword:`del` statements.  The syntax for a slicing:
 
 .. productionlist::
    slicing: `simple_slicing` | `extended_slicing`
    simple_slicing: `primary` "[" `short_slice` "]"
-   extended_slicing: `primary` "[" `slice_list` "]" 
+   extended_slicing: `primary` "[" `slice_list` "]"
    slice_list: `slice_item` ("," `slice_item`)* [","]
    slice_item: `expression` | `proper_slice` | `ellipsis`
    proper_slice: `short_slice` | `long_slice`
    short_slice: [`lower_bound`] ":" [`upper_bound`]
    long_slice: `short_slice` ":" [`stride`]
    lower_bound: `expression`
    upper_bound: `expression`
    stride: `expression`
    ellipsis: "..."
 
 .. index:: pair: extended; slicing
 
@@ -655,25 +655,25 @@
 the argument is placed in the slot, filling it (even if the expression is
 ``None``, it fills the slot).  When all arguments have been processed, the slots
 that are still unfilled are filled with the corresponding default value from the
 function definition.  (Default values are calculated, once, when the function is
 defined; thus, a mutable object such as a list or dictionary used as default
 value will be shared by all calls that don't specify an argument value for the
 corresponding slot; this should usually be avoided.)  If there are any unfilled
 slots for which no default value is specified, a :exc:`TypeError` exception is
 raised.  Otherwise, the list of filled slots is used as the argument list for
 the call.
 
 .. note::
-   
+
    An implementation may provide builtin functions whose positional parameters do
    not have names, even if they are 'named' for the purpose of documentation, and
    which therefore cannot be supplied by keyword.  In CPython, this is the case for
    functions implemented in C that use :cfunc:`PyArg_ParseTuple` to parse their
    arguments.
 
 If there are more positional arguments than there are formal parameter slots, a
 :exc:`TypeError` exception is raised, unless a formal parameter using the syntax
 ``*identifier`` is present; in this case, that formal parameter receives a tuple
 containing the excess positional arguments (or an empty tuple if there were no
 excess positional arguments).
 
@@ -807,32 +807,32 @@
 all arguments are converted to float and a float result is delivered. For
 example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``. (This last
 feature was added in Python 2.2. In Python 2.1 and before, if both arguments
 were of integer types and the second argument was negative, an exception was
 raised).
 
 Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`.
 Raising a negative number to a fractional power results in a :exc:`ValueError`.
 
 
 .. _unary:
 
-Unary arithmetic operations
-===========================
+Unary arithmetic and bitwise operations
+=======================================
 
 .. index::
    triple: unary; arithmetic; operation
    triple: unary; bitwise; operation
 
-All unary arithmetic (and bitwise) operations have the same priority:
+All unary arithmetic and bitwise operations have the same priority:
 
 .. productionlist::
    u_expr: `power` | "-" `u_expr` | "+" `u_expr` | "~" `u_expr`
 
 .. index::
    single: negation
    single: minus
 
 The unary ``-`` (minus) operator yields the negation of its numeric argument.
 
 .. index:: single: plus
 
@@ -1267,70 +1267,57 @@
 
 +-----------------------------------------------+-------------------------------------+
 | Operator                                      | Description                         |
 +===============================================+=====================================+
 | :keyword:`lambda`                             | Lambda expression                   |
 +-----------------------------------------------+-------------------------------------+
 | :keyword:`or`                                 | Boolean OR                          |
 +-----------------------------------------------+-------------------------------------+
 | :keyword:`and`                                | Boolean AND                         |
 +-----------------------------------------------+-------------------------------------+
 | :keyword:`not` *x*                            | Boolean NOT                         |
 +-----------------------------------------------+-------------------------------------+
-| :keyword:`in`, :keyword:`not` :keyword:`in`   | Membership tests                    |
-+-----------------------------------------------+-------------------------------------+
-| :keyword:`is`, :keyword:`is not`              | Identity tests                      |
-+-----------------------------------------------+-------------------------------------+
-| ``<``, ``<=``, ``>``, ``>=``, ``<>``, ``!=``, | Comparisons                         |
-| ``==``                                        |                                     |
+| :keyword:`in`, :keyword:`not` :keyword:`in`,  | Comparisons, including membership   |
+| :keyword:`is`, :keyword:`is not`, ``<``,      | tests and identity tests,           |
+| ``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==`` |                                     |
 +-----------------------------------------------+-------------------------------------+
 | ``|``                                         | Bitwise OR                          |
 +-----------------------------------------------+-------------------------------------+
 | ``^``                                         | Bitwise XOR                         |
 +-----------------------------------------------+-------------------------------------+
 | ``&``                                         | Bitwise AND                         |
 +-----------------------------------------------+-------------------------------------+
 | ``<<``, ``>>``                                | Shifts                              |
 +-----------------------------------------------+-------------------------------------+
 | ``+``, ``-``                                  | Addition and subtraction            |
 +-----------------------------------------------+-------------------------------------+
-| ``*``, ``/``, ``%``                           | Multiplication, division, remainder |
-+-----------------------------------------------+-------------------------------------+
-| ``+x``, ``-x``                                | Positive, negative                  |
-+-----------------------------------------------+-------------------------------------+
-| ``~x``                                        | Bitwise not                         |
-+-----------------------------------------------+-------------------------------------+
-| ``**``                                        | Exponentiation                      |
+| ``*``, ``/``, ``//``, ``%``                   | Multiplication, division, remainder |
 +-----------------------------------------------+-------------------------------------+
-| ``x[index]``                                  | Subscription                        |
+| ``+x``, ``-x``, ``~x``                        | Positive, negative, bitwise NOT     |
 +-----------------------------------------------+-------------------------------------+
-| ``x[index:index]``                            | Slicing                             |
+| ``**``                                        | Exponentiation [#]_                 |
 +-----------------------------------------------+-------------------------------------+
-| ``x(arguments...)``                           | Call                                |
+| ``x[index]``, ``x[index:index]``,             | Subscription, slicing,              |
+| ``x(arguments...)``, ``x.attribute``          | call, attribute reference           |
 +-----------------------------------------------+-------------------------------------+
-| ``x.attribute``                               | Attribute reference                 |
-+-----------------------------------------------+-------------------------------------+
-| ``(expressions...)``                          | Binding or tuple display            |
-+-----------------------------------------------+-------------------------------------+
-| ``[expressions...]``                          | List display                        |
-+-----------------------------------------------+-------------------------------------+
-| ``{key:datum...}``                            | Dictionary display                  |
-+-----------------------------------------------+-------------------------------------+
-| ```expressions...```                          | String conversion                   |
+| ``(expressions...)``,                         | Binding or tuple display,           |
+| ``[expressions...]``,                         | list display,                       |
+| ``{key:datum...}``,                           | dictionary display,                 |
+| ```expressions...```                          | string conversion                   |
 +-----------------------------------------------+-------------------------------------+
 
 .. rubric:: Footnotes
 
 .. [#] In Python 2.3 and later releases, a list comprehension "leaks" the control
-   variables of each ``for`` it contains into the containing scope.  However, this 
+   variables of each ``for`` it contains into the containing scope.  However, this
    behavior is deprecated, and relying on it will not work in Python 3.0
 
 .. [#] While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be
    true numerically due to roundoff.  For example, and assuming a platform on which
    a Python float is an IEEE 754 double-precision number, in order that ``-1e-100 %
    1e100`` have the same sign as ``1e100``, the computed result is ``-1e-100 +
    1e100``, which is numerically exactly equal to ``1e100``.  Function :func:`fmod`
    in the :mod:`math` module returns a result whose sign matches the sign of the
    first argument instead, and so returns ``-1e-100`` in this case. Which approach
    is more appropriate depends on the application.
 
 .. [#] If x is very close to an exact integer multiple of y, it's possible for
@@ -1345,16 +1332,19 @@
    CAPTITAL LETTER C WITH CEDILLA). To compare strings in a human
    recognizable way, compare using :func:`unicodedata.normalize`.
 
 .. [#] The implementation computes this efficiently, without constructing lists or
    sorting.
 
 .. [#] Earlier versions of Python used lexicographic comparison of the sorted (key,
    value) lists, but this was very expensive for the common case of comparing for
    equality.  An even earlier version of Python compared dictionaries by identity
    only, but this caused surprises because people expected to be able to test a
    dictionary for emptiness by comparing it to ``{}``.
 
-.. [#] Due to automatic garbage-collection, free lists, and the dynamic nature of 
+.. [#] Due to automatic garbage-collection, free lists, and the dynamic nature of
    descriptors, you may notice seemingly unusual behaviour in certain uses of
    the :keyword:`is` operator, like those involving comparisons between instance
    methods, or constants.  Check their documentation for more info.
+
+.. [#] The power operator ``**`` binds less tightly than an arithmetic or
+   bitwise unary operator on its right, that is, ``2**-1`` is ``0.5``.

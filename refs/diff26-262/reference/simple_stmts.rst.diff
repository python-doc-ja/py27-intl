--- rest26/reference/simple_stmts.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/reference/simple_stmts.rst	2009-04-07 00:06:52.000000000 +0900
@@ -109,52 +109,52 @@
 When a target is part of a mutable object (an attribute reference, subscription
 or slicing), the mutable object must ultimately perform the assignment and
 decide about its validity, and may raise an exception if the assignment is
 unacceptable.  The rules observed by various types and the exceptions raised are
 given with the definition of the object types (see section :ref:`types`).
 
 .. index:: triple: target; list; assignment
 
 Assignment of an object to a target list is recursively defined as follows.
 
 * If the target list is a single target: The object is assigned to that target.
 
-* If the target list is a comma-separated list of targets: The object must be a
-  sequence with the same number of items as there are targets in the target list,
+* If the target list is a comma-separated list of targets: The object must be an
+  iterable with the same number of items as there are targets in the target list,
   and the items are assigned, from left to right, to the corresponding targets.
   (This rule is relaxed as of Python 1.5; in earlier versions, the object had to
   be a tuple.  Since strings are sequences, an assignment like ``a, b = "xy"`` is
   now legal as long as the string has the right length.)
 
 Assignment of an object to a single target is recursively defined as follows.
 
 * If the target is an identifier (name):
 
     .. index:: statement: global
 
   * If the name does not occur in a :keyword:`global` statement in the current
     code block: the name is bound to the object in the current local namespace.
 
   * Otherwise: the name is bound to the object in the current global namespace.
 
   .. index:: single: destructor
 
   The name is rebound if it was already bound.  This may cause the reference count
   for the object previously bound to the name to reach zero, causing the object to
   be deallocated and its destructor (if it has one) to be called.
 
 * If the target is a target list enclosed in parentheses or in square brackets:
-  The object must be a sequence with the same number of items as there are targets
-  in the target list, and its items are assigned, from left to right, to the
-  corresponding targets.
+  The object must be an iterable with the same number of items as there are
+  targets in the target list, and its items are assigned, from left to right,
+  to the corresponding targets.
 
   .. index:: pair: attribute; assignment
 
 * If the target is an attribute reference: The primary expression in the
   reference is evaluated.  It should yield an object with assignable attributes;
   if this is not the case, :exc:`TypeError` is raised.  That object is then asked
   to assign the assigned object to the given attribute; if it cannot perform the
   assignment, it raises an exception (usually but not necessarily
   :exc:`AttributeError`).
 
   .. index::
      pair: subscription; assignment
@@ -219,25 +219,26 @@
 
 Augmented assignment statements
 -------------------------------
 
 .. index::
    pair: augmented; assignment
    single: statement; assignment, augmented
 
 Augmented assignment is the combination, in a single statement, of a binary
 operation and an assignment statement:
 
 .. productionlist::
-   augmented_assignment_stmt: `target` `augop` (`expression_list` | `yield_expression`)
+   augmented_assignment_stmt: `augtarget` `augop` (`expression_list` | `yield_expression`)
+   augtarget: `identifier` | `attributeref` | `subscription` | `slicing`
    augop: "+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**="
         : | ">>=" | "<<=" | "&=" | "^=" | "|="
 
 (See section :ref:`primaries` for the syntax definitions for the last three
 symbols.)
 
 An augmented assignment evaluates the target (which, unlike normal assignment
 statements, cannot be an unpacking) and the expression list, performs the binary
 operation specific to the type of assignment on the two operands, and assigns
 the result to the original target.  The target is only evaluated once.
 
 An augmented assignment expression like ``x += 1`` can be rewritten as ``x = x +
@@ -643,66 +644,142 @@
    import_stmt: "import" `module` ["as" `name`] ( "," `module` ["as" `name`] )*
               : | "from" `relative_module` "import" `identifier` ["as" `name`]
               : ( "," `identifier` ["as" `name`] )*
               : | "from" `relative_module` "import" "(" `identifier` ["as" `name`]
               : ( "," `identifier` ["as" `name`] )* [","] ")"
               : | "from" `module` "import" "*"
    module: (`identifier` ".")* `identifier`
    relative_module: "."* `module` | "."+
    name: `identifier`
 
 Import statements are executed in two steps: (1) find a module, and initialize
 it if necessary; (2) define a name or names in the local namespace (of the scope
-where the :keyword:`import` statement occurs). The first form (without
-:keyword:`from`) repeats these steps for each identifier in the list.  The form
-with :keyword:`from` performs step (1) once, and then performs step (2)
-repeatedly.
-
-In this context, to "initialize" a built-in or extension module means to call an
-initialization function that the module must provide for the purpose (in the
-reference implementation, the function's name is obtained by prepending string
-"init" to the module's name); to "initialize" a Python-coded module means to
-execute the module's body.
-
-.. index::
-   single: modules (in module sys)
-   single: sys.modules
-   pair: module; name
-   pair: built-in; module
-   pair: user-defined; module
-   module: sys
-   pair: filename; extension
-   triple: module; search; path
-
-The system maintains a table of modules that have been or are being initialized,
-indexed by module name.  This table is accessible as ``sys.modules``.  When a
-module name is found in this table, step (1) is finished.  If not, a search for
-a module definition is started.  When a module is found, it is loaded.  Details
-of the module searching and loading process are implementation and platform
-specific.  It generally involves searching for a "built-in" module with the
-given name and then searching a list of locations given as ``sys.path``.
-
-.. index::
-   pair: module; initialization
-   exception: ImportError
-   single: code block
-   exception: SyntaxError
-
-If a built-in module is found, its built-in initialization code is executed and
-step (1) is finished.  If no matching file is found, :exc:`ImportError` is
-raised. If a file is found, it is parsed, yielding an executable code block.  If
-a syntax error occurs, :exc:`SyntaxError` is raised.  Otherwise, an empty module
-of the given name is created and inserted in the module table, and then the code
-block is executed in the context of this module.  Exceptions during this
-execution terminate step (1).
+where the :keyword:`import` statement occurs). The statement comes in two
+forms differing on whether it uses the :keyword:`from` keyword. The first form
+(without :keyword:`from`) repeats these steps for each identifier in the list.
+The form with :keyword:`from` performs step (1) once, and then performs step
+(2) repeatedly.
+
+.. index::
+    single: package
+
+To understand how step (1) occurs, one must first understand how Python handles
+hierarchical naming of modules. To help organize modules and provide a
+hierarchy in naming, Python has a concept of packages. A package can contain
+other packages and modules while modules cannot contain other modules or
+packages. From a file system perspective, packages are directories and modules
+are files. The original `specification for packages
+<http://www.python.org/doc/essays/packages.html>`_ is still available to read,
+although minor details have changed since the writing of that document.
+
+.. index::
+    single: sys.modules
+
+Once the name of the module is known (unless otherwise specified, the term
+"module" will refer to both packages and modules), searching
+for the module or package can begin. The first place checked is
+:data:`sys.modules`, the cache of all modules that have been imported
+previously. If the module is found there then it is used in step (2) of import.
+
+.. index::
+    single: sys.meta_path
+    single: finder
+    pair: finder; find_module
+    single: __path__
+
+If the module is not found in the cache, then :data:`sys.meta_path` is searched
+(the specification for :data:`sys.meta_path` can be found in :pep:`302`).
+The object is a list of :term:`finder` objects which are queried in order as to
+whether they know how to load the module by calling their :meth:`find_module`
+method with the name of the module. If the module happens to be contained
+within a package (as denoted by the existence of a dot in the name), then a
+second argument to :meth:`find_module` is given as the value of the
+:attr:`__path__` attribute from the parent package (everything up to the last
+dot in the name of the module being imported). If a finder can find the module
+it returns a :term:`loader` (discussed later) or returns :keyword:`None`.
+
+.. index::
+    single: sys.path_hooks
+    single: sys.path_importer_cache
+    single: sys.path
+
+If none of the finders on :data:`sys.meta_path` are able to find the module
+then some implicitly defined finders are queried. Implementations of Python
+vary in what implicit meta path finders are defined. The one they all do
+define, though, is one that handles :data:`sys.path_hooks`,
+:data:`sys.path_importer_cache`, and :data:`sys.path`.
+
+The implicit finder searches for the requested module in the "paths" specified
+in one of two places ("paths" do not have to be file system paths). If the
+module being imported is supposed to be contained within a package then the
+second argument passed to :meth:`find_module`, :attr:`__path__` on the parent
+package, is used as the source of paths. If the module is not contained in a
+package then :data:`sys.path` is used as the source of paths.
+
+Once the source of paths is chosen it is iterated over to find a finder that
+can handle that path. The dict at :data:`sys.path_importer_cache` caches
+finders for paths and is checked for a finder. If the path does not have a
+finder cached then :data:`sys.path_hooks` is searched by calling each object in
+the list with a single argument of the path, returning a finder or raises
+:exc:`ImportError`. If a finder is returned then it is cached in
+:data:`sys.path_importer_cache` and then used for that path entry. If no finder
+can be found but the path exists then a value of :keyword:`None` is
+stored in :data:`sys.path_importer_cache` to signify that an implicit,
+file-based finder that handles modules stored as individual files should be
+used for that path. If the path does not exist then a finder which always
+returns :keyword:`None` is placed in the cache for the path.
+
+.. index::
+    single: loader
+    pair: loader; load_module
+    exception: ImportError
+
+If no finder can find the module then :exc:`ImportError` is raised. Otherwise
+some finder returned a loader whose :meth:`load_module` method is called with
+the name of the module to load (see :pep:`302` for the original definition of
+loaders). A loader has several responsibilities to perform on a module it
+loads. First, if the module already exists in :data:`sys.modules` (a
+possibility if the loader is called outside of the import machinery) then it
+is to use that module for initialization and not a new module. But if the
+module does not exist in :data:`sys.modules` then it is to be added to that
+dict before initialization begins. If an error occurs during loading of the
+module and it was added to :data:`sys.modules` it is to be removed from the
+dict. If an error occurs but the module was already in :data:`sys.modules` it
+is left in the dict.
+
+.. index::
+    single: __name__
+    single: __file__
+    single: __path__
+    single: __package__
+    single: __loader__
+
+The loader must set several attributes on the module. :data:`__name__` is to be
+set to the name of the module. :data:`__file__` is to be the "path" to the file
+unless the module is built-in (and thus listed in
+:data:`sys.builtin_module_names`) in which case the attribute is not set.
+If what is being imported is a package then :data:`__path__` is to be set to a
+list of paths to be searched when looking for modules and packages contained
+within the package being imported. :data:`__package__` is optional but should
+be set to the name of package that contains the module or package (the empty
+string is used for module not contained in a package). :data:`__loader__` is
+also optional but should be set to the loader object that is loading the
+module.
+
+.. index::
+    exception: ImportError
+
+If an error occurs during loading then the loader raises :exc:`ImportError` if
+some other exception is not already being propagated. Otherwise the loader
+returns the module that was loaded and initialized.
 
 When step (1) finishes without raising an exception, step (2) can begin.
 
 The first form of :keyword:`import` statement binds the module name in the local
 namespace to the module object, and then goes on to import the next identifier,
 if any.  If the module name is followed by :keyword:`as`, the name following
 :keyword:`as` is used as the local name for the module.
 
 .. index::
    pair: name; binding
    exception: ImportError
 
@@ -724,41 +801,39 @@
 is not defined, the set of public names includes all names found in the module's
 namespace which do not begin with an underscore character (``'_'``).
 ``__all__`` should contain the entire public API. It is intended to avoid
 accidentally exporting items that are not part of the API (such as library
 modules which were imported and used within the module).
 
 The :keyword:`from` form with ``*`` may only occur in a module scope.  If the
 wild card form of import --- ``import *`` --- is used in a function and the
 function contains or is a nested block with free variables, the compiler will
 raise a :exc:`SyntaxError`.
 
 .. index::
-   keyword: from
-   statement: from
-   triple: hierarchical; module; names
-   single: packages
-   single: __init__.py
-
-**Hierarchical module names:** when the module names contains one or more dots,
-the module search path is carried out differently.  The sequence of identifiers
-up to the last dot is used to find a "package"; the final identifier is then
-searched inside the package.  A package is generally a subdirectory of a
-directory on ``sys.path`` that has a file :file:`__init__.py`.
-
-.. 
-   [XXX Can't be
-   bothered to spell this out right now; see the URL
-   http://www.python.org/doc/essays/packages.html for more details, also about how
-   the module search works from inside a package.]
+    single: relative; import
+
+When specifying what module to import you do not have to specify the absolute
+name of the module. When a module or package is contained within another
+package it is possible to make a relative import within the same top package
+without having to mention the package name. By using leading dots in the
+specified module or package after :keyword:`from` you can specify how high to
+traverse up the current package hierarchy without specifying exact names. One
+leading dot means the current package where the module making the import
+exists. Two dots means up one package level. Three dots is up two levels, etc.
+So if you execute ``from . import mod`` from a module in the ``pkg`` package
+then you will end up importing ``pkg.mod``. If you execute ``from ..subpkg2
+imprt mod`` from within ``pkg.subpkg1`` you will import ``pkg.subpkg2.mod``.
+The specification for relative imports is contained within :pep:`328`.
+
 
 .. index:: builtin: __import__
 
 The built-in function :func:`__import__` is provided to support applications
 that determine which modules need to be loaded dynamically; refer to
 :ref:`built-in-funcs` for additional information.
 
 
 .. _future:
 
 Future statements
 -----------------
@@ -779,28 +854,29 @@
                    : ("," feature ["as" name])* [","] ")"
    feature: identifier
    name: identifier
 
 A future statement must appear near the top of the module.  The only lines that
 can appear before a future statement are:
 
 * the module docstring (if any),
 * comments,
 * blank lines, and
 * other future statements.
 
-The features recognized by Python 2.5 are ``absolute_import``, ``division``,
-``generators``, ``nested_scopes`` and ``with_statement``.  ``generators`` and
-``nested_scopes``  are redundant in Python version 2.3 and above because they
-are always enabled.
+The features recognized by Python 2.6 are ``unicode_literals``,
+``print_function``, ``absolute_import``, ``division``, ``generators``,
+``nested_scopes`` and ``with_statement``.  ``generators``, ``with_statement``,
+``nested_scopes`` are redundant in Python version 2.6 and above because they are
+always enabled.
 
 A future statement is recognized and treated specially at compile time: Changes
 to the semantics of core constructs are often implemented by generating
 different code.  It may even be the case that a new feature introduces new
 incompatible syntax (such as a new reserved word), in which case the compiler
 may need to parse the module differently.  Such decisions cannot be pushed off
 until runtime.
 
 For any given release, the compiler knows which feature names have been defined,
 and raises a compile-time error if a future statement contains a feature not
 known to it.
 
@@ -881,25 +957,25 @@
 
 The :keyword:`exec` statement
 =============================
 
 .. index:: statement: exec
 
 .. productionlist::
    exec_stmt: "exec" `or_expr` ["in" `expression` ["," `expression`]]
 
 This statement supports dynamic execution of Python code.  The first expression
 should evaluate to either a string, an open file object, or a code object.  If
 it is a string, the string is parsed as a suite of Python statements which is
-then executed (unless a syntax error occurs).  If it is an open file, the file
+then executed (unless a syntax error occurs). [#]_  If it is an open file, the file
 is parsed until EOF and executed.  If it is a code object, it is simply
 executed.  In all cases, the code that's executed is expected to be valid as
 file input (see section :ref:`file-input`).  Be aware that the
 :keyword:`return` and :keyword:`yield` statements may not be used outside of
 function definitions even within the context of code passed to the
 :keyword:`exec` statement.
 
 In all cases, if the optional parts are omitted, the code is executed in the
 current scope.  If only the first expression after :keyword:`in` is specified,
 it should be a dictionary, which will be used for both the global and the local
 variables.  If two expressions are given, they are used for the global and local
 variables, respectively. If provided, *locals* can be any mapping object.
@@ -919,12 +995,17 @@
 
 .. index::
    builtin: eval
    builtin: globals
    builtin: locals
 
 **Programmer's hints:** dynamic evaluation of expressions is supported by the
 built-in function :func:`eval`.  The built-in functions :func:`globals` and
 :func:`locals` return the current global and local dictionary, respectively,
 which may be useful to pass around for use by :keyword:`exec`.
 
 
+.. rubric:: Footnotes
+
+.. [#] Note that the parser only accepts the Unix-style end of line convention.
+       If you are reading the code from a file, make sure to use universal
+       newline mode to convert Windows or Mac-style newlines.

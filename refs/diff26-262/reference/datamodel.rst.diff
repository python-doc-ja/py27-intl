--- rest26/reference/datamodel.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/reference/datamodel.rst	2009-04-07 00:06:52.000000000 +0900
@@ -47,30 +47,31 @@
 object's mutability is determined by its type; for instance, numbers, strings
 and tuples are immutable, while dictionaries and lists are mutable.
 
 .. index::
    single: garbage collection
    single: reference counting
    single: unreachable object
 
 Objects are never explicitly destroyed; however, when they become unreachable
 they may be garbage-collected.  An implementation is allowed to postpone garbage
 collection or omit it altogether --- it is a matter of implementation quality
 how garbage collection is implemented, as long as no objects are collected that
-are still reachable.  (Implementation note: the current implementation uses a
+are still reachable.  (Implementation note: CPython currently uses a
 reference-counting scheme with (optional) delayed detection of cyclically linked
 garbage, which collects most objects as soon as they become unreachable, but is
 not guaranteed to collect garbage containing circular references.  See the
 documentation of the :mod:`gc` module for information on controlling the
-collection of cyclic garbage.)
+collection of cyclic garbage.  Other implementations act differently and CPython
+may change.)
 
 Note that the use of the implementation's tracing or debugging facilities may
 keep objects alive that would normally be collectable. Also note that catching
 an exception with a ':keyword:`try`...\ :keyword:`except`' statement may keep
 objects alive.
 
 Some objects contain references to "external" resources such as open files or
 windows.  It is understood that these resources are freed when the object is
 garbage-collected, but since garbage collection is not guaranteed to happen,
 such objects also provide an explicit way to release the external resource,
 usually a :meth:`close` method. Programs are strongly recommended to explicitly
 close such objects.  The ':keyword:`try`...\ :keyword:`finally`' statement
@@ -1153,27 +1154,28 @@
 When implementing a class that emulates any built-in type, it is important that
 the emulation only be implemented to the degree that it makes sense for the
 object being modelled.  For example, some sequences may work well with retrieval
 of individual elements, but extracting a slice may not make sense.  (One example
 of this is the :class:`NodeList` interface in the W3C's Document Object Model.)
 
 
 .. _customization:
 
 Basic customization
 -------------------
 
-
 .. method:: object.__new__(cls[, ...])
 
+   .. index:: pair: subclassing; immutable types
+
    Called to create a new instance of class *cls*.  :meth:`__new__` is a static
    method (special-cased so you need not declare it as such) that takes the class
    of which an instance was requested as its first argument.  The remaining
    arguments are those passed to the object constructor expression (the call to the
    class).  The return value of :meth:`__new__` should be the new object instance
    (usually an instance of *cls*).
 
    Typical implementations create a new instance of the class by invoking the
    superclass's :meth:`__new__` method using ``super(currentclass,
    cls).__new__(cls[, ...])`` with appropriate arguments and then modifying the
    newly-created instance as necessary before returning it.
 
@@ -1239,25 +1241,27 @@
       but can only be cleaned up if there are no Python-level :meth:`__del__`
       methods involved. Refer to the documentation for the :mod:`gc` module for
       more information about how :meth:`__del__` methods are handled by the
       cycle detector, particularly the description of the ``garbage`` value.
 
    .. warning::
 
       Due to the precarious circumstances under which :meth:`__del__` methods are
       invoked, exceptions that occur during their execution are ignored, and a warning
       is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is invoked in
       response to a module being deleted (e.g., when execution of the program is
       done), other globals referenced by the :meth:`__del__` method may already have
-      been deleted.  For this reason, :meth:`__del__` methods should do the absolute
+      been deleted or in the process of being torn down (e.g. the import
+      machinery shutting down).  For this reason, :meth:`__del__` methods
+      should do the absolute
       minimum needed to maintain external invariants.  Starting with version 1.5,
       Python guarantees that globals whose name begins with a single underscore are
       deleted from their module before other globals are deleted; if no other
       references to such globals exist, this may help in assuring that imported
       modules are still available at the time when the :meth:`__del__` method is
       called.
 
 
 .. method:: object.__repr__(self)
 
    .. index:: builtin: repr
 
@@ -1356,74 +1360,75 @@
 .. method:: object.__rcmp__(self, other)
 
    .. versionchanged:: 2.1
       No longer supported.
 
 
 .. method:: object.__hash__(self)
 
    .. index::
       object: dictionary
       builtin: hash
 
-   Called for the key object for dictionary operations, and by the built-in
-   function :func:`hash`.  Should return an integer usable as a hash value
-   for dictionary operations.  The only required property is that objects which
-   compare equal have the same hash value; it is advised to somehow mix together
-   (e.g., using exclusive or) the hash values for the components of the object that
-   also play a part in comparison of objects.
+   Called by built-in function :func:`hash` and for operations on members of
+   hashed collections including :class:`set`, :class:`frozenset`, and
+   :class:`dict`.  :meth:`__hash__` should return an integer.  The only required
+   property is that objects which compare equal have the same hash value; it is
+   advised to somehow mix together (e.g. using exclusive or) the hash values for
+   the components of the object that also play a part in comparison of objects.
 
    If a class does not define a :meth:`__cmp__` or :meth:`__eq__` method it
    should not define a :meth:`__hash__` operation either; if it defines
    :meth:`__cmp__` or :meth:`__eq__` but not :meth:`__hash__`, its instances
-   will not be usable as dictionary keys.  If a class defines mutable objects
+   will not be usable in hashed collections.  If a class defines mutable objects
    and implements a :meth:`__cmp__` or :meth:`__eq__` method, it should not
-   implement :meth:`__hash__`, since the dictionary implementation requires that
-   a key's hash value is immutable (if the object's hash value changes, it will
-   be in the wrong hash bucket).
+   implement :meth:`__hash__`, since hashable collection implementations require
+   that a object's hash value is immutable (if the object's hash value changes,
+   it will be in the wrong hash bucket).
 
    User-defined classes have :meth:`__cmp__` and :meth:`__hash__` methods
    by default; with them, all objects compare unequal (except with themselves)
    and ``x.__hash__()`` returns ``id(x)``.
 
    Classes which inherit a :meth:`__hash__` method from a parent class but
    change the meaning of :meth:`__cmp__` or :meth:`__eq__` such that the hash
    value returned is no longer appropriate (e.g. by switching to a value-based
    concept of equality instead of the default identity based equality) can
-   explicitly flag themselves as being unhashable by setting
-   ``__hash__ = None`` in the class definition. Doing so means that not only
-   will instances of the class raise an appropriate :exc:`TypeError` when
-   a program attempts to retrieve their hash value, but they will also be
-   correctly identified as unhashable when checking
-   ``isinstance(obj, collections.Hashable)`` (unlike classes which define
-   their own :meth:`__hash__` to explicitly raise :exc:`TypeError`).
+   explicitly flag themselves as being unhashable by setting ``__hash__ = None``
+   in the class definition. Doing so means that not only will instances of the
+   class raise an appropriate :exc:`TypeError` when a program attempts to
+   retrieve their hash value, but they will also be correctly identified as
+   unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike
+   classes which define their own :meth:`__hash__` to explicitly raise
+   :exc:`TypeError`).
 
    .. versionchanged:: 2.5
       :meth:`__hash__` may now also return a long integer object; the 32-bit
       integer is then derived from the hash of that object.
 
    .. versionchanged:: 2.6
       :attr:`__hash__` may now be set to :const:`None` to explicitly flag
       instances of a class as unhashable.
 
 
 .. method:: object.__nonzero__(self)
 
    .. index:: single: __len__() (mapping object method)
 
-   Called to implement truth value testing, and the built-in operation ``bool()``;
+   Called to implement truth value testing and the built-in operation ``bool()``;
    should return ``False`` or ``True``, or their integer equivalents ``0`` or
-   ``1``. When this method is not defined, :meth:`__len__` is called, if it is
-   defined (see below).  If a class defines neither :meth:`__len__` nor
-   :meth:`__nonzero__`, all its instances are considered true.
+   ``1``.  When this method is not defined, :meth:`__len__` is called, if it is
+   defined, and the object is considered true if its result is nonzero.
+   If a class defines neither :meth:`__len__` nor :meth:`__nonzero__`, all its
+   instances are considered true.
 
 
 .. method:: object.__unicode__(self)
 
    .. index:: builtin: unicode
 
    Called to implement :func:`unicode` builtin; should return a Unicode object.
    When this method is not defined, string conversion is attempted, and the result
    of string conversion is converted to Unicode using the system default encoding.
 
 
 .. _attribute-access:
@@ -1654,26 +1659,26 @@
   *__slots__*; otherwise, the class attribute would overwrite the descriptor
   assignment.
 
 * If a class defines a slot also defined in a base class, the instance variable
   defined by the base class slot is inaccessible (except by retrieving its
   descriptor directly from the base class). This renders the meaning of the
   program undefined.  In the future, a check may be added to prevent this.
 
 * The action of a *__slots__* declaration is limited to the class where it is
   defined.  As a result, subclasses will have a *__dict__* unless they also define
   *__slots__*.
 
-* *__slots__* do not work for classes derived from "variable-length" built-in
-  types such as :class:`long`, :class:`str` and :class:`tuple`.
+* Nonempty *__slots__* does not work for classes derived from "variable-length"
+  built-in types such as :class:`long`, :class:`str` and :class:`tuple`.
 
 * Any non-string iterable may be assigned to *__slots__*. Mappings may also be
   used; however, in the future, special meaning may be assigned to the values
   corresponding to each key.
 
 * *__class__* assignment works only if both classes have the same *__slots__*.
 
   .. versionchanged:: 2.6
      Previously, *__class__* assignment raised an error if either new or old class
      had *__slots__*.
 
 
@@ -2066,31 +2071,31 @@
             object.__imul__(self, other)
             object.__idiv__(self, other)
             object.__itruediv__(self, other)
             object.__ifloordiv__(self, other)
             object.__imod__(self, other)
             object.__ipow__(self, other[, modulo])
             object.__ilshift__(self, other)
             object.__irshift__(self, other)
             object.__iand__(self, other)
             object.__ixor__(self, other)
             object.__ior__(self, other)
 
-   These methods are called to implement the augmented arithmetic operations
+   These methods are called to implement the augmented arithmetic assignments
    (``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``,
    ``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation
    in-place (modifying *self*) and return the result (which could be, but does
    not have to be, *self*).  If a specific method is not defined, the augmented
-   operation falls back to the normal methods.  For instance, to evaluate the
-   expression ``x += y``, where *x* is an instance of a class that has an
+   assignment falls back to the normal methods.  For instance, to execute the
+   statement ``x += y``, where *x* is an instance of a class that has an
    :meth:`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance
    of a class that does not define a :meth:`__iadd__` method, ``x.__add__(y)``
    and ``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``.
 
 
 .. method:: object.__neg__(self)
             object.__pos__(self)
             object.__abs__(self)
             object.__invert__(self)
 
    .. index:: builtin: abs
 
@@ -2232,25 +2237,26 @@
   sequence repetition is invoked.
 
 *
 
   Rich comparisons (implemented by methods :meth:`__eq__` and so on) never use
   coercion.  Three-way comparison (implemented by :meth:`__cmp__`) does use
   coercion under the same conditions as other binary operations use it.
 
 *
 
   In the current implementation, the built-in numeric types :class:`int`,
   :class:`long` and :class:`float` do not use coercion; the type :class:`complex`
-  however does use it.  The difference can become apparent when subclassing these
+  however does use coercion for binary operators and rich comparisons, despite
+  the above rules.  The difference can become apparent when subclassing these
   types.  Over time, the type :class:`complex` may be fixed to avoid coercion.
   All these types implement a :meth:`__coerce__` method, for use by the built-in
   :func:`coerce` function.
 
 
 .. _context-managers:
 
 With Statement Context Managers
 -------------------------------
 
 .. versionadded:: 2.5
 
@@ -2360,25 +2366,25 @@
    TypeError: descriptor '__hash__' of 'int' object needs an argument
 
 Incorrectly attempting to invoke an unbound method of a class in this way is
 sometimes referred to as 'metaclass confusion', and is avoided by bypassing
 the instance when looking up special methods::
 
    >>> type(1).__hash__(1) == hash(1)
    True
    >>> type(int).__hash__(int) == hash(int)
    True
 
 In addition to bypassing any instance attributes in the interest of
-correctness, implicit special method lookup may also bypass the
+correctness, implicit special method lookup generally also bypasses the
 :meth:`__getattribute__` method even of the object's metaclass::
 
    >>> class Meta(type):
    ...    def __getattribute__(*args):
    ...       print "Metaclass getattribute invoked"
    ...       return type.__getattribute__(*args)
    ...
    >>> class C(object):
    ...     __metaclass__ = Meta
    ...     def __len__(self):
    ...         return 10
    ...     def __getattribute__(*args):

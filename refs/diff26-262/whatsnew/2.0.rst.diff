--- rest26/whatsnew/2.0.rst	2008-12-19 16:58:09.000000000 +0900
+++ rest262/whatsnew/2.0.rst	2009-04-05 05:01:47.000000000 +0900
@@ -1,14 +1,14 @@
 ****************************
-  What's New in Python 2.0  
+  What's New in Python 2.0
 ****************************
 
 :Author: A.M. Kuchling and Moshe Zadka
 
 .. |release| replace:: 1.02
 
 .. $Id: whatsnew20.tex 50964 2006-07-30 03:03:43Z fred.drake $
 
 
 Introduction
 ============
 
@@ -268,61 +268,61 @@
 all the strings containing a given substring, or strip off trailing whitespace
 from each line.
 
 The existing :func:`map` and :func:`filter` functions can be used for this
 purpose, but they require a function as one of their arguments.  This is fine if
 there's an existing built-in function that can be passed directly, but if there
 isn't, you have to create a little function to do the required work, and
 Python's scoping rules make the result ugly if the little function needs
 additional information.  Take the first example in the previous paragraph,
 finding all the strings in the list containing a given substring.  You could
 write the following to do it::
 
-   # Given the list L, make a list of all strings 
+   # Given the list L, make a list of all strings
    # containing the substring S.
-   sublist = filter( lambda s, substring=S: 
+   sublist = filter( lambda s, substring=S:
                         string.find(s, substring) != -1,
-   	          L)
+                     L)
 
 Because of Python's scoping rules, a default argument is used so that the
 anonymous function created by the :keyword:`lambda` statement knows what
 substring is being searched for.  List comprehensions make this cleaner::
 
    sublist = [ s for s in L if string.find(s, S) != -1 ]
 
 List comprehensions have the form::
 
-   [ expression for expr in sequence1 
+   [ expression for expr in sequence1
                 for expr2 in sequence2 ...
-   	     for exprN in sequenceN
+                for exprN in sequenceN
                 if condition ]
 
 The :keyword:`for`...\ :keyword:`in` clauses contain the sequences to be
 iterated over.  The sequences do not have to be the same length, because they
 are *not* iterated over in parallel, but from left to right; this is explained
 more clearly in the following paragraphs.  The elements of the generated list
 will be the successive values of *expression*.  The final :keyword:`if` clause
 is optional; if present, *expression* is only evaluated and added to the result
 if *condition* is true.
 
 To make the semantics very clear, a list comprehension is equivalent to the
 following Python code::
 
    for expr1 in sequence1:
        for expr2 in sequence2:
        ...
            for exprN in sequenceN:
                 if (condition):
-                     # Append the value of 
-                     # the expression to the 
+                     # Append the value of
+                     # the expression to the
                      # resulting list.
 
 This means that when there are multiple :keyword:`for`...\ :keyword:`in`
 clauses, the resulting list will be equal to the product of the lengths of all
 the sequences.  If you have two lists of length 3, the output list is 9 elements
 long::
 
    seq1 = 'abc'
    seq2 = (1,2,3)
    >>> [ (x,y) for x in seq1 for y in seq2]
    [('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1),
    ('c', 2), ('c', 3)]
@@ -359,25 +359,25 @@
 named :meth:`__iadd__`, :meth:`__isub__`, etc.  For example, the following
 :class:`Number` class stores a number and supports using += to create a new
 instance with an incremented value.
 
 .. The empty groups below prevent conversion to guillemets.
 
 ::
 
    class Number:
        def __init__(self, value):
            self.value = value
        def __iadd__(self, increment):
-   	return Number( self.value + increment)
+           return Number( self.value + increment)
 
    n = Number(5)
    n += 3
    print n.value
 
 The :meth:`__iadd__` special method is called with the value of the increment,
 and should return a new instance with an appropriately modified value; this
 return value is bound as the new value of the variable on the left-hand side.
 
 Augmented assignment operators were first introduced in the C programming
 language, and most C-derived languages, such as :program:`awk`, C++, Java, Perl,
 and PHP also support them.  The augmented assignment patch was implemented by
@@ -581,25 +581,25 @@
 
 An attempt has been made to alleviate one of Python's warts, the often-confusing
 :exc:`NameError` exception when code refers to a local variable before the
 variable has been assigned a value.  For example, the following code raises an
 exception on the :keyword:`print` statement in both 1.5.2 and 2.0; in 1.5.2 a
 :exc:`NameError` exception is raised, while 2.0 raises a new
 :exc:`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass of
 :exc:`NameError`, so any existing code that expects :exc:`NameError` to be
 raised should still work. ::
 
    def f():
        print "i=",i
-       i = i + 1 
+       i = i + 1
    f()
 
 Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been
 introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised when
 Python code is found to be improperly indented.
 
 
 Changes to Built-in Functions
 -----------------------------
 
 A new built-in, :func:`zip(seq1, seq2, ...)`, has been added.  :func:`zip`
 returns a list of tuples where each tuple contains the i-th element from each of
@@ -618,25 +618,25 @@
 :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, micro,
 level, serial)`` For example, in a hypothetical 2.0.1beta1, ``sys.version_info``
 would be ``(2, 0, 1, 'beta', 1)``. *level* is a string such as ``"alpha"``,
 ``"beta"``, or ``"final"`` for a final release.
 
 Dictionaries have an odd new method, :meth:`setdefault(key, default)`, which
 behaves similarly to the existing :meth:`get` method.  However, if the key is
 missing, :meth:`setdefault` both returns the value of *default* as :meth:`get`
 would do, and also inserts it into the dictionary as the value for *key*.  Thus,
 the following lines of code::
 
    if dict.has_key( key ): return dict[key]
-   else: 
+   else:
        dict[key] = []
        return dict[key]
 
 can be reduced to a single ``return dict.setdefault(key, [])`` statement.
 
 The interpreter sets a maximum recursion depth in order to catch runaway
 recursion before filling the C stack and causing a core dump or GPF..
 Previously this limit was fixed when you compiled Python, but in 2.0 the maximum
 recursion depth can be read and modified using :func:`sys.getrecursionlimit` and
 :func:`sys.setrecursionlimit`. The default value is 1000, and a rough maximum
 value for a given platform can be found by running a new script,
 :file:`Misc/find_recursionlimit.py`.
@@ -827,49 +827,48 @@
 setup.py install``".  The platform will be automatically detected, the compiler
 will be recognized, C extension modules will be compiled, and the distribution
 installed into the proper directory.  Optional command-line arguments provide
 more control over the installation process, the distutils package offers many
 places to override defaults -- separating the build from the install, building
 or installing in non-default directories, and more.
 
 In order to use the Distutils, you need to write a :file:`setup.py` script.  For
 the simple case, when the software contains only .py files, a minimal
 :file:`setup.py` can be just a few lines long::
 
    from distutils.core import setup
-   setup (name = "foo", version = "1.0", 
+   setup (name = "foo", version = "1.0",
           py_modules = ["module1", "module2"])
 
 The :file:`setup.py` file isn't much more complicated if the software consists
 of a few packages::
 
    from distutils.core import setup
-   setup (name = "foo", version = "1.0", 
+   setup (name = "foo", version = "1.0",
           packages = ["package", "package.subpackage"])
 
 A C extension can be the most complicated case; here's an example taken from
 the PyXML package::
 
    from distutils.core import setup, Extension
 
    expat_extension = Extension('xml.parsers.pyexpat',
-   	define_macros = [('XML_NS', None)],
-   	include_dirs = [ 'extensions/expat/xmltok',
-   	                 'extensions/expat/xmlparse' ],
-   	sources = [ 'extensions/pyexpat.c',
-   	            'extensions/expat/xmltok/xmltok.c',
-    		    'extensions/expat/xmltok/xmlrole.c',
-                     ]
+        define_macros = [('XML_NS', None)],
+        include_dirs = [ 'extensions/expat/xmltok',
+                         'extensions/expat/xmlparse' ],
+        sources = [ 'extensions/pyexpat.c',
+                    'extensions/expat/xmltok/xmltok.c',
+                    'extensions/expat/xmltok/xmlrole.c', ]
           )
-   setup (name = "PyXML", version = "0.5.4", 
+   setup (name = "PyXML", version = "0.5.4",
           ext_modules =[ expat_extension ] )
 
 The Distutils can also take care of creating source and binary distributions.
 The "sdist" command, run by "``python setup.py sdist``', builds a source
 distribution such as :file:`foo-1.0.tar.gz`. Adding new commands isn't
 difficult, "bdist_rpm" and "bdist_wininst" commands have already been
 contributed to create an RPM distribution and a Windows installer for the
 software, respectively.  Commands to create other distribution formats such as
 Debian packages and Solaris :file:`.pkg` files are in various stages of
 development.
 
 All this is documented in a new manual, *Distributing Python Modules*, that

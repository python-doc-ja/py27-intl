--- rest26/library/urllib2.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/urllib2.rst	2009-04-05 05:02:09.000000000 +0900
@@ -100,25 +100,25 @@
       URLs).
 
 
 .. exception:: HTTPError
 
    Though being an exception (a subclass of :exc:`URLError`), an :exc:`HTTPError`
    can also function as a non-exceptional file-like return value (the same thing
    that :func:`urlopen` returns).  This is useful when handling exotic HTTP
    errors, such as requests for authentication.
 
    .. attribute:: code
 
-      An HTTP status code as defined in `RFC 2616 <http://www.faqs.org/rfcs/rfc2616.html>`_. 
+      An HTTP status code as defined in `RFC 2616 <http://www.faqs.org/rfcs/rfc2616.html>`_.
       This numeric value corresponds to a value found in the dictionary of
       codes as found in :attr:`BaseHTTPServer.BaseHTTPRequestHandler.responses`.
 
 
 
 The following classes are provided:
 
 
 .. class:: Request(url[, data][, headers][, origin_req_host][, unverifiable])
 
    This class is an abstraction of a URL request.
 
@@ -382,41 +382,41 @@
 
 
 .. _opener-director-objects:
 
 OpenerDirector Objects
 ----------------------
 
 :class:`OpenerDirector` instances have the following methods:
 
 
 .. method:: OpenerDirector.add_handler(handler)
 
-   *handler* should be an instance of :class:`BaseHandler`.  The following methods
-   are searched, and added to the possible chains (note that HTTP errors are a
-   special case).
+   *handler* should be an instance of :class:`BaseHandler`.  The following
+   methods are searched, and added to the possible chains (note that HTTP errors
+   are a special case).
 
-   * :meth:`protocol_open` --- signal that the handler knows how to open *protocol*
-     URLs.
+   * :samp:`{protocol}_open` --- signal that the handler knows how to open
+     *protocol* URLs.
 
-   * :meth:`http_error_type` --- signal that the handler knows how to handle HTTP
-     errors with HTTP error code *type*.
+   * :samp:`http_error_{type}` --- signal that the handler knows how to handle
+     HTTP errors with HTTP error code *type*.
 
-   * :meth:`protocol_error` --- signal that the handler knows how to handle errors
-     from (non-\ ``http``) *protocol*.
+   * :samp:`{protocol}_error` --- signal that the handler knows how to handle
+     errors from (non-\ ``http``) *protocol*.
 
-   * :meth:`protocol_request` --- signal that the handler knows how to pre-process
-     *protocol* requests.
+   * :samp:`{protocol}_request` --- signal that the handler knows how to
+     pre-process *protocol* requests.
 
-   * :meth:`protocol_response` --- signal that the handler knows how to
+   * :samp:`{protocol}_response` --- signal that the handler knows how to
      post-process *protocol* responses.
 
 
 .. method:: OpenerDirector.open(url[, data][, timeout])
 
    Open the given *url* (which can be a request object or a string), optionally
    passing the given *data*. Arguments, return values and exceptions raised are
    the same as those of :func:`urlopen` (which simply calls the :meth:`open`
    method on the currently installed global :class:`OpenerDirector`).  The
    optional *timeout* parameter specifies a timeout in seconds for blocking
    operations like the connection attempt (if not specified, the global default
    timeout setting will be usedi). The timeout feature actually works only for
@@ -432,42 +432,42 @@
    handlers for the given protocol with the given arguments (which are protocol
    specific).  The HTTP protocol is a special case which uses the HTTP response
    code to determine the specific error handler; refer to the :meth:`http_error_\*`
    methods of the handler classes.
 
    Return values and exceptions raised are the same as those of :func:`urlopen`.
 
 OpenerDirector objects open URLs in three stages:
 
 The order in which these methods are called within each stage is determined by
 sorting the handler instances.
 
-#. Every handler with a method named like :meth:`protocol_request` has that
+#. Every handler with a method named like :samp:`{protocol}_request` has that
    method called to pre-process the request.
 
-#. Handlers with a method named like :meth:`protocol_open` are called to handle
+#. Handlers with a method named like :samp:`{protocol}_open` are called to handle
    the request. This stage ends when a handler either returns a non-\ :const:`None`
    value (ie. a response), or raises an exception (usually :exc:`URLError`).
    Exceptions are allowed to propagate.
 
    In fact, the above algorithm is first tried for methods named
-   :meth:`default_open`.  If all such methods return :const:`None`, the algorithm
-   is repeated for methods named like :meth:`protocol_open`.  If all such methods
-   return :const:`None`, the algorithm is repeated for methods named
-   :meth:`unknown_open`.
+   :meth:`default_open`.  If all such methods return :const:`None`, the
+   algorithm is repeated for methods named like :samp:`{protocol}_open`.  If all
+   such methods return :const:`None`, the algorithm is repeated for methods
+   named :meth:`unknown_open`.
 
    Note that the implementation of these methods may involve calls of the parent
    :class:`OpenerDirector` instance's :meth:`.open` and :meth:`.error` methods.
 
-#. Every handler with a method named like :meth:`protocol_response` has that
+#. Every handler with a method named like :samp:`{protocol}_response` has that
    method called to post-process the response.
 
 
 .. _base-handler-objects:
 
 BaseHandler Objects
 -------------------
 
 :class:`BaseHandler` objects provide a couple of methods that are directly
 useful, and others that are meant to be used by derived classes.  These are
 intended for direct use:
 
@@ -505,26 +505,28 @@
    This method, if implemented, will be called by the parent
    :class:`OpenerDirector`.  It should return a file-like object as described in
    the return value of the :meth:`open` of :class:`OpenerDirector`, or ``None``.
    It should raise :exc:`URLError`, unless a truly exceptional thing happens (for
    example, :exc:`MemoryError` should not be mapped to :exc:`URLError`).
 
    This method will be called before any protocol-specific open method.
 
 
 .. method:: BaseHandler.protocol_open(req)
    :noindex:
 
+   ("protocol" is to be replaced by the protocol name.)
+
    This method is *not* defined in :class:`BaseHandler`, but subclasses should
-   define it if they want to handle URLs with the given protocol.
+   define it if they want to handle URLs with the given *protocol*.
 
    This method, if defined, will be called by the parent :class:`OpenerDirector`.
    Return values should be the same as for  :meth:`default_open`.
 
 
 .. method:: BaseHandler.unknown_open(req)
 
    This method is *not* defined in :class:`BaseHandler`, but subclasses should
    define it if they want to catch all URLs with no specific registered handler to
    open it.
 
    This method, if implemented, will be called by the :attr:`parent`
@@ -554,79 +556,84 @@
    in :class:`BaseHandler`, but will be called, if it exists, on an instance of a
    subclass, when an HTTP error with code *nnn* occurs.
 
    Subclasses should override this method to handle specific HTTP errors.
 
    Arguments, return values and exceptions raised should be the same as for
    :meth:`http_error_default`.
 
 
 .. method:: BaseHandler.protocol_request(req)
    :noindex:
 
+   ("protocol" is to be replaced by the protocol name.)
+
    This method is *not* defined in :class:`BaseHandler`, but subclasses should
-   define it if they want to pre-process requests of the given protocol.
+   define it if they want to pre-process requests of the given *protocol*.
 
    This method, if defined, will be called by the parent :class:`OpenerDirector`.
    *req* will be a :class:`Request` object. The return value should be a
    :class:`Request` object.
 
 
 .. method:: BaseHandler.protocol_response(req, response)
    :noindex:
 
+   ("protocol" is to be replaced by the protocol name.)
+
    This method is *not* defined in :class:`BaseHandler`, but subclasses should
-   define it if they want to post-process responses of the given protocol.
+   define it if they want to post-process responses of the given *protocol*.
 
    This method, if defined, will be called by the parent :class:`OpenerDirector`.
    *req* will be a :class:`Request` object. *response* will be an object
    implementing the same interface as the return value of :func:`urlopen`.  The
    return value should implement the same interface as the return value of
    :func:`urlopen`.
 
 
 .. _http-redirect-handler:
 
 HTTPRedirectHandler Objects
 ---------------------------
 
 .. note::
 
    Some HTTP redirections require action from this module's client code.  If this
    is the case, :exc:`HTTPError` is raised.  See :rfc:`2616` for details of the
    precise meanings of the various redirection codes.
 
 
-.. method:: HTTPRedirectHandler.redirect_request(req, fp, code, msg, hdrs)
+.. method:: HTTPRedirectHandler.redirect_request(req, fp, code, msg, hdrs, newurl)
 
    Return a :class:`Request` or ``None`` in response to a redirect. This is called
    by the default implementations of the :meth:`http_error_30\*` methods when a
    redirection is received from the server.  If a redirection should take place,
    return a new :class:`Request` to allow :meth:`http_error_30\*` to perform the
-   redirect.  Otherwise, raise :exc:`HTTPError` if no other handler should try to
-   handle this URL, or return ``None`` if you can't but another handler might.
+   redirect to *newurl*.  Otherwise, raise :exc:`HTTPError` if no other handler
+   should try to handle this URL, or return ``None`` if you can't but another
+   handler might.
 
    .. note::
 
       The default implementation of this method does not strictly follow :rfc:`2616`,
       which says that 301 and 302 responses to ``POST`` requests must not be
       automatically redirected without confirmation by the user.  In reality, browsers
       do allow automatic redirection of these responses, changing the POST to a
       ``GET``, and the default implementation reproduces this behavior.
 
 
 .. method:: HTTPRedirectHandler.http_error_301(req, fp, code, msg, hdrs)
 
-   Redirect to the ``Location:`` URL.  This method is called by the parent
-   :class:`OpenerDirector` when getting an HTTP 'moved permanently' response.
+   Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the
+   parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' response.
 
 
 .. method:: HTTPRedirectHandler.http_error_302(req, fp, code, msg, hdrs)
 
    The same as :meth:`http_error_301`, but called for the 'found' response.
 
 
 .. method:: HTTPRedirectHandler.http_error_303(req, fp, code, msg, hdrs)
 
    The same as :meth:`http_error_301`, but called for the 'see other' response.
 
 
@@ -651,25 +658,27 @@
    The :class:`cookielib.CookieJar` in which cookies are stored.
 
 
 .. _proxy-handler:
 
 ProxyHandler Objects
 --------------------
 
 
 .. method:: ProxyHandler.protocol_open(request)
    :noindex:
 
-   The :class:`ProxyHandler` will have a method :meth:`protocol_open` for every
+   ("protocol" is to be replaced by the protocol name.)
+
+   The :class:`ProxyHandler` will have a method :samp:`{protocol}_open` for every
    *protocol* which has a proxy in the *proxies* dictionary given in the
    constructor.  The method will modify requests to go through the proxy, by
    calling ``request.set_proxy()``, and call the next handler in the chain to
    actually execute the protocol.
 
 
 .. _http-password-mgr:
 
 HTTPPasswordMgr Objects
 -----------------------
 
 These methods are available on :class:`HTTPPasswordMgr` and
@@ -856,27 +865,28 @@
 --------------------------
 
 .. versionadded:: 2.4
 
 
 .. method:: HTTPErrorProcessor.unknown_open()
 
    Process HTTP error responses.
 
    For 200 error codes, the response object is returned immediately.
 
    For non-200 error codes, this simply passes the job on to the
-   :meth:`protocol_error_code` handler methods, via :meth:`OpenerDirector.error`.
-   Eventually, :class:`urllib2.HTTPDefaultErrorHandler` will raise an
-   :exc:`HTTPError` if no other handler handles the error.
+   :samp:`{protocol}_error_code` handler methods, via
+   :meth:`OpenerDirector.error`.  Eventually,
+   :class:`urllib2.HTTPDefaultErrorHandler` will raise an :exc:`HTTPError` if no
+   other handler handles the error.
 
 
 .. _urllib2-examples:
 
 Examples
 --------
 
 This example gets the python.org main page and displays the first 100 bytes of
 it::
 
    >>> import urllib2
    >>> f = urllib2.urlopen('http://www.python.org/')

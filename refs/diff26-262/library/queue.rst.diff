--- rest26/library/queue.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/queue.rst	2009-04-05 05:02:09.000000000 +0900
@@ -57,24 +57,30 @@
 
 .. exception:: Empty
 
    Exception raised when non-blocking :meth:`get` (or :meth:`get_nowait`) is called
    on a :class:`Queue` object which is empty.
 
 
 .. exception:: Full
 
    Exception raised when non-blocking :meth:`put` (or :meth:`put_nowait`) is called
    on a :class:`Queue` object which is full.
 
+.. seealso::
+
+   :class:`collections.deque` is an alternative implementation of unbounded
+   queues with fast atomic :func:`append` and :func:`popleft` operations that
+   do not require locking.
+
 
 .. _queueobjects:
 
 Queue Objects
 -------------
 
 Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:`PriorityQueue`)
 provide the public methods described below.
 
 
 .. method:: Queue.qsize()
 
@@ -153,25 +159,25 @@
    the queue.
 
    .. versionadded:: 2.5
 
 
 .. method:: Queue.join()
 
    Blocks until all items in the queue have been gotten and processed.
 
    The count of unfinished tasks goes up whenever an item is added to the queue.
    The count goes down whenever a consumer thread calls :meth:`task_done` to
    indicate that the item was retrieved and all work on it is complete. When the
-   count of unfinished tasks drops to zero, join() unblocks.
+   count of unfinished tasks drops to zero, :meth:`join` unblocks.
 
    .. versionadded:: 2.5
 
 Example of how to wait for enqueued tasks to be completed::
 
    def worker():
        while True:
            item = q.get()
            do_work(item)
            q.task_done()
 
    q = Queue()

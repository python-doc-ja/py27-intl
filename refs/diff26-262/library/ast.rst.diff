--- rest26/library/ast.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/ast.rst	2009-04-05 05:02:09.000000000 +0900
@@ -12,31 +12,30 @@
 .. versionadded:: 2.5
    The low-level ``_ast`` module containing only the node classes.
 
 .. versionadded:: 2.6
    The high-level ``ast`` module containing all helpers.
 
 
 The :mod:`ast` module helps Python applications to process trees of the Python
 abstract syntax grammar.  The abstract syntax itself might change with each
 Python release; this module helps to find out programmatically what the current
 grammar looks like.
 
-An abstract syntax tree can be generated by passing :data:`_ast.PyCF_ONLY_AST`
-as a flag to the :func:`compile` builtin function, or using the :func:`parse`
+An abstract syntax tree can be generated by passing :data:`ast.PyCF_ONLY_AST` as
+a flag to the :func:`compile` builtin function, or using the :func:`parse`
 helper provided in this module.  The result will be a tree of objects whose
-classes all inherit from :class:`ast.AST`.
+classes all inherit from :class:`ast.AST`.  An abstract syntax tree can be
+compiled into a Python code object using the built-in :func:`compile` function.
 
-A modified abstract syntax tree can be compiled into a Python code object using
-the built-in :func:`compile` function.
 
 Node classes
 ------------
 
 .. class:: AST
 
    This is the base of all AST node classes.  The actual node classes are
    derived from the :file:`Parser/Python.asdl` file, which is reproduced
    :ref:`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C
    module and re-exported in :mod:`ast`.
 
    There is one class defined for each left-hand side symbol in the abstract
@@ -117,27 +116,27 @@
 
 :mod:`ast` Helpers
 ------------------
 
 .. versionadded:: 2.6
 
 Apart from the node classes, :mod:`ast` module defines these utility functions
 and classes for traversing abstract syntax trees:
 
 .. function:: parse(expr, filename='<unknown>', mode='exec')
 
    Parse an expression into an AST node.  Equivalent to ``compile(expr,
-   filename, mode, PyCF_ONLY_AST)``.
+   filename, mode, ast.PyCF_ONLY_AST)``.
+
 
-   
 .. function:: literal_eval(node_or_string)
 
    Safely evaluate an expression node or a string containing a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,
    and ``None``.
 
    This can be used for safely evaluating strings containing Python expressions
    from untrusted sources without the need to parse the values oneself.
 
 
 .. function:: get_docstring(node, clean=True)
@@ -183,58 +182,58 @@
 
 .. function:: walk(node)
 
    Recursively yield all child nodes of *node*, in no specified order.  This is
    useful if you only want to modify nodes in place and don't care about the
    context.
 
 
 .. class:: NodeVisitor()
 
    A node visitor base class that walks the abstract syntax tree and calls a
    visitor function for every node found.  This function may return a value
-   which is forwarded by the `visit` method.
+   which is forwarded by the :meth:`visit` method.
 
    This class is meant to be subclassed, with the subclass adding visitor
    methods.
 
    .. method:: visit(node)
 
       Visit a node.  The default implementation calls the method called
       :samp:`self.visit_{classname}` where *classname* is the name of the node
       class, or :meth:`generic_visit` if that method doesn't exist.
 
    .. method:: generic_visit(node)
 
       This visitor calls :meth:`visit` on all children of the node.
-      
+
       Note that child nodes of nodes that have a custom visitor method won't be
       visited unless the visitor calls :meth:`generic_visit` or visits them
       itself.
 
    Don't use the :class:`NodeVisitor` if you want to apply changes to nodes
    during traversal.  For this a special visitor exists
    (:class:`NodeTransformer`) that allows modifications.
 
 
 .. class:: NodeTransformer()
 
    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
    allows modification of nodes.
 
-   The `NodeTransformer` will walk the AST and use the return value of the
-   visitor methods to replace or remove the old node.  If the return value of
-   the visitor method is ``None``, the node will be removed from its location,
-   otherwise it is replaced with the return value.  The return value may be the
-   original node in which case no replacement takes place.
+   The :class:`NodeTransformer` will walk the AST and use the return value of
+   the visitor methods to replace or remove the old node.  If the return value
+   of the visitor method is ``None``, the node will be removed from its
+   location, otherwise it is replaced with the return value.  The return value
+   may be the original node in which case no replacement takes place.
 
    Here is an example transformer that rewrites all occurrences of name lookups
    (``foo``) to ``data['foo']``::
 
       class RewriteName(NodeTransformer):
 
           def visit_Name(self, node):
               return copy_location(Subscript(
                   value=Name(id='data', ctx=Load()),
                   slice=Index(value=Str(s=node.id)),
                   ctx=node.ctx
               ), node)

--- rest26/library/operator.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/operator.rst	2009-04-05 05:02:09.000000000 +0900
@@ -1,22 +1,22 @@
 :mod:`operator` --- Standard operators as functions
 ===================================================
 
 .. module:: operator
    :synopsis: Functions corresponding to the standard operators.
 .. sectionauthor:: Skip Montanaro <skip@automatrix.com>
 
 
 .. testsetup::
-   
+
    import operator
    from operator import itemgetter
 
 
 The :mod:`operator` module exports a set of functions implemented in C
 corresponding to the intrinsic operators of Python.  For example,
 ``operator.add(x, y)`` is equivalent to the expression ``x+y``.  The function
 names are those used for special class methods; variants without leading and
 trailing ``__`` are also provided for convenience.
 
 The functions fall into categories that perform object comparisons, logical
 operations, mathematical operations, sequence operations, and abstract type
@@ -231,67 +231,92 @@
 
 .. function:: delitem(a, b)
               __delitem__(a, b)
 
    Remove the value of *a* at index *b*.
 
 
 .. function:: delslice(a, b, c)
               __delslice__(a, b, c)
 
    Delete the slice of *a* from index *b* to index *c-1*.
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use :func:`delitem` with a slice
+      index.
+
 
 .. function:: getitem(a, b)
               __getitem__(a, b)
 
    Return the value of *a* at index *b*.
 
 
 .. function:: getslice(a, b, c)
               __getslice__(a, b, c)
 
    Return the slice of *a* from index *b* to index *c-1*.
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use :func:`getitem` with a slice
+      index.
+
 
 .. function:: indexOf(a, b)
 
    Return the index of the first of occurrence of *b* in *a*.
 
 
 .. function:: repeat(a, b)
               __repeat__(a, b)
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use :func:`__mul__` instead.
+
    Return ``a * b`` where *a* is a sequence and *b* is an integer.
 
 
 .. function:: sequenceIncludes(...)
 
    .. deprecated:: 2.0
       Use :func:`contains` instead.
 
    Alias for :func:`contains`.
 
 
 .. function:: setitem(a, b, c)
               __setitem__(a, b, c)
 
    Set the value of *a* at index *b* to *c*.
 
 
 .. function:: setslice(a, b, c, v)
               __setslice__(a, b, c, v)
 
    Set the slice of *a* from index *b* to index *c-1* to the sequence *v*.
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use :func:`setitem` with a slice
+      index.
+
+Example use of operator functions::
+
+    >>> # Elementwise multiplication
+    >>> map(mul, [0, 1, 2, 3], [10, 20, 30, 40])
+    [0, 20, 60, 120]
+
+    >>> # Dot product
+    >>> sum(map(mul, [0, 1, 2, 3], [10, 20, 30, 40]))
+    200
+
 Many operations have an "in-place" version.  The following functions provide a
 more primitive access to in-place operators than the usual syntax does; for
 example, the :term:`statement` ``x += y`` is equivalent to
 ``x = operator.iadd(x, y)``.  Another way to put it is to say that
 ``z = operator.iadd(x, y)`` is equivalent to the compound statement
 ``z = x; z += y``.
 
 .. function:: iadd(a, b)
               __iadd__(a, b)
 
    ``a = iadd(a, b)`` is equivalent to ``a += b``.
 
@@ -365,24 +390,27 @@
 
 .. function:: ipow(a, b)
               __ipow__(a, b)
 
    ``a = ipow(a, b)`` is equivalent to ``a **= b``.
 
    .. versionadded:: 2.5
 
 
 .. function:: irepeat(a, b)
               __irepeat__(a, b)
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use :func:`__imul__` instead.
+
    ``a = irepeat(a, b)`` is equivalent to ``a *= b`` where *a* is a sequence and
    *b* is an integer.
 
    .. versionadded:: 2.5
 
 
 .. function:: irshift(a, b)
               __irshift__(a, b)
 
    ``a = irshift(a, b)`` is equivalent to ``a >>= b``.
 
    .. versionadded:: 2.5
@@ -405,102 +433,65 @@
    .. versionadded:: 2.5
 
 
 .. function:: ixor(a, b)
               __ixor__(a, b)
 
    ``a = ixor(a, b)`` is equivalent to ``a ^= b``.
 
    .. versionadded:: 2.5
 
 
 The :mod:`operator` module also defines a few predicates to test the type of
-objects.
-
-.. note::
-
-   Be careful not to misinterpret the results of these functions; only
-   :func:`isCallable` has any measure of reliability with instance objects.
-   For example:
-
-      >>> class C:
-      ...     pass
-      ... 
-      >>> import operator
-      >>> obj = C()
-      >>> operator.isMappingType(obj)
-      True
-
-.. note::
-
-   Python 3 is expected to introduce abstract base classes for
-   collection types, so it should be possible to write, for example,
-   ``isinstance(obj, collections.Mapping)`` and ``isinstance(obj,
-   collections.Sequence)``.
+objects; however, these are not all reliable.  It is preferable to test
+abstract base classes instead (see :mod:`collections` and
+:mod:`numbers` for details).
 
 .. function:: isCallable(obj)
 
    .. deprecated:: 2.0
-      Use the :func:`callable` built-in function instead.
+      Use ``isinstance(x, collections.Callable)`` instead.
 
    Returns true if the object *obj* can be called like a function, otherwise it
    returns false.  True is returned for functions, bound and unbound methods, class
    objects, and instance objects which support the :meth:`__call__` method.
 
 
 .. function:: isMappingType(obj)
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use ``isinstance(x, collections.Mapping)`` instead.
+
    Returns true if the object *obj* supports the mapping interface. This is true for
    dictionaries and all instance objects defining :meth:`__getitem__`.
 
-   .. warning::
-
-      There is no reliable way to test if an instance supports the complete mapping
-      protocol since the interface itself is ill-defined.  This makes this test less
-      useful than it otherwise might be.
-
 
 .. function:: isNumberType(obj)
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use ``isinstance(x, numbers.Number)`` instead.
+
    Returns true if the object *obj* represents a number.  This is true for all
    numeric types implemented in C.
 
-   .. warning::
-
-      There is no reliable way to test if an instance supports the complete numeric
-      interface since the interface itself is ill-defined.  This makes this test less
-      useful than it otherwise might be.
-
 
 .. function:: isSequenceType(obj)
 
+   .. deprecated:: 2.6
+      This function is removed in Python 3.0.  Use ``isinstance(x, collections.Sequence)`` instead.
+
    Returns true if the object *obj* supports the sequence protocol. This returns true
    for all objects which define sequence methods in C, and for all instance objects
    defining :meth:`__getitem__`.
 
-   .. warning::
-
-      There is no reliable way to test if an instance supports the complete sequence
-      interface since the interface itself is ill-defined.  This makes this test less
-      useful than it otherwise might be.
-
-Example: Build a dictionary that maps the ordinals from ``0`` to ``255`` to
-their character equivalents.
-
-   >>> d = {}
-   >>> keys = range(256)
-   >>> vals = map(chr, keys)
-   >>> map(operator.setitem, [d]*len(keys), keys, vals)   # doctest: +SKIP
-
-.. XXX: find a better, readable, example
 
 The :mod:`operator` module also defines tools for generalized attribute and item
 lookups.  These are useful for making fast field extractors as arguments for
 :func:`map`, :func:`sorted`, :meth:`itertools.groupby`, or other functions that
 expect a function argument.
 
 
 .. function:: attrgetter(attr[, args...])
 
    Return a callable object that fetches *attr* from its operand. If more than one
    attribute is requested, returns a tuple of attributes. After,
    ``f = attrgetter('name')``, the call ``f(b)`` returns ``b.name``.  After,
@@ -525,27 +516,27 @@
    operand's :meth:`__getitem__` method.  If multiple items are specified,
    returns a tuple of lookup values.  Equivalent to::
 
         def itemgetter(*items):
             if len(items) == 1:
                 item = items[0]
                 def g(obj):
                     return obj[item]
             else:
                 def g(obj):
                     return tuple(obj[item] for item in items)
             return g
-   
-   The items can be any type accepted by the operand's :meth:`__getitem__` 
-   method.  Dictionaries accept any hashable value.  Lists, tuples, and 
+
+   The items can be any type accepted by the operand's :meth:`__getitem__`
+   method.  Dictionaries accept any hashable value.  Lists, tuples, and
    strings accept an index or a slice:
 
       >>> itemgetter(1)('ABCDEFG')
       'B'
       >>> itemgetter(1,3,5)('ABCDEFG')
       ('B', 'D', 'F')
       >>> itemgetter(slice(2,None))('ABCDEFG')
       'CDEFG'
 
    .. versionadded:: 2.4
 
    .. versionchanged:: 2.5

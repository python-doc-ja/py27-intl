--- rest26/library/sqlite3.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/sqlite3.rst	2009-04-05 05:02:09.000000000 +0900
@@ -18,70 +18,70 @@
 pysqlite was written by Gerhard HÃ¤ring and provides a SQL interface compliant
 with the DB-API 2.0 specification described by :pep:`249`.
 
 To use the module, you must first create a :class:`Connection` object that
 represents the database.  Here the data will be stored in the
 :file:`/tmp/example` file::
 
    conn = sqlite3.connect('/tmp/example')
 
 You can also supply the special name ``:memory:`` to create a database in RAM.
 
 Once you have a :class:`Connection`, you can create a :class:`Cursor`  object
-and call its :meth:`execute` method to perform SQL commands::
+and call its :meth:`~Cursor.execute` method to perform SQL commands::
 
    c = conn.cursor()
 
    # Create table
    c.execute('''create table stocks
    (date text, trans text, symbol text,
     qty real, price real)''')
 
    # Insert a row of data
    c.execute("""insert into stocks
              values ('2006-01-05','BUY','RHAT',100,35.14)""")
 
    # Save (commit) the changes
    conn.commit()
 
    # We can also close the cursor if we are done with it
    c.close()
 
 Usually your SQL operations will need to use values from Python variables.  You
 shouldn't assemble your query using Python's string operations because doing so
 is insecure; it makes your program vulnerable to an SQL injection attack.
 
 Instead, use the DB-API's parameter substitution.  Put ``?`` as a placeholder
 wherever you want to use a value, and then provide a tuple of values as the
-second argument to the cursor's :meth:`execute` method.  (Other database modules
+second argument to the cursor's :meth:`~Cursor.execute` method.  (Other database modules
 may use a different placeholder, such as ``%s`` or ``:1``.) For example::
 
    # Never do this -- insecure!
    symbol = 'IBM'
    c.execute("... where symbol = '%s'" % symbol)
 
    # Do this instead
    t = (symbol,)
    c.execute('select * from stocks where symbol=?', t)
 
    # Larger example
-   for t in (('2006-03-28', 'BUY', 'IBM', 1000, 45.00),
+   for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),
              ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),
              ('2006-04-06', 'SELL', 'IBM', 500, 53.00),
-            ):
+            ]:
        c.execute('insert into stocks values (?,?,?,?,?)', t)
 
 To retrieve data after executing a SELECT statement, you can either treat the
-cursor as an :term:`iterator`, call the cursor's :meth:`fetchone` method to
-retrieve a single matching row, or call :meth:`fetchall` to get a list of the
+cursor as an :term:`iterator`, call the cursor's :meth:`~Cursor.fetchone` method to
+retrieve a single matching row, or call :meth:`~Cursor.fetchall` to get a list of the
 matching rows.
 
 This example uses the iterator form::
 
    >>> c = conn.cursor()
    >>> c.execute('select * from stocks order by price')
    >>> for row in c:
    ...    print row
    ...
    (u'2006-01-05', u'BUY', u'RHAT', 100, 35.140000000000001)
    (u'2006-03-28', u'BUY', u'IBM', 1000, 45.0)
    (u'2006-04-06', u'SELL', u'IBM', 500, 53.0)
@@ -121,25 +121,25 @@
    that type there.
 
 
 .. data:: PARSE_COLNAMES
 
    This constant is meant to be used with the *detect_types* parameter of the
    :func:`connect` function.
 
    Setting this makes the SQLite interface parse the column name for each column it
    returns.  It will look for a string formed [mytype] in there, and then decide
    that 'mytype' is the type of the column. It will try to find an entry of
    'mytype' in the converters dictionary and then use the converter function found
-   there to return the value. The column name found in :attr:`cursor.description`
+   there to return the value. The column name found in :attr:`Cursor.description`
    is only the first word of the column name, i.  e. if you use something like
    ``'as "x [datetime]"'`` in your SQL, then we will parse out everything until the
    first blank for the column name: the column name would simply be "x".
 
 
 .. function:: connect(database[, timeout, isolation_level, detect_types, factory])
 
    Opens a connection to the SQLite database file *database*. You can use
    ``":memory:"`` to open a database connection to a database that resides in RAM
    instead of on disk.
 
    When a database is accessed by multiple connections, and one of the processes
@@ -208,50 +208,52 @@
    By default you will not get any tracebacks in user-defined functions,
    aggregates, converters, authorizer callbacks etc. If you want to debug them, you
    can call this function with *flag* as True. Afterwards, you will get tracebacks
    from callbacks on ``sys.stderr``. Use :const:`False` to disable the feature
    again.
 
 
 .. _sqlite3-connection-objects:
 
 Connection Objects
 ------------------
 
-A :class:`Connection` instance has the following attributes and methods:
+.. class:: Connection
+
+   A SQLite database connection has the following attributes and methods:
 
 .. attribute:: Connection.isolation_level
 
-   Get or set the current isolation level. None for autocommit mode or one of
-   "DEFERRED", "IMMEDIATE" or "EXLUSIVE". See section
+   Get or set the current isolation level. :const:`None` for autocommit mode or
+   one of "DEFERRED", "IMMEDIATE" or "EXCLUSIVE". See section
    :ref:`sqlite3-controlling-transactions` for a more detailed explanation.
 
 
 .. method:: Connection.cursor([cursorClass])
 
    The cursor method accepts a single optional parameter *cursorClass*. If
    supplied, this must be a custom cursor class that extends
    :class:`sqlite3.Cursor`.
 
 
 .. method:: Connection.commit()
 
    This method commits the current transaction. If you don't call this method,
-   anything you did since the last call to commit() is not visible from from
+   anything you did since the last call to ``commit()`` is not visible from from
    other database connections. If you wonder why you don't see the data you've
    written to the database, please check you didn't forget to call this method.
 
 .. method:: Connection.rollback()
 
-   This method rolls back any changes to the database since the last call to 
+   This method rolls back any changes to the database since the last call to
    :meth:`commit`.
 
 .. method:: Connection.close()
 
    This closes the database connection. Note that this does not automatically
    call :meth:`commit`. If you just close your database connection without
    calling :meth:`commit` first, your changes will be lost!
 
 .. method:: Connection.execute(sql, [parameters])
 
    This is a nonstandard shortcut that creates an intermediate cursor object by
    calling the cursor method, then calls the cursor's :meth:`execute` method with
@@ -377,27 +379,27 @@
    If returning a tuple doesn't suffice and you want name-based access to
    columns, you should consider setting :attr:`row_factory` to the
    highly-optimized :class:`sqlite3.Row` type. :class:`Row` provides both
    index-based and case-insensitive name-based access to columns with almost no
    memory overhead. It will probably be better than your own custom
    dictionary-based approach or even a db_row based solution.
 
    .. XXX what's a db_row-based solution?
 
 
 .. attribute:: Connection.text_factory
 
-   Using this attribute you can control what objects are returned for the TEXT data
-   type. By default, this attribute is set to :class:`unicode` and the
-   :mod:`sqlite3` module will return Unicode objects for TEXT. If you want to
+   Using this attribute you can control what objects are returned for the ``TEXT``
+   data type. By default, this attribute is set to :class:`unicode` and the
+   :mod:`sqlite3` module will return Unicode objects for ``TEXT``. If you want to
    return bytestrings instead, you can set it to :class:`str`.
 
    For efficiency reasons, there's also a way to return Unicode objects only for
    non-ASCII data, and bytestrings otherwise. To activate it, set this attribute to
    :const:`sqlite3.OptimizedUnicode`.
 
    You can also set it to any other callable that accepts a single bytestring
    parameter and returns the resulting object.
 
    See the following example code for illustration:
 
    .. literalinclude:: ../includes/sqlite3/text_factory.py
@@ -415,37 +417,37 @@
    saving an in-memory database for later restoration.  This function provides
    the same capabilities as the :kbd:`.dump` command in the :program:`sqlite3`
    shell.
 
    .. versionadded:: 2.6
 
    Example::
 
       # Convert file existing_db.db to SQL dump file dump.sql
       import sqlite3, os
 
       con = sqlite3.connect('existing_db.db')
-      full_dump = os.linesep.join(con.iterdump())
-      f = open('dump.sql', 'w')
-      f.writelines(full_dump)
-      f.close()
+      with open('dump.sql', 'w') as f:
+          for line in con.iterdump():
+              f.write('%s\n' % line)
 
 
 .. _sqlite3-cursor-objects:
 
 Cursor Objects
 --------------
 
-A :class:`Cursor` instance has the following attributes and methods:
+.. class:: Cursor
 
+   A SQLite database cursor has the following attributes and methods:
 
 .. method:: Cursor.execute(sql, [parameters])
 
    Executes an SQL statement. The SQL statement may be parametrized (i. e.
    placeholders instead of SQL literals). The :mod:`sqlite3` module supports two
    kinds of placeholders: question marks (qmark style) and named placeholders
    (named style).
 
    This example shows how to use parameters with qmark style:
 
    .. literalinclude:: ../includes/sqlite3/execute_1.py
 
@@ -466,135 +468,213 @@
    :term:`iterator` yielding parameters instead of a sequence.
 
    .. literalinclude:: ../includes/sqlite3/executemany_1.py
 
    Here's a shorter example using a :term:`generator`:
 
    .. literalinclude:: ../includes/sqlite3/executemany_2.py
 
 
 .. method:: Cursor.executescript(sql_script)
 
    This is a nonstandard convenience method for executing multiple SQL statements
-   at once. It issues a COMMIT statement first, then executes the SQL script it
+   at once. It issues a ``COMMIT`` statement first, then executes the SQL script it
    gets as a parameter.
 
    *sql_script* can be a bytestring or a Unicode string.
 
    Example:
 
    .. literalinclude:: ../includes/sqlite3/executescript.py
 
 
-.. method:: Cursor.fetchone() 
-          
+.. method:: Cursor.fetchone()
+
    Fetches the next row of a query result set, returning a single sequence,
-   or ``None`` when no more data is available.
+   or :const:`None` when no more data is available.
 
 
 .. method:: Cursor.fetchmany([size=cursor.arraysize])
-          
+
    Fetches the next set of rows of a query result, returning a list.  An empty
    list is returned when no more rows are available.
-   
+
    The number of rows to fetch per call is specified by the *size* parameter.
    If it is not given, the cursor's arraysize determines the number of rows
    to be fetched. The method should try to fetch as many rows as indicated by
    the size parameter. If this is not possible due to the specified number of
    rows not being available, fewer rows may be returned.
-   
+
    Note there are performance considerations involved with the *size* parameter.
    For optimal performance, it is usually best to use the arraysize attribute.
    If the *size* parameter is used, then it is best for it to retain the same
    value from one :meth:`fetchmany` call to the next.
-            
-.. method:: Cursor.fetchall() 
+
+.. method:: Cursor.fetchall()
 
    Fetches all (remaining) rows of a query result, returning a list.  Note that
    the cursor's arraysize attribute can affect the performance of this operation.
    An empty list is returned when no rows are available.
 
 
 .. attribute:: Cursor.rowcount
 
    Although the :class:`Cursor` class of the :mod:`sqlite3` module implements this
    attribute, the database engine's own support for the determination of "rows
    affected"/"rows selected" is quirky.
 
    For ``DELETE`` statements, SQLite reports :attr:`rowcount` as 0 if you make a
    ``DELETE FROM table`` without any condition.
 
    For :meth:`executemany` statements, the number of modifications are summed up
    into :attr:`rowcount`.
 
    As required by the Python DB API Spec, the :attr:`rowcount` attribute "is -1 in
-   case no executeXX() has been performed on the cursor or the rowcount of the last
-   operation is not determinable by the interface".
+   case no ``executeXX()`` has been performed on the cursor or the rowcount of the
+   last operation is not determinable by the interface".
 
    This includes ``SELECT`` statements because we cannot determine the number of
    rows a query produced until all rows were fetched.
 
 .. attribute:: Cursor.lastrowid
 
    This read-only attribute provides the rowid of the last modified row. It is
    only set if you issued a ``INSERT`` statement using the :meth:`execute`
    method. For operations other than ``INSERT`` or when :meth:`executemany` is
    called, :attr:`lastrowid` is set to :const:`None`.
 
+.. attribute:: Cursor.description
+
+   This read-only attribute provides the column names of the last query. To
+   remain compatible with the Python DB API, it returns a 7-tuple for each
+   column where the last six items of each tuple are :const:`None`.
+
+   It is set for ``SELECT`` statements without any matching rows as well.
+
+.. _sqlite3-row-objects:
+
+Row Objects
+-----------
+
+.. class:: Row
+
+   A :class:`Row` instance serves as a highly optimized
+   :attr:`~Connection.row_factory` for :class:`Connection` objects.
+   It tries to mimic a tuple in most of its features.
+
+   It supports mapping access by column name and index, iteration,
+   representation, equality testing and :func:`len`.
+
+   If two :class:`Row` objects have exactly the same columns and their
+   members are equal, they compare equal.
+
+   .. versionchanged:: 2.6
+      Added iteration and equality (hashability).
+
+   .. method:: keys
+
+      This method returns a tuple of column names. Immediately after a query,
+      it is the first member of each tuple in :attr:`Cursor.description`.
+
+      .. versionadded:: 2.6
+
+Let's assume we initialize a table as in the example given above::
+
+    conn = sqlite3.connect(":memory:")
+    c = conn.cursor()
+    c.execute('''create table stocks
+    (date text, trans text, symbol text,
+     qty real, price real)''')
+    c.execute("""insert into stocks
+              values ('2006-01-05','BUY','RHAT',100,35.14)""")
+    conn.commit()
+    c.close()
+
+Now we plug :class:`Row` in::
+
+    >>> conn.row_factory = sqlite3.Row
+    >>> c = conn.cursor()
+    >>> c.execute('select * from stocks')
+    <sqlite3.Cursor object at 0x7f4e7dd8fa80>
+    >>> r = c.fetchone()
+    >>> type(r)
+    <type 'sqlite3.Row'>
+    >>> r
+    (u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.140000000000001)
+    >>> len(r)
+    5
+    >>> r[2]
+    u'RHAT'
+    >>> r.keys()
+    ['date', 'trans', 'symbol', 'qty', 'price']
+    >>> r['qty']
+    100.0
+    >>> for member in r: print member
+    ...
+    2006-01-05
+    BUY
+    RHAT
+    100.0
+    35.14
+
+
 .. _sqlite3-types:
 
 SQLite and Python types
 -----------------------
 
 
 Introduction
 ^^^^^^^^^^^^
 
-SQLite natively supports the following types: NULL, INTEGER, REAL, TEXT, BLOB.
+SQLite natively supports the following types: ``NULL``, ``INTEGER``,
+``REAL``, ``TEXT``, ``BLOB``.
 
 The following Python types can thus be sent to SQLite without any problem:
 
-+------------------------+-------------+
-| Python type            | SQLite type |
-+========================+=============+
-| ``None``               | NULL        |
-+------------------------+-------------+
-| ``int``                | INTEGER     |
-+------------------------+-------------+
-| ``long``               | INTEGER     |
-+------------------------+-------------+
-| ``float``              | REAL        |
-+------------------------+-------------+
-| ``str (UTF8-encoded)`` | TEXT        |
-+------------------------+-------------+
-| ``unicode``            | TEXT        |
-+------------------------+-------------+
-| ``buffer``             | BLOB        |
-+------------------------+-------------+
++-----------------------------+-------------+
+| Python type                 | SQLite type |
++=============================+=============+
+| :const:`None`               | ``NULL``    |
++-----------------------------+-------------+
+| :class:`int`                | ``INTEGER`` |
++-----------------------------+-------------+
+| :class:`long`               | ``INTEGER`` |
++-----------------------------+-------------+
+| :class:`float`              | ``REAL``    |
++-----------------------------+-------------+
+| :class:`str` (UTF8-encoded) | ``TEXT``    |
++-----------------------------+-------------+
+| :class:`unicode`            | ``TEXT``    |
++-----------------------------+-------------+
+| :class:`buffer`             | ``BLOB``    |
++-----------------------------+-------------+
 
 This is how SQLite types are converted to Python types by default:
 
-+-------------+---------------------------------------------+
-| SQLite type | Python type                                 |
-+=============+=============================================+
-| ``NULL``    | None                                        |
-+-------------+---------------------------------------------+
-| ``INTEGER`` | int or long, depending on size              |
-+-------------+---------------------------------------------+
-| ``REAL``    | float                                       |
-+-------------+---------------------------------------------+
-| ``TEXT``    | depends on text_factory, unicode by default |
-+-------------+---------------------------------------------+
-| ``BLOB``    | buffer                                      |
-+-------------+---------------------------------------------+
++-------------+----------------------------------------------+
+| SQLite type | Python type                                  |
++=============+==============================================+
+| ``NULL``    | :const:`None`                                |
++-------------+----------------------------------------------+
+| ``INTEGER`` | :class:`int` or :class:`long`,               |
+|             | depending on size                            |
++-------------+----------------------------------------------+
+| ``REAL``    | :class:`float`                               |
++-------------+----------------------------------------------+
+| ``TEXT``    | depends on :attr:`~Connection.text_factory`, |
+|             | :class:`unicode` by default                  |
++-------------+----------------------------------------------+
+| ``BLOB``    | :class:`buffer`                              |
++-------------+----------------------------------------------+
 
 The type system of the :mod:`sqlite3` module is extensible in two ways: you can
 store additional Python types in a SQLite database via object adaptation, and
 you can let the :mod:`sqlite3` module convert SQLite types to different Python
 types via converters.
 
 
 Using adapters to store additional Python types in SQLite databases
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 As described before, SQLite supports only a limited set of types natively. To
 use other Python types with SQLite, you must **adapt** them to one of the
@@ -704,60 +784,61 @@
 
 The following example demonstrates this.
 
 .. literalinclude:: ../includes/sqlite3/pysqlite_datetime.py
 
 
 .. _sqlite3-controlling-transactions:
 
 Controlling Transactions
 ------------------------
 
 By default, the :mod:`sqlite3` module opens transactions implicitly before a
-Data Modification Language (DML)  statement (i.e. INSERT/UPDATE/DELETE/REPLACE),
-and commits transactions implicitly before a non-DML, non-query statement (i. e.
-anything other than SELECT/INSERT/UPDATE/DELETE/REPLACE).
+Data Modification Language (DML)  statement (i.e.
+``INSERT``/``UPDATE``/``DELETE``/``REPLACE``), and commits transactions
+implicitly before a non-DML, non-query statement (i. e.
+anything other than ``SELECT`` or the aforementioned).
 
 So if you are within a transaction and issue a command like ``CREATE TABLE
 ...``, ``VACUUM``, ``PRAGMA``, the :mod:`sqlite3` module will commit implicitly
 before executing that command. There are two reasons for doing that. The first
 is that some of these commands don't work within transactions. The other reason
 is that pysqlite needs to keep track of the transaction state (if a transaction
 is active or not).
 
-You can control which kind of "BEGIN" statements pysqlite implicitly executes
+You can control which kind of ``BEGIN`` statements pysqlite implicitly executes
 (or none at all) via the *isolation_level* parameter to the :func:`connect`
 call, or via the :attr:`isolation_level` property of connections.
 
 If you want **autocommit mode**, then set :attr:`isolation_level` to None.
 
 Otherwise leave it at its default, which will result in a plain "BEGIN"
-statement, or set it to one of SQLite's supported isolation levels: DEFERRED,
-IMMEDIATE or EXCLUSIVE.
+statement, or set it to one of SQLite's supported isolation levels: "DEFERRED",
+"IMMEDIATE" or "EXCLUSIVE".
 
 
 
 Using pysqlite efficiently
 --------------------------
 
 
 Using shortcut methods
 ^^^^^^^^^^^^^^^^^^^^^^
 
 Using the nonstandard :meth:`execute`, :meth:`executemany` and
 :meth:`executescript` methods of the :class:`Connection` object, your code can
 be written more concisely because you don't have to create the (often
 superfluous) :class:`Cursor` objects explicitly. Instead, the :class:`Cursor`
 objects are created implicitly and these shortcut methods return the cursor
-objects. This way, you can execute a SELECT statement and iterate over it
+objects. This way, you can execute a ``SELECT`` statement and iterate over it
 directly using only a single call on the :class:`Connection` object.
 
 .. literalinclude:: ../includes/sqlite3/shortcut_methods.py
 
 
 Accessing columns by name instead of by index
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 One useful feature of the :mod:`sqlite3` module is the builtin
 :class:`sqlite3.Row` class designed to be used as a row factory.
 
 Rows wrapped with this class can be accessed both by index (like tuples) and

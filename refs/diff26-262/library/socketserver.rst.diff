--- rest26/library/socketserver.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/socketserver.rst	2009-04-07 00:06:53.000000000 +0900
@@ -1,24 +1,24 @@
 
 :mod:`SocketServer` --- A framework for network servers
 =======================================================
 
 .. module:: SocketServer
    :synopsis: A framework for network servers.
 
 .. note::
 
-   The :mod:`SocketServer` module has been renamed to `socketserver` in Python
-   3.0.  The :term:`2to3` tool will automatically adapt imports when converting
-   your sources to 3.0.
+   The :mod:`SocketServer` module has been renamed to :mod:`socketserver` in
+   Python 3.0.  The :term:`2to3` tool will automatically adapt imports when
+   converting your sources to 3.0.
 
 
 The :mod:`SocketServer` module simplifies the task of writing network servers.
 
 There are four basic server classes: :class:`TCPServer` uses the Internet TCP
 protocol, which provides for continuous streams of data between the client and
 server.  :class:`UDPServer` uses datagrams, which are discrete packets of
 information that may arrive out of order or be lost while in transit.  The more
 infrequently used :class:`UnixStreamServer` and :class:`UnixDatagramServer`
 classes are similar, but use Unix domain sockets; they're not available on
 non-Unix platforms.  For more details on network programming, consult a book
 such as
@@ -120,213 +120,222 @@
 next (or whether to handle a new incoming request).  This is particularly
 important for stream services where each client can potentially be connected for
 a long time (if threads or subprocesses cannot be used). See :mod:`asyncore` for
 another way to manage this.
 
 .. XXX should data and methods be intermingled, or separate?
    how should the distinction between class and instance variables be drawn?
 
 
 Server Objects
 --------------
 
+.. class:: BaseServer
 
-.. function:: fileno()
+   This is the superclass of all Server objects in the module.  It defines the
+   interface, given below, but does not implement most of the methods, which is
+   done in subclasses.
+
+
+.. method:: BaseServer.fileno()
 
    Return an integer file descriptor for the socket on which the server is
    listening.  This function is most commonly passed to :func:`select.select`, to
    allow monitoring multiple servers in the same process.
 
 
-.. function:: handle_request()
+.. method:: BaseServer.handle_request()
 
    Process a single request.  This function calls the following methods in
    order: :meth:`get_request`, :meth:`verify_request`, and
    :meth:`process_request`.  If the user-provided :meth:`handle` method of the
    handler class raises an exception, the server's :meth:`handle_error` method
    will be called.  If no request is received within :attr:`self.timeout`
    seconds, :meth:`handle_timeout` will be called and :meth:`handle_request`
    will return.
 
 
-.. function:: serve_forever(poll_interval=0.5)
+.. method:: BaseServer.serve_forever(poll_interval=0.5)
 
    Handle requests until an explicit :meth:`shutdown` request.  Polls for
    shutdown every *poll_interval* seconds.
 
 
-.. function:: shutdown()
+.. method:: BaseServer.shutdown()
 
    Tells the :meth:`serve_forever` loop to stop and waits until it does.
 
    .. versionadded:: 2.6
 
 
-.. data:: address_family
+.. attribute:: BaseServer.address_family
 
    The family of protocols to which the server's socket belongs.
    Common examples are :const:`socket.AF_INET` and :const:`socket.AF_UNIX`.
 
 
-.. data:: RequestHandlerClass
+.. attribute:: BaseServer.RequestHandlerClass
 
    The user-provided request handler class; an instance of this class is created
    for each request.
 
 
-.. data:: server_address
+.. attribute:: BaseServer.server_address
 
    The address on which the server is listening.  The format of addresses varies
    depending on the protocol family; see the documentation for the socket module
    for details.  For Internet protocols, this is a tuple containing a string giving
    the address, and an integer port number: ``('127.0.0.1', 80)``, for example.
 
 
-.. data:: socket
+.. attribute:: BaseServer.socket
 
    The socket object on which the server will listen for incoming requests.
 
+
 The server classes support the following class variables:
 
 .. XXX should class variables be covered before instance variables, or vice versa?
 
-
-.. data:: allow_reuse_address
+.. attribute:: BaseServer.allow_reuse_address
 
    Whether the server will allow the reuse of an address. This defaults to
    :const:`False`, and can be set in subclasses to change the policy.
 
 
-.. data:: request_queue_size
+.. attribute:: BaseServer.request_queue_size
 
    The size of the request queue.  If it takes a long time to process a single
    request, any requests that arrive while the server is busy are placed into a
    queue, up to :attr:`request_queue_size` requests.  Once the queue is full,
    further requests from clients will get a "Connection denied" error.  The default
    value is usually 5, but this can be overridden by subclasses.
 
 
-.. data:: socket_type
+.. attribute:: BaseServer.socket_type
 
    The type of socket used by the server; :const:`socket.SOCK_STREAM` and
    :const:`socket.SOCK_DGRAM` are two common values.
 
-.. data:: timeout
+
+.. attribute:: BaseServer.timeout
 
    Timeout duration, measured in seconds, or :const:`None` if no timeout is
    desired.  If :meth:`handle_request` receives no incoming requests within the
    timeout period, the :meth:`handle_timeout` method is called.
 
+
 There are various server methods that can be overridden by subclasses of base
 server classes like :class:`TCPServer`; these methods aren't useful to external
 users of the server object.
 
 .. XXX should the default implementations of these be documented, or should
    it be assumed that the user will look at SocketServer.py?
 
-
-.. function:: finish_request()
+.. method:: BaseServer.finish_request()
 
    Actually processes the request by instantiating :attr:`RequestHandlerClass` and
    calling its :meth:`handle` method.
 
 
-.. function:: get_request()
+.. method:: BaseServer.get_request()
 
    Must accept a request from the socket, and return a 2-tuple containing the *new*
    socket object to be used to communicate with the client, and the client's
    address.
 
 
-.. function:: handle_error(request, client_address)
+.. method:: BaseServer.handle_error(request, client_address)
 
    This function is called if the :attr:`RequestHandlerClass`'s :meth:`handle`
    method raises an exception.  The default action is to print the traceback to
    standard output and continue handling further requests.
 
-.. function:: handle_timeout()
+
+.. method:: BaseServer.handle_timeout()
 
    This function is called when the :attr:`timeout` attribute has been set to a
    value other than :const:`None` and the timeout period has passed with no
    requests being received.  The default action for forking servers is
    to collect the status of any child processes that have exited, while
    in threading servers this method does nothing.
 
-.. function:: process_request(request, client_address)
+
+.. method:: BaseServer.process_request(request, client_address)
 
    Calls :meth:`finish_request` to create an instance of the
    :attr:`RequestHandlerClass`.  If desired, this function can create a new process
    or thread to handle the request; the :class:`ForkingMixIn` and
    :class:`ThreadingMixIn` classes do this.
 
+
 .. Is there any point in documenting the following two functions?
    What would the purpose of overriding them be: initializing server
    instance variables, adding new network families?
 
-
-.. function:: server_activate()
+.. method:: BaseServer.server_activate()
 
    Called by the server's constructor to activate the server.  The default behavior
    just :meth:`listen`\ s to the server's socket. May be overridden.
 
 
-.. function:: server_bind()
+.. method:: BaseServer.server_bind()
 
    Called by the server's constructor to bind the socket to the desired address.
    May be overridden.
 
 
-.. function:: verify_request(request, client_address)
+.. method:: BaseServer.verify_request(request, client_address)
 
    Must return a Boolean value; if the value is :const:`True`, the request will be
    processed, and if it's :const:`False`, the request will be denied. This function
    can be overridden to implement access controls for a server. The default
    implementation always returns :const:`True`.
 
 
 RequestHandler Objects
 ----------------------
 
 The request handler class must define a new :meth:`handle` method, and can
 override any of the following methods.  A new instance is created for each
 request.
 
 
-.. function:: finish()
+.. method:: RequestHandler.finish()
 
    Called after the :meth:`handle` method to perform any clean-up actions
    required.  The default implementation does nothing.  If :meth:`setup` or
    :meth:`handle` raise an exception, this function will not be called.
 
 
-.. function:: handle()
+.. method:: RequestHandler.handle()
 
    This function must do all the work required to service a request.  The
    default implementation does nothing.  Several instance attributes are
    available to it; the request is available as :attr:`self.request`; the client
    address as :attr:`self.client_address`; and the server instance as
    :attr:`self.server`, in case it needs access to per-server information.
 
    The type of :attr:`self.request` is different for datagram or stream
    services.  For stream services, :attr:`self.request` is a socket object; for
    datagram services, :attr:`self.request` is a pair of string and socket.
    However, this can be hidden by using the request handler subclasses
    :class:`StreamRequestHandler` or :class:`DatagramRequestHandler`, which
    override the :meth:`setup` and :meth:`finish` methods, and provide
    :attr:`self.rfile` and :attr:`self.wfile` attributes.  :attr:`self.rfile` and
    :attr:`self.wfile` can be read or written, respectively, to get the request
    data or return data to the client.
 
 
-.. function:: setup()
+.. method:: RequestHandler.setup()
 
    Called before the :meth:`handle` method to perform any initialization actions
    required.  The default implementation does nothing.
 
 
 Examples
 --------
 
 :class:`SocketServer.TCPServer` Example
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 This is the server side::
@@ -439,25 +448,25 @@
        when sending data back via sendto().
        """
 
        def handle(self):
            data = self.request[0].strip()
            socket = self.request[1]
            print "%s wrote:" % self.client_address[0]
            print data
            socket.sendto(data.upper(), self.client_address)
 
    if __name__ == "__main__":
       HOST, PORT = "localhost", 9999
-      server = SocketServer.UDPServer((HOST, PORT), BaseUDPRequestHandler)
+      server = SocketServer.UDPServer((HOST, PORT), MyUDPHandler)
       server.serve_forever()
 
 This is the client side::
 
    import socket
    import sys
 
    HOST, PORT = "localhost"
    data = " ".join(sys.argv[1:])
 
    # SOCK_DGRAM is the socket type to use for UDP sockets
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
@@ -508,25 +517,25 @@
        # Port 0 means to select an arbitrary unused port
        HOST, PORT = "localhost", 0
 
        server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)
        ip, port = server.server_address
 
        # Start a thread with the server -- that thread will then start one
        # more thread for each request
        server_thread = threading.Thread(target=server.serve_forever)
        # Exit the server thread when the main thread terminates
        server_thread.setDaemon(True)
        server_thread.start()
-       print "Server loop running in thread:", t.getName()
+       print "Server loop running in thread:", server_thread.getName()
 
        client(ip, port, "Hello World 1")
        client(ip, port, "Hello World 2")
        client(ip, port, "Hello World 3")
 
        server.shutdown()
 
 The output of the example should look something like this::
 
    $ python ThreadedTCPServer.py
    Server loop running in thread: Thread-1
    Received: Thread-2: Hello World 1

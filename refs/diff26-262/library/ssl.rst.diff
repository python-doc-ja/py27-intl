--- rest26/library/ssl.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/ssl.rst	2009-04-05 05:02:09.000000000 +0900
@@ -39,25 +39,25 @@
 a socket-like wrapper that also encrypts and decrypts the data
 going over the socket with SSL.  It supports additional
 :meth:`read` and :meth:`write` methods, along with a method, :meth:`getpeercert`,
 to retrieve the certificate of the other side of the connection, and
 a method, :meth:`cipher`, to retrieve the cipher being used for the
 secure connection.
 
 Functions, Constants, and Exceptions
 ------------------------------------
 
 .. exception:: SSLError
 
-   Raised to signal an error from the underlying SSL implementation.  This 
+   Raised to signal an error from the underlying SSL implementation.  This
    signifies some problem in the higher-level
    encryption and authentication layer that's superimposed on the underlying
    network connection.  This error is a subtype of :exc:`socket.error`, which
    in turn is a subtype of :exc:`IOError`.
 
 .. function:: wrap_socket (sock, keyfile=None, certfile=None, server_side=False, cert_reqs=CERT_NONE, ssl_version={see docs}, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True)
 
    Takes an instance ``sock`` of :class:`socket.socket`, and returns an instance of :class:`ssl.SSLSocket`, a subtype
    of :class:`socket.socket`, which wraps the underlying socket in an SSL context.
    For client-side sockets, the context construction is lazy; if the underlying socket isn't
    connected yet, the context construction will be performed after :meth:`connect` is called
    on the socket.  For server-side sockets, if the socket has no remote peer, it is assumed
@@ -164,25 +164,25 @@
    Returns a floating-point value containing a normal seconds-after-the-epoch time
    value, given the time-string representing the "notBefore" or "notAfter" date
    from a certificate.
 
    Here's an example::
 
      >>> import ssl
      >>> ssl.cert_time_to_seconds("May  9 00:00:00 2007 GMT")
      1178694000.0
      >>> import time
      >>> time.ctime(ssl.cert_time_to_seconds("May  9 00:00:00 2007 GMT"))
      'Wed May  9 00:00:00 2007'
-     >>> 
+     >>>
 
 .. function:: get_server_certificate (addr, ssl_version=PROTOCOL_SSLv3, ca_certs=None)
 
    Given the address ``addr`` of an SSL-protected server, as a
    (*hostname*, *port-number*) pair, fetches the server's certificate,
    and returns it as a PEM-encoded string.  If ``ssl_version`` is
    specified, uses that version of the SSL protocol to attempt to
    connect to the server.  If ``ca_certs`` is specified, it should be
    a file containing a list of root certificates, the same format as
    used for the same parameter in :func:`wrap_socket`.  The call will
    attempt to validate the server certificate against that set of root
    certificates, and will fail if the validation attempt fails.
@@ -252,25 +252,25 @@
    Reads up to ``nbytes`` bytes from the SSL-encrypted channel and returns them.
 
 .. method:: SSLSocket.write(data)
 
    Writes the ``data`` to the other side of the connection, using the
    SSL channel to encrypt.  Returns the number of bytes written.
 
 .. method:: SSLSocket.getpeercert(binary_form=False)
 
    If there is no certificate for the peer on the other end of the
    connection, returns ``None``.
 
-   If the the parameter ``binary_form`` is :const:`False`, and a
+   If the parameter ``binary_form`` is :const:`False`, and a
    certificate was received from the peer, this method returns a
    :class:`dict` instance.  If the certificate was not validated, the
    dict is empty.  If the certificate was validated, it returns a dict
    with the keys ``subject`` (the principal for which the certificate
    was issued), and ``notAfter`` (the time after which the certificate
    should not be trusted).  The certificate was already validated, so
    the ``notBefore`` and ``issuer`` fields are not returned.  If a
    certificate contains an instance of the *Subject Alternative Name*
    extension (see :rfc:`3280`), there will also be a
    ``subjectAltName`` key in the dictionary.
 
    The "subject" field is a tuple containing the sequence of relative
@@ -376,25 +376,25 @@
 with a header line and a footer line::
 
       -----BEGIN CERTIFICATE-----
       ... (certificate in base64 PEM encoding) ...
       -----END CERTIFICATE-----
 
 The Python files which contain certificates can contain a sequence
 of certificates, sometimes called a *certificate chain*.  This chain
 should start with the specific certificate for the principal who "is"
 the client or server, and then the certificate for the issuer of that
 certificate, and then the certificate for the issuer of *that* certificate,
 and so on up the chain till you get to a certificate which is *self-signed*,
-that is, a certificate which has the same subject and issuer, 
+that is, a certificate which has the same subject and issuer,
 sometimes called a *root certificate*.  The certificates should just
 be concatenated together in the certificate file.  For example, suppose
 we had a three certificate chain, from our server certificate to the
 certificate of the certification authority that signed our server certificate,
 to the root certificate of the agency which issued the certification authority's
 certificate::
 
       -----BEGIN CERTIFICATE-----
       ... (certificate for your server)...
       -----END CERTIFICATE-----
       -----BEGIN CERTIFICATE-----
       ... (the certificate for the CA)...
@@ -413,31 +413,31 @@
 authorities:
 `CACert.org <http://www.cacert.org/index.php?id=3>`_,
 `Thawte <http://www.thawte.com/roots/>`_,
 `Verisign <http://www.verisign.com/support/roots.html>`_,
 `Positive SSL <http://www.PositiveSSL.com/ssl-certificate-support/cert_installation/UTN-USERFirst-Hardware.crt>`_ (used by python.org),
 `Equifax and GeoTrust <http://www.geotrust.com/resources/root_certificates/index.asp>`_.
 
 In general, if you are using
 SSL3 or TLS1, you don't need to put the full chain in your "CA certs" file;
 you only need the root certificates, and the remote peer is supposed to
 furnish the other certificates necessary to chain from its certificate to
 a root certificate.
-See :rfc:`4158` for more discussion of the way in which 
+See :rfc:`4158` for more discussion of the way in which
 certification chains can be built.
 
 If you are going to create a server that provides SSL-encrypted
 connection services, you will need to acquire a certificate for that
 service.  There are many ways of acquiring appropriate certificates,
-such as buying one from a certification authority.  Another common 
+such as buying one from a certification authority.  Another common
 practice is to generate a self-signed certificate.  The simplest
 way to do this is with the OpenSSL package, using something like
 the following::
 
   % openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem
   Generating a 1024 bit RSA private key
   .......++++++
   .............................++++++
   writing new private key to 'cert.pem'
   -----
   You are about to be asked to enter information that will be incorporated
   into your certificate request.
@@ -561,25 +561,25 @@
       # null data means the client is finished with us
       while data:
          if not do_something(connstream, data):
             # we'll assume do_something returns False
             # when we're finished with client
             break
          data = connstream.read()
       # finished with client
       connstream.close()
 
 And go back to listening for new client connections.
 
-           
+
 .. seealso::
 
    Class :class:`socket.socket`
             Documentation of underlying :mod:`socket` class
 
    `Introducing SSL and Certificates using OpenSSL <http://old.pseudonym.org/ssl/wwwj-index.html>`_
        Frederick J. Hirsch
 
    `RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management <http://www.ietf.org/rfc/rfc1422>`_
        Steve Kent
 
    `RFC 1750: Randomness Recommendations for Security <http://www.ietf.org/rfc/rfc1750>`_

--- rest26/library/numbers.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/numbers.rst	2009-04-05 05:02:09.000000000 +0900
@@ -42,49 +42,49 @@
       Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate()
       == (1-3j)``.
 
 .. class:: Real
 
    To :class:`Complex`, :class:`Real` adds the operations that work on real
    numbers.
 
    In short, those are: a conversion to :class:`float`, :func:`trunc`,
    :func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``,
    ``%``, ``<``, ``<=``, ``>``, and ``>=``.
 
-   Real also provides defaults for :func:`complex`, :attr:`Complex.real`,
-   :attr:`Complex.imag`, and :meth:`Complex.conjugate`.
+   Real also provides defaults for :func:`complex`, :attr:`~Complex.real`,
+   :attr:`~Complex.imag`, and :meth:`~Complex.conjugate`.
 
 
 .. class:: Rational
 
    Subtypes :class:`Real` and adds
-   :attr:`Rational.numerator` and :attr:`Rational.denominator` properties, which
+   :attr:`~Rational.numerator` and :attr:`~Rational.denominator` properties, which
    should be in lowest terms. With these, it provides a default for
    :func:`float`.
 
    .. attribute:: numerator
 
       Abstract.
 
    .. attribute:: denominator
 
       Abstract.
 
 
 .. class:: Integral
 
    Subtypes :class:`Rational` and adds a conversion to :class:`int`.
-   Provides defaults for :func:`float`, :attr:`Rational.numerator`, and
-   :attr:`Rational.denominator`, and bit-string operations: ``<<``,
+   Provides defaults for :func:`float`, :attr:`~Rational.numerator`, and
+   :attr:`~Rational.denominator`, and bit-string operations: ``<<``,
    ``>>``, ``&``, ``^``, ``|``, ``~``.
 
 
 Notes for type implementors
 ---------------------------
 
 Implementors should be careful to make equal numbers equal and hash
 them to the same values. This may be subtle if there are two different
 extensions of the real numbers. For example, :class:`fractions.Fraction`
 implements :func:`hash` as follows::
 
     def __hash__(self):
@@ -162,25 +162,25 @@
        :meth:`__add__`. (Or ``A`` may not implement :meth:`__add__` at
        all.)
     3. Then ``B``'s :meth:`__radd__` gets a chance. If it accepts
        ``a``, all is well.
     4. If it falls back to the boilerplate, there are no more possible
        methods to try, so this is where the default implementation
        should live.
     5. If ``B <: A``, Python tries ``B.__radd__`` before
        ``A.__add__``. This is ok, because it was implemented with
        knowledge of ``A``, so it can handle those instances before
        delegating to :class:`Complex`.
 
-If ``A<:Complex`` and ``B<:Real`` without sharing any other knowledge,
+If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge,
 then the appropriate shared operation is the one involving the built
 in :class:`complex`, and both :meth:`__radd__` s land there, so ``a+b
 == b+a``.
 
 Because most of the operations on any given type will be very similar,
 it can be useful to define a helper function which generates the
 forward and reverse instances of any given operator. For example,
 :class:`fractions.Fraction` uses::
 
     def _operator_fallbacks(monomorphic_operator, fallback_operator):
         def forward(a, b):
             if isinstance(b, (int, long, Fraction)):

--- rest26/library/abc.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/abc.rst	2009-04-07 00:06:53.000000000 +0900
@@ -34,33 +34,33 @@
    ABC by the built-in :func:`issubclass` function, but the registering ABC
    won't show up in their MRO (Method Resolution Order) nor will method
    implementations defined by the registering ABC be callable (not even via
    :func:`super`). [#]_
 
    Classes created with a metaclass of :class:`ABCMeta` have the following method:
 
    .. method:: register(subclass)
 
       Register *subclass* as a "virtual subclass" of this ABC. For
       example::
 
-	from abc import ABCMeta
+        from abc import ABCMeta
 
-	class MyABC:
-	    __metaclass__ = ABCMeta
+        class MyABC:
+            __metaclass__ = ABCMeta
 
-	MyABC.register(tuple)
+        MyABC.register(tuple)
 
-	assert issubclass(tuple, MyABC)
-	assert isinstance((), MyABC)
+        assert issubclass(tuple, MyABC)
+        assert isinstance((), MyABC)
 
    You can also override this method in an abstract base class:
 
    .. method:: __subclasshook__(subclass)
 
       (Must be defined as a class method.)
 
       Check whether *subclass* is considered a subclass of this ABC.  This means
       that you can customize the behavior of ``issubclass`` further without the
       need to call :meth:`register` on every class you want to consider a
       subclass of the ABC.  (This class method is called from the
       :meth:`__subclasscheck__` method of the ABC.)
@@ -121,75 +121,76 @@
    old-style iterable protocol, defined in terms of :meth:`__len__` and
    :meth:`__getitem__`).  Note that this will not make ``get_iterator``
    available as a method of ``Foo``, so it is provided separately.
 
 
 It also provides the following decorators:
 
 .. function:: abstractmethod(function)
 
    A decorator indicating abstract methods.
 
    Using this decorator requires that the class's metaclass is :class:`ABCMeta` or
-   is derived from it. 
+   is derived from it.
    A class that has a metaclass derived from :class:`ABCMeta`
    cannot be instantiated unless all of its abstract methods and
    properties are overridden.
-   The abstract methods can be called using any of the the normal 'super' call
+   The abstract methods can be called using any of the normal 'super' call
    mechanisms.
 
    Dynamically adding abstract methods to a class, or attempting to modify the
    abstraction status of a method or class once it is created, are not
    supported.  The :func:`abstractmethod` only affects subclasses derived using
    regular inheritance; "virtual subclasses" registered with the ABC's
    :meth:`register` method are not affected.
 
    Usage::
 
       class C:
           __metaclass__ = ABCMeta
           @abstractmethod
           def my_abstract_method(self, ...):
               ...
 
    .. note::
 
-      Unlike C++'s pure virtual functions, or Java abstract methods, these abstract
+      Unlike Java abstract methods, these abstract
       methods may have an implementation. This implementation can be
       called via the :func:`super` mechanism from the class that
       overrides it.  This could be useful as an end-point for a
       super-call in a framework that uses cooperative
       multiple-inheritance.
 
 
-.. function:: abstractproperty(fget[, fset[, fdel[, doc]]])
+.. function:: abstractproperty([fget[, fset[, fdel[, doc]]]])
 
    A subclass of the built-in :func:`property`, indicating an abstract property.
 
    Using this function requires that the class's metaclass is :class:`ABCMeta` or
-   is derived from it. 
+   is derived from it.
    A class that has a metaclass derived from :class:`ABCMeta` cannot be
    instantiated unless all of its abstract methods and properties are overridden.
    The abstract properties can be called using any of the normal
    'super' call mechanisms.
 
    Usage::
 
       class C:
           __metaclass__ = ABCMeta
           @abstractproperty
           def my_abstract_property(self):
               ...
 
    This defines a read-only property; you can also define a read-write abstract
    property using the 'long' form of property declaration::
 
       class C:
           __metaclass__ = ABCMeta
           def getx(self): ...
           def setx(self, value): ...
           x = abstractproperty(getx, setx)
 
+
 .. rubric:: Footnotes
 
 .. [#] C++ programmers should note that Python's virtual base class
    concept is not the same as C++'s.

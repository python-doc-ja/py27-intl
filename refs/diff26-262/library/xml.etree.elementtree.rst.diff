--- rest26/library/xml.etree.elementtree.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/xml.etree.elementtree.rst	2009-04-05 05:02:09.000000000 +0900
@@ -25,25 +25,25 @@
 * an optional tail string.
 
 * a number of child elements, stored in a Python sequence
 
 To create an element instance, use the Element or SubElement factory functions.
 
 The :class:`ElementTree` class can be used to wrap an element structure, and
 convert it from and to XML.
 
 A C implementation of this API is available as :mod:`xml.etree.cElementTree`.
 
 See http://effbot.org/zone/element-index.htm for tutorials and links to other
-docs. Fredrik Lundh's page is also the location of the development version of the 
+docs. Fredrik Lundh's page is also the location of the development version of the
 xml.etree.ElementTree.
 
 .. _elementtree-functions:
 
 Functions
 ---------
 
 
 .. function:: Comment([text])
 
    Comment element factory.  This factory function creates a special element that
    will be serialized as an XML comment. The comment string can be either an 8-bit
@@ -85,24 +85,34 @@
 
    Checks if an object appears to be a valid element object. *element* is an
    element instance. Returns a true value if this is an element object.
 
 
 .. function:: iterparse(source[, events])
 
    Parses an XML section into an element tree incrementally, and reports what's
    going on to the user. *source* is a filename or file object containing XML data.
    *events* is a list of events to report back.  If omitted, only "end" events are
    reported. Returns an :term:`iterator` providing ``(event, elem)`` pairs.
 
+   .. note::
+
+      :func:`iterparse` only guarantees that it has seen the ">"
+      character of a starting tag when it emits a "start" event, so the
+      attributes are defined, but the contents of the text and tail attributes
+      are undefined at that point.  The same applies to the element children;
+      they may or may not be present.
+
+      If you need a fully populated element, look for "end" events instead.
+
 
 .. function:: parse(source[, parser])
 
    Parses an XML section into an element tree. *source* is a filename or file
    object containing XML data. *parser* is an optional parser instance.  If not
    given, the standard XMLTreeBuilder parser is used. Returns an ElementTree
    instance.
 
 
 .. function:: ProcessingInstruction(target[, text])
 
    PI element factory.  This factory function creates a special element that will
@@ -360,25 +370,25 @@
 
       Writes the element tree to a file, as XML. *file* is a file name, or a
       file object opened for writing. *encoding* [1]_ is the output encoding
       (default is US-ASCII).
 
 This is the XML file that is going to be manipulated::
 
     <html>
         <head>
             <title>Example page</title>
         </head>
         <body>
-            <p>Moved to <a href="http://example.org/">example.org</a> 
+            <p>Moved to <a href="http://example.org/">example.org</a>
             or <a href="http://example.com/">example.com</a>.</p>
         </body>
     </html>
 
 Example of changing the attribute "target" of every link in first paragraph::
 
     >>> from xml.etree.ElementTree import ElementTree
     >>> tree = ElementTree()
     >>> tree.parse("index.xhtml")
     <Element html at b7d3f1ec>
     >>> p = tree.find("body/p")     # Finds first occurrence of tag p in body
     >>> p
@@ -467,57 +477,57 @@
    .. method:: doctype(name, pubid, system)
 
       Handles a doctype declaration. *name* is the doctype name. *pubid* is the
       public identifier. *system* is the system identifier.
 
 
    .. method:: feed(data)
 
       Feeds data to the parser. *data* is encoded data.
 
 :meth:`XMLTreeBuilder.feed` calls *target*\'s :meth:`start` method
 for each opening tag, its :meth:`end` method for each closing tag,
-and data is processed by method :meth:`data`. :meth:`XMLTreeBuilder.close` 
-calls *target*\'s method :meth:`close`. 
-:class:`XMLTreeBuilder` can be used not only for building a tree structure. 
+and data is processed by method :meth:`data`. :meth:`XMLTreeBuilder.close`
+calls *target*\'s method :meth:`close`.
+:class:`XMLTreeBuilder` can be used not only for building a tree structure.
 This is an example of counting the maximum depth of an XML file::
 
     >>> from xml.etree.ElementTree import XMLTreeBuilder
     >>> class MaxDepth:                     # The target object of the parser
     ...     maxDepth = 0
     ...     depth = 0
     ...     def start(self, tag, attrib):   # Called for each opening tag.
-    ...         self.depth += 1 
+    ...         self.depth += 1
     ...         if self.depth > self.maxDepth:
     ...             self.maxDepth = self.depth
     ...     def end(self, tag):             # Called for each closing tag.
     ...         self.depth -= 1
-    ...     def data(self, data):   
+    ...     def data(self, data):
     ...         pass            # We do not need to do anything with data.
     ...     def close(self):    # Called when all data has been parsed.
     ...         return self.maxDepth
-    ... 
+    ...
     >>> target = MaxDepth()
     >>> parser = XMLTreeBuilder(target=target)
     >>> exampleXml = """
     ... <a>
     ...   <b>
     ...   </b>
     ...   <b>
     ...     <c>
     ...       <d>
     ...       </d>
     ...     </c>
     ...   </b>
     ... </a>"""
     >>> parser.feed(exampleXml)
     >>> parser.close()
     4
 
 
 .. rubric:: Footnotes
 
 .. [#] The encoding string included in XML output should conform to the
    appropriate standards. For example, "UTF-8" is valid, but "UTF8" is
    not. See http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl
-   and http://www.iana.org/assignments/character-sets .
+   and http://www.iana.org/assignments/character-sets.
 

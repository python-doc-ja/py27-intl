--- rest26/library/string.rst	2008-12-19 16:58:10.000000000 +0900
+++ rest262/library/string.rst	2009-04-07 00:06:53.000000000 +0900
@@ -53,63 +53,60 @@
 
 
 .. data:: letters
 
    The concatenation of the strings :const:`lowercase` and :const:`uppercase`
    described below.  The specific value is locale-dependent, and will be updated
    when :func:`locale.setlocale` is called.
 
 
 .. data:: lowercase
 
    A string containing all the characters that are considered lowercase letters.
-   On most systems this is the string ``'abcdefghijklmnopqrstuvwxyz'``.  Do not
-   change its definition --- the effect on the routines :func:`upper` and
-   :func:`swapcase` is undefined.  The specific value is locale-dependent, and will
-   be updated when :func:`locale.setlocale` is called.
+   On most systems this is the string ``'abcdefghijklmnopqrstuvwxyz'``.  The
+   specific value is locale-dependent, and will be updated when
+   :func:`locale.setlocale` is called.
 
 
 .. data:: octdigits
 
    The string ``'01234567'``.
 
 
 .. data:: punctuation
 
    String of ASCII characters which are considered punctuation characters in the
    ``C`` locale.
 
 
 .. data:: printable
 
    String of characters which are considered printable.  This is a combination of
    :const:`digits`, :const:`letters`, :const:`punctuation`, and
    :const:`whitespace`.
 
 
 .. data:: uppercase
 
    A string containing all the characters that are considered uppercase letters.
-   On most systems this is the string ``'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``.  Do not
-   change its definition --- the effect on the routines :func:`lower` and
-   :func:`swapcase` is undefined.  The specific value is locale-dependent, and will
-   be updated when :func:`locale.setlocale` is called.
+   On most systems this is the string ``'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``.  The
+   specific value is locale-dependent, and will be updated when
+   :func:`locale.setlocale` is called.
 
 
 .. data:: whitespace
 
    A string containing all characters that are considered whitespace. On most
    systems this includes the characters space, tab, linefeed, return, formfeed, and
-   vertical tab.  Do not change its definition --- the effect on the routines
-   :func:`strip` and :func:`split` is undefined.
+   vertical tab.
 
 
 .. _new-string-formatting:
 
 String Formatting
 -----------------
 
 Starting in Python 2.6, the built-in str and unicode classes provide the ability
 to do complex variable substitutions and value formatting via the
 :meth:`str.format` method described in :pep:`3101`.  The :class:`Formatter`
 class in the :mod:`string` module allows you to create and customize your own
 string formatting behaviors using the same implementation as the built-in
@@ -117,61 +114,61 @@
 
 .. class:: Formatter
 
    The :class:`Formatter` class has the following public methods:
 
    .. method:: format(format_string, *args, *kwargs)
 
       :meth:`format` is the primary API method.  It takes a format template
       string, and an arbitrary set of positional and keyword argument.
       :meth:`format` is just a wrapper that calls :meth:`vformat`.
 
    .. method:: vformat(format_string, args, kwargs)
-   
+
       This function does the actual work of formatting.  It is exposed as a
       separate function for cases where you want to pass in a predefined
       dictionary of arguments, rather than unpacking and repacking the
       dictionary as individual arguments using the ``*args`` and ``**kwds``
       syntax.  :meth:`vformat` does the work of breaking up the format template
       string into character data and replacement fields.  It calls the various
       methods described below.
 
    In addition, the :class:`Formatter` defines a number of methods that are
    intended to be replaced by subclasses:
 
    .. method:: parse(format_string)
-   
+
       Loop over the format_string and return an iterable of tuples
       (*literal_text*, *field_name*, *format_spec*, *conversion*).  This is used
       by :meth:`vformat` to break the string in to either literal text, or
       replacement fields.
-      
+
       The values in the tuple conceptually represent a span of literal text
       followed by a single replacement field.  If there is no literal text
       (which can happen if two replacement fields occur consecutively), then
       *literal_text* will be a zero-length string.  If there is no replacement
       field, then the values of *field_name*, *format_spec* and *conversion*
       will be ``None``.
 
    .. method:: get_field(field_name, args, kwargs)
 
       Given *field_name* as returned by :meth:`parse` (see above), convert it to
       an object to be formatted.  Returns a tuple (obj, used_key).  The default
       version takes strings of the form defined in :pep:`3101`, such as
       "0[name]" or "label.title".  *args* and *kwargs* are as passed in to
       :meth:`vformat`.  The return value *used_key* has the same meaning as the
       *key* parameter to :meth:`get_value`.
 
    .. method:: get_value(key, args, kwargs)
-   
+
       Retrieve a given field value.  The *key* argument will be either an
       integer or a string.  If it is an integer, it represents the index of the
       positional argument in *args*; if it is a string, then it represents a
       named argument in *kwargs*.
 
       The *args* parameter is set to the list of positional arguments to
       :meth:`vformat`, and the *kwargs* parameter is set to the dictionary of
       keyword arguments.
 
       For compound field names, these functions are only called for the first
       component of the field name; Subsequent components are handled through
       normal attribute and indexing operations.
@@ -191,74 +188,74 @@
       the format string (integers for positional arguments, and strings for
       named arguments), and a reference to the *args* and *kwargs* that was
       passed to vformat.  The set of unused args can be calculated from these
       parameters.  :meth:`check_unused_args` is assumed to throw an exception if
       the check fails.
 
    .. method:: format_field(value, format_spec)
 
       :meth:`format_field` simply calls the global :func:`format` built-in.  The
       method is provided so that subclasses can override it.
 
    .. method:: convert_field(value, conversion)
-   
+
       Converts the value (returned by :meth:`get_field`) given a conversion type
       (as in the tuple returned by the :meth:`parse` method.)  The default
       version understands 'r' (repr) and 's' (str) conversion types.
 
 
 .. _formatstrings:
 
 Format String Syntax
 --------------------
 
 The :meth:`str.format` method and the :class:`Formatter` class share the same
 syntax for format strings (although in the case of :class:`Formatter`,
 subclasses can define their own format string syntax.)
 
 Format strings contain "replacement fields" surrounded by curly braces ``{}``.
 Anything that is not contained in braces is considered literal text, which is
 copied unchanged to the output.  If you need to include a brace character in the
 literal text, it can be escaped by doubling: ``{{`` and ``}}``.
 
 The grammar for a replacement field is as follows:
 
    .. productionlist:: sf
       replacement_field: "{" `field_name` ["!" `conversion`] [":" `format_spec`] "}"
-      field_name: (`identifier` | `integer`) ("." `attribute_name` | "[" element_index "]")*
+      field_name: (`identifier` | `integer`) ("." `attribute_name` | "[" `element_index` "]")*
       attribute_name: `identifier`
       element_index: `integer`
       conversion: "r" | "s"
       format_spec: <described in the next section>
-      
+
 In less formal terms, the replacement field starts with a *field_name*, which
 can either be a number (for a positional argument), or an identifier (for
 keyword arguments).  Following this is an optional *conversion* field, which is
 preceded by an exclamation point ``'!'``, and a *format_spec*, which is preceded
 by a colon ``':'``.
 
 The *field_name* itself begins with either a number or a keyword.  If it's a
 number, it refers to a positional argument, and if it's a keyword it refers to a
 named keyword argument.  This can be followed by any number of index or
 attribute expressions. An expression of the form ``'.name'`` selects the named
 attribute using :func:`getattr`, while an expression of the form ``'[index]'``
 does an index lookup using :func:`__getitem__`.
 
 Some simple format string examples::
 
    "First, thou shalt count to {0}" # References first positional argument
    "My quest is {name}"             # References keyword argument 'name'
    "Weight in tons {0.weight}"      # 'weight' attribute of first positional arg
    "Units destroyed: {players[0]}"  # First element of keyword argument 'players'.
-   
+
 The *conversion* field causes a type coercion before formatting.  Normally, the
 job of formatting a value is done by the :meth:`__format__` method of the value
 itself.  However, in some cases it is desirable to force a type to be formatted
 as a string, overriding its own definition of formatting.  By converting the
 value to a string before calling :meth:`__format__`, the normal formatting logic
 is bypassed.
 
 Two conversion flags are currently supported: ``'!s'`` which calls :func:`str`
 on the value, and ``'!r'`` which calls :func:`repr`.
 
 Some examples::
 
@@ -283,29 +280,29 @@
 determined by another variable::
 
    "A man with two {0:{1}}".format("noses", 10)
 
 This would first evaluate the inner replacement field, making the format string
 effectively::
 
    "A man with two {0:10}"
 
 Then the outer replacement field would be evaluated, producing::
 
    "noses     "
-   
+
 Which is substituted into the string, yielding::
-   
+
    "A man with two noses     "
-   
+
 (The extra space is because we specified a field width of 10, and because left
 alignment is the default for strings.)
 
 
 .. _formatspec:
 
 Format Specification Mini-Language
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 "Format specifications" are used within replacement fields contained within a
 format string to define how individual values are presented (see
 :ref:`formatstrings`.)  They can also be passed directly to the builtin
@@ -319,25 +316,25 @@
 result as if you had called :func:`str` on the value.
 
 The general form of a *standard format specifier* is:
 
 .. productionlist:: sf
    format_spec: [[`fill`]`align`][`sign`][#][0][`width`][.`precision`][`type`]
    fill: <a character other than '}'>
    align: "<" | ">" | "=" | "^"
    sign: "+" | "-" | " "
    width: `integer`
    precision: `integer`
    type: "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "x" | "X" | "%"
-   
+
 The *fill* character can be any character other than '}' (which signifies the
 end of the field).  The presence of a fill character is signaled by the *next*
 character, which must be one of the alignment options. If the second character
 of *format_spec* is not a valid alignment option, then it is assumed that both
 the fill character and the alignment option are absent.
 
 The meaning of the various alignment options is as follows:
 
    +---------+----------------------------------------------------------+
    | Option  | Meaning                                                  |
    +=========+==========================================================+
    | ``'<'`` | Forces the field to be left-aligned within the available |
@@ -412,27 +409,27 @@
    | ``'x'`` | Hex format. Outputs the number in base 16, using lower-  |
    |         | case letters for the digits above 9.                     |
    +---------+----------------------------------------------------------+
    | ``'X'`` | Hex format. Outputs the number in base 16, using upper-  |
    |         | case letters for the digits above 9.                     |
    +---------+----------------------------------------------------------+
    | ``'n'`` | Number. This is the same as ``'d'``, except that it uses |
    |         | the current locale setting to insert the appropriate     |
    |         | number separator characters.                             |
    +---------+----------------------------------------------------------+
    | None    | The same as ``'d'``.                                     |
    +---------+----------------------------------------------------------+
-                                                                         
+
 The available presentation types for floating point and decimal values are:
-                                                                         
+
    +---------+----------------------------------------------------------+
    | Type    | Meaning                                                  |
    +=========+==========================================================+
    | ``'e'`` | Exponent notation. Prints the number in scientific       |
    |         | notation using the letter 'e' to indicate the exponent.  |
    +---------+----------------------------------------------------------+
    | ``'E'`` | Exponent notation. Same as ``'e'`` except it uses an     |
    |         | upper case 'E' as the separator character.               |
    +---------+----------------------------------------------------------+
    | ``'f'`` | Fixed point. Displays the number as a fixed-point        |
    |         | number.                                                  |
    +---------+----------------------------------------------------------+
@@ -590,25 +587,25 @@
 
 
 .. function:: maketrans(from, to)
 
    Return a translation table suitable for passing to :func:`translate`, that will
    map each character in *from* into the character at the same position in *to*;
    *from* and *to* must have the same length.
 
    .. warning::
 
       Don't use strings derived from :const:`lowercase` and :const:`uppercase` as
       arguments; in some locales, these don't have the same length.  For case
-      conversions, always use :func:`lower` and :func:`upper`.
+      conversions, always use :meth:`str.lower` and :meth:`str.upper`.
 
 
 Deprecated string functions
 ---------------------------
 
 The following list of functions are also defined as methods of string and
 Unicode objects; see section :ref:`string-methods` for more information on
 those.  You should consider these functions as deprecated, although they will
 not be removed until Python 3.0.  The functions defined in this module are:
 
 
 .. function:: atof(s)

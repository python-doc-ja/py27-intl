--- rest25/library/thread.rst	2008-10-21 04:57:07.775055095 +0900
+++ rest26/library/thread.rst	2008-10-21 05:03:04.921980052 +0900
@@ -1,30 +1,37 @@
-
 :mod:`thread` --- Multiple threads of control
 =============================================
 
 .. module:: thread
    :synopsis: Create multiple threads of control within one interpreter.
 
+.. note::
+   The :mod:`thread` module has been renamed to :mod:`_thread` in Python 3.0.
+   The :term:`2to3` tool will automatically adapt imports when converting your
+   sources to 3.0; however, you should consider using the high-level
+   :mod:`threading` module instead.
+
 
 .. index::
    single: light-weight processes
    single: processes, light-weight
    single: binary semaphores
    single: semaphores, binary
 
 This module provides low-level primitives for working with multiple threads
-(a.k.a. :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple threads of
+(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple threads of
 control sharing their global data space.  For synchronization, simple locks
-(a.k.a. :dfn:`mutexes` or :dfn:`binary semaphores`) are provided.
+(also called :dfn:`mutexes` or :dfn:`binary semaphores`) are provided.
+The :mod:`threading` module provides an easier to use and higher-level
+threading API built on top of this module.
 
 .. index::
    single: pthreads
    pair: threads; POSIX
 
 The module is optional.  It is supported on Windows, Linux, SGI IRIX, Solaris
 2.x, as well as on systems that have a POSIX thread (a.k.a. "pthread")
 implementation.  For systems lacking the :mod:`thread` module, the
 :mod:`dummy_thread` module is available. It duplicates this module's interface
 and can be used as a drop-in replacement.
 
 It defines the following constant and functions:
@@ -54,30 +61,31 @@
 
    Raise a :exc:`KeyboardInterrupt` exception in the main thread.  A subthread can
    use this function to interrupt the main thread.
 
    .. versionadded:: 2.3
 
 
 .. function:: exit()
 
    Raise the :exc:`SystemExit` exception.  When not caught, this will cause the
    thread to exit silently.
 
-.. % \begin{funcdesc}{exit_prog}{status}
-.. % Exit all threads and report the value of the integer argument
-.. % \var{status} as the exit status of the entire program.
-.. % \strong{Caveat:} code in pending \keyword{finally} clauses, in this thread
-.. % or in other threads, is not executed.
-.. % \end{funcdesc}
+..
+   function:: exit_prog(status)
+
+      Exit all threads and report the value of the integer argument
+      *status* as the exit status of the entire program.
+      **Caveat:** code in pending :keyword:`finally` clauses, in this thread
+      or in other threads, is not executed.
 
 
 .. function:: allocate_lock()
 
    Return a new lock object.  Methods of locks are described below.  The lock is
    initially unlocked.
 
 
 .. function:: get_ident()
 
    Return the 'thread identifier' of the current thread.  This is a nonzero
    integer.  Its value has no direct meaning; it is intended as a magic cookie to
@@ -123,25 +131,24 @@
    Releases the lock.  The lock must have been acquired earlier, but not
    necessarily by the same thread.
 
 
 .. method:: lock.locked()
 
    Return the status of the lock: ``True`` if it has been acquired by some thread,
    ``False`` if not.
 
 In addition to these methods, lock objects can also be used via the
 :keyword:`with` statement, e.g.::
 
-   from __future__ import with_statement
    import thread
 
    a_lock = thread.allocate_lock()
 
    with a_lock:
        print "a_lock is locked while this executes"
 
 **Caveats:**
 
   .. index:: module: signal
 
 * Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt`

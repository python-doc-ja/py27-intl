--- rest25/library/zlib.rst	2008-10-21 04:57:10.364641523 +0900
+++ rest26/library/zlib.rst	2008-10-21 05:03:05.137171708 +0900
@@ -1,52 +1,62 @@
 
 :mod:`zlib` --- Compression compatible with :program:`gzip`
 ===========================================================
 
 .. module:: zlib
    :synopsis: Low-level interface to compression and decompression routines compatible with
               gzip.
 
 
 For applications that require data compression, the functions in this module
 allow compression and decompression, using the zlib library. The zlib library
-has its own home page at `<http://www.zlib.net>`_.   There are known
+has its own home page at http://www.zlib.net.   There are known
 incompatibilities between the Python module and versions of the zlib library
 earlier than 1.1.3; 1.1.3 has a security vulnerability, so we recommend using
 1.1.4 or later.
 
 zlib's functions have many options and often need to be used in a particular
 order.  This documentation doesn't attempt to cover all of the permutations;
-consult the zlib manual at `<http://www.zlib.net/manual.html>`_ for
-authoritative information.
+consult the zlib manual at http://www.zlib.net/manual.html for authoritative
+information.
+
+For reading and writing ``.gz`` files see the :mod:`gzip` module. For
+other archive formats, see the :mod:`bz2`, :mod:`zipfile`, and
+:mod:`tarfile` modules.
 
 The available exception and functions in this module are:
 
 
 .. exception:: error
 
    Exception raised on compression and decompression errors.
 
 
 .. function:: adler32(string[, value])
 
    Computes a Adler-32 checksum of *string*.  (An Adler-32 checksum is almost as
    reliable as a CRC32 but can be computed much more quickly.)  If *value* is
    present, it is used as the starting value of the checksum; otherwise, a fixed
    default value is used.  This allows computing a running checksum over the
    concatenation of several input strings.  The algorithm is not cryptographically
    strong, and should not be used for authentication or digital signatures.  Since
    the algorithm is designed for use as a checksum algorithm, it is not suitable
    for use as a general hash algorithm.
 
+   This function always returns an integer object.
+
+   .. versionchanged:: 2.6
+     For consistent cross-platform behavior we always return a signed integer.
+     ie: Results in the (2**31)...(2**32-1) range will be negative.
+
 
 .. function:: compress(string[, level])
 
    Compresses the data in *string*, returning a string contained compressed data.
    *level* is an integer from ``1`` to ``9`` controlling the level of compression;
    ``1`` is fastest and produces the least compression, ``9`` is slowest and
    produces the most.  The default value is ``6``.  Raises the :exc:`error`
    exception if any error occurs.
 
 
 .. function:: compressobj([level])
 
@@ -61,25 +71,29 @@
    .. index::
       single: Cyclic Redundancy Check
       single: checksum; Cyclic Redundancy Check
 
    Computes a CRC (Cyclic Redundancy Check)  checksum of *string*. If *value* is
    present, it is used as the starting value of the checksum; otherwise, a fixed
    default value is used.  This allows computing a running checksum over the
    concatenation of several input strings.  The algorithm is not cryptographically
    strong, and should not be used for authentication or digital signatures.  Since
    the algorithm is designed for use as a checksum algorithm, it is not suitable
    for use as a general hash algorithm.
 
-   .. % 
+   This function always returns an integer object.
+
+   .. versionchanged:: 2.6
+     For consistent cross-platform behavior we always return a signed integer.
+     ie: Results in the (2**31)...(2**32-1) range will be negative.
 
 
 .. function:: decompress(string[, wbits[, bufsize]])
 
    Decompresses the data in *string*, returning a string containing the
    uncompressed data.  The *wbits* parameter controls the size of the window
    buffer.  If *bufsize* is given, it is used as the initial size of the output
    buffer.  Raises the :exc:`error` exception if any error occurs.
 
    The absolute value of *wbits* is the base two logarithm of the size of the
    history buffer (the "window size") used when compressing data.  Its absolute
    value should be between 8 and 15 for the most recent versions of the zlib
@@ -126,40 +140,40 @@
 
 
 .. method:: Compress.copy()
 
    Returns a copy of the compression object.  This can be used to efficiently
    compress a set of data that share a common initial prefix.
 
    .. versionadded:: 2.5
 
 Decompression objects support the following methods, and two attributes:
 
 
-.. attribute:: XXX Class.unused_data
+.. attribute:: Decompress.unused_data
 
    A string which contains any bytes past the end of the compressed data. That is,
    this remains ``""`` until the last byte that contains compression data is
    available.  If the whole string turned out to contain compressed data, this is
    ``""``, the empty string.
 
    The only way to determine where a string of compressed data ends is by actually
    decompressing it.  This means that when compressed data is contained part of a
    larger file, you can only find the end of it by reading data and feeding it
    followed by some non-empty string into a decompression object's
    :meth:`decompress` method until the :attr:`unused_data` attribute is no longer
    the empty string.
 
 
-.. attribute:: XXX Class.unconsumed_tail
+.. attribute:: Decompress.unconsumed_tail
 
    A string that contains any data that was not consumed by the last
    :meth:`decompress` call because it exceeded the limit for the uncompressed data
    buffer.  This data has not yet been seen by the zlib machinery, so you must feed
    it (possibly with further data concatenated to it) back to a subsequent
    :meth:`decompress` method call in order to get correct output.
 
 
 .. method:: Decompress.decompress(string[, max_length])
 
    Decompress *string*, returning a string containing the uncompressed data
    corresponding to at least part of the data in *string*.  This data should be

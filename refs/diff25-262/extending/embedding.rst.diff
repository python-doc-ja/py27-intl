--- rest25/extending/embedding.rst	2008-12-19 16:58:05.000000000 +0900
+++ rest262/extending/embedding.rst	2009-04-05 05:01:41.000000000 +0900
@@ -16,42 +16,41 @@
 to tailor the application to their needs by writing some scripts in Python.  You
 can also use it yourself if some of the functionality can be written in Python
 more easily.
 
 Embedding Python is similar to extending it, but not quite.  The difference is
 that when you extend Python, the main program of the application is still the
 Python interpreter, while if you embed Python, the main program may have nothing
 to do with Python --- instead, some parts of the application occasionally call
 the Python interpreter to run some Python code.
 
 So if you are embedding Python, you are providing your own main program.  One of
 the things this main program has to do is initialize the Python interpreter.  At
-the very least, you have to call the function :cfunc:`Py_Initialize` (on Mac OS,
-call :cfunc:`PyMac_Initialize` instead).  There are optional calls to pass
-command line arguments to Python.  Then later you can call the interpreter from
-any part of the application.
+the very least, you have to call the function :cfunc:`Py_Initialize`.  There are
+optional calls to pass command line arguments to Python.  Then later you can
+call the interpreter from any part of the application.
 
 There are several different ways to call the interpreter: you can pass a string
 containing Python statements to :cfunc:`PyRun_SimpleString`, or you can pass a
 stdio file pointer and a file name (for identification in error messages only)
 to :cfunc:`PyRun_SimpleFile`.  You can also call the lower-level operations
 described in the previous chapters to construct and use Python objects.
 
 A simple demo of embedding Python can be found in the directory
 :file:`Demo/embed/` of the source distribution.
 
 
 .. seealso::
 
-   `Python/C API Reference Manual <../api/api.html>`_
+   :ref:`c-api-index`
       The details of Python's C interface are given in this manual. A great deal of
       necessary information can be found here.
 
 
 .. _high-level-embedding:
 
 Very High Level Embedding
 =========================
 
 The simplest form of embedding Python is the use of the very high level
 interface. This interface is intended to execute a Python script without needing
 to interact with the application directly. This can for example be used to
@@ -123,53 +122,48 @@
 .. _pure-embedding:
 
 Pure Embedding
 ==============
 
 The first program aims to execute a function in a Python script. Like in the
 section about the very high level interface, the Python interpreter does not
 directly interact with the application (but that will change in the next
 section).
 
 The code to run a function defined in a Python script is:
 
+.. literalinclude:: ../includes/run-func.c
 
-.. include:: ../includes/run-func.c
-   :literal:
 
 This code loads a Python script using ``argv[1]``, and calls the function named
 in ``argv[2]``.  Its integer arguments are the other values of the ``argv``
 array.  If you compile and link this program (let's call the finished executable
 :program:`call`), and use it to execute a Python script, such as::
 
    def multiply(a,b):
        print "Will compute", a, "times", b
        c = 0
        for i in range(0, a):
            c = c + b
        return c
 
 then the result should be::
 
    $ call multiply multiply 3 2
    Will compute 3 times 2
    Result of call: 6
 
 Although the program is quite large for its functionality, most of the code is
 for data conversion between Python and C, and for error reporting.  The
-interesting part with respect to embedding Python starts with
-
-.. % $
-
-::
+interesting part with respect to embedding Python starts with ::
 
    Py_Initialize();
    pName = PyString_FromString(argv[1]);
    /* Error checking of pName left out */
    pModule = PyImport_Import(pName);
 
 After initializing the interpreter, the script is loaded using
 :cfunc:`PyImport_Import`.  This routine needs a Python string as its argument,
 which is constructed using the :cfunc:`PyString_FromString` data conversion
 routine. ::
 
    pFunc = PyObject_GetAttrString(pModule, argv[2]);
@@ -231,33 +225,26 @@
    Py_InitModule("emb", EmbMethods);
 
 These two lines initialize the ``numargs`` variable, and make the
 :func:`emb.numargs` function accessible to the embedded Python interpreter.
 With these extensions, the Python script can do things like ::
 
    import emb
    print "Number of arguments", emb.numargs()
 
 In a real application, the methods will expose an API of the application to
 Python.
 
-.. % \section{For the future}
-.. % 
-.. % You don't happen to have a nice library to get textual
-.. % equivalents of numeric values do you :-) ?
-.. % Callbacks here ? (I may be using information from that section
-.. % ?!)
-.. % threads
-.. % code examples do not really behave well if errors happen
-.. % (what to watch out for)
+.. TODO: threads, code examples do not really behave well if errors happen
+   (what to watch out for)
 
 
 .. _embeddingincplusplus:
 
 Embedding Python in C++
 =======================
 
 It is also possible to embed Python in a C++ program; precisely how this is done
 will depend on the details of the C++ system used; in general you will need to
 write the main program in C++, and use the C++ compiler to compile and link your
 program.  There is no need to recompile Python itself using C++.
 

--- rest25/c-api/init.rst	2008-12-19 16:58:05.000000000 +0900
+++ rest262/c-api/init.rst	2009-04-07 00:06:52.000000000 +0900
@@ -93,33 +93,34 @@
       single: stdin (in module sys)
 
    Create a new sub-interpreter.  This is an (almost) totally separate environment
    for the execution of Python code.  In particular, the new interpreter has
    separate, independent versions of all imported modules, including the
    fundamental modules :mod:`__builtin__`, :mod:`__main__` and :mod:`sys`.  The
    table of loaded modules (``sys.modules``) and the module search path
    (``sys.path``) are also separate.  The new environment has no ``sys.argv``
    variable.  It has new standard I/O stream file objects ``sys.stdin``,
    ``sys.stdout`` and ``sys.stderr`` (however these refer to the same underlying
    :ctype:`FILE` structures in the C library).
 
-   The return value points to the first thread state created in the new sub-
-   interpreter.  This thread state is made in the current thread state.  Note that
-   no actual thread is created; see the discussion of thread states below.  If
-   creation of the new interpreter is unsuccessful, *NULL* is returned; no
-   exception is set since the exception state is stored in the current thread state
-   and there may not be a current thread state.  (Like all other Python/C API
-   functions, the global interpreter lock must be held before calling this function
-   and is still held when it returns; however, unlike most other Python/C API
-   functions, there needn't be a current thread state on entry.)
+   The return value points to the first thread state created in the new
+   sub-interpreter.  This thread state is made in the current thread state.
+   Note that no actual thread is created; see the discussion of thread states
+   below.  If creation of the new interpreter is unsuccessful, *NULL* is
+   returned; no exception is set since the exception state is stored in the
+   current thread state and there may not be a current thread state.  (Like all
+   other Python/C API functions, the global interpreter lock must be held before
+   calling this function and is still held when it returns; however, unlike most
+   other Python/C API functions, there needn't be a current thread state on
+   entry.)
 
    .. index::
       single: Py_Finalize()
       single: Py_Initialize()
 
    Extension modules are shared between (sub-)interpreters as follows: the first
    time a particular extension is imported, it is initialized normally, and a
    (shallow) copy of its module's dictionary is squirreled away.  When the same
    extension is imported by another (sub-)interpreter, a new module is initialized
    and filled with the contents of this copy; the extension's ``init`` function is
    not called.  Note that this is different from what happens when an extension is
    imported after the interpreter has been completely re-initialized by calling
@@ -160,33 +161,33 @@
    interpreter lock must be held before calling this function and is still held
    when it returns.)  :cfunc:`Py_Finalize` will destroy all sub-interpreters that
    haven't been explicitly destroyed at that point.
 
 
 .. cfunction:: void Py_SetProgramName(char *name)
 
    .. index::
       single: Py_Initialize()
       single: main()
       single: Py_GetPath()
 
-   This function should be called before :cfunc:`Py_Initialize` is called for the
-   first time, if it is called at all.  It tells the interpreter the value of the
-   ``argv[0]`` argument to the :cfunc:`main` function of the program.  This is used
-   by :cfunc:`Py_GetPath` and some other functions below to find the Python run-
-   time libraries relative to the interpreter executable.  The default value is
-   ``'python'``.  The argument should point to a zero-terminated character string
-   in static storage whose contents will not change for the duration of the
-   program's execution.  No code in the Python interpreter will change the contents
-   of this storage.
+   This function should be called before :cfunc:`Py_Initialize` is called for
+   the first time, if it is called at all.  It tells the interpreter the value
+   of the ``argv[0]`` argument to the :cfunc:`main` function of the program.
+   This is used by :cfunc:`Py_GetPath` and some other functions below to find
+   the Python run-time libraries relative to the interpreter executable.  The
+   default value is ``'python'``.  The argument should point to a
+   zero-terminated character string in static storage whose contents will not
+   change for the duration of the program's execution.  No code in the Python
+   interpreter will change the contents of this storage.
 
 
 .. cfunction:: char* Py_GetProgramName()
 
    .. index:: single: Py_SetProgramName()
 
    Return the program name set with :cfunc:`Py_SetProgramName`, or the default.
    The returned string points into static storage; the caller should not modify its
    value.
 
 
 .. cfunction:: char* Py_GetPrefix()
@@ -195,25 +196,25 @@
    through a number of complicated rules from the program name set with
    :cfunc:`Py_SetProgramName` and some environment variables; for example, if the
    program name is ``'/usr/local/bin/python'``, the prefix is ``'/usr/local'``. The
    returned string points into static storage; the caller should not modify its
    value.  This corresponds to the :makevar:`prefix` variable in the top-level
    :file:`Makefile` and the :option:`--prefix` argument to the :program:`configure`
    script at build time.  The value is available to Python code as ``sys.prefix``.
    It is only useful on Unix.  See also the next function.
 
 
 .. cfunction:: char* Py_GetExecPrefix()
 
-   Return the *exec-prefix* for installed platform-*de*pendent files.  This is
+   Return the *exec-prefix* for installed platform-*dependent* files.  This is
    derived through a number of complicated rules from the program name set with
    :cfunc:`Py_SetProgramName` and some environment variables; for example, if the
    program name is ``'/usr/local/bin/python'``, the exec-prefix is
    ``'/usr/local'``.  The returned string points into static storage; the caller
    should not modify its value.  This corresponds to the :makevar:`exec_prefix`
    variable in the top-level :file:`Makefile` and the :option:`--exec-prefix`
    argument to the :program:`configure` script at build  time.  The value is
    available to Python code as ``sys.exec_prefix``.  It is only useful on Unix.
 
    Background: The exec-prefix differs from the prefix when platform dependent
    files (such as executables and shared libraries) are installed in a different
    directory tree.  In a typical installation, platform dependent files may be
@@ -250,31 +251,31 @@
    to Python code as ``sys.executable``.
 
 
 .. cfunction:: char* Py_GetPath()
 
    .. index::
       triple: module; search; path
       single: path (in module sys)
 
    Return the default module search path; this is computed from the  program name
    (set by :cfunc:`Py_SetProgramName` above) and some environment variables.  The
    returned string consists of a series of directory names separated by a platform
-   dependent delimiter character.  The delimiter character is ``':'`` on Unixand
+   dependent delimiter character.  The delimiter character is ``':'`` on Unix and
    Mac OS X, ``';'`` on Windows.  The returned string points into static storage;
    the caller should not modify its value.  The value is available to Python code
    as the list ``sys.path``, which may be modified to change the future search path
    for loaded modules.
 
-   .. % XXX should give the exact rules
+   .. XXX should give the exact rules
 
 
 .. cfunction:: const char* Py_GetVersion()
 
    Return the version of this Python interpreter.  This is a string that looks
    something like ::
 
       "1.5 (#67, Dec 31 1997, 22:34:28) [GCC 2.7.2.2]"
 
    .. index:: single: version (in module sys)
 
    The first word (up to the first space character) is the current Python version;
@@ -343,55 +344,71 @@
    The returned string points into static storage; the caller should not modify its
    value.  The value is available to Python code as part of the variable
    ``sys.version``.
 
 
 .. cfunction:: void PySys_SetArgv(int argc, char **argv)
 
    .. index::
       single: main()
       single: Py_FatalError()
       single: argv (in module sys)
 
-   Set ``sys.argv`` based on *argc* and *argv*.  These parameters are similar to
-   those passed to the program's :cfunc:`main` function with the difference that
-   the first entry should refer to the script file to be executed rather than the
-   executable hosting the Python interpreter.  If there isn't a script that will be
-   run, the first entry in *argv* can be an empty string.  If this function fails
-   to initialize ``sys.argv``, a fatal condition is signalled using
-   :cfunc:`Py_FatalError`.
+   Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are
+   similar to those passed to the program's :cfunc:`main` function with the
+   difference that the first entry should refer to the script file to be
+   executed rather than the executable hosting the Python interpreter.  If there
+   isn't a script that will be run, the first entry in *argv* can be an empty
+   string.  If this function fails to initialize :data:`sys.argv`, a fatal
+   condition is signalled using :cfunc:`Py_FatalError`.
 
-   .. % XXX impl. doesn't seem consistent in allowing 0/NULL for the params;
-   .. % check w/ Guido.
+   This function also prepends the executed script's path to :data:`sys.path`.
+   If no script is executed (in the case of calling ``python -c`` or just the
+   interactive interpreter), the empty string is used instead.
 
-.. % XXX Other PySys thingies (doesn't really belong in this chapter)
+   .. XXX impl. doesn't seem consistent in allowing 0/NULL for the params;
+      check w/ Guido.
+
+
+.. cfunction:: void Py_SetPythonHome(char *home)
+
+   Set the default "home" directory, that is, the location of the standard
+   Python libraries.  The libraries are searched in
+   :file:`{home}/lib/python{version}` and :file:`{home}/lib/python{version}`.
+
+
+.. cfunction:: char* Py_GetPythonHome()
+
+   Return the default "home", that is, the value set by a previous call to
+   :cfunc:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME`
+   environment variable if it is set.
 
 
 .. _threads:
 
 Thread State and the Global Interpreter Lock
 ============================================
 
 .. index::
    single: global interpreter lock
    single: interpreter lock
    single: lock, interpreter
 
-The Python interpreter is not fully thread safe.  In order to support multi-
-threaded Python programs, there's a global lock that must be held by the current
-thread before it can safely access Python objects. Without the lock, even the
-simplest operations could cause problems in a multi-threaded program: for
-example, when two threads simultaneously increment the reference count of the
-same object, the reference count could end up being incremented only once
-instead of twice.
+The Python interpreter is not fully thread safe.  In order to support
+multi-threaded Python programs, there's a global lock, called the :dfn:`global
+interpreter lock` or :dfn:`GIL`, that must be held by the current thread before
+it can safely access Python objects. Without the lock, even the simplest
+operations could cause problems in a multi-threaded program: for example, when
+two threads simultaneously increment the reference count of the same object, the
+reference count could end up being incremented only once instead of twice.
 
 .. index:: single: setcheckinterval() (in module sys)
 
 Therefore, the rule exists that only the thread that has acquired the global
 interpreter lock may operate on Python objects or call Python/C API functions.
 In order to support multi-threaded Python programs, the interpreter regularly
 releases and reacquires the lock --- by default, every 100 bytecode instructions
 (this can be changed with  :func:`sys.setcheckinterval`).  The lock is also
 released and reacquired around potentially blocking I/O operations like reading
 or writing a file, so that other threads can run while the thread that requests
 the I/O is waiting for the I/O operation to complete.
 
@@ -402,44 +419,44 @@
 The Python interpreter needs to keep some bookkeeping information separate per
 thread --- for this it uses a data structure called :ctype:`PyThreadState`.
 There's one global variable, however: the pointer to the current
 :ctype:`PyThreadState` structure.  While most thread packages have a way to
 store "per-thread global data," Python's internal platform independent thread
 abstraction doesn't support this yet.  Therefore, the current thread state must
 be manipulated explicitly.
 
 This is easy enough in most cases.  Most code manipulating the global
 interpreter lock has the following simple structure::
 
    Save the thread state in a local variable.
-   Release the interpreter lock.
+   Release the global interpreter lock.
    ...Do some blocking I/O operation...
-   Reacquire the interpreter lock.
+   Reacquire the global interpreter lock.
    Restore the thread state from the local variable.
 
 This is so common that a pair of macros exists to simplify it::
 
    Py_BEGIN_ALLOW_THREADS
    ...Do some blocking I/O operation...
    Py_END_ALLOW_THREADS
 
 .. index::
    single: Py_BEGIN_ALLOW_THREADS
    single: Py_END_ALLOW_THREADS
 
 The :cmacro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a
 hidden local variable; the :cmacro:`Py_END_ALLOW_THREADS` macro closes the
 block.  Another advantage of using these two macros is that when Python is
 compiled without thread support, they are defined empty, thus saving the thread
-state and lock manipulations.
+state and GIL manipulations.
 
 When thread support is enabled, the block above expands to the following code::
 
    PyThreadState *_save;
 
    _save = PyEval_SaveThread();
    ...Do some blocking I/O operation...
    PyEval_RestoreThread(_save);
 
 Using even lower level primitives, we can get roughly the same effect as
 follows::
 
@@ -453,25 +470,25 @@
 
 .. index::
    single: PyEval_RestoreThread()
    single: errno
    single: PyEval_SaveThread()
    single: PyEval_ReleaseLock()
    single: PyEval_AcquireLock()
 
 There are some subtle differences; in particular, :cfunc:`PyEval_RestoreThread`
 saves and restores the value of the  global variable :cdata:`errno`, since the
 lock manipulation does not guarantee that :cdata:`errno` is left alone.  Also,
 when thread support is disabled, :cfunc:`PyEval_SaveThread` and
-:cfunc:`PyEval_RestoreThread` don't manipulate the lock; in this case,
+:cfunc:`PyEval_RestoreThread` don't manipulate the GIL; in this case,
 :cfunc:`PyEval_ReleaseLock` and :cfunc:`PyEval_AcquireLock` are not available.
 This is done so that dynamically loaded extensions compiled with thread support
 enabled can be loaded by an interpreter that was compiled with disabled thread
 support.
 
 The global interpreter lock is used to protect the pointer to the current thread
 state.  When releasing the lock and saving the thread state, the current thread
 state pointer must be retrieved before the lock is released (since another
 thread could immediately acquire the lock and store its own thread state in the
 global variable). Conversely, when acquiring the lock and restoring the thread
 state, the lock must be acquired before storing the thread state pointer.
 
@@ -536,45 +553,45 @@
    main thread before creating a second thread or engaging in any other thread
    operations such as :cfunc:`PyEval_ReleaseLock` or
    ``PyEval_ReleaseThread(tstate)``. It is not needed before calling
    :cfunc:`PyEval_SaveThread` or :cfunc:`PyEval_RestoreThread`.
 
    .. index:: single: Py_Initialize()
 
    This is a no-op when called for a second time.  It is safe to call this function
    before calling :cfunc:`Py_Initialize`.
 
    .. index:: module: thread
 
-   When only the main thread exists, no lock operations are needed. This is a
+   When only the main thread exists, no GIL operations are needed. This is a
    common situation (most Python programs do not use threads), and the lock
-   operations slow the interpreter down a bit. Therefore, the lock is not created
-   initially.  This situation is equivalent to having acquired the lock:  when
-   there is only a single thread, all object accesses are safe.  Therefore, when
-   this function initializes the lock, it also acquires it.  Before the Python
-   :mod:`thread` module creates a new thread, knowing that either it has the lock
-   or the lock hasn't been created yet, it calls :cfunc:`PyEval_InitThreads`.  When
-   this call returns, it is guaranteed that the lock has been created and that the
-   calling thread has acquired it.
+   operations slow the interpreter down a bit. Therefore, the lock is not
+   created initially.  This situation is equivalent to having acquired the lock:
+   when there is only a single thread, all object accesses are safe.  Therefore,
+   when this function initializes the global interpreter lock, it also acquires
+   it.  Before the Python :mod:`thread` module creates a new thread, knowing
+   that either it has the lock or the lock hasn't been created yet, it calls
+   :cfunc:`PyEval_InitThreads`.  When this call returns, it is guaranteed that
+   the lock has been created and that the calling thread has acquired it.
 
    It is **not** safe to call this function when it is unknown which thread (if
    any) currently has the global interpreter lock.
 
    This function is not available when thread support is disabled at compile time.
 
 
 .. cfunction:: int PyEval_ThreadsInitialized()
 
    Returns a non-zero value if :cfunc:`PyEval_InitThreads` has been called.  This
-   function can be called without holding the lock, and therefore can be used to
+   function can be called without holding the GIL, and therefore can be used to
    avoid calls to the locking API when running single-threaded.  This function is
    not available when thread support is disabled at compile time.
 
    .. versionadded:: 2.4
 
 
 .. cfunction:: void PyEval_AcquireLock()
 
    Acquire the global interpreter lock.  The lock must have been created earlier.
    If this thread already has the lock, a deadlock ensues.  This function is not
    available when thread support is disabled at compile time.
 
@@ -596,38 +613,46 @@
 .. cfunction:: void PyEval_ReleaseThread(PyThreadState *tstate)
 
    Reset the current thread state to *NULL* and release the global interpreter
    lock.  The lock must have been created earlier and must be held by the current
    thread.  The *tstate* argument, which must not be *NULL*, is only used to check
    that it represents the current thread state --- if it isn't, a fatal error is
    reported. This function is not available when thread support is disabled at
    compile time.
 
 
 .. cfunction:: PyThreadState* PyEval_SaveThread()
 
-   Release the interpreter lock (if it has been created and thread support is
-   enabled) and reset the thread state to *NULL*, returning the previous thread
-   state (which is not *NULL*).  If the lock has been created, the current thread
-   must have acquired it.  (This function is available even when thread support is
-   disabled at compile time.)
+   Release the global interpreter lock (if it has been created and thread
+   support is enabled) and reset the thread state to *NULL*, returning the
+   previous thread state (which is not *NULL*).  If the lock has been created,
+   the current thread must have acquired it.  (This function is available even
+   when thread support is disabled at compile time.)
 
 
 .. cfunction:: void PyEval_RestoreThread(PyThreadState *tstate)
 
-   Acquire the interpreter lock (if it has been created and thread support is
-   enabled) and set the thread state to *tstate*, which must not be *NULL*.  If the
-   lock has been created, the current thread must not have acquired it, otherwise
-   deadlock ensues.  (This function is available even when thread support is
-   disabled at compile time.)
+   Acquire the global interpreter lock (if it has been created and thread
+   support is enabled) and set the thread state to *tstate*, which must not be
+   *NULL*.  If the lock has been created, the current thread must not have
+   acquired it, otherwise deadlock ensues.  (This function is available even
+   when thread support is disabled at compile time.)
+
+
+.. cfunction:: void PyEval_ReInitThreads()
+
+   This function is called from :cfunc:`PyOS_AfterFork` to ensure that newly
+   created child processes don't hold locks referring to threads which
+   are not running in the child process.
+
 
 The following macros are normally used without a trailing semicolon; look for
 example usage in the Python source distribution.
 
 
 .. cmacro:: Py_BEGIN_ALLOW_THREADS
 
    This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();``.
    Note that it contains an opening brace; it must be matched with a following
    :cmacro:`Py_END_ALLOW_THREADS` macro.  See above for further discussion of this
    macro.  It is a no-op when thread support is disabled at compile time.
 
@@ -645,78 +670,79 @@
    This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to
    :cmacro:`Py_END_ALLOW_THREADS` without the closing brace.  It is a no-op when
    thread support is disabled at compile time.
 
 
 .. cmacro:: Py_UNBLOCK_THREADS
 
    This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to
    :cmacro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable
    declaration.  It is a no-op when thread support is disabled at compile time.
 
 All of the following functions are only available when thread support is enabled
-at compile time, and must be called only when the interpreter lock has been
-created.
+at compile time, and must be called only when the global interpreter lock has
+been created.
 
 
 .. cfunction:: PyInterpreterState* PyInterpreterState_New()
 
-   Create a new interpreter state object.  The interpreter lock need not be held,
-   but may be held if it is necessary to serialize calls to this function.
+   Create a new interpreter state object.  The global interpreter lock need not
+   be held, but may be held if it is necessary to serialize calls to this
+   function.
 
 
 .. cfunction:: void PyInterpreterState_Clear(PyInterpreterState *interp)
 
-   Reset all information in an interpreter state object.  The interpreter lock must
-   be held.
+   Reset all information in an interpreter state object.  The global interpreter
+   lock must be held.
 
 
 .. cfunction:: void PyInterpreterState_Delete(PyInterpreterState *interp)
 
-   Destroy an interpreter state object.  The interpreter lock need not be held.
-   The interpreter state must have been reset with a previous call to
+   Destroy an interpreter state object.  The global interpreter lock need not be
+   held.  The interpreter state must have been reset with a previous call to
    :cfunc:`PyInterpreterState_Clear`.
 
 
 .. cfunction:: PyThreadState* PyThreadState_New(PyInterpreterState *interp)
 
-   Create a new thread state object belonging to the given interpreter object.  The
-   interpreter lock need not be held, but may be held if it is necessary to
-   serialize calls to this function.
+   Create a new thread state object belonging to the given interpreter object.
+   The global interpreter lock need not be held, but may be held if it is
+   necessary to serialize calls to this function.
 
 
 .. cfunction:: void PyThreadState_Clear(PyThreadState *tstate)
 
-   Reset all information in a thread state object.  The interpreter lock must be
-   held.
+   Reset all information in a thread state object.  The global interpreter lock
+   must be held.
 
 
 .. cfunction:: void PyThreadState_Delete(PyThreadState *tstate)
 
-   Destroy a thread state object.  The interpreter lock need not be held.  The
-   thread state must have been reset with a previous call to
+   Destroy a thread state object.  The global interpreter lock need not be held.
+   The thread state must have been reset with a previous call to
    :cfunc:`PyThreadState_Clear`.
 
 
 .. cfunction:: PyThreadState* PyThreadState_Get()
 
-   Return the current thread state.  The interpreter lock must be held.  When the
-   current thread state is *NULL*, this issues a fatal error (so that the caller
-   needn't check for *NULL*).
+   Return the current thread state.  The global interpreter lock must be held.
+   When the current thread state is *NULL*, this issues a fatal error (so that
+   the caller needn't check for *NULL*).
 
 
 .. cfunction:: PyThreadState* PyThreadState_Swap(PyThreadState *tstate)
 
    Swap the current thread state with the thread state given by the argument
-   *tstate*, which may be *NULL*.  The interpreter lock must be held.
+   *tstate*, which may be *NULL*.  The global interpreter lock must be held.
 
 
 .. cfunction:: PyObject* PyThreadState_GetDict()
 
    Return a dictionary in which extensions can store thread-specific state
    information.  Each extension should use a unique key to use to store state in
    the dictionary.  It is okay to call this function when no current thread state
    is available. If this function returns *NULL*, no exception has been raised and
    the caller should assume no current thread state is available.
 
    .. versionchanged:: 2.3
       Previously this could only be called when a current thread is active, and *NULL*
@@ -729,39 +755,40 @@
    id of the target thread; *exc* is the exception object to be raised. This
    function does not steal any references to *exc*. To prevent naive misuse, you
    must write your own C extension to call this.  Must be called with the GIL held.
    Returns the number of thread states modified; this is normally one, but will be
    zero if the thread id isn't found.  If *exc* is :const:`NULL`, the pending
    exception (if any) for the thread is cleared. This raises no exceptions.
 
    .. versionadded:: 2.3
 
 
 .. cfunction:: PyGILState_STATE PyGILState_Ensure()
 
-   Ensure that the current thread is ready to call the Python C API regardless of
-   the current state of Python, or of its thread lock. This may be called as many
-   times as desired by a thread as long as each call is matched with a call to
-   :cfunc:`PyGILState_Release`. In general, other thread-related APIs may be used
-   between :cfunc:`PyGILState_Ensure` and :cfunc:`PyGILState_Release` calls as long
-   as the thread state is restored to its previous state before the Release().  For
-   example, normal usage of the :cmacro:`Py_BEGIN_ALLOW_THREADS` and
-   :cmacro:`Py_END_ALLOW_THREADS` macros is acceptable.
+   Ensure that the current thread is ready to call the Python C API regardless
+   of the current state of Python, or of the global interpreter lock. This may
+   be called as many times as desired by a thread as long as each call is
+   matched with a call to :cfunc:`PyGILState_Release`. In general, other
+   thread-related APIs may be used between :cfunc:`PyGILState_Ensure` and
+   :cfunc:`PyGILState_Release` calls as long as the thread state is restored to
+   its previous state before the Release().  For example, normal usage of the
+   :cmacro:`Py_BEGIN_ALLOW_THREADS` and :cmacro:`Py_END_ALLOW_THREADS` macros is
+   acceptable.
 
    The return value is an opaque "handle" to the thread state when
-   :cfunc:`PyGILState_Acquire` was called, and must be passed to
+   :cfunc:`PyGILState_Ensure` was called, and must be passed to
    :cfunc:`PyGILState_Release` to ensure Python is left in the same state. Even
    though recursive calls are allowed, these handles *cannot* be shared - each
-   unique call to :cfunc:`PyGILState_Ensure` must save the handle for its call to
-   :cfunc:`PyGILState_Release`.
+   unique call to :cfunc:`PyGILState_Ensure` must save the handle for its call
+   to :cfunc:`PyGILState_Release`.
 
    When the function returns, the current thread will hold the GIL. Failure is a
    fatal error.
 
    .. versionadded:: 2.3
 
 
 .. cfunction:: void PyGILState_Release(PyGILState_STATE)
 
    Release any resources previously acquired.  After this call, Python's state will
    be the same as it was prior to the corresponding :cfunc:`PyGILState_Ensure` call
    (but generally this state will be unknown to the caller, hence the use of the
@@ -882,24 +909,64 @@
    the profile function needs to maintain state, using a different value for *obj*
    for each thread provides a convenient and thread-safe place to store it.  The
    profile function is called for all monitored events except the line-number
    events.
 
 
 .. cfunction:: void PyEval_SetTrace(Py_tracefunc func, PyObject *obj)
 
    Set the tracing function to *func*.  This is similar to
    :cfunc:`PyEval_SetProfile`, except the tracing function does receive line-number
    events.
 
+.. cfunction:: PyObject* PyEval_GetCallStats(PyObject *self)
+
+   Return a tuple of function call counts.  There are constants defined for the
+   positions within the tuple:
+
+   +-------------------------------+-------+
+   | Name                          | Value |
+   +===============================+=======+
+   | :const:`PCALL_ALL`            | 0     |
+   +-------------------------------+-------+
+   | :const:`PCALL_FUNCTION`       | 1     |
+   +-------------------------------+-------+
+   | :const:`PCALL_FAST_FUNCTION`  | 2     |
+   +-------------------------------+-------+
+   | :const:`PCALL_FASTER_FUNCTION`| 3     |
+   +-------------------------------+-------+
+   | :const:`PCALL_METHOD`         | 4     |
+   +-------------------------------+-------+
+   | :const:`PCALL_BOUND_METHOD`   | 5     |
+   +-------------------------------+-------+
+   | :const:`PCALL_CFUNCTION`      | 6     |
+   +-------------------------------+-------+
+   | :const:`PCALL_TYPE`           | 7     |
+   +-------------------------------+-------+
+   | :const:`PCALL_GENERATOR`      | 8     |
+   +-------------------------------+-------+
+   | :const:`PCALL_OTHER`          | 9     |
+   +-------------------------------+-------+
+   | :const:`PCALL_POP`            | 10    |
+   +-------------------------------+-------+
+
+   :const:`PCALL_FAST_FUNCTION` means no argument tuple needs to be created.
+   :const:`PCALL_FASTER_FUNCTION` means that the fast-path frame setup code is used.
+
+   If there is a method call where the call can be optimized by changing
+   the argument tuple and calling the function directly, it gets recorded
+   twice.
+
+   This function is only present if Python is compiled with :const:`CALL_PROFILE`
+   defined.
 
 .. _advanced-debugging:
 
 Advanced Debugger Support
 =========================
 
 .. sectionauthor:: Fred L. Drake, Jr. <fdrake@acm.org>
 
 
 These functions are only intended to be used by advanced debugging tools.
 
 

--- rest25/library/fcntl.rst	2008-12-19 16:58:07.000000000 +0900
+++ rest262/library/fcntl.rst	2009-04-05 05:02:09.000000000 +0900
@@ -41,24 +41,26 @@
    larger than 1024 bytes, this is most likely to result in a segmentation
    violation or a more subtle data corruption.
 
    If the :cfunc:`fcntl` fails, an :exc:`IOError` is raised.
 
 
 .. function:: ioctl(fd, op[, arg[, mutate_flag]])
 
    This function is identical to the :func:`fcntl` function, except that the
    operations are typically defined in the library module :mod:`termios` and the
    argument handling is even more complicated.
 
+   The op parameter is limited to values that can fit in 32-bits.
+
    The parameter *arg* can be one of an integer, absent (treated identically to the
    integer ``0``), an object supporting the read-only buffer interface (most likely
    a plain Python string) or an object supporting the read-write buffer interface.
 
    In all but the last case, behaviour is as for the :func:`fcntl` function.
 
    If a mutable buffer is passed, then the behaviour is determined by the value of
    the *mutate_flag* parameter.
 
    If it is false, the buffer's mutability is ignored and behaviour is as for a
    read-only buffer, except that the 1024 byte limit mentioned above is avoided --
    so long as the buffer you pass is as least as long as what the operating system
@@ -95,63 +97,61 @@
    Perform the lock operation *op* on file descriptor *fd* (file objects providing
    a :meth:`fileno` method are accepted as well). See the Unix manual
    :manpage:`flock(3)` for details.  (On some systems, this function is emulated
    using :cfunc:`fcntl`.)
 
 
 .. function:: lockf(fd, operation, [length, [start, [whence]]])
 
    This is essentially a wrapper around the :func:`fcntl` locking calls.  *fd* is
    the file descriptor of the file to lock or unlock, and *operation* is one of the
    following values:
 
-* :const:`LOCK_UN` -- unlock
-
-* :const:`LOCK_SH` -- acquire a shared lock
-
-* :const:`LOCK_EX` -- acquire an exclusive lock
-
-   When *operation* is :const:`LOCK_SH` or :const:`LOCK_EX`, it can also be bit-
-   wise OR'd with :const:`LOCK_NB` to avoid blocking on lock acquisition.  If
-   :const:`LOCK_NB` is used and the lock cannot be acquired, an :exc:`IOError` will
-   be raised and the exception will have an *errno* attribute set to
-   :const:`EACCES` or :const:`EAGAIN` (depending on the operating system; for
-   portability, check for both values).  On at least some systems, :const:`LOCK_EX`
-   can only be used if the file descriptor refers to a file opened for writing.
+   * :const:`LOCK_UN` -- unlock
+   * :const:`LOCK_SH` -- acquire a shared lock
+   * :const:`LOCK_EX` -- acquire an exclusive lock
+
+   When *operation* is :const:`LOCK_SH` or :const:`LOCK_EX`, it can also be
+   bitwise ORed with :const:`LOCK_NB` to avoid blocking on lock acquisition.
+   If :const:`LOCK_NB` is used and the lock cannot be acquired, an
+   :exc:`IOError` will be raised and the exception will have an *errno*
+   attribute set to :const:`EACCES` or :const:`EAGAIN` (depending on the
+   operating system; for portability, check for both values).  On at least some
+   systems, :const:`LOCK_EX` can only be used if the file descriptor refers to a
+   file opened for writing.
 
    *length* is the number of bytes to lock, *start* is the byte offset at which the
    lock starts, relative to *whence*, and *whence* is as with :func:`fileobj.seek`,
    specifically:
 
-* :const:`0` -- relative to the start of the file (:const:`SEEK_SET`)
-
-* :const:`1` -- relative to the current buffer position (:const:`SEEK_CUR`)
-
-* :const:`2` -- relative to the end of the file (:const:`SEEK_END`)
+   * :const:`0` -- relative to the start of the file (:const:`SEEK_SET`)
+   * :const:`1` -- relative to the current buffer position (:const:`SEEK_CUR`)
+   * :const:`2` -- relative to the end of the file (:const:`SEEK_END`)
 
    The default for *start* is 0, which means to start at the beginning of the file.
    The default for *length* is 0 which means to lock to the end of the file.  The
    default for *whence* is also 0.
 
 Examples (all on a SVR4 compliant system)::
 
    import struct, fcntl, os
 
    f = open(...)
    rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)
 
    lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)
    rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)
 
 Note that in the first example the return value variable *rv* will hold an
 integer value; in the second example it will hold a string value.  The structure
 lay-out for the *lockdata* variable is system dependent --- therefore using the
 :func:`flock` call may be better.
 
 
 .. seealso::
 
    Module :mod:`os`
-      If the locking flags :const:`O_SHLOCK` and :const:`O_EXLOCK` are present in the
-      :mod:`os` module, the :func:`os.open` function provides a more platform-
-      independent alternative to the :func:`lockf` and :func:`flock` functions.
+      If the locking flags :const:`O_SHLOCK` and :const:`O_EXLOCK` are present
+      in the :mod:`os` module, the :func:`os.open` function provides a more
+      platform-independent alternative to the :func:`lockf` and :func:`flock`
+      functions.
 

--- rest25/library/codecs.rst	2008-12-19 16:58:07.000000000 +0900
+++ rest262/library/codecs.rst	2009-04-05 05:02:09.000000000 +0900
@@ -21,52 +21,52 @@
 decoders) and provides access to the internal Python codec registry which
 manages the codec and error handling lookup process.
 
 It defines the following functions:
 
 
 .. function:: register(search_function)
 
    Register a codec search function. Search functions are expected to take one
    argument, the encoding name in all lower case letters, and return a
    :class:`CodecInfo` object having the following attributes:
 
-* ``name`` The name of the encoding;
+   * ``name`` The name of the encoding;
 
-* ``encoder`` The stateless encoding function;
+   * ``encode`` The stateless encoding function;
 
-* ``decoder`` The stateless decoding function;
+   * ``decode`` The stateless decoding function;
 
-* ``incrementalencoder`` An incremental encoder class or factory function;
+   * ``incrementalencoder`` An incremental encoder class or factory function;
 
-* ``incrementaldecoder`` An incremental decoder class or factory function;
+   * ``incrementaldecoder`` An incremental decoder class or factory function;
 
-* ``streamwriter`` A stream writer class or factory function;
+   * ``streamwriter`` A stream writer class or factory function;
 
-* ``streamreader`` A stream reader class or factory function.
+   * ``streamreader`` A stream reader class or factory function.
 
    The various functions or classes take the following arguments:
 
-   *encoder* and *decoder*: These must be functions or methods which have the same
+   *encode* and *decode*: These must be functions or methods which have the same
    interface as the :meth:`encode`/:meth:`decode` methods of Codec instances (see
    Codec Interface). The functions/methods are expected to work in a stateless
    mode.
 
-   *incrementalencoder* and *incrementalencoder*: These have to be factory
+   *incrementalencoder* and *incrementaldecoder*: These have to be factory
    functions providing the following interface:
 
    ``factory(errors='strict')``
 
    The factory functions must return objects providing the interfaces defined by
-   the base classes :class:`IncrementalEncoder` and :class:`IncrementalEncoder`,
+   the base classes :class:`IncrementalEncoder` and :class:`IncrementalDecoder`,
    respectively. Incremental codecs can maintain state.
 
    *streamreader* and *streamwriter*: These have to be factory functions providing
    the following interface:
 
    ``factory(stream, errors='strict')``
 
    The factory functions must return objects providing the interfaces defined by
    the base classes :class:`StreamWriter` and :class:`StreamReader`, respectively.
    Stream codecs can maintain state.
 
    Possible values for errors are ``'strict'`` (raise an exception in case of an
@@ -181,48 +181,56 @@
 
 
 .. function:: replace_errors(exception)
 
    Implements the ``replace`` error handling.
 
 
 .. function:: ignore_errors(exception)
 
    Implements the ``ignore`` error handling.
 
 
-.. function:: xmlcharrefreplace_errors_errors(exception)
+.. function:: xmlcharrefreplace_errors(exception)
 
    Implements the ``xmlcharrefreplace`` error handling.
 
 
-.. function:: backslashreplace_errors_errors(exception)
+.. function:: backslashreplace_errors(exception)
 
    Implements the ``backslashreplace`` error handling.
 
 To simplify working with encoded files or stream, the module also defines these
 utility functions:
 
 
 .. function:: open(filename, mode[, encoding[, errors[, buffering]]])
 
    Open an encoded file using the given *mode* and return a wrapped version
-   providing transparent encoding/decoding.
+   providing transparent encoding/decoding.  The default file mode is ``'r'``
+   meaning to open the file in read mode.
 
    .. note::
 
       The wrapped version will only accept the object format defined by the codecs,
       i.e. Unicode objects for most built-in codecs.  Output is also codec-dependent
       and will usually be Unicode as well.
 
+   .. note::
+
+      Files are always opened in binary mode, even if no binary mode was
+      specified.  This is done to avoid data loss due to encodings using 8-bit
+      values.  This means that no automatic conversion of ``'\n'`` is done
+      on reading and writing.
+
    *encoding* specifies the encoding which is to be used for the file.
 
    *errors* may be given to define the error handling. It defaults to ``'strict'``
    which causes a :exc:`ValueError` to be raised in case an encoding error occurs.
 
    *buffering* has the same meaning as for the built-in :func:`open` function.  It
    defaults to line buffered.
 
 
 .. function:: EncodedFile(file, input[, output[, errors]])
 
    Return a wrapped version of file which provides transparent encoding
@@ -233,35 +241,35 @@
    *output* encoding. The intermediate encoding will usually be Unicode but depends
    on the specified codecs.
 
    If *output* is not given, it defaults to *input*.
 
    *errors* may be given to define the error handling. It defaults to ``'strict'``,
    which causes :exc:`ValueError` to be raised in case an encoding error occurs.
 
 
 .. function:: iterencode(iterable, encoding[, errors])
 
    Uses an incremental encoder to iteratively encode the input provided by
-   *iterable*. This function is a generator. *errors* (as well as any other keyword
-   argument) is passed through to the incremental encoder.
+   *iterable*. This function is a :term:`generator`.  *errors* (as well as any
+   other keyword argument) is passed through to the incremental encoder.
 
    .. versionadded:: 2.5
 
 
 .. function:: iterdecode(iterable, encoding[, errors])
 
    Uses an incremental decoder to iteratively decode the input provided by
-   *iterable*. This function is a generator. *errors* (as well as any other keyword
-   argument) is passed through to the incremental encoder.
+   *iterable*. This function is a :term:`generator`.  *errors* (as well as any
+   other keyword argument) is passed through to the incremental decoder.
 
    .. versionadded:: 2.5
 
 The module also provides the following constants which are useful for reading
 and writing to platform dependent files:
 
 
 .. data:: BOM
           BOM_BE
           BOM_LE
           BOM_UTF8
           BOM_UTF16
@@ -278,25 +286,26 @@
    native byte order, :const:`BOM` is an alias for :const:`BOM_UTF16`,
    :const:`BOM_LE` for :const:`BOM_UTF16_LE` and :const:`BOM_BE` for
    :const:`BOM_UTF16_BE`. The others represent the BOM in UTF-8 and UTF-32
    encodings.
 
 
 .. _codec-base-classes:
 
 Codec Base Classes
 ------------------
 
 The :mod:`codecs` module defines a set of base classes which define the
-interface and can also be used to easily write you own codecs for use in Python.
+interface and can also be used to easily write your own codecs for use in
+Python.
 
 Each codec has to define four interfaces to make it usable as codec in Python:
 stateless encoder, stateless decoder, stream reader and stream writer. The
 stream reader and writers typically reuse the stateless encoder/decoder to
 implement the file protocols.
 
 The :class:`Codec` class defines the interface for stateless encoders/decoders.
 
 To simplify and standardize error handling, the :meth:`encode` and
 :meth:`decode` methods may implement different error handling schemes by
 providing the *errors* string argument.  The following string values are defined
 and implemented by all standard Python codecs:
@@ -326,43 +335,43 @@
 The set of allowed values can be extended via :meth:`register_error`.
 
 
 .. _codec-objects:
 
 Codec Objects
 ^^^^^^^^^^^^^
 
 The :class:`Codec` class defines these methods which also define the function
 interfaces of the stateless encoder and decoder:
 
 
-.. method:: XXX Class.encode(input[, errors])
+.. method:: Codec.encode(input[, errors])
 
    Encodes the object *input* and returns a tuple (output object, length consumed).
    While codecs are not restricted to use with Unicode, in a Unicode context,
    encoding converts a Unicode object to a plain string using a particular
    character set encoding (e.g., ``cp1252`` or ``iso-8859-1``).
 
    *errors* defines the error handling to apply. It defaults to ``'strict'``
    handling.
 
    The method may not store state in the :class:`Codec` instance. Use
    :class:`StreamCodec` for codecs which have to keep state in order to make
    encoding/decoding efficient.
 
    The encoder must be able to handle zero length input and return an empty object
    of the output object type in this situation.
 
 
-.. method:: XXX Class.decode(input[, errors])
+.. method:: Codec.decode(input[, errors])
 
    Decodes the object *input* and returns a tuple (output object, length consumed).
    In a Unicode context, decoding converts a plain string encoded using a
    particular character set encoding to a Unicode object.
 
    *input* must be an object which provides the ``bf_getreadbuf`` buffer slot.
    Python strings, buffer objects and memory mapped files are examples of objects
    providing this slot.
 
    *errors* defines the error handling to apply. It defaults to ``'strict'``
    handling.
 
@@ -399,105 +408,106 @@
 
 .. class:: IncrementalEncoder([errors])
 
    Constructor for an :class:`IncrementalEncoder` instance.
 
    All incremental encoders must provide this constructor interface. They are free
    to add additional keyword arguments, but only the ones defined here are used by
    the Python codec registry.
 
    The :class:`IncrementalEncoder` may implement different error handling schemes
    by providing the *errors* keyword argument. These parameters are predefined:
 
-* ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
+   * ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
 
-* ``'ignore'`` Ignore the character and continue with the next.
+   * ``'ignore'`` Ignore the character and continue with the next.
 
-* ``'replace'`` Replace with a suitable replacement character
+   * ``'replace'`` Replace with a suitable replacement character
 
-* ``'xmlcharrefreplace'`` Replace with the appropriate XML character reference
+   * ``'xmlcharrefreplace'`` Replace with the appropriate XML character reference
 
-* ``'backslashreplace'`` Replace with backslashed escape sequences.
+   * ``'backslashreplace'`` Replace with backslashed escape sequences.
 
    The *errors* argument will be assigned to an attribute of the same name.
    Assigning to this attribute makes it possible to switch between different error
    handling strategies during the lifetime of the :class:`IncrementalEncoder`
    object.
 
    The set of allowed values for the *errors* argument can be extended with
    :func:`register_error`.
 
 
-.. method:: IncrementalEncoder.encode(object[, final])
+   .. method:: encode(object[, final])
 
-   Encodes *object* (taking the current state of the encoder into account) and
-   returns the resulting encoded object. If this is the last call to :meth:`encode`
-   *final* must be true (the default is false).
+      Encodes *object* (taking the current state of the encoder into account)
+      and returns the resulting encoded object. If this is the last call to
+      :meth:`encode` *final* must be true (the default is false).
 
 
-.. method:: IncrementalEncoder.reset()
+   .. method:: reset()
 
-   Reset the encoder to the initial state.
+      Reset the encoder to the initial state.
 
 
 .. _incremental-decoder-objects:
 
 IncrementalDecoder Objects
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 The :class:`IncrementalDecoder` class is used for decoding an input in multiple
 steps. It defines the following methods which every incremental decoder must
 define in order to be compatible with the Python codec registry.
 
 
 .. class:: IncrementalDecoder([errors])
 
    Constructor for an :class:`IncrementalDecoder` instance.
 
    All incremental decoders must provide this constructor interface. They are free
    to add additional keyword arguments, but only the ones defined here are used by
    the Python codec registry.
 
    The :class:`IncrementalDecoder` may implement different error handling schemes
    by providing the *errors* keyword argument. These parameters are predefined:
 
-* ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
+   * ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
 
-* ``'ignore'`` Ignore the character and continue with the next.
+   * ``'ignore'`` Ignore the character and continue with the next.
 
-* ``'replace'`` Replace with a suitable replacement character.
+   * ``'replace'`` Replace with a suitable replacement character.
 
    The *errors* argument will be assigned to an attribute of the same name.
    Assigning to this attribute makes it possible to switch between different error
-   handling strategies during the lifetime of the :class:`IncrementalEncoder`
+   handling strategies during the lifetime of the :class:`IncrementalDecoder`
    object.
 
    The set of allowed values for the *errors* argument can be extended with
    :func:`register_error`.
 
 
-.. method:: IncrementalDecoder.decode(object[, final])
+   .. method:: decode(object[, final])
+
+      Decodes *object* (taking the current state of the decoder into account)
+      and returns the resulting decoded object. If this is the last call to
+      :meth:`decode` *final* must be true (the default is false). If *final* is
+      true the decoder must decode the input completely and must flush all
+      buffers. If this isn't possible (e.g. because of incomplete byte sequences
+      at the end of the input) it must initiate error handling just like in the
+      stateless case (which might raise an exception).
 
-   Decodes *object* (taking the current state of the decoder into account) and
-   returns the resulting decoded object. If this is the last call to :meth:`decode`
-   *final* must be true (the default is false). If *final* is true the decoder must
-   decode the input completely and must flush all buffers. If this isn't possible
-   (e.g. because of incomplete byte sequences at the end of the input) it must
-   initiate error handling just like in the stateless case (which might raise an
-   exception).
 
+   .. method:: reset()
 
-.. method:: IncrementalDecoder.reset()
+      Reset the decoder to the initial state.
 
-   Reset the decoder to the initial state.
 
 The :class:`StreamWriter` and :class:`StreamReader` classes provide generic
 working interfaces which can be used to implement new encoding submodules very
 easily. See :mod:`encodings.utf_8` for an example of how this is done.
 
 
 .. _stream-writer-objects:
 
 StreamWriter Objects
 ^^^^^^^^^^^^^^^^^^^^
 
 The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines the
@@ -509,60 +519,61 @@
 
    Constructor for a :class:`StreamWriter` instance.
 
    All stream writers must provide this constructor interface. They are free to add
    additional keyword arguments, but only the ones defined here are used by the
    Python codec registry.
 
    *stream* must be a file-like object open for writing binary data.
 
    The :class:`StreamWriter` may implement different error handling schemes by
    providing the *errors* keyword argument. These parameters are predefined:
 
-* ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
+   * ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
 
-* ``'ignore'`` Ignore the character and continue with the next.
+   * ``'ignore'`` Ignore the character and continue with the next.
 
-* ``'replace'`` Replace with a suitable replacement character
+   * ``'replace'`` Replace with a suitable replacement character
 
-* ``'xmlcharrefreplace'`` Replace with the appropriate XML character reference
+   * ``'xmlcharrefreplace'`` Replace with the appropriate XML character reference
 
-* ``'backslashreplace'`` Replace with backslashed escape sequences.
+   * ``'backslashreplace'`` Replace with backslashed escape sequences.
 
    The *errors* argument will be assigned to an attribute of the same name.
    Assigning to this attribute makes it possible to switch between different error
    handling strategies during the lifetime of the :class:`StreamWriter` object.
 
    The set of allowed values for the *errors* argument can be extended with
    :func:`register_error`.
 
 
-.. method:: StreamWriter.write(object)
+   .. method:: write(object)
 
-   Writes the object's contents encoded to the stream.
+      Writes the object's contents encoded to the stream.
 
 
-.. method:: StreamWriter.writelines(list)
+   .. method:: writelines(list)
 
-   Writes the concatenated list of strings to the stream (possibly by reusing the
-   :meth:`write` method).
+      Writes the concatenated list of strings to the stream (possibly by reusing
+      the :meth:`write` method).
 
 
-.. method:: StreamWriter.reset()
+   .. method:: reset()
 
-   Flushes and resets the codec buffers used for keeping state.
+      Flushes and resets the codec buffers used for keeping state.
+
+      Calling this method should ensure that the data on the output is put into
+      a clean state that allows appending of new fresh data without having to
+      rescan the whole stream to recover state.
 
-   Calling this method should ensure that the data on the output is put into a
-   clean state that allows appending of new fresh data without having to rescan the
-   whole stream to recover state.
 
 In addition to the above methods, the :class:`StreamWriter` must also inherit
 all other methods and attributes from the underlying stream.
 
 
 .. _stream-reader-objects:
 
 StreamReader Objects
 ^^^^^^^^^^^^^^^^^^^^
 
 The :class:`StreamReader` class is a subclass of :class:`Codec` and defines the
 following methods which every stream reader must define in order to be
@@ -573,96 +584,100 @@
 
    Constructor for a :class:`StreamReader` instance.
 
    All stream readers must provide this constructor interface. They are free to add
    additional keyword arguments, but only the ones defined here are used by the
    Python codec registry.
 
    *stream* must be a file-like object open for reading (binary) data.
 
    The :class:`StreamReader` may implement different error handling schemes by
    providing the *errors* keyword argument. These parameters are defined:
 
-* ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
+   * ``'strict'`` Raise :exc:`ValueError` (or a subclass); this is the default.
 
-* ``'ignore'`` Ignore the character and continue with the next.
+   * ``'ignore'`` Ignore the character and continue with the next.
 
-* ``'replace'`` Replace with a suitable replacement character.
+   * ``'replace'`` Replace with a suitable replacement character.
 
    The *errors* argument will be assigned to an attribute of the same name.
    Assigning to this attribute makes it possible to switch between different error
    handling strategies during the lifetime of the :class:`StreamReader` object.
 
    The set of allowed values for the *errors* argument can be extended with
    :func:`register_error`.
 
 
-.. method:: StreamReader.read([size[, chars, [firstline]]])
+   .. method:: read([size[, chars, [firstline]]])
+
+      Decodes data from the stream and returns the resulting object.
 
-   Decodes data from the stream and returns the resulting object.
+      *chars* indicates the number of characters to read from the
+      stream. :func:`read` will never return more than *chars* characters, but
+      it might return less, if there are not enough characters available.
 
-   *chars* indicates the number of characters to read from the stream. :func:`read`
-   will never return more than *chars* characters, but it might return less, if
-   there are not enough characters available.
+      *size* indicates the approximate maximum number of bytes to read from the
+      stream for decoding purposes. The decoder can modify this setting as
+      appropriate. The default value -1 indicates to read and decode as much as
+      possible.  *size* is intended to prevent having to decode huge files in
+      one step.
 
-   *size* indicates the approximate maximum number of bytes to read from the stream
-   for decoding purposes. The decoder can modify this setting as appropriate. The
-   default value -1 indicates to read and decode as much as possible.  *size* is
-   intended to prevent having to decode huge files in one step.
+      *firstline* indicates that it would be sufficient to only return the first
+      line, if there are decoding errors on later lines.
 
-   *firstline* indicates that it would be sufficient to only return the first line,
-   if there are decoding errors on later lines.
+      The method should use a greedy read strategy meaning that it should read
+      as much data as is allowed within the definition of the encoding and the
+      given size, e.g.  if optional encoding endings or state markers are
+      available on the stream, these should be read too.
 
-   The method should use a greedy read strategy meaning that it should read as much
-   data as is allowed within the definition of the encoding and the given size,
-   e.g.  if optional encoding endings or state markers are available on the stream,
-   these should be read too.
+      .. versionchanged:: 2.4
+         *chars* argument added.
 
-   .. versionchanged:: 2.4
-      *chars* argument added.
+      .. versionchanged:: 2.4.2
+         *firstline* argument added.
 
-   .. versionchanged:: 2.4.2
-      *firstline* argument added.
 
+   .. method:: readline([size[, keepends]])
 
-.. method:: StreamReader.readline([size[, keepends]])
+      Read one line from the input stream and return the decoded data.
 
-   Read one line from the input stream and return the decoded data.
+      *size*, if given, is passed as size argument to the stream's
+      :meth:`readline` method.
 
-   *size*, if given, is passed as size argument to the stream's :meth:`readline`
-   method.
+      If *keepends* is false line-endings will be stripped from the lines
+      returned.
 
-   If *keepends* is false line-endings will be stripped from the lines returned.
+      .. versionchanged:: 2.4
+         *keepends* argument added.
 
-   .. versionchanged:: 2.4
-      *keepends* argument added.
 
+   .. method:: readlines([sizehint[, keepends]])
 
-.. method:: StreamReader.readlines([sizehint[, keepends]])
+      Read all lines available on the input stream and return them as a list of
+      lines.
 
-   Read all lines available on the input stream and return them as a list of lines.
+      Line-endings are implemented using the codec's decoder method and are
+      included in the list entries if *keepends* is true.
 
-   Line-endings are implemented using the codec's decoder method and are included
-   in the list entries if *keepends* is true.
+      *sizehint*, if given, is passed as the *size* argument to the stream's
+      :meth:`read` method.
 
-   *sizehint*, if given, is passed as the *size* argument to the stream's
-   :meth:`read` method.
 
+   .. method:: reset()
 
-.. method:: StreamReader.reset()
+      Resets the codec buffers used for keeping state.
 
-   Resets the codec buffers used for keeping state.
+      Note that no stream repositioning should take place.  This method is
+      primarily intended to be able to recover from decoding errors.
 
-   Note that no stream repositioning should take place.  This method is primarily
-   intended to be able to recover from decoding errors.
 
 In addition to the above methods, the :class:`StreamReader` must also inherit
 all other methods and attributes from the underlying stream.
 
 The next two base classes are included for convenience. They are not needed by
 the codec registry, but may provide useful in practice.
 
 
 .. _stream-reader-writer:
 
 StreamReaderWriter Objects
 ^^^^^^^^^^^^^^^^^^^^^^^^^^
@@ -713,54 +728,55 @@
    *encode*, *decode* must adhere to the :class:`Codec` interface. *Reader*,
    *Writer* must be factory functions or classes providing objects of the
    :class:`StreamReader` and :class:`StreamWriter` interface respectively.
 
    *encode* and *decode* are needed for the frontend translation, *Reader* and
    *Writer* for the backend translation.  The intermediate format used is
    determined by the two sets of codecs, e.g. the Unicode codecs will use Unicode
    as the intermediate encoding.
 
    Error handling is done in the same way as defined for the stream readers and
    writers.
 
+
 :class:`StreamRecoder` instances define the combined interfaces of
 :class:`StreamReader` and :class:`StreamWriter` classes. They inherit all other
 methods and attributes from the underlying stream.
 
 
 .. _encodings-overview:
 
 Encodings and Unicode
 ---------------------
 
 Unicode strings are stored internally as sequences of codepoints (to be precise
 as :ctype:`Py_UNICODE` arrays). Depending on the way Python is compiled (either
-via :option:`--enable-unicode=ucs2` or  :option:`--enable-unicode=ucs4`, with
-the former being the default) :ctype:`Py_UNICODE` is either a 16-bit or 32-bit
-data type. Once a Unicode object is used outside of CPU and memory, CPU
-endianness and how these arrays are stored as bytes become an issue.
-Transforming a unicode object into a sequence of bytes is called encoding and
-recreating the unicode object from the sequence of bytes is known as decoding.
-There are many different methods for how this transformation can be done (these
-methods are also called encodings). The simplest method is to map the codepoints
-0-255 to the bytes ``0x0``\ -\ ``0xff``. This means that a unicode object that
-contains  codepoints above ``U+00FF`` can't be encoded with this method (which
-is called ``'latin-1'`` or ``'iso-8859-1'``). :func:`unicode.encode` will raise
-a :exc:`UnicodeEncodeError` that looks like this: ``UnicodeEncodeError:
-'latin-1' codec can't encode character u'\u1234' in position 3: ordinal not in
+via :option:`--enable-unicode=ucs2` or :option:`--enable-unicode=ucs4`, with the
+former being the default) :ctype:`Py_UNICODE` is either a 16-bit or 32-bit data
+type. Once a Unicode object is used outside of CPU and memory, CPU endianness
+and how these arrays are stored as bytes become an issue.  Transforming a
+unicode object into a sequence of bytes is called encoding and recreating the
+unicode object from the sequence of bytes is known as decoding.  There are many
+different methods for how this transformation can be done (these methods are
+also called encodings). The simplest method is to map the codepoints 0-255 to
+the bytes ``0x0``-``0xff``. This means that a unicode object that contains
+codepoints above ``U+00FF`` can't be encoded with this method (which is called
+``'latin-1'`` or ``'iso-8859-1'``). :func:`unicode.encode` will raise a
+:exc:`UnicodeEncodeError` that looks like this: ``UnicodeEncodeError: 'latin-1'
+codec can't encode character u'\u1234' in position 3: ordinal not in
 range(256)``.
 
 There's another group of encodings (the so called charmap encodings) that choose
 a different subset of all unicode code points and how these codepoints are
-mapped to the bytes ``0x0``\ -\ ``0xff.`` To see how this is done simply open
+mapped to the bytes ``0x0``-``0xff``. To see how this is done simply open
 e.g. :file:`encodings/cp1252.py` (which is an encoding that is used primarily on
 Windows). There's a string constant with 256 characters that shows you which
 character is mapped to which byte value.
 
 All of these encodings can only encode 256 of the 65536 (or 1114111) codepoints
 defined in unicode. A simple and straightforward way that can store each Unicode
 code point, is to store each codepoint as two consecutive bytes. There are two
 possibilities: Store the bytes in big endian or in little endian order. These
 two encodings are called UTF-16-BE and UTF-16-LE respectively. Their
 disadvantage is that if e.g. you use UTF-16-BE on a little endian machine you
 will always have to swap bytes on encoding and decoding. UTF-16 avoids this
 problem: Bytes will always be in natural endianness. When these bytes are read
@@ -807,34 +823,35 @@
 +-----------------------------------+----------------------------------------------+
 
 The least significant bit of the Unicode character is the rightmost x bit.
 
 As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` character in
 the decoded Unicode string (even if it's the first character) is treated as a
 ``ZERO WIDTH NO-BREAK SPACE``.
 
 Without external information it's impossible to reliably determine which
 encoding was used for encoding a Unicode string. Each charmap encoding can
 decode any random byte sequence. However that's not possible with UTF-8, as
 UTF-8 byte sequences have a structure that doesn't allow arbitrary byte
-sequence. To increase the reliability with which a UTF-8 encoding can be
+sequences. To increase the reliability with which a UTF-8 encoding can be
 detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls
 ``"utf-8-sig"``) for its Notepad program: Before any of the Unicode characters
 is written to the file, a UTF-8 encoded BOM (which looks like this as a byte
 sequence: ``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable
 that any charmap encoded file starts with these byte values (which would e.g.
 map to
 
-LATIN SMALL LETTER I WITH DIAERESIS  ---  RIGHT-POINTING DOUBLE ANGLE QUOTATION
-MARK  ---  INVERTED QUESTION MARK
+   | LATIN SMALL LETTER I WITH DIAERESIS
+   | RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+   | INVERTED QUESTION MARK
 
 in iso-8859-1), this increases the probability that a utf-8-sig encoding can be
 correctly guessed from the byte sequence. So here the BOM is not used to be able
 to determine the byte order used for generating the byte sequence, but as a
 signature that helps in guessing the encoding. On encoding the utf-8-sig codec
 will write ``0xef``, ``0xbb``, ``0xbf`` as the first three bytes to the file. On
 decoding utf-8-sig will skip those three bytes if they appear as the first three
 bytes in the file.
 
 
 .. _standard-encodings:
 
@@ -983,25 +1000,25 @@
 | iso2022_jp_ext  | iso2022jp-ext, iso-2022-jp-ext | Japanese                       |
 +-----------------+--------------------------------+--------------------------------+
 | iso2022_kr      | csiso2022kr, iso2022kr,        | Korean                         |
 |                 | iso-2022-kr                    |                                |
 +-----------------+--------------------------------+--------------------------------+
 | latin_1         | iso-8859-1, iso8859-1, 8859,   | West Europe                    |
 |                 | cp819, latin, latin1, L1       |                                |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_2       | iso-8859-2, latin2, L2         | Central and Eastern Europe     |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_3       | iso-8859-3, latin3, L3         | Esperanto, Maltese             |
 +-----------------+--------------------------------+--------------------------------+
-| iso8859_4       | iso-8859-4, latin4, L4         | Baltic languagues              |
+| iso8859_4       | iso-8859-4, latin4, L4         | Baltic languages               |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_5       | iso-8859-5, cyrillic           | Bulgarian, Byelorussian,       |
 |                 |                                | Macedonian, Russian, Serbian   |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_6       | iso-8859-6, arabic             | Arabic                         |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_7       | iso-8859-7, greek, greek8      | Greek                          |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_8       | iso-8859-8, hebrew             | Hebrew                         |
 +-----------------+--------------------------------+--------------------------------+
 | iso8859_9       | iso-8859-9, latin5, L5         | Turkish                        |
 +-----------------+--------------------------------+--------------------------------+
@@ -1035,24 +1052,30 @@
 | ptcp154         | csptcp154, pt154, cp154,       | Kazakh                         |
 |                 | cyrillic-asian                 |                                |
 +-----------------+--------------------------------+--------------------------------+
 | shift_jis       | csshiftjis, shiftjis, sjis,    | Japanese                       |
 |                 | s_jis                          |                                |
 +-----------------+--------------------------------+--------------------------------+
 | shift_jis_2004  | shiftjis2004, sjis_2004,       | Japanese                       |
 |                 | sjis2004                       |                                |
 +-----------------+--------------------------------+--------------------------------+
 | shift_jisx0213  | shiftjisx0213, sjisx0213,      | Japanese                       |
 |                 | s_jisx0213                     |                                |
 +-----------------+--------------------------------+--------------------------------+
+| utf_32          | U32, utf32                     | all languages                  |
++-----------------+--------------------------------+--------------------------------+
+| utf_32_be       | UTF-32BE                       | all languages                  |
++-----------------+--------------------------------+--------------------------------+
+| utf_32_le       | UTF-32LE                       | all languages                  |
++-----------------+--------------------------------+--------------------------------+
 | utf_16          | U16, utf16                     | all languages                  |
 +-----------------+--------------------------------+--------------------------------+
 | utf_16_be       | UTF-16BE                       | all languages (BMP only)       |
 +-----------------+--------------------------------+--------------------------------+
 | utf_16_le       | UTF-16LE                       | all languages (BMP only)       |
 +-----------------+--------------------------------+--------------------------------+
 | utf_7           | U7, unicode-1-1-utf-7          | all languages                  |
 +-----------------+--------------------------------+--------------------------------+
 | utf_8           | U8, UTF, utf8                  | all languages                  |
 +-----------------+--------------------------------+--------------------------------+
 | utf_8_sig       |                                | all languages                  |
 +-----------------+--------------------------------+--------------------------------+
@@ -1071,105 +1094,104 @@
 +====================+===========================+================+===========================+
 | base64_codec       | base64, base-64           | byte string    | Convert operand to MIME   |
 |                    |                           |                | base64                    |
 +--------------------+---------------------------+----------------+---------------------------+
 | bz2_codec          | bz2                       | byte string    | Compress the operand      |
 |                    |                           |                | using bz2                 |
 +--------------------+---------------------------+----------------+---------------------------+
 | hex_codec          | hex                       | byte string    | Convert operand to        |
 |                    |                           |                | hexadecimal               |
 |                    |                           |                | representation, with two  |
 |                    |                           |                | digits per byte           |
 +--------------------+---------------------------+----------------+---------------------------+
-| idna               |                           | Unicode string | Implements :rfc:`3490`.   |
-|                    |                           |                | See also                  |
+| idna               |                           | Unicode string | Implements :rfc:`3490`,   |
+|                    |                           |                | see also                  |
 |                    |                           |                | :mod:`encodings.idna`     |
 +--------------------+---------------------------+----------------+---------------------------+
 | mbcs               | dbcs                      | Unicode string | Windows only: Encode      |
 |                    |                           |                | operand according to the  |
 |                    |                           |                | ANSI codepage (CP_ACP)    |
 +--------------------+---------------------------+----------------+---------------------------+
 | palmos             |                           | Unicode string | Encoding of PalmOS 3.5    |
 +--------------------+---------------------------+----------------+---------------------------+
-| punycode           |                           | Unicode string | Implements :rfc:`3492`.   |
+| punycode           |                           | Unicode string | Implements :rfc:`3492`    |
 +--------------------+---------------------------+----------------+---------------------------+
 | quopri_codec       | quopri, quoted-printable, | byte string    | Convert operand to MIME   |
 |                    | quotedprintable           |                | quoted printable          |
 +--------------------+---------------------------+----------------+---------------------------+
 | raw_unicode_escape |                           | Unicode string | Produce a string that is  |
 |                    |                           |                | suitable as raw Unicode   |
 |                    |                           |                | literal in Python source  |
 |                    |                           |                | code                      |
 +--------------------+---------------------------+----------------+---------------------------+
 | rot_13             | rot13                     | Unicode string | Returns the Caesar-cypher |
 |                    |                           |                | encryption of the operand |
 +--------------------+---------------------------+----------------+---------------------------+
 | string_escape      |                           | byte string    | Produce a string that is  |
 |                    |                           |                | suitable as string        |
 |                    |                           |                | literal in Python source  |
 |                    |                           |                | code                      |
 +--------------------+---------------------------+----------------+---------------------------+
 | undefined          |                           | any            | Raise an exception for    |
 |                    |                           |                | all conversions. Can be   |
 |                    |                           |                | used as the system        |
 |                    |                           |                | encoding if no automatic  |
-|                    |                           |                | coercion between byte and |
-|                    |                           |                | Unicode strings is        |
-|                    |                           |                | desired.                  |
+|                    |                           |                | :term:`coercion` between  |
+|                    |                           |                | byte and Unicode strings  |
+|                    |                           |                | is desired.               |
 +--------------------+---------------------------+----------------+---------------------------+
 | unicode_escape     |                           | Unicode string | Produce a string that is  |
 |                    |                           |                | suitable as Unicode       |
 |                    |                           |                | literal in Python source  |
 |                    |                           |                | code                      |
 +--------------------+---------------------------+----------------+---------------------------+
 | unicode_internal   |                           | Unicode string | Return the internal       |
 |                    |                           |                | representation of the     |
 |                    |                           |                | operand                   |
 +--------------------+---------------------------+----------------+---------------------------+
 | uu_codec           | uu                        | byte string    | Convert the operand using |
 |                    |                           |                | uuencode                  |
 +--------------------+---------------------------+----------------+---------------------------+
 | zlib_codec         | zip, zlib                 | byte string    | Compress the operand      |
 |                    |                           |                | using gzip                |
 +--------------------+---------------------------+----------------+---------------------------+
 
+.. versionadded:: 2.3
+   The ``idna`` and ``punycode`` encodings.
+
 
 :mod:`encodings.idna` --- Internationalized Domain Names in Applications
 ------------------------------------------------------------------------
 
 .. module:: encodings.idna
    :synopsis: Internationalized Domain Names implementation
-
-
-.. % XXX The next line triggers a formatting bug, so it's commented out
-.. % until that can be fixed.
-.. % \moduleauthor{Martin v. L\"owis}
+.. moduleauthor:: Martin v. Löwis
 
 .. versionadded:: 2.3
 
 This module implements :rfc:`3490` (Internationalized Domain Names in
 Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for
 Internationalized Domain Names (IDN)). It builds upon the ``punycode`` encoding
 and :mod:`stringprep`.
 
 These RFCs together define a protocol to support non-ASCII characters in domain
 names. A domain name containing non-ASCII characters (such as
-"www.Alliancefrançaise.nu") is converted into an ASCII-compatible encoding (ACE,
-such as "www.xn--alliancefranaise-npb.nu"). The ACE form of the domain name is
-then used in all places where arbitrary characters are not allowed by the
-protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so on. This
-conversion is carried out in the application; if possible invisible to the user:
-The application should transparently convert Unicode domain labels to IDNA on
-the wire, and convert back ACE labels to Unicode before presenting them to the
-user.
+``www.Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding
+(ACE, such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain
+name is then used in all places where arbitrary characters are not allowed by
+the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so
+on. This conversion is carried out in the application; if possible invisible to
+the user: The application should transparently convert Unicode domain labels to
+IDNA on the wire, and convert back ACE labels to Unicode before presenting them
+to the user.
 
 Python supports this conversion in several ways: The ``idna`` codec allows to
 convert between Unicode and the ACE. Furthermore, the :mod:`socket` module
 transparently converts Unicode host names to ACE, so that applications need not
 be concerned about converting host names themselves when they pass them to the
 socket module. On top of that, modules that have host names as function
 parameters, such as :mod:`httplib` and :mod:`ftplib`, accept Unicode host names
 (:mod:`httplib` then also transparently sends an IDNA hostname in the
 :mailheader:`Host` field if it sends that field at all).
 
 When receiving host names from the wire (such as in reverse name lookup), no
 automatic conversion to Unicode is performed: Applications wishing to present
@@ -1192,26 +1214,23 @@
    Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` is
    assumed to be false.
 
 
 .. function:: ToUnicode(label)
 
    Convert a label to Unicode, as specified in :rfc:`3490`.
 
 
 :mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature
 -------------------------------------------------------------
 
-.. module:: encodings.utf-8-sig
+.. module:: encodings.utf_8_sig
    :synopsis: UTF-8 codec with BOM signature
 .. moduleauthor:: Walter Dörwald
 
-
-.. % XXX utf_8_sig gives TeX errors
-
 .. versionadded:: 2.5
 
 This module implements a variant of the UTF-8 codec: On encoding a UTF-8 encoded
 BOM will be prepended to the UTF-8 encoded bytes. For the stateful encoder this
 is only done once (on the first write to the byte stream).  For decoding an
 optional UTF-8 encoded BOM at the start of the data will be skipped.
 

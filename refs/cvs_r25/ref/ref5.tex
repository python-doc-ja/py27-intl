\chapter{式 (expression)\label{expressions}}
\index{expression}

この章では、Python の式における個々の要素の意味について解説します。

\strong{表記法に関する注意:} この章と以降の章での拡張BNF 
(extended BNF) 表記は、字句解析規則ではなく、構文規則を記述する
ために用いられています。ある構文規則 (のある表現方法) が、以下の形式

\begin{productionlist}[*]
  \production{name}{\token{othername}}
\end{productionlist}

で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、
\code{name} の形式をとる構文の意味付けは、\code{othername}
の意味付けと同じになります。
\index{syntax}


\section{算術変換 (arithmetic conversion)\label{conversions}}
\indexii{arithmetic}{conversion}

以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と
書かれている場合、引数は ~\ref{coercion-rules} に記載されている
型強制規則に基づいて型強制されます。引数がいずれも標準の数値型
である場合、以下の型強制が適用されます:

\begin{itemize}
\item	片方の引数が複素数型であれば、他方は複素数型に変換されます;
\item	それ以外の場合で、片方の引数が浮動小数点数であれば、他方は
浮動小数点型に変換されます;
\item	それ以外の場合で、片方の引数が長整数型であれば、他方は
長整数型に変換されます;
\item	それ以外の場合で、両方の引数が通常の整数型であれば、変換の
必要はありません。
\end{itemize}

特定の演算子 (文字列を左引数とする `\%' 演算子など) では、さらに
別の規則が適用されます。拡張をおこなうことで、個々の演算子に対する
型強制を定義できます。


\section{アトム、原子的要素 (atom)\label{atoms}}
\index{atom}

アトム (原子的要素: atom) は、式を構成する基本単位です。もっとも単純な
アトムは、識別子またはリテラルになります。逆クオートや丸括弧、波括弧、
または角括弧で囲われた形式 (form) もまた、文法的にはアトムに分類
されます。アトムの構文定義は以下のようになります:

\begin{productionlist}
  \production{atom}
             {\token{identifier} | \token{literal} | \token{enclosure}}
  \production{enclosure}
             {\token{parenth_form} | \token{list_display}}
  \productioncont{| \token{generator_expression} | \token{dict_display}}
  \productioncont{| \token{string_conversion}}
\end{productionlist}


\subsection{識別子 (identifier、または名前 (name))\label{atom-identifiers}}
\index{name}
\index{identifier}

アトムの形になっている識別子 (identifier) は名前 (name) です。
名前づけや束縛については、\ref{naming} 節を参照してください。

名前があるオブジェクトに束縛されている場合、名前アトムを評価すると
そのオブジェクトになります。名前が束縛されていない場合、アトムを
評価しようとすると\exception{NameError} 例外を送出します。
\exindex{NameError}

\strong{プライベートな名前の難号化 (mangling):}
\indexii{name}{mangling}%
\indexii{private}{names}%
クラス定義内にテキストの形で書かれた識別子で、二つ以上のアンダースコア
から始まり、末尾が二つ以上のアンダースコアになっていないものは、
そのクラスの \dfn{プライベートな名前 (private name)} とみなされます。
プライベートな名前は、コードが生成される前に、より長い形式の名前に
変換されます。この変換では、クラス名の先頭にあるアンダースコアを全て
はぎとり、先頭にアンダースコアを一つ挿入して、名前の前に付加します。
例えば、クラス \code{Ham} 内の識別子 \code{__spam} は、
\code{_Ham__spam} に変換されます。変換は識別子が使われている構文的
コンテキストとは独立しています。変換された名前が非常に長い
(255 文字以上) の場合には、実装によっては名前の切り詰めが起きる
かもしれません。クラス名がアンダースコアだけから成り立つ場合には、
変換は行われません。


\subsection{リテラル\label{atom-literals}}
\index{literal}

Python では、文字列リテラルと、様々な数値リテラルをサポートしています:

\begin{productionlist}
  \production{literal}
             {\token{stringliteral} | \token{integer} | \token{longinteger}}
  \productioncont{| \token{floatnumber} | \token{imagnumber}}
\end{productionlist}

リテラルを評価すると、指定した型 (文字列、整数、長整数、
浮動小数点数、複素数) の指定した値を持つオブジェクトになります。
浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合
があります。詳しくは \ref{literals} を参照してください。
リテラルは全て変更不能なデータ型に対応します。このため、オブジェクト
のアイデンティティはオブジェクトの値ほど重要ではありません。
同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルが
プログラムの同じ場所由来のものであっても、そうでなくても) 
同じオブジェクトを指しているか、まったく同じ値を持つ別の
オブジェクトになります。
\indexiii{immutable}{data}{type}
\indexii{immutable}{object}


\subsection{丸括弧形式 (parenthesized form)\label{parenthesized}}
\index{parenthesized form}

丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:

\begin{productionlist}
  \production{parenth_form}
             {"(" [\token{expression_list}] ")"}
\end{productionlist}

丸括弧で囲われた式のリストは、個々の式が表現するものになります:
リスト内に少なくとも一つのカンマが入っていた場合、タプルになります;
そうでない場合、式のリストを構成している単一の式自体の値になります。

中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。
タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、
空のタプルが二箇所で使われると、それらは同じオブジェクトになることも
あるし、ならないこともあります)。
\indexii{empty}{tuple}

タプルは丸括弧で作成されるのではなく、カンマによって作成される
ことに注意してください。例外は空のタプルで、この場合には
丸括弧が\emph{必要です} --- 丸括弧のつかない、
``何も記述しない式 (nothing)'' を使えるようにしてしまうと、
文法があいまいなものになってしまい、よくあるタイプミスが検出されなく
なってしまいます。
\index{comma}
\indexii{tuple}{display}


\subsection{リスト表現\label{lists}}
\indexii{list}{display}
\indexii{list}{comprehensions}

リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であっても
かまいません:

\begin{productionlist}
  \production{test}
             {\token{or_test} | \token{lambda_form}}
  \production{testlist}
             {\token{test} ( "," \token{test} )* [ "," ]}
  \production{list_display}
             {"[" [\token{listmaker}] "]"}
  \production{listmaker}
             {\token{expression} ( \token{list_for}
              | ( "," \token{expression} )* [","] )}
  \production{list_iter}
             {\token{list_for} | \token{list_if}}
  \production{list_for}
             {"for" \token{expression_list} "in" \token{testlist}
              [\token{list_iter}]}
  \production{list_if}
             {"if" \token{test} [\token{list_iter}]}
\end{productionlist}

リスト表現は、新に作成されたリストオブジェクトを表します。
新たなリストの内容は、式のリストを与えるか、リストの内包表記
(list comprehension) で指定します。
\indexii{list}{comprehensions}
カンマで区切られた式のリストを与えた場合、リストの各要素は左から
右へと順に評価され、評価された順番にリスト内に配置されます。
リストの内包表記を与える場合、内包表記はまず単一の式、続いて
少なくとも一つの \keyword{for} 節、続いてゼロ個以上の 
\keyword{for} 節か、\keyword{if} 節になります。
この場合、新たに作成されるリストの各要素は、各々の \keyword{for}
や \keyword{if} 節を左から右の順にネストしたブロックとみなして実行し、
ネストの最内ブロックに到達する度に式を評価した値となります。
\footnote{Python 2.3 では、リスト内包が \samp{for} の中で使う制御
変数を内包表記を書いたスコープに「漏らして」しまう仕様になって
いました。この挙動は撤廃されたので、将来のバージョンでバグが修正
されれば、この挙動に依存したコードは動作しなくなります。}
\obindex{list}
\indexii{empty}{list}

\subsection{ジェネレータ式\label{genexpr}} %Generator expressions
\indexii{generator}{expression}

ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトな
ジェネレータ表記法です:

\begin{productionlist}
  \production{generator_expression}
             {"(" \token{test} \token{genexpr_for} ")"}
  \production{genexpr_for}
             {"for" \token{expression_list} "in" \token{test}
              [\token{genexpr_iter}]}
  \production{genexpr_iter}
             {\token{genexpr_for} | \token{genexpr_if}}
  \production{genexpr_if}
             {"if" \token{test} [\token{genexpr_iter}]}
\end{productionlist}

ジェネレータ式は新たなジェネレータオブジェクトを生み出します。
\obindex{generator}
\obindex{generator expression}
ジェネレータ式は単一の式の後ろに少なくとも一つの \keyword{for}
節と、場合によりさらに複数の\keyword{for} または \keyword{if} 節を
続けたものです。 新たなジェネレータが繰り返す値は、各\keyword{for}
および \keyword{if} 節をブロックとして、左から右へとネストし、
その最内ブロックの中で式を評価した結果を出力しているものと
みなせます。

ジェネレータ式の使う変数の評価は、ジェネレータオブジェクトに対して
\method{next()} メソッドを呼び出すまで遅延されます。とはいえ、
もっとも左に位置する \keyword{for} 節はただちに評価されるため、
ジェネレータ式の最左 \keyword{for} 節のエラーは、ジェネレータ式を
使っているコードの他のエラーに先立って起きることがあります。
それ以後の \keyword{for} 節は、先行する \keyword{for} ループに
依存しているため、直ちには評価されません。

例: \samp{(x*y for x in range(10) for y in bar(x))}

関数の唯一の引数として渡す場合には、丸括弧を省略できます。
詳しくは\ref{calls} 節を参照してください。

\subsection{辞書表現\label{dict}}
\indexii{dictionary}{display}

辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。
系列は空の系列であってもかまいません:
\index{key}
\index{datum}
\index{key/datum pair}

\begin{productionlist}
  \production{dict_display}
             {"\{" [\token{key_datum_list}] "\}"}
  \production{key_datum_list}
             {\token{key_datum} ("," \token{key_datum})* [","]}
  \production{key_datum}
             {\token{expression} ":" \token{expression}}
\end{productionlist}

辞書表現は、新たな辞書オブジェクトを表します。
\obindex{dictionary}

キー/データのペアは、左から右へと評価され、その結果が辞書の各
エントリを決定します: 各キーオブジェクトは、対応するデータを
辞書に記憶するためのキーとして用いられます。

キーの値として使える型に関する制限は、\ref{types} 節ですでに
列挙しています。(一言でいうと、キーは変更可能なオブジェクトを
全て排除したハッシュ可能な型でなければなりません。)
重複するキー間で衝突が起きても、衝突が検出されることはありません;
あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、
辞書表記の最も右側値となるもの) が使われます。
\indexii{immutable}{object}


\subsection{文字列変換\label{string-conversions}}
\indexii{string}{conversion}
\indexii{reverse}{quotes}
\indexii{backward}{quotes}
\index{back-quotes}

文字列変換は、逆クオート (reverse quite, 別名バッククオート: 
backward quote) で囲われた式のリストです:

\begin{productionlist}
  \production{string_conversion}
             {"`" \token{expression_list} "`"}
\end{productionlist}

文字列変換は、逆クオート内の式リストを評価して、評価結果の
オブジェクトを各オブジェクトの型特有の規則に従って文字列に
変換します。

オブジェクトが文字列、数値、\code{None} か、それらの型のオブジェクト
のみを含むタプル、リストまたは辞書の場合、評価結果の文字列は
有効な Python 式となり、組み込み関数 \function{eval()} に渡した
場合に同じ値となります  (浮動小数点が含まれている場合には近似値の
場合もあります)。

(特に、文字列を変換すると、値を安全に出力するために文字列の両側に
クオートが付けられ、``変 (funny) な'' 文字はエスケープシーケンスに
変換されます。)

再帰的な構造をもつオブジェクト (例えば自分自身を直接または間接的に
含むリストや辞書) では、\samp{...} を使って再帰的参照であることが
示され、オブジェクトの評価結果は \function{eval()} に渡しても
等価な値を得ることができません (\exception{SyntaxError} が
送出されます)。
\obindex{recursive}

組み込み関数 \function{repr()} は、括弧内の引数に対して、
逆クオート表記で囲われた中身と全く同じ変換を実行します。
組み込み関数 \function{str()} は似たような動作をしますが、
もっとユーザフレンドリな変換になります。
\bifuncindex{repr}
\bifuncindex{str}


\section{一次語 (primary) \label{primaries}}
\index{primary}

一次語は、言語において最も結合の強い操作を表します。
文法は以下のようになります:

\begin{productionlist}
  \production{primary}
             {\token{atom} | \token{attributeref}
              | \token{subscription} | \token{slicing} | \token{call}}
\end{productionlist}


\subsection{属性参照\label{attribute-references}}
\indexii{attribute}{reference}

属性参照は、一次語の後ろにピリオドと名前を連ねたものです:

\begin{productionlist}
  \production{attributeref}
             {\token{primary} "." \token{identifier}}
\end{productionlist}

一次語の値評価結果は、例えばモジュール、リスト、インスタンスと
いった、属性参照をサポートする型でなければなりません。
オブジェクトは次に、指定した名前が識別子名と
なっているような属性を生成するよう問い合わせされます。
問い合わせた属性が得られない場合、例外
\exception{AttributeError}\exindex{AttributeError} が送出
されます。それ以外の場合、オブジェクトは属性オブジェクトの型と
値を決定し、生成して返します。同じ属性参照を複数回評価したとき、
互いに異なる属性オブジェクトになることがあります。
\obindex{module}
\obindex{list}


\subsection{添字表記 (subscription)\label{subscriptions}}
\index{subscription}

添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書)
オブジェクトから、要素を一つ選択します:
\obindex{sequence}
\obindex{mapping}
\obindex{string}
\obindex{tuple}
\obindex{list}
\obindex{dictionary}
\indexii{sequence}{item}

\begin{productionlist}
  \production{subscription}
             {\token{primary} "[" \token{expression_list} "]"}
\end{productionlist}

一次語の値評価結果は、シーケンス型かマップ型のオブジェクトでなければなりません。

一次語がマップであれば、式リストの値評価結果はマップ内のいずれかの
キー値に相当するオブジェクトにならなければなりません。添字表記は、
そのキーに対応するマップ内の値 (value) を選択します。
(式リストの要素が単独である場合を除き、式リストはタプルでなければ
なりません。)

一次語がシーケンスの場合、式 (リスト) の値評価結果は (通常の) 整数でなければ
なりません。値が負の場合、シーケンスの長さが加算されます
(\code{x[-1]} が\code{x} の最後の要素を指すことになります)。
加算結果はシーケンス内の要素数よりも小さな非負の整数とならなければなりません。
添字表記は、添字と同じシーケンス中の (ゼロから数えた) インデクスを持つ要素を
選択します。

文字列型の要素は文字 (character) です。文字は個別の型ではなく、
1 文字だけからなる文字列です。
\index{character}
\indexii{string}{item}


\subsection{スライス表記 (slicing)\label{slicings}}
\index{slicing}
\index{slice}

スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある
範囲の要素を選択します。スライス表記は式として用いたり、代入や \keyword{del} 文の
対象として用いたりできます。スライス表記の構文は以下のようになります:
\obindex{sequence}
\obindex{string}
\obindex{tuple}
\obindex{list}

\begin{productionlist}
  \production{slicing}
             {\token{simple_slicing} | \token{extended_slicing}}
  \production{simple_slicing}
             {\token{primary} "[" \token{short_slice} "]"}
  \production{extended_slicing}
             {\token{primary} "[" \token{slice_list} "]" }
  \production{slice_list}
             {\token{slice_item} ("," \token{slice_item})* [","]}
  \production{slice_item}
             {\token{expression} | \token{proper_slice} | \token{ellipsis}}
  \production{proper_slice}
             {\token{short_slice} | \token{long_slice}}
  \production{short_slice}
             {[\token{lower_bound}] ":" [\token{upper_bound}]}
  \production{long_slice}
             {\token{short_slice} ":" [\token{stride}]}
  \production{lower_bound}
             {\token{expression}}
  \production{upper_bound}
             {\token{expression}}
  \production{stride}
             {\token{expression}}
  \production{ellipsis}
             {"..."}
\end{productionlist}

上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、
スライスリストにも見えるため、添字表記はスライス表記としても解釈されうる
ということです。
この場合には、(スライスリストの評価結果が、適切なスライスや省略表記
(ellipsis) にならない場合)、スライス表記としての解釈よりも添字表記
としての解釈の方が高い優先順位を持つように定義することで、構文法をより
難解にすることなくあいまいさを取り除いています。同様に、
スライスリストが厳密に一つだけの短いスライスで、末尾にカンマが
続いていない場合、拡張スライスとしての解釈より、単純なスライスとして
の解釈が優先されます。\indexii{extended}{slicing}

単純なスライスに対する意味付けは以下のようになります。
一次語の値評価結果は、シーケンス型のオブジェクトでなければなりません。
下境界および上境界を表す式がある場合、それらの値評価結果は整数で
なくてはなりません; デフォルトの値は、それぞれゼロと
\code{sys.maxint} です。どちらかの境界値が負である場合、
シーケンスの長さが加算されます。こうして、スライスは
\var{i} および \var{j} をそれぞれ指定した下境界、上境界として、
インデクス \var{k} が \code{\var{i} <= \var{k} < \var{j}} となる全ての
要素を選択します。
選択の結果、空のシーケンスになることもあります。\var{i} や \var{j} が
有効なインデクス範囲の外側にある場合でも、エラーにはなりません
(範囲外の要素は存在しないので、選択されないだけです)。

拡張スライスに対する意味付けは、以下のようになります。
一次語の値評価結果は、辞書型のオブジェクトでなければなりません。
また、辞書は以下に述べるようにしてスライスリストから生成された
キーによってインデクス指定できなければなりません。
スライスリストに少なくとも一つのカンマが含まれている場合、
キーは各スライス要素を値変換したものからなるタプルになります;
それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。
一個の式でできたスライス要素の変換は、その式になります。
省略表記スライス要素の変換は、組み込みの \code{Ellipsis} オブジェクト
になります。適切なスライスの変換は、スライスオブジェクト
(\ref{types} 参照) で、\member{start}, \member{stop} および
 \member{step} 属性は、それぞれ指定した下境界、上境界、および
とび幅 (stride) になります。式がない場合には、\code{None} に置き換え
られます。
\withsubitem{(slice object attribute)}{\ttindex{start}
  \ttindex{stop}\ttindex{step}}


\subsection{呼び出し (call)\label{calls}}
\index{call}

呼び出し (call) は、呼び出し可能オブジェクト (callable object, 例えば
関数など) を、引数列とともに呼び出します。引数列は空のシーケンスでも
かまいません:
\obindex{callable}

\begin{productionlist}
  \production{call}
             {\token{primary} "(" [\token{argument_list} [","]] ")"}
             {\token{primary} "(" [\token{argument_list} [","] |
	      \token{test} \token{genexpr_for} ] ")"}
  \production{argument_list}
             {\token{positional_arguments} ["," \token{keyword_arguments}]}
  \productioncont{                     ["," "*" \token{expression}]}
  \productioncont{                     ["," "**" \token{expression}]}
  \productioncont{| \token{keyword_arguments} ["," "*" \token{expression}]}
  \productioncont{                    ["," "**" \token{expression}]}
  \productioncont{| "*" \token{expression} ["," "**" \token{expression}]}
  \productioncont{| "**" \token{expression}}
  \production{positional_arguments}
             {\token{expression} ("," \token{expression})*}
  \production{keyword_arguments}
             {\token{keyword_item} ("," \token{keyword_item})*}
  \production{keyword_item}
             {\token{identifier} "=" \token{expression}}
\end{productionlist}

固定引数やキーワード引数の後ろにカンマをつけてもかまいません。
構文の意味付けに影響を及ぼすことはありません。

一次語の値評価結果は、呼び出し可能オブジェクトでなければなりません
 (ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、
クラスオブジェクト、クラスインスタンスのメソッド、そして特定の
クラスインスタンス自体が呼び出し可能です; 拡張によって、
その他の呼び出し可能オブジェクト型を定義することができます)。
引数式は全て、呼び出しを試みる前に値評価されます。
仮引数 (formal parameter) リストの構文については、\ref{function} 
を参照してください。

キーワード引数が存在する場合、以下のようにして最初に固定引数
(positional argument) に変換されます。まず、値の入っていない
スロットが仮引数に対して生成されます。N 個の固定引数が
ある場合、固定引数は先頭の N スロットに配置されます。
次に、各キーワード引数について、識別子を使って対応するスロット
を決定します (識別子が最初の仮引数パラメタ名と同じなら、最初の
スロットを使う、といった具合です)。スロットがすでにすべて埋まって
いたなら、\exception{TypeError} 例外が送出されます。
それ以外の場合、引数値をスロットに埋めていきます。
(式が \code{None} であっても、その式でスロットを埋めます)。
全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに
対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、
関数が定義されたときに一度だけ計算されます; 従って、リストや
辞書のような変更可能なオブジェクトがデフォルト値として使われると、
対応するスロットに引数を指定しない限り、このオブジェクトが全ての
呼び出しから共有されます; このような状況は通常避けるべきです。)
デフォルト値が指定されていない、値の埋められていないスロットが
残っている場合、\exception{TypeError} 例外が送出されます。
そうでない場合、値の埋められたスロットからなるリストが呼び出しの
引数として使われます。

仮引数スロットの数よりも多くの固定引数がある場合、構文 
\samp{*identifier} を使って指定された仮引数がないかぎり、
\exception{TypeError} 例外が送出されます; 
仮引数 \samp{*identifier} がある場合、
この仮引数は余分な固定引数が入ったタプル (もしくは、余分な
固定引数がない場合には空のタプル) を受け取ります。

キーワード引数のいずれかが仮引数名に対応しない場合、構文
\samp{**identifier} を使って指定された仮引数がない限り、
\exception{TypeError} 例外が送出されます;
仮引数 \samp{**identifier} がある場合、
この仮引数は余分なキーワード引数が入った (キーワードをキーとし、
引数値をキーに対応する値とした) 辞書を受け取ります。
余分なキーワード引数がない場合には、空の (新たな) 辞書を
受け取ります。

関数呼び出しの際に \samp{*expression} 構文が使われる場合、
\samp{expression} の値評価結果はシーケンスでなくてはなりません。
このシーケンスの要素は、追加の固定引数のように扱われます;
すなわち、固定引数 \var{x1},...,\var{xN} と、
\var{y1},...,\var{yM} になるシーケンス \samp{expression} を使った
場合、M+N 個の固定引数 \var{x1},...,\var{xN},\var{y1},...,\var{yM}
を使った呼び出しと同じになります。

上記の仕様による結果として、\samp{*expression} 構文は
たとえキーワード引数 \emph{以降に} あっても、キーワード引数
\emph{以前に} (\samp{**expression} 引数があればさらにその後に
 -- 下記参照) 処理されます。従って:

\begin{verbatim}
>>> def f(a, b):
...  print a, b
...
>>> f(b=1, *(2,))
2 1
>>> f(a=1, *(2,))
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: f() got multiple values for keyword argument 'a'
>>> f(1, *(2,))
1 2
\end{verbatim}

となります。

キーワード引数と \samp{*expression} 構文を同じ呼び出しに使うことは
あまりないので、実質的には上記のような混乱が生じることはありません。

関数呼び出しで \samp{**expression} 構文が使われた場合、
\samp{expression} の値評価結果は辞書 (またはそのサブクラス) で
なければなりません。辞書の内容は追加のキーワード引数として扱われ
ます。明示的なキーワード引数が \samp{expression} 内のキーワード
と重複した場合には、\exception{TypeError} 例外が送出されます。

\samp{*identifier} や \samp{**identifier} 構文を使った仮引数は、
固定引数スロットやキーワード引数名にすることができません。
\samp{(sublist)} 構文を使った仮引数は、キーワード引数名には
使えません; sublist は、リスト全体が一つの無名の引数スロット
に対応しており、sublist 中の引数は、他の全てのパラメタに対する
処理が終わった後に、通常のタプル形式の代入規則を使ってスロットに
入れられます。

呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。
\code{None} を返す場合もあります。戻り値がどのように算出されるかは、
呼び出し可能オブジェクトの形態によって異なります。

呼び出し可能オブジェクトが。。。

\begin{description}

\item[ユーザ定義関数のとき:] 関数のコードブロックに引数リストが
渡され、実行されます。コードブロックは、まず仮引数を実引数に
結合 (bind) します; この動作については \ref{function} で記述しています。
コードブロックで \keyword{return} 文が実行される際に、関数呼び出しの
戻り値 (return value) が決定されます。
\indexii{function}{call}
\indexiii{user-defined}{function}{call}
\obindex{user-defined function}
\obindex{function}

\item[組み込み関数や組み込みメソッドのとき:] 結果はインタプリタに
依存します; 組み込み関数や組み込みメソッドの詳細は、\citetitle[../lib/built-in-funcs.html]{Python ライブラリリファレンス} を参照してください。
\indexii{function}{call}
\indexii{built-in function}{call}
\indexii{method}{call}
\indexii{built-in method}{call}
\obindex{built-in method}
\obindex{built-in function}
\obindex{method}
\obindex{function}

\item[クラスオブジェクトのとき:] そのクラスの新しいインスタンスが
返されます。
\obindex{class}
\indexii{class object}{call}

\item[クラスインスタンスメソッドのとき:] 対応するユーザ定義の関数
が呼び出されます。このとき、呼び出し時の引数リストより一つ長い
引数リストで呼び出されます: インスタンスが引数リストの先頭に追加
されます。
\obindex{class instance}
\obindex{instance}
\indexii{class instance}{call}

\item[クラスインスタンスのとき:] クラスで \method{__call__()}
メソッドが定義されていなければなりません; \method{__call__()}
メソッドが呼び出された場合と同じ効果をもたらします。
\indexii{instance}{call}
\withsubitem{(object method)}{\ttindex{__call__()}}

\end{description}


\section{べき乗演算 (power operator)\label{power}}

べき乗演算は、左側にある単項演算子よりも強い結合優先順位
があります; 一方、右側にある単項演算子よりは低い結合優先順位に
なっています。構文は以下のようになります:

\begin{productionlist}
  \production{power}
             {\token{primary} ["**" \token{u_expr}]}
\end{productionlist}

従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われて
いない場合、演算子は右から左へと評価されます (この演算規則は、
被演算子の評価順序を縛る規則ではありません)。

べき乗演算子は、二つの引数で呼び出される組み込み関数 \function{pow()} 
と同じ意味付けを持っています。引数はまず共通の型に変換されます。
結果の型は、型強制後の引数の型になります。

引数型を混合すると、二項算術演算における型強制規則が適用されます。
整数や長整数の被演算子の場合、第二引数が負でない限り、結果は 
(型強制後の) 被演算子と同じになります; 第二引数が負の場合、
全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。
例えば、\code{10**2} は \code{100} を返しますが、\code{10**-2} 
は \code{0.01} を返します。 (上述の仕様のうち、最後のものは
Python 2.2 で追加されました。 Python 2.1 以前では、双方の引数が
整数型で、第二引数が負の場合、例外が送出されていました。)

\code{0.0} を負の数でべき乗すると、\exception{ZeroDivisionError}
を送出します。負の数を小数でべき乗すると \exception{ValueError}
になります。


\section{単項算術演算 (unary arithmetic operation)\label{unary}}
\indexiii{unary}{arithmetic}{operation}
\indexiii{unary}{bit-wise}{operation}

全ての単項算術演算 (およびビット単位演算子) は、同じ優先順位を
持っています:

\begin{productionlist}
  \production{u_expr}
             {\token{power} | "-" \token{u_expr}
              | "+" \token{u_expr} | "{\~}" \token{u_expr}}
\end{productionlist}

単項演算子 \code{-} (マイナス) は、引数となる数値の符号を反転
(invert) します。
\index{negation}
\index{minus}

単項演算子 \code{+} (プラス) は、数値引数を変更しません。
\index{plus}

単項演算子 \code{\~} (逆転) は、整数または長整数の引数を
ビット単位反転 (bit-wise invert) します。 \code{x} の
ビット単位反転は、 \code{-(x+1)} として定義されています。
この演算子は整数にのみ適用されます。
\index{inversion}

上記の三つはいずれも、引数が正しい型でない場合には \exception{TypeError}
例外が送出されます。
\exindex{TypeError}


\section{二項算術演算 (binary arithmetic operation)\label{binary}}
\indexiii{binary}{arithmetic}{operation}

二項算術演算は、慣習的な優先順位を踏襲しています。
演算子のいずれかは、特定の非数値型にも適用されるので注意して
ください。べき乗 (power) 演算子を除き、演算子には二つのレベル、
すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子
しかありません:

\begin{productionlist}
  \production{m_expr}
             {\token{u_expr} | \token{m_expr} "*" \token{u_expr}
              | \token{m_expr} "//" \token{u_expr}
              | \token{m_expr} "/" \token{u_expr}}
  \productioncont{| \token{m_expr} "\%" \token{u_expr}}
  \production{a_expr}
             {\token{m_expr} | \token{a_expr} "+" \token{m_expr}
              | \token{a_expr} "-" \token{m_expr}}
\end{productionlist}

\code{*} (乗算: multiplication) 演算は、引数間の積になります。
引数の組は、双方ともに数値型であるか、片方が整数 (通常の整数または
長整数) 型で他方がシーケンス型かのどちらかでなければなりません。
前者の場合、数値は共通の型に変換された後乗算されます。
後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負に
すると、空のシーケンスになります。
\index{multiplication}

\code{/} (除算: division) および \code{//} (切り捨て除算: floor division)
は、引数間の商になります。数値引数はまず共通の型に変換されます。
整数または長整数の除算結果は、同じ型の整数になります; この場合、
結果は数学的な除算に関数 `floor' を適用したものになります。
ゼロによる除算を行うと \exception{ZeroDivisionError} 例外を送出
します。
\exindex{ZeroDivisionError}
\index{division}

\code{\%} (モジュロ: modulo) 演算は、第一引数を第二引数で除算
したときの剰余になります。数値引数はまず共通の型に変換されます。
右引数値がゼロの場合には、\exception{ZeroDivisionError} 例外が
送出されます。引数値は浮動小数点でもよく。例えば \code{3.14\%0.7} 
は \code{0.34} になります (\code{3.14} は \code{4*0.7 + 0.34} 
だからです)。モジュロ演算子は常に第二引数と同じ符号 (またはゼロ)
の結果になります; モジュロ演算の結果の絶対値は、常に第二引数
の絶対値よりも小さくなります。\footnote{
\code{abs(x\%y) < abs(y)} は数学的には真となりますが、浮動小数点
に対する演算の場合には、値丸め (roundoff) のために数値計算的に
真にならない場合があります。例えば、Python の浮動小数点型が
IEEE754 倍精度数型になっているプラットフォームを仮定すると、
\code{-1e-100 \% 1e100} は \code{1e100} と同じ符号になるはず
なのに、計算結果は \code{-1e-100 + 1e100} となります。これは
数値計算的には厳密に \code{1e100} と等価です。\module{math}
モジュールの関数 \function{fmod()} は、最初の引数と符号が一致する
ような値を返すので、上記の場合には \code{-1e-100} を返します。
どちらのアプローチが適切かは、アプリケーションに依存します。
}
\index{modulo}

整数による除算演算やモジュロ演算は、恒等式: 
\code{x == (x/y)*y + (x\%y)} と関係しています。整数除算や
モジュロはまた、組み込み関数 \function{divmod()}:
\code{divmod(x, y) == (x/y, x\%y)} と関係しています。
これらの恒等関係は浮動小数点の場合には維持されません;
\code{x/y} が \code{floor(x/y)} や \code{floor(x/y) - 1} に
置き換えられた場合、これらの恒等式は近似性を維持します。
\footnote{
x が y の整数倍に非常に近い場合、丸め誤差によって \code{floor(x/y)} 
は \code{(x-x\%y)/y} よりも大きな値になる可能性があります。
そのような場合、 Python は\code{divmod(x,y)[0] * y + x \%{} y} 
が \code{x} に非常に近くなるという関係を保つために、後者の値を
返します。
}

数値に対するモジュロ演算の実行に加えて、\code{\%} 演算子は
文字列 (string) とユニコードオブジェクトにオーバーロードされ、
文字列の書式化 (文字列の挿入としても知られる) を行います。
文字列の書式化の構文は
\citetitle[../lib/typesseq-strings.html]{Python ライブラリリファレンス} の 
``シーケンス型'' で説明されています。

\deprecated{2.3}{切り捨て除算演算子、モジュロ演算子、および
\function{divmod()} 関数は、複素数に対してはもはや定義されて
いません。目的に合うならば、代わりに \function{abs()} を使って
浮動小数点に変換してください。}

\code{+} (加算) 演算は、引数を加算した値を返します。
引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。
前者の場合、数値は共通の型に変換され、加算されます。
後者の場合、シーケンスは結合 (concatenate) されます。
\index{addition}

\code{-} (減算) 演算は、引数間で減算を行った値を返します。
数値引数はまず共通の型に変換されます。
\index{subtraction}


\section{シフト演算 (shifting operation)\label{shifting}}
\indexii{shifting}{operation}

シフト演算は、算術演算よりも低い優先順位を持っています:

\begin{productionlist}
  % The empty groups below prevent conversion to guillemets.
  \production{shift_expr}
             {\token{a_expr}
              | \token{shift_expr} ( "<{}<" | ">{}>" ) \token{a_expr}}
\end{productionlist}

シフトの演算子は整数または長整数を引数にとります。
引数は共通の型に変換されます。シフト演算では、最初の引数を
二つ目の引数に応じたビット数だけ、左または右にビットシフト
します。

\var{n} ビットの右シフトは、\code{pow(2,\var{n})} による除算
として定義されています。 \var{n} ビットの左シフトは、
\code{pow(2,\var{n})} による乗算として定義されています; 
整数の場合、桁あふれ (overflow) のチェックはされないので、
演算によって末端のビットは捨てられます。また、結果の絶対値が
\code{pow(2, 31)} よりも小さくない場合には、符号の反転が起こります。
負のビット数でシフトを行うと、 \exception{ValueError} 例外を
送出します。
\exindex{ValueError}


\section{ビット単位演算の二項演算 (binary bit-wise operation)\label{bitwise}}
\indexiii{binary}{bit-wise}{operation}

以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:

\begin{productionlist}
  \production{and_expr}
             {\token{shift_expr} | \token{and_expr} "\&" \token{shift_expr}}
  \production{xor_expr}
             {\token{and_expr} | \token{xor_expr} "\textasciicircum" \token{and_expr}}
  \production{or_expr}
             {\token{xor_expr} | \token{or_expr} "|" \token{xor_expr}}
\end{productionlist}

\code{\&} 演算子は、引数間でビット単位の AND をとった値になります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。
\indexii{bit-wise}{and}

\code{\^} 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値に
なります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。
\indexii{bit-wise}{xor}
\indexii{exclusive}{or}

\code{|} 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値に
なります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。
\indexii{bit-wise}{or}
\indexii{inclusive}{or}


\section{比較 (comparison)\label{comparisons}}
\index{comparison}

C 言語と違って、Python における比較演算子は同じ優先順位をもっており、
全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。
また、\code{a < b < c} が数学で伝統的に用いられているのと同じ解釈に
なる点も C 言語と違います:
\indexii{C}{language}

\begin{productionlist}
  \production{comparison}
             {\token{or_expr} ( \token{comp_operator} \token{or_expr} )*}
  \production{comp_operator}
             {"<" | ">" | "==" | ">=" | "<=" | "<>" | "!="}
  \productioncont{| "is" ["not"] | ["not"] "in"}
\end{productionlist}

比較演算の結果はブール値: \code{True} または \code{False} になります。

比較はいくらでも連鎖することができます。例えば \code{x < y <= z} 
は \code{x < y and y <= z} と等価になります。ただしこの場合、前者では
\code{y} はただ一度だけ評価される点が異なります (どちらの場合でも、
\code{x < y} が偽になると \code{z} の値はまったく評価されません)。
\indexii{chaining}{comparisons}

形式的には、 \var{a}, \var{b}, \var{c}, \ldots, \var{y}, \var{z} 
が式で、\var{opa}, \var{opb}, \ldots, \var{opy} が比較演算子で
ある場合、\var{a opa b opb c} \ldots \var{y opy z} は
 \var{a opa b} \keyword{and} \var{b opb c} \keyword{and} \ldots
\var{y opy z} と等価になります。ただし、前者では各式は多くても一度
しか評価されません。

\var{a opa b opb c} と書いた場合、 \var{a} から \var{c} までの範囲
にあるかどうかのテストを指すのではないことに注意してください。
例えば、\code{x < y > z} は (きれいな書き方ではありませんが)
完全に正しい文法です。

\code{<>} と \code{!=} の二つの形式は等価です; C との整合性を
持たせるためには、\code{!=} を推奨します; 以下で \code{!=} について
触れている部分では、\code{<>} を使うこともできます。
\code{<>} のような書き方は、現在では古い書き方とみなされています。

演算子 \code{<}, \code{>}, \code{==}, \code{>=}, \code{<=}, および
\code{!=} は、二つのオブジェクト間の値を比較します。オブジェクトは
同じ型である必要はありません。双方のオブジェクトが数値であれば、
共通型への変換が行われます。それ以外の場合、異なる型のオブジェクトは
\emph{常に} 不等であるとみなされ、一貫してはいるが規定されていない
方法で並べられます。組み込み型でないオブジェクト比較の振る舞いは 
\code{__cmp__} メソッドや \code{__gt__} といったリッチな比較メソッドを
定義することでコントロールすることができます。これは ~\ref{specialnames} セクションで
説明されています。

(このような比較演算の変則的な定義は、ソートのような操作や、
\keyword{in} および\keyword{not in} といった演算子の定義を
単純化するためのものです。将来、異なる型のオブジェクト間における
比較規則は変更されるかもしれません。)

同じ型のオブジェクト間における比較は、型によって異なります:

\begin{itemize}

\item
数値間の比較では、算術的な比較が行われます。

\item
文字列間の比較では、各文字に対する等価な数値型 (組み込み関数 
\function{ord()} の結果) を使って辞書的な (lexicographically) 
比較が行われます。Unicode および 8 ビット文字列は、この動作に関しては
完全に互換です。

\item
タプルやリスト間の比較では、対応する各要素の比較結果を使って辞書的な
比較が行われます。このため、二つのシーケンスを等価にするためには、各要素が
完全に等価でなくてはならず、シーケンスは同じ型で同じ長さをもっていなければ
なりません。

二つのシーケンスが等価でない場合、異なる値を持つ最初の要素間での比較に
従った順序関係になります。例えば、\code{cmp([1,2,x], [1,2,y])} は
\code{cmp(x,y)} と等しい結果を返します。片方の要素に対応する要素が
他方にない場合、より短いシーケンスが前に並びます (例えば、
\code{[1,2] < [1,2,3]} となります)。

\item
マップ (辞書) 間の比較では、(key, value) からなるリストをソート
したものが等しい場合に等価になります。\footnote{実装では、この
演算をリストを構築したりソートしたりすることなく効率的に
行います。}
等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないか
のいずれかです。\footnote{Python の初期のバージョンでは、ソートされた
(key, value) のリストに対して辞書的な比較を行っていましたが、
これは等価性の計算のようなよくある操作を実現するには非常に
コストの高い操作でした。もっと以前のバージョンの Python では、辞書は
アイデンティティだけで比較されていました。しかしこの仕様は、
\code{\{\}} との比較によって辞書が空であるか確かめられると期待して
いた人々を混乱させていました。}

\item
その他のほとんどの組み込み型のオブジェクト比較では、同じオブジェクトでないかぎり
等価にはなりません；あるオブジェクトの他のオブジェクトに対する
大小関係は任意に決定され、一つのプログラムの実行中は一貫した
ものとなります。

\end{itemize}

演算子 \keyword{in} および \keyword{not in} は、集合内の要素であるか
どうか (メンバシップ、membership) を調べます。
\code{\var{x} in \var{s}} は、\var{x} が集合 \var{s} のメンバである
場合には真となり、それ以外の場合には偽となります。
\code{\var{x} not in \var{s}} は \code{\var{x} in \var{s}} の否定
(negation) を返します。集合メンバシップテストは、伝統的には
シーケンス型に限定されてきました; すなわち、あるオブジェクトがある集合
のメンバとなるのは、集合がシーケンス型であり、シーケンスがオブジェクトと等価な
要素を含む場合でした。しかしながら、現在ではオブジェクトがシーケンスで
なくてもメンバシップテストをサポートしています。特に、
辞書型では、\code{\var{key} in \var{dict}} と書くことで、
うまい具合にメンバシップテストをサポートしています; 他のマップ型も
これに倣っているかもしれません。

リストやタプル型については、\code{\var{x} in \var{y}} は
\code{\var{x} == \var{y}[\var{i}]} となるようなインデクス
\var{i} が存在するとき、かつそのときに限り真になります。

Unicode 文字列または文字列型については、\code{\var{x} in \var{y}} 
は \var{x} が \var{y} の部分文字列であるとき、かつそのときに限り
真になります。この演算と等価なテストは \code{y.find(x) != -1} です。
\var{x} および \var{y} は同じ型である必要はないので注意してください。
すなわち、\code{u'ab' in 'abc'} は \code{True} を返すことになります。
空文字列は、他のどんな文字列に対しても常に部分文字列とみなされます。
従って、\code{"" in "abc"} は \code{True} を返すことになります。
\versionchanged[以前は、\var{x} は長さ \code{1} の文字列型でなければ
なりませんでした]{2.3}

\method{__contains__()} メソッドの定義されたユーザ定義クラスでは、
\code{\var{x} in \var{y}} が真となるのは 
\code{\var{y}.__contains__(\var{x})} が真となるとき、かつそのときに限ります。

\method{__contains__()} は定義していないが \method{__getitem__()}
は定義しているようなユーザ定義クラスでは、 \code{\var{x} in \var{y}} 
は \code{\var{x} == \var{y}[\var{i}]} となるような非負の整数インデクス
\var{i} が存在するとき、かつそのときにかぎり真となります。
インデクス \var{i} が負である場合に \exception{IndexError} 例外が
送出されることはありません。 (別の何らかの例外が送出された場合、
例外は \keyword{in} から送出されたかのようになります)。

演算子 \keyword{not in} は、\keyword{in} の真値に対する逆転として定義されて
います。
\opindex{in}
\opindex{not in}
\indexii{membership}{test}
\obindex{sequence}

演算子 \keyword{is} および \keyword{is not} は、オブジェクトの
アイデンティティに対するテストを行います:
\code{\var{x} is \var{y}} は、 \var{x} と \var{y} が同じオブジェクト
を指すとき、かつそのときに限り真になります。
 \code{\var{x} is not \var{y}} は、\keyword{is} の真値を逆転したもの
になります。
\opindex{is}
\opindex{is not}
\indexii{identity}{test}


\section{ブール演算 (boolean operation)\label{Booleans}}
\indexii{Boolean}{operation}

ブール演算は、全ての Python 演算子の中で、最も低い優先順位になっています:

\begin{productionlist}
  \production{expression}
             {\token{or_test} [\token{if} \token{or_test} \token{else}
              \token{test}] | \token{lambda_form}}
  \production{or_test}
             {\token{and_test} | \token{or_test} "or" \token{and_test}}
  \production{and_test}
             {\token{not_test} | \token{and_test} "and" \token{not_test}}
  \production{not_test}
             {\token{comparison} | "not" \token{not_test}}
\end{productionlist}

ブール演算のコンテキストや、式が制御フロー文中で使われる最には、
以下の値: \code{False}、\code{None} 、すべての型における数値のゼロ、空の文字列と
コンテナ (文字列、タプル、リスト、辞書、set、frozenset を含む) は偽 (false) であると
解釈されます。それ以外の値は真 (true) であると解釈されます。

演算子 \keyword{not} は、引数が偽である場合には \code{1} を、それ以外の
場合には \code{0} になります。
\opindex{not}

式 \code{\var{x} if \var{C} else \var{y}} はまず \var{C} を評価 (\var{x} では\emph{ない}です)します；
もし \var{C} が true な場合、\var{x} が評価されてその値が返されます；そうでなければ、\var{y} が
評価されてその値が返されます。\versionadded{2.5}

式 \code{\var{x} and \var{y}} は、まず \var{x} を評価します;
\var{x} が偽なら、\var{x} の値を返します; それ以外の場合には、
\var{y} の値を評価し、その結果を返します。
\opindex{and}

式 \code{\var{x} or \var{y}} は、まず \var{x} を評価します; 
\var{x} が真なら、\var{x} の値を返します; それ以外の場合には、
\var{y} の値を評価し、その結果を返します。
\opindex{or}

(\keyword{and} も \keyword{not} も、返す値を \code{0} や \code{1} に
制限するのではなく、最後に評価した引数の値を返すので注意してください。
この仕様は、例えば \code{s} を文字列として、\code{s} が空文字列の
場合にデフォルトの値に置き換えるような場合に、\code{s or 'foo'} 
と書くと期待通りの値になるために便利なことがあります。
\keyword{not} は、式の値でなく独自に値を作成して返すので、
引数と同じ型の値を返すような処理に煩わされることはありません。
例えば、 \code{not 'foo'} は、 \code{''} ではなく \code{0} になります)

\section{ラムダ (lambda) \label{lambdas}}
\indexii{lambda}{expression}
\indexii{lambda}{form}
\indexii{anonymous}{function}

\begin{productionlist}
  \production{lambda_form}
             {"lambda" [\token{parameter_list}]: \token{expression}}
\end{productionlist}

ラムダ形式 (lambda form, ラムダ式 (lambda expression)) は、
構文法的には式と同じ位置付けになります。ラムダは、無名関数を作成
できる省略記法です; 式 \code{lambda \var{arguments}: \var{expression}}
は、関数オブジェクトになります。ラムダが表す無名オブジェクトは、
以下のコード

\begin{verbatim}
def name(arguments):
    return expression
\end{verbatim}

で定義された関数と同様に動作します。

引数リストの構文法については、\ref{function} 節を参照してください。
ラムダ形式で作成された関数は、実行文 (statement) を含むことができない
ので注意してください。
\label{lambda}

\section{式のリスト\label{exprlists}}
\indexii{expression}{list}

\begin{productionlist}
  \production{expression_list}
             {\token{expression} ( "," \token{expression} )* [","]}
\end{productionlist}

少なくとも一つのカンマを含む式のリストは、タプルになります。
タプルの長さは、リスト中の式の数に等しくなります。
リスト中の式は左から右へと順に評価されます。
\obindex{tuple}

単一要素のタプル (別名\emph{単集合 (singleton)}) を作りたければ、
末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合
には、タプルではなくその式の値になります (空のタプルを作りたいなら、
中身が空の丸括弧ペア: \code{()} を使います。)
\indexii{trailing}{comma}

\section{評価順序\label{evalorder}}
\indexii{evaluation}{order}

Python は、式を左から右へと順に評価してゆきます。
ただし、代入式を評価する最には、代入演算子の右側項が左側項よりも
先に評価されるので注意してください。

以下に示す実行文の各行での評価順序は、添え字の数字順序と同じ
になります:

\begin{verbatim}
expr1, expr2, expr3, expr4
(expr1, expr2, expr3, expr4)
{expr1: expr2, expr3: expr4}
expr1 + expr2 * (expr3 - expr4)
func(expr1, expr2, *expr3, **expr4)
expr3, expr4 = expr1, expr2
\end{verbatim}

\section{まとめ\label{summary}}

以下の表は、Python における演算子を、優先順位
\indexii{operator}{precedence} の最も低い (結合度が最も低い)
ものから最も高い (結合度が最も高い) ものの順に並べたものです。
同じボックス内に示された演算子は同じ優先順位を持ちます。演算子の
文法が示されていないかぎり、演算子は全て二項演算子です。
同じボックス内の演算子は、左から右へとグループ化されます
(値のテストを含む比較演算子を除きます。比較演算子は、左から右に連鎖
します --- \ref{comparisons} を参照してください。また、べき乗演算子も
除きます。べき乗演算子は右から左にグループ化されます)。

\begin{tableii}{c|l}{textrm}{演算子}{説明}
    \lineii{\keyword{lambda}}			{ラムダ式}
  \hline
    \lineii{\keyword{or}}			{ブール演算 OR}
  \hline
    \lineii{\keyword{and}}			{ブール演算 AND}
  \hline
    \lineii{\keyword{not} \var{x}}		{ブール演算 NOT}
  \hline
    \lineii{\keyword{in}, \keyword{not} \keyword{in}}{メンバシップテスト}
    \lineii{\keyword{is}, \keyword{is not}}{アイデンティティテスト}
    \lineii{\code{<}, \code{<=}, \code{>}, \code{>=},
            \code{<>}, \code{!=}, \code{==}}
	   {比較}
  \hline
    \lineii{\code{|}}				{ビット単位 OR}
  \hline
    \lineii{\code{\^}}				{ビット単位 XOR}
  \hline
    \lineii{\code{\&}}				{ビット単位 AND}
  \hline
    \lineii{\code{<<}, \code{>>}}		{シフト演算}
  \hline
    \lineii{\code{+}, \code{-}}{加算および減算}
  \hline
    \lineii{\code{*}, \code{/}, \code{\%}}
           {乗算、除算、剰余}
  \hline
    \lineii{\code{+\var{x}}, \code{-\var{x}}}	{正符号、負符号}
    \lineii{\code{\~\var{x}}}			{ビット単位 NOT}
  \hline
    \lineii{\code{**}}				{べき乗}
  \hline
    \lineii{\code{\var{x}.\var{attribute}}}	{属性参照}
    \lineii{\code{\var{x}[\var{index}]}}	{添字指定}
    \lineii{\code{\var{x}[\var{index}:\var{index}]}}	{スライス操作}
    \lineii{\code{\var{f}(\var{arguments}...)}}	{関数呼び出し}
  \hline
    \lineii{\code{(\var{expressions}\ldots)}}	{式結合またはタプル表現}
    \lineii{\code{[\var{expressions}\ldots]}}	{リスト表現}
    \lineii{\code{\{\var{key}:\var{datum}\ldots\}}}{辞書表現}
    \lineii{\code{`\var{expressions}\ldots`}}	{文字列への型変換}
\end{tableii}

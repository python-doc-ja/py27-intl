\chapter{実行モデル \label{execmodel}}
\index{execution model}


\section{名前づけと束縛 (naming and binding) \label{naming}}
\indexii{code}{block}
\index{namespace}
\index{scope}

\dfn{名前 (name)}\index{name} とは、オブジェクトを参照する
ものを指します。名前への束縛 (name binding) 操作を行うと、
名前を導入できます。プログラムテキスト中に名前が出現するたびに、
その名前が使われている最も内側の関数ブロック中で作成された
\dfn{束縛 (binding)}\indexii{binding}{name} を使って名前の
参照が行われます。

\dfn{ブロック (block)}\index{block} は、Python のプログラムテキスト
からなる断片で、一つの実行単位となるものです。
モジュール、関数本体、そしてクラス定義はブロックです。
また、対話的に入力された個々のコマンドもブロックです。
スクリプトファイル (インタプリタに標準入力として与えたり、
コマンドラインの第一引数として指定したファイル) は、コードブロック
です。スクリプトコマンド (インタプリタのコマンドライン上で
`\strong{-c}' オプションを使って指定したコマンド) もコードブロック
です。組み込み関数 \function{eval()} や \keyword{exec} 文に
渡した文字列もコードブロックになります。
組み込み関数 \function{input()} から読み取られ、評価される
式もまた、コードブロックです。

コードブロックは、\dfn{実行フレーム (execution frame)}
\indexii{execution}{frame} 上で実行されます。実行フレームには、
(デバッグに使われる) 管理情報が収められています。また、
現在のコードブロックの実行が完了した際に、どのようにプログラムの
実行を継続するかを決定しています。

\dfn{スコープ (scope)}\index{scope} は、ある名前があるブロック内で
参照できるかどうかを決めます。ローカル変数があるブロック内で定義されて
いる場合、変数のスコープはそのブロックを含みます。関数ブロック内で
名前の定義を行った場合、その名前に対して別の束縛を行っている
ブロックを除いた、関数内の全てのブロックを含むようにスコープが
拡張されます。
クラス内で定義された名前のスコープは、クラスのブロック内に制限
されます; スコープがメソッドのコードブロックを含むよう拡張される
ことはありません。

ある名前がコードブロック内で使われると、その名前を最も近傍から囲う
ようなスコープ (最内スコープ: nearest enclosing scope) を使って束縛の
解決を行います。こうしたスコープからなる、あるコードブロック内で
参照できるスコープ全ての集合は、ブロックの 
\dfn{環境 (environment)}\index{environment} と呼ばれます。

ある名前がブロック内で束縛されている場合、名前はそのブロックに
おけるローカル変数 (local variable) です。
ある名前がモジュールレベルで束縛されている場合、名前は
グローバル変数 (global variable) です。
(モジュールコードブロックの変数は、ローカル変数でもあるし、
グローバル変数でもあります。)
ある変数がコードブロック内で使われているが、そのブロックでは定義
されていない場合、変数は
\dfn{自由変数 (free variable)}\indexii{free}{variable}
です。

ある名前の定義がどこにもない場合、
\exception{NameError}\withsubitem{(built-in exception)}{\ttindex{NameError}}
例外が送出されます。名前がまだ束縛されていないローカルな変数を参照
した場合、\exception{UnboundLocalError}\ttindex{UnboundLocalError} 
例外が送出されます。\exception{UnboundLocalError} は、
\exception{NameError} のサブクラスです。

名前への束縛は、以下の文構成 (construct): 関数の仮引数 (formal parameter)
指定、\keyword{import} 文、クラスや関数の定義 (定義を行ったブロック中
で、クラスや関数名の束縛が行われます)、代入時に、代入対象が識別子
である場合、\keyword{for} ループのヘッダ、または第二形式の
\keyword{except} 文ヘッダ、で行われます。
``\samp{from\ldots import *}''\stindex{from} 形式の import 文は、
import しようとするモジュール内で定義されている名前について、
アンダースコアから始まっている名前以外の全てを束縛します。
この形式は、モジュールレベルでしか使うことができません。

\keyword{del} 文で指定された対象は、(\keyword{del} の意味付けは、
実際は名前の解放 (unbind) ですが) 文の目的上、束縛済みのもの
とみなされます。外側のスコープで参照されている名前の解放は、
不正な操作になります; コンパイラは \exception{SyntaxError} を
報告するでしょう。

代入文や import 文はいずれも、クラスや関数定義、モジュールレベル
(トップレベルのコードブロック) 内で起こります。

ある名前束縛操作がコードブロック内のどこかにある場合、ブロック
内でその名前を使うと、全て現在のブロックで束縛されている名前を
指すものとみなされます。このため、ある名前が束縛される前に
ブロック内で使われるとエラーを引き起こす可能性があります。

この規則はやや微妙です。Python には宣言文がなく、コードブロックの
どこで名前束縛操作を行ってもかまいません。
あるコードブロックにおけるローカル変数は、
ブロック全体から名前束縛操作が行われている部分を走査して決定
します。

global 文で指定された名前がブロック内にある場合、その名前は
常にトップレベルの名前空間で束縛された名前を参照します。
それらの名前はグローバル名前空間、すなわちコードブロックが収め
られているモジュールの名前空間とモジュール名 \module{__builtin__}
で表される組み込み名前空間、を検索することによって、トップレベルの
名前空間で解決されます。グローバル名前空間は、常に最初に検索
されます。名前がグローバル名前空間中に見つからない場合、組み込み
名前空間が検索されます。global 文は、その名前が使われている全て
の文に先立って記述されていなければなりません。

あるコードブロックの実行時に関連付けられる組み込み名前空間は、
実際にはコードブロックのグローバル名前空間内に入っている名前
\code{__builtins__} を参照する形になっています; \code{__builtins__} 
は辞書かモジュール (後者の場合にはモジュールの辞書が使われます)
でなければなりません。デフォルトで \code{__main__} モジュール中においては、
\code{__builtins__} は組み込みモジュール \module{__builtin__} です (注意: 's' なし)；
それ以外のモジュールでは、\code{__builtins__} は \module{__builtin__} モジュール
それ自身の辞書のエイリアスです。\code{__builtins__} はユーザが作成した辞書を
設定して、弱い形態の制限実行 \indexii{restricted}{execution}
を作成することが可能です。

\begin{notice}
ユーザは \code{__builtins__} に触れるべきではありません；これは
くれぐれも実装の詳細であるのです。組み込みの名前空間の中の値を
オーバーライドしたいユーザは、\module{__builtin__} ('s'はありません) 
モジュールを \keyword{import} して、その属性を好きに変更するべきです。
\end{notice}

あるモジュールの名前空間は、そのモジュールが最初に import された
時に自動的に作成されます。スクリプトの主モジュール (main module)は
常に \module{__main__}\refbimodindex{__main__} と呼ばれます。

グローバル文は、同じブロックの束縛操作と同じスコープを持ちます。
ある自由変数の最内スコープに global 文がある場合、その自由変数は
グローバル変数とみなされます。

クラス定義は一つの実行文で、名前の使用や定義を行います。クラス定義
への参照は、通常の名前解決規則に従います。
クラス定義の名前空間は、そのクラスの属性辞書になります。
クラスのスコープで定義された名前は、メソッドからは見えません。

\subsection{動的な機能とのやりとり \label{dynamic-features}}

自由変数の入った入れ子スコープ (nested scope) を併用すると、
Python の文が不正な文になる場合がいくつかあります。

ある変数がスコープの外側から参照された場合、その名前に対する
削除操作は不正になります。この場合、コンパイル時にエラーが
報告されることになります。

ワイルドカード形式の import 文  --- \samp{import *} --- 
を関数内で使った場合や、関数が自由変数を含んでいたり、自由変数
を伴う入れ子ブロックである場合、コンパイラは \exception{SyntaxError} を
送出します。

\keyword{exec} が関数内で使われており、関数が自由変数を含んでいたり、
自由変数を伴う入れ子ブロックである場合、\keyword{exec} に明示的に
ローカル名前空間を指定しないかぎりコンパイラは SyntaxError を
送出します。 (別の言い方をすれば、\samp{exec obj}
は不正になることがあり、\samp{exec obj in ns} はならない、という
ことです。)

\function{eval()}、 \function{execfile()}、および \function{input()}
関数、そして \keyword{exec} 文は、名前の解決を行う際に、現在の環境
に対して完全にアクセスできるわけではありません。名前が呼び出し側の
ローカル名前空間やグローバル名前空間から解決されることはあります。
自由変数は最内名前空間ではなく、グローバル名前空間から解決されます。
\footnote{この制限は、上記の操作によって実行されるコードが、モジュールをコンパイルしたときには利用できないために起こります。}

\keyword{exec} 文と、関数 \function{eval()} および
\function{execfile()} にはオプションの引数があり、グローバルおよび
ローカル名前空間をオーバライドできます。名前空間を一つしか指定
しなければ、両方の名前空間として使われます。

\section{例外 \label{exceptions}}
\index{exception}

例外とは、コードブロックの通常の制御フローを中断して、
エラーやその他の例外的な状況を処理できるようにするための
手段です。
例外はエラーが検出された時点で
\emph{送出 (raise)}\index{raise an exception} されます;
例外は、エラーが発生部の周辺のコードブロックか、エラーが発生した
コードブロック直接または間接的に呼び出しているコードブロック
で \emph{処理 (handle)}\index{handle an exception} することが
できます。
\index{exception handler}
\index{errors}
\index{error handling}

Python インタプリタは、ランタイムエラー (ゼロによる除算など) が
検出されると例外を送出します。Python プログラムから、\keyword{raise}
文を使って明示的に例外を送出することもできます。
例外ハンドラ (exception handler) は、 \keyword{try} ... \keyword{except}
文で指定することができます。\keyword{try} ... \keyword{finally} 
節を使うとクリーンアップコード (cleanup code) を指定できます。
このコードは例外は処理しませんが、先行するコードブロックで例外が
起きても起きなくても実行されます。

Python は、エラー処理に ``プログラムの終了 (termination)''
\index{termination model} モデルを用いています: 例外ハンドラは、
プログラムに何が発生したかを把握することができ、ハンドラの外側の
レベルに処理を継続することはできますが、(問題のあったコード部分を
最初から実行しなおすのでない限り) エラーの原因を修復したり、
実行に失敗した操作をやり直すことはできません。

例外が全く処理されない場合、インタプリタはプログラムの実行を終了させる
か、対話メインループに処理を戻します。どちらの場合も、
例外が \exception{SystemExit}\withsubitem{(built-in exception)}{\ttindex{SystemExit}}
でない限りバックトレース (backtrace) を出力します。

例外は、クラスインスタンスによって識別されます。
\keyword{except} 節はインスタンスのクラスにもとづいて選択されます：
これはインスタンスのクラスか、そのベースクラスを参照します。この
インスタンスはハンドラによって受け取られ、例外条件に関する追加情報を
伝えることができます。

例外は文字列 (strings) によっても識別することができ、このような場合には
\keyword{except} 節はオブジェクトの同一性によって選択されます。
任意の値をハンドラに渡される識別文字列に伴って送出することができます。

\deprecated{2.5}{文字列の例外は新規のコードでは使うべきではありません。
これは Python の将来のバージョンではサポートされないでしょう。
古いコードは代わりにクラスによる例外を使うように書き直すべきです。}

\begin{notice}[warning]
例外に対するメッセージは、Python API 仕様には含まれていません。
メッセージの内容は、ある Python のバージョンから次のバージョンに
なるときに、警告なしに変更される可能性があります。したがって、
複数バージョンのインタプリタで動作するようなコードにおいては、
例外メッセージの内容に依存した記述をすべきではありません。
\end{notice}

\keyword{try} 文については、~\ref{try} 節、
\keyword{raise} 文については ~\ref{raise} 節も参照してください。

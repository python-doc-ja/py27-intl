\documentclass{manualjp}

% Things to do:
% Add a section on file I/O
% Write a chapter entitled ``Some Useful Modules''
%  --re, math+cmath
% Should really move the Python startup file info to an appendix

\title{Python チュートリアル}

\input{boilerplatejp}

\makeindex

\begin{document}

\maketitle

\ifhtml
\chapter*{序\label{front}}
\fi

\input{copyrightjp}

\begin{abstract}

\noindent
%% Python is an easy to learn, powerful programming language.  It has
%% efficient high-level data structures and a simple but effective
%% approach to object-oriented programming.  Python's elegant syntax and
%% dynamic typing, together with its interpreted nature, make it an ideal 
%% language for scripting and rapid application development in many areas 
%% on most platforms.

Python は簡単に習得でき、それでいて強力な言語の一つです。Python は高レ
ベルなデータ構造を効率的に実装していて、オブジェクト指向プログラミング
に対しても、単純ながら効果的なアプローチをとっています。洗練された文法
とデータ型を動的に決定する機能、そしてインタプリタであるという特徴から、
Python はほとんどのプラットフォームの幅広い対象領域において、スクリプ
ティングや迅速なアプリケーション開発のための理想的な言語になっています。

%% The Python interpreter and the extensive standard library are freely
%% available in source or binary form for all major platforms from the
%% Python Web site, \url{http://www.python.org/}, and can be freely
%% distributed.  The same site also contains distributions of and
%% pointers to many free third party Python modules, programs and tools,
%% and additional documentation.

Pythonインタプリタ自体と膨大な標準ライブラリは、ソースコード形式や、
主要なプラットフォーム向けのバイナリ形式で、Python Web サイト 
\url{http://www.python.org/} から無料で入手でき、かつ無料で再配布
できます。また、Python Webサイトでは、無料で手に入るたくさんのサードパー
ティ製 Python モジュールから、プログラム、ツール類、その他のドキュメント
に至るまで、配布物やポインタの情報を公開しています。

%% The Python interpreter is easily extended with new functions and data
%% types implemented in C or \Cpp{} (or other languages callable from C).
%% Python is also suitable as an extension language for customizable
%% applications.

Python インタプリタは、 C 言語や \Cpp{} 言語 (あるいはその他の C 言語
から呼び出せる言語) で実装された新たな関数やデータ構造を組み込んで簡単
に拡張できます。 Python はまた、 カスタマイズ可能なアプリケーションを
作るための拡張機能記述言語としても適しています。

%% This tutorial introduces the reader informally to the basic concepts
%% and features of the Python language and system.  It helps to have a
%% Python interpreter handy for hands-on experience, but all examples are
%% self-contained, so the tutorial can be read off-line as well.

このチュートリアルでは、Python の言語仕様と仕組みについて、基本的な概
念と機能をざっと紹介します。 Python インタプリタが手元にあれば、自分で
試しながら学ぶ助けになりますが、例題は全て明解なので、チュートリアルは
オフラインでも十分読めます。

%% For a description of standard objects and modules, see the
%% \citetitle[../lib/lib.html]{Python Library Reference} document.  The
%% \citetitle[../ref/ref.html]{Python Reference Manual} gives a more
%% formal definition of the language.  To write extensions in C or
%% \Cpp, read \citetitle[../ext/ext.html]{Extending and Embedding the
%% Python Interpreter} and \citetitle[../api/api.html]{Python/C API
%% Reference}.  There are also several books covering Python in depth.

標準のオブジェクトやモジュールの記述については、「Python ライブラリリ
ファレンス (\citetitle[../lib/lib.html]{Python Library Reference})」
を参照してください。C 言語や \Cpp{} 言語で拡張モジュールを書くなら、
「Python インタプリタの拡張と埋め込み
(\citetitle[../ext/ext.html]{Extending and Embedding the Python
  Interpreter})」や「Python/C API リファレンス
(\citetitle[../api/api.html]{Python/C API Reference})」を参照してくだ
さい。他にも、 Python について広く深くカバーしている書籍はいくつかあり
ます。

%% This tutorial does not attempt to be comprehensive and cover every
%% single feature, or even every commonly used feature.  Instead, it
%% introduces many of Python's most noteworthy features, and will give
%% you a good idea of the language's flavor and style.  After reading it,
%% you will be able to read and write Python modules and programs, and
%% you will be ready to learn more about the various Python library
%% modules described in the \citetitle[../lib/lib.html]{Python Library
%% Reference}.

このチュートリアルは網羅的な内容を目指しているわけではありませんし、
Pythonの個別の機能や、よく使われる機能でさえ完全にカバーしてはいません。
その代わり、このチュートリアルではPythonの特筆すべき機能をたくさん紹介
して、この言語の持ち味やスタイルについて好印象を持ってもらうつもりです。
このチュートリアルを読んだ後には、読者のみなさんは Python のモジュール
やプログラムを読み書きできるようになり、「Python ライブラリリファレン
ス (\citetitle[../lib/lib.html]{Python  Library Reference})」に記述さ
れているさまざまな Python ライブラリモジュールについて学べるようになる
でしょう。
	
\end{abstract}

\tableofcontents

\chapter{やる気を高めよう \label{intro}} %% Whetting Your Appetite

%% If you do much work on computers, eventually you find that there's
%% some task you'd like to automate.  For example, you may wish to
%% perform a search-and-replace over a large number of text files, or
%% rename and rearrange a bunch of photo files in a complicated way.
%% Perhaps you'd like to write a small custom database, or a specialized
%% GUI application, or a simple game.

コンピュータ上で様々な仕事をしているなら、自動化したい仕事があることに
気がつくでしょう。たとえば、たくさんのテキストファイルで検索-置換操作を
行いたい、大量の写真ファイルを込み入ったやりかたでリネームまたは整理し
たいといったものです。
ひょっとすると、小さなカスタムデータベースや、何かに特化したGUIアプリケー
ション、シンプルなゲームを作りたいかもしれません。

%% If you're a professional software developer, you may have to work with
%% several C/\Cpp/Java libraries but find the usual
%% write/compile/test/re-compile cycle is too slow.  Perhaps you're
%% writing a test suite for such a library and find writing the testing
%% code a tedious task.  Or maybe you've written a program that could use
%% an extension language, and you don't want to design and implement a
%% whole new language for your application.


もしあなたがプロのソフト開発者なら、C/\Cpp/Java　ライブラリを扱う必要
があるが、通常の write/compile/test/re-compile サイクルが遅すぎると感
じるかもしれません。
ひょっとするとそのようなライブラリのテストスイートを書いていて、
テスト用のコードを書くのにうんざりしているかもしれません。
拡張言語を使えるプログラムを書いていて、アプリケーションのために新しい
言語一式の設計と実装をしたくないと思っているかもしれません。


%% Python is just the language for you.

Pythonはそんなあなたのための言語です。


%% You could write a {\UNIX} shell script or Windows batch files for some
%% +of these tasks, but shell scripts are best at moving around files and
%% +changing text data, not well-suited for GUI applications or games.
%% +You could write a C/{\Cpp}/Java program, but it can take a lot of
%% +development time to get even a first-draft program.  Python is simpler
%% +to use, available on Windows, MacOS X, and {\UNIX} operating systems,
%% +and will help you get the job done more quickly.

それらの作業を \UNIX{} シェルスクリプトや Windows バッチファイルを書く
こともできますが、シェルスクリプトはファイル操作やテキストデータの操作
には向いていますがGUIアプリケーションやゲームにはむいていません。
C/{\Cpp}/Java プログラムを書くこともできますが、最初の試し書きにすらか
なりの時間がかかってしまいます。Pythonは簡単に利用でき、Windows、
MacOS X、そして {\UNIX} オペレーティングシステムで動作し、あなたの
仕事を素早く行う助けになるでしょう。

%% Python is simple to use, but it is a real programming language,
%% offering much more structure and support for large programs than shell
%% scripts or batch files can offer.  On the other hand, Python also
%% offers much more error checking than C, and, being a
%% \emph{very-high-level language}, it has high-level data types built
%% in, such as flexible arrays and dictionaries.  Because of its more
%% general data types Python is applicable to a much larger problem
%% domain than Awk or even Perl, yet many things are at
%% least as easy in Python as in those languages.


Pyhonは簡単に利用できますが、本物のプログラミング言語であり、
シェルスクリプトやバッチファイルで提供されるよりも
たくさんの大規模プログラムむけの構造や支援を提供しています。
一方、PythonはCよりたくさんのエラーチェックを提供しており、
\emph{超高級言語(very-high-level language)}であり、可変長配列や辞書な
どのハイレベルな型を組込みでもっています。
そのような型は一般的なため、PythonはAwkやPerlが扱うものより
(多くの場合、少なくともそれらの言語と同じくらい簡単に)大規模な
問題に利用できます。

%% Python allows you to split your program in modules that can be
%% reused in other Python programs.  It comes with a large collection of
%% standard modules that you can use as the basis of your programs --- or
%% as examples to start learning to program in Python.  Some of these
%% modules provide things like file I/O, system calls,
%% sockets, and even interfaces to graphical user interface toolkits like Tk.  

Python ではプログラムをモジュールに分割して他の Python プログラムで再
利用できます。Python には膨大な標準モジュールが付属していて、プログラ
ムを作る上での基盤として、あるいは Python プログラミングを学ぶために利
用できます。組み込みモジュールではまた、ファイル I/O 、システムコール、
ソケットといった機能や、Tk のようなグラフィカルユーザインタフェースツー
ルキットを使うためのインタフェースなども提供しています。

%% Python is an interpreted language, which can save you considerable time
%% during program development because no compilation and linking is
%% necessary.  The interpreter can be used interactively, which makes it
%% easy to experiment with features of the language, to write throw-away
%% programs, or to test functions during bottom-up program development.
%% It is also a handy desk calculator.

Python はインタプリタ言語です。このため、コンパイルやリンクが必要ない
ので、プログラムを開発する際にかなりの時間を節約できます。インタプリタ
は対話的な使い方もできます。インタプリタは対話的にも使えるので、言語の
様々な機能について実験してみたり、やっつけ仕事のプログラムを書いたり、
ボトムアップでプログラムを開発する際に関数をテストしたりといったことが
簡単にできます。便利な電卓にもなります。

%% Python allows writing very compact and readable programs.  Programs
%% written in Python are typically much shorter than equivalent C or
%% \Cpp{} programs, for several reasons:
%% \begin{itemize}
%% \item
%% the high-level data types allow you to express complex operations in a
%% single statement;
%% \item
%% statement grouping is done by indentation instead of beginning and ending
%% brackets;
%% \item
%% no variable or argument declarations are necessary.
%% \end{itemize}

Python では、とてもコンパクトで読みやすいプログラムを書けます。Python
で書かれたプログラムは大抵、同じ機能を提供する C 言語, \Cpp{} 言語や Javaの
プログラムよりもはるかに短くなります。これには以下のようないくつかの理
由があります:

\begin{itemize}
\item
高レベルのデータ型によって、複雑な操作を一つの実行文で表現できます。
\item
実行文のグループ化を、グループの開始や終了の括弧ではなくインデントで行えます。
\item
変数や引数の宣言が不要です。
\end{itemize}

%% Python is \emph{extensible}: if you know how to program in C it is easy
%% to add a new built-in function or module to the interpreter, either to
%% perform critical operations at maximum speed, or to link Python
%% programs to libraries that may only be available in binary form (such
%% as a vendor-specific graphics library).  Once you are really hooked,
%% you can link the Python interpreter into an application written in C
%% and use it as an extension or command language for that application.

Python は \emph{拡張} できます: C 言語でプログラムを書く方法を知ってい
るなら、新たな組み込み関数やモジュールを簡単にインタプリタに追加できま
す。これによって、処理速度を決定的に左右する操作を最大速度で動作するよ
うに実現したり、(ベンダ特有のグラフィクスライブラリのように) バイナリ
形式でしか手に入らないライブラリを Python にリンクしたりできます。その
気になれば、Python インタプリタを C で書かれたアプリケーションにリンク
して、アプリケーションに対する拡張言語や命令言語としても使えます。

%% By the way, the language is named after the BBC show ``Monty Python's
%% Flying Circus'' and has nothing to do with nasty reptiles.  Making
%% references to Monty Python skits in documentation is not only allowed,
%% it is encouraged!

ところで、この言語は BBC のショー番組、``モンティパイソンの空飛ぶサー
カス (Monty Python's Flying Circus)'' から取ったもので、気味の悪い爬虫
類とは関係ありません。このドキュメントにあるモンティパイソンの寸劇は、
参照してもかまわないというより、むしろ積極的に見るようおすすめします！

\section{ここからどこへ \label{where}} % Where From Here

%% Now that you are all excited about Python, you'll want to examine it
%% in some more detail.  Since the best way to learn a language is
%% to use it, the tutorial invites you to play with the Python interpreter
%% as you read.


さて、皆さんはもう Python にワクワクして、もうちょっと詳しく調べてみた
くなったはずです。プログラミング言語を習得する最良の方法は使ってみるこ
とですから、このチュートリアルではみなさんが読んだ内容を Python 
インタプリタで試してみることをおすすめします。


%% In the next chapter, the mechanics of using the interpreter are
%% explained.  This is rather mundane information, but essential for
%% trying out the examples shown later.

次の章では、まずインタプリタを使うための機微を説明します。これはさして
面白みのない情報なのですが、後に説明する例題を試してみる上で不可欠なこ
とです。

%% The rest of the tutorial introduces various features of the Python
%% language and system through examples, beginning with simple
%% expressions, statements and data types, through functions and modules,
%% and finally touching upon advanced concepts like exceptions
%% and user-defined classes.

チュートリアルの残りの部分では、Python プログラム言語と実行システムの
様々な機能を例題を交えて紹介します。単純な式、実行文、データ型から始め
て、関数とモジュールを経て、最後には例外処理やユーザ定義クラスといった
やや高度な概念にも触れます。

\chapter{Python インタプリタを使う \label{using}} % Using the Python Interpreter

\section{インタプリタを起動する \label{invoking}} % Invoking the Interpreter

%% The Python interpreter is usually installed as
%% \file{/usr/local/bin/python} on those machines where it is available;
%% putting \file{/usr/local/bin} in your \UNIX{} shell's search path
%% makes it possible to start it by typing the command

Python が使える計算機なら、インタプリタはたいてい
\file{/usr/local/bin/python} にインストールされています。\UNIX{} シェ
ルのサーチパスに \file{/usr/local/bin} を入れれば、シェルで

Windows マシンの場合には、Pythonは大抵の場合 \file{C:\e Python24}
にインストールされますが、インストーラ実行時に変更すること
ができます。
このディレクトリをあなたのパスに追加するには、
以下のコマンドをコマンドプロンプトで実行してください:

\begin{verbatim}
set path=%path%;C:\python24
\end{verbatim}



\begin{verbatim}
python
\end{verbatim}

%% to the shell.  Since the choice of the directory where the interpreter
%% lives is an installation option, other places are possible; check with
%% your local Python guru or system administrator.  (E.g.,
%% \file{/usr/local/python} is a popular alternative location.)

とコマンドを入力すれば使えるようになります。インストールする際にどのディ
レクトリに Python インタプリタを入れるかをオプションで指定できるので、
インタプリタは他のディレクトリにあるかもしれません; 身近な Python の導
師 (guru) か、システム管理者に聞いてみてください。(例えば、その他の場
所としては \file{/usr/local/python} が一般的です。)

%% Typing an end-of-file character (\kbd{Control-D} on \UNIX,
%% \kbd{Control-Z} on DOS or Windows) at the primary prompt causes the
%% interpreter to exit with a zero exit status.  If that doesn't work,
%% you can exit the interpreter by typing the following commands:
%% \samp{import sys; sys.exit()}.

ファイル終端文字 (\UNIX では \kbd{Control-D}、DOS や Windows では
\kbd{Control-Z}) を一次プロンプト (primary prompt) に入力すると、イン
タプリタが終了状態ゼロで終了します。もしこの操作がうまく働かないなら、
コマンド: \samp{import sys; sys.exit()} と入力すればインタプリタを終了
できます。

%% The interpreter's line-editing features usually aren't very
%% sophisticated.  On \UNIX, whoever installed the interpreter may have
%% enabled support for the GNU readline library, which adds more
%% elaborate interactive editing and history features. Perhaps the
%% quickest check to see whether command line editing is supported is
%% typing Control-P to the first Python prompt you get.  If it beeps, you
%% have command line editing; see Appendix \ref{interacting} for an
%% introduction to the keys.  If nothing appears to happen, or if
%% \code{\^P} is echoed, command line editing isn't available; you'll
%% only be able to use backspace to remove characters from the current
%% line.

通常、インタプリタの行編集機能は、あまり洗練されたものではありません。
\UNIX システムでは、インタプリタをインストールした誰かが GNU readline
ライブラリのサポートを有効にしていれば、洗練された対話的行編集やヒスト
リ機能が追加されます。
コマンドライン編集機能がサポートされているかを最も手っ取り早く調べる方
法は、おそらく最初に表示された Python プロンプトに Control-P を入力し
てみることでしょう。ビープ音が鳴るなら、コマンドライン編集機能がありま
す。編集キーについての解説は付録 \ref{interacting} を参照してください。
何も起こらないように見えるか、\code{\^P} がエコーバックされるなら、コ
マンドライン編集機能は利用できません。この場合、現在編集中の行から文字
を削除するにはバックスペースを使うしかありません。

%% The interpreter operates somewhat like the \UNIX{} shell: when called
%% with standard input connected to a tty device, it reads and executes
%% commands interactively; when called with a file name argument or with
%% a file as standard input, it reads and executes a \emph{script} from
%% that file. 

インタプリタはさながら \UNIX{} シェルのように働きます。標準入力が端末
に接続された状態で呼び出されると、コマンドを対話的に読み込んで実行しま
す。ファイル名を引数にしたり、標準入力からファイルを入力すると、インタ
プリタはファイルから \emph{スクリプト} を読み込んで実行します。

%% A second way of starting the interpreter is
%% \samp{\program{python} \programopt{-c} \var{command} [arg] ...}, which
%% executes the statement(s) in \var{command}, analogous to the shell's
%% \programopt{-c} option.  Since Python statements often contain spaces
%% or other characters that are special to the shell, it is best to quote 
%% \var{command} in its entirety with double quotes.

インタプリタを起動する第二の方法は
\samp{\program{python} \programopt{-c} \var{command} [arg] ...}
です。この形式では、シェルの \programopt{-c} オプションと同じように、
\var{command} に指定した文を実行します。Python 文には、スペースなどの
シェルにとって特殊な意味をもつ文字がしばしば含まれるので、
\var{command} 全体を二重引用符を囲っておくのがベストです。

% +Some Python modules are also useful as scripts.  These can be invoked using
% +\samp{\program{python} \programopt{-m} \var{module} [arg] ...}, which
% +executes the source file for \var{module} as if you had spelled out its
% +full name on the command line.

Python のモジュールには、スクリプトとしても便利に使えるものがあります。
\samp{\program{python} \programopt{-m} \var{module} [arg] ...}
のようにすると、 \var{module} のソースファイルを、フルパスを指定して
起動したかのように実行できます。

%% Note that there is a difference between \samp{python file} and
%% \samp{python <file}.  In the latter case, input requests from the
%% program, such as calls to \code{input()} and \code{raw_input()}, are
%% satisfied from \emph{file}.  Since this file has already been read
%% until the end by the parser before the program starts executing, the
%% program will encounter end-of-file immediately.  In the former case
%% (which is usually what you want) they are satisfied from whatever file
%% or device is connected to standard input of the Python interpreter.

\samp{python file} と \samp{python <file} の違いに注意してください。後
者の場合、プログラム内で\function{input()} や \function{raw_input()}
が呼び出され、ユーザからの入力が必要な場合、入力は\emph{ファイル} から
取り込まれます。この場合、パーザはプログラムの実行を開始される前にファ
イルを終端まで読み込んでおくので、プログラムはすぐに入力の終わりまで到
達してしまいます。前者の場合 (大抵はこちらの方が望ましい動作です)、入
力には Python インタプリタの標準入力に接続された何らかのファイルまたは
デバイスが充てられます。

%% When a script file is used, it is sometimes useful to be able to run
%% the script and enter interactive mode afterwards.  This can be done by
%% passing \programopt{-i} before the script.  (This does not work if the
%% script is read from standard input, for the same reason as explained
%% in the previous paragraph.)

スクリプトファイルが使われた場合、スクリプトを走らせて、そのまま対話
モードに入れると便利なことがあります。これには \programopt{-i} をスク
リプトの前に追加します。(前の段落で述べたのと同じ理由から、スクリプト
を標準入力から読み込んだ場合には、このオプションはうまく働きません。)

\subsection{引数の受け渡し \label{argPassing}} % Argument Passing

%% When known to the interpreter, the script name and additional
%% arguments thereafter are passed to the script in the variable
%% \code{sys.argv}, which is a list of strings.  Its length is at least
%% one; when no script and no arguments are given, \code{sys.argv[0]} is
%% an empty string.  When the script name is given as \code{'-'} (meaning 
%% standard input), \code{sys.argv[0]} is set to \code{'-'}.  When
%% \programopt{-c} \var{command} is used, \code{sys.argv[0]} is set to
% \code{'-c'}.  When \programopt{-m} \var{module} is used, \code{sys.argv[0]} 
% is set to the full name of the located module.  Options found after 
% \programopt{-c} \var{command} or \programopt{-m} \var{module} are
% not consumed 
% by the Python interpreter's option processing but left in \code{sys.argv} for 
% the command or module to handle.

スクリプト名と引数を指定してインタプリタを起動した場合、スクリプト名や
スクリプト名以後に指定した引数は、スクリプトからは \code{sys.argv} で
アクセスできるようになります。 \code{sys.argv} はこれは文字列からなる
リストで、少なくとも一つ要素が入っています。スクリプト名も引数も指定し
なければ\code{sys.argv[0]} は空の文字列になります。スクリプト名の代わ
りに \code{'-'} (標準入力を意味します) を指定すると、
\code{sys.argv[0]} は \code{'-'} になります。\programopt{-c} 
\var{command} を使うと、\code{sys.argv[0]} は \code{'-c'} になります。
\programopt{-m} \var{module} を使った場合、 \code{sys.argv[0]} は
モジュールのフルパスになります。\programopt{-c} \var{command} や
\programopt{-m} \var{module} の後ろにオプションを指定した場合、Python
インタプリタ自体はこれらの引数を処理せず、\code{sys.argv}を介して
\var{command}や\var{module}から扱えるようになります。

\subsection{対話モード \label{interactive}} % Interactive Mode

%% When commands are read from a tty, the interpreter is said to be in
%% \emph{interactive mode}.  In this mode it prompts for the next command
%% with the \emph{primary prompt}, usually three greater-than signs
%% (\samp{>\code{>}>~}); for continuation lines it prompts with the
%% \emph{secondary prompt}, by default three dots (\samp{...~}).
%% The interpreter prints a welcome message stating its version number
%% and a copyright notice before printing the first prompt:

インタプリタが命令を端末 (tty) やコマンドプロンプトから読み取っている
場合、インタプリタは\emph{対話モード (interactive mode)} で動作してい
るといいます。このモードでは、インタプリタは \emph{一次プロンプト
  (primary prompt)} を表示して、ユーザにコマンドを入力するようします。
一次プロンプトは普通、三つの「大なり記号」 (\samp{>>>~}) です。
一つの入力が次の行まで続く (行継続: continuation line を行う) 場合、イ
ンタプリタは\emph{二次プロンプト (secondary prompt)} を表示します。二
次プロンプトは、デフォルトでは三つのドット (\samp{...~}) です。インタ
プリタは、最初のプロンプトを出す前にバージョン番号と著作権表示から始ま
る起動メッセージを出力します。

\begin{verbatim}
python
Python 1.5.2b2 (#1, Feb 28 1999, 00:02:06)  [GCC 2.8.1] on sunos5
Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
>>>
\end{verbatim}

%% Continuation lines are needed when entering a multi-line construct.
%% As an example, take a look at this \keyword{if} statement:

行継続は、例えば以下の \keyword{if} 文のように、複数の行からなる構文を
入力するときに必要です:

\begin{verbatim}
>>> the_world_is_flat = 1
>>> if the_world_is_flat:
...     print "Be careful not to fall off!"
... 
Be careful not to fall off!
\end{verbatim}


%%% XXX ProofReeding Done To Here XXX %%%

\section{インタプリタとその環境 \label{interp}} % The Interpreter and Its Environment

\subsection{エラー処理 \label{error}} % Error Handling

%% When an error occurs, the interpreter prints an error
%% message and a stack trace.  In interactive mode, it then returns to
%% the primary prompt; when input came from a file, it exits with a
%% nonzero exit status after printing
%% the stack trace.  (Exceptions handled by an \code{except} clause in a
%% \code{try} statement are not errors in this context.)  Some errors are
%% unconditionally fatal and cause an exit with a nonzero exit; this
%% applies to internal inconsistencies and some cases of running out of
%% memory.  All error messages are written to the standard error stream;
%% normal output from the executed commands is written to standard
%% output.

エラーが発生すると、インタプリタはエラーメッセージとスタックトレース
(stack trace) を出力します。対話モードにいるときは、インタプリタは
一次プロンプトに戻ります; 入力がファイルからきているときには、
インタプリタはスタックトレースを出力した後、非ゼロの終了状態で終了します。
(\code{try} 文の \keyword{except} 節で処理された例外は、ここでいうエラー
にはあたりません。)
いくつかのエラーは無条件に致命的であり、非ゼロの終了状態となるプログラム
の終了を引き起こします; これにはインタプリタ内部の矛盾や
ある種のメモリ枯渇が当てはまります。
エラーメッセージは全て標準エラー出力ストリームに書き込まれます;
これに対して、実行した命令からの通常出力される内容は標準出力に
書き込まれます。

%% Typing the interrupt character (usually Control-C or DEL) to the
%% primary or secondary prompt cancels the input and returns to the
%% primary prompt.\footnote{
%%         A problem with the GNU Readline package may prevent this.
%% }
%% Typing an interrupt while a command is executing raises the
%% \code{KeyboardInterrupt} exception, which may be handled by a
%% \code{try} statement.

割り込み文字 (interrupt character、普通は Control-C か DEL) を
一次または二次プロンプトに対して打鍵すると、入力が取り消されて
一次プロンプトに戻ります。 \footnote{
GNU Readline パッケージに関する問題のせいで妨げられることがあります。
}
コマンドの実行中に割り込み文字を打鍵すると \exception{KeyboardInterrupt} 
例外が送出されます。この例外は \code{try} 文で処理できます。

\subsection{実行可能な Python スクリプト \label{scripts}} % Executable Python Scripts

%% On BSD'ish \UNIX{} systems, Python scripts can be made directly
%% executable, like shell scripts, by putting the line

BSD 風の \UNIX{} システムでは、Python スクリプトはシェルスクリプトの
ようにして直接実行可能にできます。これを行うには、以下の行

\begin{verbatim}
#! /usr/bin/env python
\end{verbatim}

%% (assuming that the interpreter is on the user's \envvar{PATH}) at the
%% beginning of the script and giving the file an executable mode.  The
%% \samp{\#!} must be the first two characters of the file.  On some
%% platforms, this first line must end with a \UNIX-style line ending
%% (\character{\e n}), not a Mac OS (\character{\e r}) or Windows
%% (\character{\e r\e n}) line ending.  Note that
%% the hash, or pound, character, \character{\#}, is used to start a
%% comment in Python.
 
(ここではインタプリタがユーザの \envvar{PATH} 上にあると仮定しています)
をスクリプトの先頭に置き、スクリプトファイルに実行可能モードを
与えます。
\samp{\#!} はファイルの最初の２文字でなければなりません。
プラットフォームによっては、この最初の行を終端する改行文字が
Mac OS 形式 (\character{\e r}) や Windows 形式 (\character{\e r\e n}) で
はなく、 \UNIX 形式(\character{\e n})でなければならないことがあります。
ハッシュまたはポンド文字、すなわち \character{\#} は、Python 
ではコメントを書き始めるために使われているので注意してください。

%% The script can be given a executable mode, or permission, using the
%% \program{chmod} command:
 
%% begin{verbatim}
%% $ chmod +x myscript.py
%% end{verbatim} % $ <-- bow to font-lock
 
\program{chmod} コマンドを使えば、スクリプトに実行モード (または実行権限)
を与えることができます:

\begin{verbatim}
$ chmod +x myscript.py
\end{verbatim} % $ <-- bow to font-lock

\subsection{ソースコードの文字コード方式 (encoding)}
 
%% It is possible to use encodings different than \ASCII{} in Python source
%% files. The best way to do it is to put one more special comment line
%% right after the \code{\#!} line to define the source file encoding:

\ASCII{} 形式でない文字コード化方式 (エンコーディング: encoding) を Python 
ソースコードファイル中で使うことができます。最良の方法は、 \code{\#!} 行の
直後に一行かそれ以上の特殊なコメントを挿入して、ソースファイルのエンコード
を指定するというものです:
 
\begin{alltt}
# -*- coding: \var{encoding} -*- 
\end{alltt}
 
%% With that declaration, all characters in the source file will be treated as
%% {}\code{iso-8859-1}, and it will be
%% possible to directly write Unicode string literals in the selected
%% encoding.  The list of possible encodings can be found in the
%% \citetitle[../lib/lib.html]{Python Library Reference}, in the section
%% on \ulink{\module{codecs}}{../lib/module-codecs.html}.

このように宣言しておくと、ソースファイル中の全ての文字は \var{encoding}
という文字コードでエンコードされているものとして扱われ、Unicode 文字列
リテラルを指定したエンコードで直接記述できます。利用可能なエンコードのリストは
\citetitle[../lib/lib.html]{Python ライブラリリファレンス} の 
\ulink{\module{codecs}}{../lib/module-codecs.html}
の節にあります。

% For example, to write Unicode literals including the Euro currency
% symbol, the ISO-8859-15 encoding can be used, with the Euro symbol
% having the ordinal value 164.  This script will print the value 8364
% (the Unicode codepoint corresponding to the Euro symbol) and then
% exit:

例えばユーロ通過記号を含む Unicode リテラルを書くには、
ISO-8859-15 エンコーディングを使えます。 ISO-8859-15 では、ユーロ
通過記号の序数 (ordinal) は 164 です。以下のスクリプトは 8364
という値 (Unicode で ユーロ記号に対応するコードポイントの値) を
出力して終了します:

\begin{alltt}
# -*- coding: iso-8859-15 -*-

currency = u"\texteuro"
print ord(currency)
\end{alltt}

%% If your editor supports saving files as \code{UTF-8} with a UTF-8
%% \emph{byte order mark} (aka BOM), you can use that instead of an
%% encoding declaration. IDLE supports this capability if
%% \code{Options/General/Default Source Encoding/UTF-8} is set. Notice
%% that this signature is not understood in older Python releases (2.2
%% and earlier), and also not understood by the operating system for
% +script files with \code{\#!} lines (only used on \UNIX{} systems).

利用しているエディタがファイルを UTF-8 バイト整列記号 (通称 BOM: Byte
Order Mark)
付きの \code{UTF-8} で保存できる場合、エンコード
宣言の代わりに使うことができます。 IDLE は 
\code{Options/General/Default Source Encoding/UTF-8} が設定されている場合、
UTF-8 でエンコードされたファイルの識別機能をサポートします。ただし、
(2.2 以前の) 古い Python リリースは UTF-8 シグネチャを理解しませんし、
オペレーティングシステムは (\UNIX{} システムでしか使われていませんが)
\code{\#!} の行を含むスクリプトファイルを判別できなくなるので注意してください。
 
%% By using UTF-8 (either through the signature or an encoding
%% declaration), characters of most languages in the world can be used
%% simultaneously in string literals and comments. Using non-\ASCII
%% characters in identifiers is not supported. To display all these
%% characters properly, your editor must recognize that the file is
%% UTF-8, and it must use a font that supports all the characters in the
%% file.

UTF-8 を (シグネチャやエンコード宣言を行って) 使うと、世界中の
ほとんどの言語で使われている文字を文字列リテラルやコメントの中に
同時に使うことができます。識別子に対する非 \ASCII{} 文字の使用はサポート
されていません。全ての文字を正しく表示できるようにするには、使っている
エディタがファイルを UTF-8 であると認識することができなければならず、
かつファイル内で使われている全ての文字をサポートするようなフォントを
使わなければなりません。


\subsection{対話モード用の起動時実行ファイル \label{startup}} % The Interactive Startup File

% XXX This should probably be dumped in an appendix, since most people
% don't use Python interactively in non-trivial ways.

%% When you use Python interactively, it is frequently handy to have some
%% standard commands executed every time the interpreter is started.  You
%% can do this by setting an environment variable named
%% \envvar{PYTHONSTARTUP} to the name of a file containing your start-up
%% commands.  This is similar to the \file{.profile} feature of the
%% \UNIX{} shells.

Python を対話的に使うときには、インタプリタが起動する度に実行される
何らかの標準的なコマンドがあると便利なことがよくあります。
これを行うには、\envvar{PYTHONSTARTUP} と呼ばれる環境変数を、
インタプリタ起動時に実行されるコマンドが入ったファイル名に設定します。
この機能は \UNIX{} シェルの \file{.profile} に似ています。

%% This file is only read in interactive sessions, not when Python reads
%% commands from a script, and not when \file{/dev/tty} is given as the
%% explicit source of commands (which otherwise behaves like an
%% interactive session).  It is executed in the same namespace where
%% interactive commands are executed, so that objects that it defines or
%% imports can be used without qualification in the interactive session.
%% You can also change the prompts \code{sys.ps1} and \code{sys.ps2} in
%% this file.

このファイルは対話セッションのときだけ読み出されます。Python がコマンドを
スクリプトから読み出しているときや、 \file{/dev/tty} がコマンドの
入力元として明示的に指定されている (この場合対話的セッションのように
動作します) \emph{わけではない} 場合にはこのファイルは読み出されません。
ファイル内のコマンドは、対話的コマンドが実行される名前空間と同じ名前空間内で
実行されます。このため、ファイル内で定義されていたり import された
オブジェクトは、限定子をつけなくても対話セッション内で使うことができます。
また、このファイル内で \code{sys.ps1} や \code{sys.ps2} を変更して、
プロンプトを変更することもできます。

%% If you want to read an additional start-up file from the current
%% directory, you can program this in the global start-up file using code
%% like \samp{if os.path.isfile('.pythonrc.py'):
%% execfile('.pythonrc.py')}.  If you want to use the startup file in a
%% script, you must do this explicitly in the script:

もし現在のディレクトリから追加的なスタートアップファイルを読み出したいのなら、
グローバルのスタートアップファイルの中で
\samp{if os.path.isfile('.pythonrc.py'): execfile('.pythonrc.py')}
のようなコードのプログラムを書くことができます。
スクリプト中でスタートアップファイルを使いたいのなら、以下のようにして
スクリプト中で明示的に実行しなければなりません:

\begin{verbatim}
import os
filename = os.environ.get('PYTHONSTARTUP')
if filename and os.path.isfile(filename):
    execfile(filename)
\end{verbatim}


\chapter{形式ばらない Python の紹介 \label{informal}} % An Informal Introduction to Python

%% In the following examples, input and output are distinguished by the
%% presence or absence of prompts (\samp{>\code{>}>~} and \samp{...~}): to repeat
%% the example, you must type everything after the prompt, when the
%% prompt appears; lines that do not begin with a prompt are output from
%% the interpreter. %
%\footnote{
%        I'd prefer to use different fonts to distinguish input
%        from output, but the amount of LaTeX hacking that would require
%        is currently beyond my ability.
%}

以下の例では、入力と出力は (\samp{>>>~} や \samp{...~}) といった
プロンプトがあるかないかで区別します: 例どおりに実行するなら、
プロンプトが表示されているときに、例中のプロンプトよりも後ろの内容全てを
タイプ入力しなければなりません; プロンプトが先頭にない行はインタプリタ
からの出力です
\footnote{
入力と出力を区別するために異なるフォントを使おうとは思うのですが、
それに必要な LaTeX の hack 作業に必要な量が、今のところ私の能力を
超えています。
}
。

%% Note that a secondary prompt on a line by itself in an example means
%% you must type a blank line; this is used to end a multi-line command.

例中には二次プロンプトだけが表示されている行がありますが、これは
空行を入力しなければならないことを意味するので注意してください; 
空行の入力は複数の行からなる命令の終わりをインタプリタに教えるために
使われます。

%% Many of the examples in this manual, even those entered at the
%% interactive prompt, include comments.  Comments in Python start with
%% the hash character, \character{\#}, and extend to the end of the
%% physical line.  A comment may appear at the start of a line or
%% following whitespace or code, but not within a string literal.  A hash 
%% character within a string literal is just a hash character.

このマニュアルにある例の多くは、対話プロンプトで入力されるものでも
コメントを含んでいます。Python におけるコメント文はハッシュ文字
\character{\#} で始まり、物理行の終わりまで続きます。
コメントは行の先頭にも、空白やコードの後にも書くことができますが、
文字列リテラル (string literal) の内部に置くことはできません。
文字列リテラル中のハッシュ文字はただのハッシュ文字です。

%% Some examples:
例:

\begin{verbatim}
# これは１番目のコメント
SPAM = 1                 # そしてこれは２番目のコメント
                         # ... そしてこれは３番目!
STRING = "# これはコメントではありません。"
\end{verbatim}


\section{Python を電卓として使う \label{calculator}} % Using Python as a Calculator

%% Let's try some simple Python commands.  Start the interpreter and wait
%% for the primary prompt, \samp{>>>~}.  (It shouldn't take long.)

それでは、簡単な Python コマンドをいくつか試しましょう。
インタプリタを起動して、
一次プロンプト、\samp{>>>~} が現れるのを待ちます。
(そう長くはかからないはずです)

\subsection{数 \label{numbers}} % Numbers

%% The interpreter acts as a simple calculator: you can type an
%% expression at it and it will write the value.  Expression syntax is
%% straightforward: the operators \code{+}, \code{-}, \code{*} and
%% \code{/} work just like in most other languages (for example, Pascal
%% or C); parentheses can be used for grouping.  For example:

インタプリタは単純な電卓のように動作します: 
式をタイプ入力することができ、その結果が書き出されます。
式の文法は素直なものです: 演算子 \code{+}, \code{-}, \code{*}, \code{/} 
は (Pascal や C といった) 他のほとんどの言語と同じように動作します。
括弧をグループ化に使うこともできます。例えば:

\begin{verbatim}
>>> 2+2
4
>>> # これはコメント
... 2+2
4
>>> 2+2  # そしてこれはコードと同じ行にあるコメント
4
>>> (50-5*6)/4
5
>>> # 整数の除算は floor (実数の解を越えない最大の整数) を返す:
... 7/3
2
>>> 7/-3
-3
\end{verbatim}

% +The equal sign (\character{=}) is used to assign a value to a variable.
% +Afterwards, no result is displayed before the next interactive prompt:

%% Like in C, the equal sign (\character{=}) is used to assign a value to a
%% variable.  The value of an assignment is not written:

等号 (\character{=}) は変数に値を代入するときに使います。
代入を行っても、その結果が次のプロンプトの前に出力されたりはしません:

\begin{verbatim}
>>> width = 20
>>> height = 5*9
>>> width * height
900
\end{verbatim}

%% A value can be assigned to several variables simultaneously:

複数の変数に同時に値を代入することができます:

\begin{verbatim}
>>> x = y = z = 0  # x と y と z をゼロにする
>>> x
0
>>> y
0
>>> z
0
\end{verbatim}

%% There is full support for floating point; operators with mixed type
%% operands convert the integer operand to floating point:

浮動小数点は完全にサポートしています; 被演算子の型が混合されているときには、
演算子は整数の被演算子を浮動小数点型に変換します。

\begin{verbatim}
>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5
\end{verbatim}

%% Complex numbers are also supported; imaginary numbers are written with
%% a suffix of \samp{j} or \samp{J}.  Complex numbers with a nonzero
%% real component are written as \samp{(\var{real}+\var{imag}j)}, or can
%% be created with the \samp{complex(\var{real}, \var{imag})} function.

複素数もサポートされています。虚数は接尾辞 \samp{j} または \samp{J} を
付けて書き表します。ゼロでない実数部をもつ複素数は
 \samp{(\var{real}+\var{imag}j)} のように書き表すか、
\samp{complex(\var{real}, \var{imag})} 関数で生成できます。

\begin{verbatim}
>>> 1j * 1J
(-1+0j)
>>> 1j * complex(0,1)
(-1+0j)
>>> 3+1j*3
(3+3j)
>>> (3+1j)*3
(9+3j)
>>> (1+2j)/(1+1j)
(1.5+0.5j)
\end{verbatim}

%% Complex numbers are always represented as two floating point numbers,
%% the real and imaginary part.  To extract these parts from a complex
%% number \var{z}, use \code{\var{z}.real} and \code{\var{z}.imag}.  

複素数は、常に実部と虚部に相当する二つの浮動小数点数で表されます。
複素数 \var{z} からそれぞれの部分を取り出すには、\code{\var{z}.real} 
と \code{\var{z}.imag} を使います。

\begin{verbatim}
>>> a=1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5
\end{verbatim}

%% The conversion functions to floating point and integer
%% (\function{float()}, \function{int()} and \function{long()}) don't
%% work for complex numbers --- there is no one correct way to convert a
%% complex number to a real number.  Use \code{abs(\var{z})} to get its
%% magnitude (as a float) or \code{z.real} to get its real part.

数値を浮動小数点数や整数へに変換する関数 (\function{float()}, 
\function{int()}, \function{long()}) は複素数に対しては動作しません --- 
複素数を実数に変換する方法には、ただ一つの正解というものがないからです。
絶対値 (magnitude) を (浮動小数点数として) 得るには \code{abs(\var{z})} を
使い、実部を得るには \code{z.real} を使ってください。

\begin{verbatim}
>>> a=3.0+4.0j
>>> float(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: can't convert complex to float; use abs(z)
>>> a.real
3.0
>>> a.imag
4.0
>>> abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0
>>>
\end{verbatim}

%% In interactive mode, the last printed expression is assigned to the
%% variable \code{_}.  This means that when you are using Python as a
%% desk calculator, it is somewhat easier to continue calculations, for
%% example:

対話モードでは、最後に印字された式は変数 \code{_} に代入されます。
このことを利用すると、 Python を電卓として使うときに、計算を連続して
行う作業が多少楽になります。以下に例を示します:

\begin{verbatim}
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
>>>
\end{verbatim}

%% This variable should be treated as read-only by the user.  Don't
%% explicitly assign a value to it --- you would create an independent
%% local variable with the same name masking the built-in variable with
%% its magic behavior.

ユーザはこの変数を読取り専用の値として扱うべきです。
この変数に明示的な代入を行ってはいけません --- そんなことをすれば、
この組み込み変数と同じ名前で、元の組み込み変数の不思議な動作を覆い隠して
しまうような、別個のローカルな変数が生成されてしまいます。

\subsection{文字列 \label{strings}} % Strings

%% Besides numbers, Python can also manipulate strings, which can be
%% expressed in several ways.  They can be enclosed in single quotes or
%% double quotes:

数のほかに、Python は文字列も操作できます。
文字列はいくつもの方法で表現できます。
文字列はシングルまたはダブルのクォートで囲みます。

\begin{verbatim}
>>> 'spam eggs'
'spam eggs'
>>> 'doesn\'t'
"doesn't"
>>> "doesn't"
"doesn't"
>>> '"Yes," he said.'
'"Yes," he said.'
>>> "\"Yes,\" he said."
'"Yes," he said.'
>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'
\end{verbatim}

%% String literals can span multiple lines in several ways.  Continuation
%% lines can be used, with a backslash as the last character on the line
%% indicating that the next line is a logical continuation of the line:

文字列リテラルはいくつかの方法で複数行にまたがって記述できます。継続行
を使うことができ、これには行の末尾の文字を
バックスラッシュにします。こうすることで、次の行が現在の行と論理的に
継続していることを示します:

\begin{verbatim}
hello = "This is a rather long string containing\n\
several lines of text just as you would do in C.\n\
    Note that whitespace at the beginning of the line is\
 significant."

print hello
\end{verbatim}

%% Note that newlines would still need to be embedded in the string using
%% \code{\e n}; the newline following the trailing backslash is
%% discarded.  This example would print the following:

\code{\e n} を使って文字列に改行位置を埋め込まなくてはならないことに注意
してください; 末尾のバックスラッシュの後ろにある改行文字は無視されます。
従って、上の例は以下のような出力を行います:

\begin{verbatim}
This is a rather long string containing
several lines of text just as you would do in C.
    Note that whitespace at the beginning of the line is significant.
\end{verbatim}

%% If we make the string literal a ``raw'' string, however, the
%% \code{\e n} sequences are not converted to newlines, but the backslash
%% at the end of the line, and the newline character in the source, are
%% both included in the string as data.  Thus, the example:

一方、文字列リテラルを ``raw'' 文字列にすると、\code{\e n} のような
エスケープシーケンスは改行に変換されません。逆に、行末のバックスラッシュ
やソースコード中の改行文字が文字列データに含められます。つまり、以下の例:


\begin{verbatim}
hello = r"This is a rather long string containing\n\
several lines of text much as you would do in C."

print hello
\end{verbatim}

%% would print:
は、以下のような出力を行います:

\begin{verbatim}
This is a rather long string containing\n\
several lines of text much as you would do in C.
\end{verbatim}


%% Or, strings can be surrounded in a pair of matching triple-quotes:
%% \code{"""} or \code{'\code{'}'}.  End of lines do not need to be escaped
%% when using triple-quotes, but they will be included in the string.

また、対になった三重クォート \code{"""} または \code{'\code{'}'} で
文字列を囲むこともできます。
三重クォートを使っているときには、行末をエスケープする必要はありません、
しかし、行末の改行文字も文字列に含まれることになります。

\begin{verbatim}
print """
Usage: thingy [OPTIONS] 
     -h                        Display this usage message
     -H hostname               Hostname to connect to
"""
\end{verbatim}

%% produces the following output:
は以下のような出力を行います:

\begin{verbatim}
Usage: thingy [OPTIONS] 
     -h                        Display this usage message
     -H hostname               Hostname to connect to
\end{verbatim}

%% The interpreter prints the result of string operations in the same way
%% as they are typed for input: inside quotes, and with quotes and other
%% funny characters escaped by backslashes, to show the precise
%% value.  The string is enclosed in double quotes if the string contains
%% a single quote and no double quotes, else it's enclosed in single
%% quotes.  (The \keyword{print} statement, described later, can be used
%% to write strings without quotes or escapes.)

インタプリタは、文字列演算の結果を、タイプ入力する時のと同じ方法で
出力します: 文字列はクオート文字で囲い、クオート文字自体やその他の
奇妙な文字は、正しい文字が表示されるようにするために
バックスラッシュでエスケープします。
文字列がシングルクオートを含み、かつダブルクオートを含まない場合には、
全体をダブルクオートで囲います。そうでない場合にはシングルクオートで
囲みます。
(後で述べる \keyword{print} を使って、クオートやエスケープ
のない文字列を書くことができます。)

%% Strings can be concatenated (glued together) with the
%% \code{+} operator, and repeated with \code{*}:

文字列は \code{+} 演算子で連結させる (くっつけて一つにする) ことができ、
\code{*} 演算子で反復させることができます。

\begin{verbatim}
>>> word = 'Help' + 'A'
>>> word
'HelpA'
>>> '<' + word*5 + '>'
'<HelpAHelpAHelpAHelpAHelpA>'
\end{verbatim}

%% Two string literals next to each other are automatically concatenated;
%% the first line above could also have been written \samp{word = 'Help'
%% 'A'}; this only works with two literals, not with arbitrary string
%% expressions:

互いに隣あった二つの文字列リテラルは自動的に連結されます:
例えば、上記の最初の行は \samp{word = 'Help' 'A'} と書くことも
できました; この機能は二つともリテラルの場合にのみ働くもので、
任意の文字列表現で使うことができるわけではありません。

\begin{verbatim}
>>> 'str' 'ing'             #  <-  これは ok
'string'
>>> 'str'.strip() + 'ing'   #  <-  これは ok
'string'
>>> 'str'.strip() 'ing'     #  <-  これはダメ
  File "<stdin>", line 1, in ?
    'str'.strip() 'ing'
                  ^
SyntaxError: invalid syntax
\end{verbatim}

%% Strings can be subscripted (indexed); like in C, the first character
%% of a string has subscript (index) 0.  There is no separate character
%% type; a character is simply a string of size one.  Like in Icon,
%% substrings can be specified with the \emph{slice notation}: two indices
%% separated by a colon.

文字列は添字表記 (インデクス表記) することができます; 
C 言語と同じく、文字列の最初の文字の添字 (インデクス) は 0 となります。
独立した文字型というものはありません; 単一の文字は、単に
サイズが 1 の文字列です。Icon 言語と同じく、部分文字列を 
\emph{スライス表記}: コロンで区切られた二つのインデクスで指定する
ことができます。

\begin{verbatim}
>>> word[4]
'A'
>>> word[0:2]
'He'
>>> word[2:4]
'lp'
\end{verbatim}

%% Slice indices have useful defaults; an omitted first index defaults to
%% zero, an omitted second index defaults to the size of the string being
%% sliced.

スライスのインデクスには便利なデフォルト値があります;
最初のインデクスを省略すると、0 と見なされます。
第 2 のインデクスを省略すると、スライスしようとする文字列のサイズと
みなされます。

\begin{verbatim}
>>> word[:2]    # 最初の 2 文字
'He'
>>> word[2:]    # 最初の 2 文字を除くすべて
'lpA'
\end{verbatim}

%% Unlike a C string, Python strings cannot be changed.  Assigning to an 
%% indexed position in the string results in an error:

C 言語の文字列と違い、Python の文字列は変更できません。
インデクス指定された文字列中のある位置に代入を行おうとすると
エラーになります:

\begin{verbatim}
>>> word[0] = 'x'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: object doesn't support item assignment
>>> word[:1] = 'Splat'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: object doesn't support slice assignment
\end{verbatim}

%% However, creating a new string with the combined content is easy and
%% efficient:

一方、要素どうしを組み合わせた新たな文字列の生成は、簡単で効率的です:

\begin{verbatim}
>>> 'x' + word[1:]
'xelpA'
>>> 'Splat' + word[4]
'SplatA'
\end{verbatim}


%% Here's a useful invariant of slice operations:
%% \code{s[:i] + s[i:]} equals \code{s}.

スライス演算には便利な不変式があります: 
\code{s[:i] + s[i:]} は \code{s} に等しくなります。

\begin{verbatim}
>>> word[:2] + word[2:]
'HelpA'
>>> word[:3] + word[3:]
'HelpA'
\end{verbatim}

%% Degenerate slice indices are handled gracefully: an index that is too
%% large is replaced by the string size, an upper bound smaller than the
%% lower bound returns an empty string.

スライス表記に行儀の悪いインデクス指定をしても、値はたしなみよく処理
されます: インデクスが大きすぎる場合は文字列のサイズと置き換えられます。
スライスの下境界 (文字列の左端) よりも小さいインデクス値を上境界
(文字列の右端) に指定すると、空文字列が返されます。

\begin{verbatim}
>>> word[1:100]
'elpA'
>>> word[10:]
''
>>> word[2:1]
''
\end{verbatim}

%% Indices may be negative numbers, to start counting from the right.
%% For example:

インデクスを負の数にして、右から数えることもできます。
例えば:

\begin{verbatim}
>>> word[-1]     # 末尾の文字
'A'
>>> word[-2]     # 末尾から 2 つめの文字
'p'
>>> word[-2:]    # 末尾の 2 文字
'pA'
>>> word[:-2]    # 末尾の 2 文字を除くすべて
'Hel'
\end{verbatim}

%% But note that -0 is really the same as 0, so it does not count from
%% the right!

-0 は 0 と全く同じなので、右から数えることができません。
注意してください!

\begin{verbatim}
>>> word[-0]     # (-0 は 0 に等しい)
'H'
\end{verbatim}

%% Out-of-range negative slice indices are truncated, but don't try this
%% for single-element (non-slice) indices:

負で、かつ範囲外のインデクスをスライス表記で行うと、インデクス
は切り詰められます。しかし、単一の要素を指定する (スライスでない)
インデクス指定でこれを行ってはいけません:

\begin{verbatim}
>>> word[-100:]
'HelpA'
>>> word[-10]    # エラー
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
IndexError: string index out of range
\end{verbatim}

%% The best way to remember how slices work is to think of the indices as
%% pointing \emph{between} characters, with the left edge of the first
%% character numbered 0.  Then the right edge of the last character of a
%% string of \var{n} characters has index \var{n}, for example:

スライスの働きかたをおぼえる最も良い方法は、
インデクスが文字と文字の\emph{あいだ (between)} を指しており、最初の
文字の左端が 0 になっていると考えることです。そうすると、
\var{n} 文字からなる文字列中の最後の文字の右端はインデクス \var{n}
となります。例えば:

\begin{verbatim}
 +---+---+---+---+---+ 
 | H | e | l | p | A |
 +---+---+---+---+---+ 
 0   1   2   3   4   5 
-5  -4  -3  -2  -1
\end{verbatim}

といった具合です。

%% The first row of numbers gives the position of the indices 0...5 in
%% the string; the second row gives the corresponding negative indices.
%% The slice from \var{i} to \var{j} consists of all characters between
%% the edges labeled \var{i} and \var{j}, respectively.

数が記された行のうち、最初の方の行は、文字列中のインデクス 0...5 の
位置を表します; 次の行は、対応する負のインデクスを表しています。
\var{i} から \var{j} までのスライスは、それぞれ \var{i}, \var{j} 
とラベル付けされたけられた端点間のすべての文字からなります。

%% For non-negative indices, the length of a slice is the difference of
%% the indices, if both are within bounds.  For example, the length of
%% \code{word[1:3]} is 2.

非負のインデクス対の場合、スライスされたシーケンスの長さは、スライスの両端の
インデクスが境界内にあるかぎり、インデクス間の差になります。
例えば、 \code{word[1:3]} の長さは 2 になります。

%% The built-in function \function{len()} returns the length of a string:

組込み関数 \function{len()} は文字列の長さ (length) を返します。

\begin{verbatim}
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
\end{verbatim}

\begin{seealso} 
     \seetitle[../lib/typesseq.html]{シーケンス型}% 
              {次節で記述されている文字列および Unicode 文字列は
\emph{シーケンス型} の例であり、シーケンス型でサポートされている共通の操作を
サポートしています。}
     \seetitle[../lib/string-methods.html]{文字列メソッド}% 
              {文字列や Unicode 文字列では、基本的な変換や検索を
行うための数多くのメソッドをサポートしています。} 
     \seetitle[../lib/typesseq-strings.html]{文字列フォーマット操作}% 
              {文字列や Unicode 文字列が \code{\%} 演算子の左被演算子
である場合に呼び出されるフォーマット操作については、ここで詳しく記述
されています。} 
   \end{seealso} 

\subsection{Unicode 文字列 \label{unicodeStrings}} % Unicode Strings
\sectionauthor{Marc-Andre Lemburg}{mal@lemburg.com}

%% Starting with Python 2.0 a new data type for storing text data is
%% available to the programmer: the Unicode object. It can be used to
%% store and manipulate Unicode data (see \url{http://www.unicode.org/})
%% and integrates well with the existing string objects providing
%% auto-conversions where necessary.

Python 2.0 から、プログラマはテキスト・データを格納するための新しい
データ型、Unicode オブジェクトを利用できるようになりました。
Unicode オブジェクトを使うと、Unicode データ (\url{http://www.unicode.org/} 
参照) を記憶したり、操作したりできます。また、 Unicode オブジェクトは
既存の文字列オブジェクトとよく統合していて、必要に応じた自動変換機能を
提供しています。

%% Unicode has the advantage of providing one ordinal for every character
%% in every script used in modern and ancient texts. Previously, there
%% were only 256 possible ordinals for script characters and texts were
%% typically bound to a code page which mapped the ordinals to script
%% characters. This lead to very much confusion especially with respect
%% to internationalization (usually written as \samp{i18n} ---
%% \character{i} + 18 characters + \character{n}) of software.  Unicode
%% solves these problems by defining one code page for all scripts.

Unicode には、古今のテキストで使われているあらゆる書き文字のあらゆる
文字について、対応付けを行うための一つの序数を規定しているという利点が
あります。
これまでは、書き文字のために利用可能な序数は 256 個しかなく、テキストは
書き文字の対応付けを行っているコードページに束縛されているのが通常
でした。
このことは、とりわけソフトウェアの国際化 (通常 \samp{i18n} ---
\character{i} + 18 文字 + \character{n} の意) に対して大きな
混乱をもたらしました。Unicode では、すべての書き文字に対して単一の
コードページを定義することで、これらの問題を解決しています。

%% Creating Unicode strings in Python is just as simple as creating
%% normal strings:

Python では、Unicode 文字列の作成は通常の文字列を作成するのと
同じように単純なものです:

\begin{verbatim}
>>> u'Hello World !'
u'Hello World !'
\end{verbatim}

%% The small \character{u} in front of the quote indicates that an
%% Unicode string is supposed to be created. If you want to include
%% special characters in the string, you can do so by using the Python
%% \emph{Unicode-Escape} encoding. The following example shows how:

クオートの前にある小文字の \character{u} は、Unicode 文字列を生成
することになっていることを示します。文字列に特殊な文字を
含めたければ、Python の \emph{Unicode-Escape} エンコーディングを
使って行えます。以下はその方法を示しています:

\begin{verbatim}
>>> u'Hello\u0020World !'
u'Hello World !'
\end{verbatim}

%% The escape sequence \code{\e u0020} indicates to insert the Unicode
%% character with the ordinal value 0x0020 (the space character) at the
%% given position.

エスケープシーケンス \code{\e u0020} は、序数の値 0x0020 を持つ 
Unicode 文字 (スペース文字) を、指定場所に挿入することを示します。

%% Other characters are interpreted by using their respective ordinal
%% values directly as Unicode ordinals.  If you have literal strings
%% in the standard Latin-1 encoding that is used in many Western countries,
%% you will find it convenient that the lower 256 characters
%% of Unicode are the same as the 256 characters of Latin-1.

他の文字は、それぞれの序数値をそのまま Unicode の序数値に用いて
解釈されます。多くの西洋諸国で使われている標準 Latin-1 エンコーディング
のリテラル文字列があれば、Unicode の下位 256 文字が Latin-1 の 256 
文字と同じになっていて便利だと思うことでしょう。

%% For experts, there is also a raw mode just like the one for normal
%% strings. You have to prefix the opening quote with 'ur' to have
%% Python use the \emph{Raw-Unicode-Escape} encoding. It will only apply
%% the above \code{\e uXXXX} conversion if there is an uneven number of
%% backslashes in front of the small 'u'.

上級者のために、通常の文字列の場合と同じく raw モードもあります。
これには、文字列を開始するクオート文字の前に 'ur' を付けて、
Python に \emph{Raw-Unicode-Escape} エンコーディングを使わせ
なければなりません。このモードでは、上記の \code{\e uXXXX} の
変換は機能、小文字の 'u' の前に奇数個のバックスラッシュがあるときにだけ
適用されます。

\begin{verbatim}
>>> ur'Hello\u0020World !'
u'Hello World !'
>>> ur'Hello\\u0020World !'
u'Hello\\\\u0020World !'
\end{verbatim}

%% The raw mode is most useful when you have to enter lots of
%% backslashes, as can be necessary in regular expressions.

raw モードは、正規表現を記述する時のように、沢山のバックスラッシュを
入力しなければならないときとても役に立ちます。

%% Apart from these standard encodings, Python provides a whole set of
%% other ways of creating Unicode strings on the basis of a known
%% encoding. 

これら標準のエンコーディングにとは別に、Python では、既知の
文字エンコーディングに基づいて Unicode 文字列を生成する一連の
手段を提供しています。

%% The built-in function \function{unicode()}\bifuncindex{unicode} provides
%% access to all registered Unicode codecs (COders and DECoders). Some of
%% the more well known encodings which these codecs can convert are
%% \emph{Latin-1}, \emph{ASCII}, \emph{UTF-8}, and \emph{UTF-16}.
%% The latter two are variable-length encodings that store each Unicode
%% character in one or more bytes. The default encoding is
%% normally set to \ASCII, which passes through characters in the range
%% 0 to 127 and rejects any other characters with an error.
%% When a Unicode string is printed, written to a file, or converted
%% with \function{str()}, conversion takes place using this default encoding.

組込み関数 \function{unicode()}\bifuncindex{unicode} は、
登録されているすべての Unicode codecs (COder: エンコーダ と DECoder
デコーダ) へのアクセス機能を提供します。codecs が変換できる
エンコーディングには、よく知られているものとして
\emph{Latin-1}, \emph{ASCII}, \emph{UTF-8} および \emph{UTF-16} が
あります。後者の二つは可変長のエンコードで、各 Unicode 文字を
1 バイトまたはそれ以上のバイト列に保存します。デフォルトのエンコーディング
は通常 \ASCII に設定されています。\ASCII では 0 から 127 の範囲の
文字だけを通過させ、それ以外の文字は受理せずエラーを出します。
Unicode 文字列を印字したり、ファイルに書き出したり、
\function{str()} で変換すると、デフォルトのエンコーディングを
使った変換が行われます。

\begin{verbatim}
>>> u"abc"
u'abc'
>>> u"あいう"
u'\x82\xa0\x82\xa2\x82\xa4'
>>> str(u"あいう")
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-5: 
ordinal not in range(128)
\end{verbatim}

%% To convert a Unicode string into an 8-bit string using a specific
%% encoding, Unicode objects provide an \function{encode()} method
%% that takes one argument, the name of the encoding.  Lowercase names
%% for encodings are preferred.

特定のエンコーディングを使って Unicode 文字列を 8 ビットの文字列に
変換するために、Unicode オブジェクトでは \function{encode()} 
メソッドを提供しています。このメソッドは単一の引数として
エンコーディングの名前をとります。エンコーディング名には
小文字の使用が推奨されています。

\begin{verbatim}
>>> u"あいう".encode('utf-8')
'\xc2\x82\xc2\xa0\xc2\x82\xc2\xa2\xc2\x82\xc2\xa4'
\end{verbatim}

%% If you have data in a specific encoding and want to produce a
%% corresponding Unicode string from it, you can use the
%% \function{unicode()} function with the encoding name as the second
%% argument.

特定のエンコーディングで書かれているデータがあり、そこから
Unicode 文字列を生成したいなら、\function{unicode()} を使い、
第 2 引数にエンコーディング名を指定します。

\begin{verbatim}
unicode('\xc2\x82\xc2\xa0\xc2\x82\xc2\xa2\xc2\x82\xc2\xa4', 'utf-8')
u'\x82\xa0\x82\xa2\x82\xa4'
\end{verbatim}

\subsection{リスト \label{lists}} % Lists

%% Python knows a number of \emph{compound} data types, used to group
%% together other values.  The most versatile is the \emph{list}, which
%% can be written as a list of comma-separated values (items) between
%% square brackets.  List items need not all have the same type.

Python は数多くの \emph{複合 (compound)} データ型を備えており、
別々の値を一まとめにするために使えます。
最も汎用的なデータ型は \emph{リスト (list) } で、コンマで区切られた
値からなるリストを各カッコで囲んだものとして書き表されます。
リストの要素をすべて同じ型にする必要はありません。

\begin{verbatim}
>>> a = ['spam', 'eggs', 100, 1234]
>>> a
['spam', 'eggs', 100, 1234]
\end{verbatim}

%% Like string indices, list indices start at 0, and lists can be sliced,
%% concatenated and so on:

文字列のインデクスと同じく、リストのインデクスは 0 から開始します。
また、スライス、連結なども行えます:

\begin{verbatim}
>>> a[0]
'spam'
>>> a[3]
1234
>>> a[-2]
100
>>> a[1:-1]
['eggs', 100]
>>> a[:2] + ['bacon', 2*2]
['spam', 'eggs', 'bacon', 4]
>>> 3*a[:3] + ['Boo!']
['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']
\end{verbatim}

%% Unlike strings, which are \emph{immutable}, it is possible to change
%% individual elements of a list:

\emph{変化不可能 (immutable)} な文字列型と違い、
リストは個々の要素を変更することができます。

\begin{verbatim}
>>> a
['spam', 'eggs', 100, 1234]
>>> a[2] = a[2] + 23
>>> a
['spam', 'eggs', 123, 1234]
\end{verbatim}

%% Assignment to slices is also possible, and this can even change the size
%% of the list or clear it entirely:

スライスに代入することもできます。スライスの代入を行って、
リストのサイズを変更したり、完全に消すことさえできます:

\begin{verbatim}
>>> # いくつかの項目を置換する:
... a[0:2] = [1, 12]
>>> a
[1, 12, 123, 1234]
>>> # いくつかの項目を除去する:
... a[0:2] = []
>>> a
[123, 1234]
>>> # いくつかの項目を挿入する:
... a[1:1] = ['bletch', 'xyzzy']
>>> a
[123, 'bletch', 'xyzzy', 1234]
>>> # それ自身 (のコピー) を先頭に挿入する
>>> a[:0] = a    
>>> a
[123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
>>> # リストをクリアする: 全てのアイテムを空のリストに置換する
>>> a[:] = []
>>> a
[]
\end{verbatim}

%% The built-in function \function{len()} also applies to lists:
組込み関数 \function{len()} はリストにも適用できます。

\begin{verbatim}
>>> len(a)
8
\end{verbatim}

%% It is possible to nest lists (create lists containing other lists),
%% for example:

リストを入れ子にする (ほかのリストを含むリストを造る) ことも可能です。
例えば、

\begin{verbatim}
>>> q = [2, 3]
>>> p = [1, q, 4]
>>> len(p)
3
>>> p[1]
[2, 3]
>>> p[1][0]
2
>>> p[1].append('xtra')     # 5.1節を参照
>>> p
[1, [2, 3, 'xtra'], 4]
>>> q
[2, 3, 'xtra']
\end{verbatim}

%% Note that in the last example, \code{p[1]} and \code{q} really refer to
%% the same object!  We'll come back to \emph{object semantics} later.

最後の例では、 \code{p[1]} と \code{q} が実際には同一のオブジェクトを
参照していることに注意してください!　
\emph{オブジェクトの意味付け (semantics)} については、後ほど触れることに
します。

\section{プログラミングへの第一歩 \label{firstSteps}} % First Steps Towards Programming

%% Of course, we can use Python for more complicated tasks than adding
%% two and two together.  For instance, we can write an initial
%% sub-sequence of the \emph{Fibonacci} series as follows:

もちろん、2 たす 2 よりももっと複雑な仕事にも Python を使うことが
できます。\emph{Fibonacci} 級数列の先頭の部分列は次のようにして
書くことができます:

\begin{verbatim}
>>> # Fibonacci 級数:
... # 二つの要素の和が次の要素を定義する
... a, b = 0, 1
>>> while b < 10:
...       print b
...       a, b = b, a+b
... 
1
1
2
3
5
8
\end{verbatim}

%% This example introduces several new features.
上の例では、いくつか新しい機能を取り入れています。

\begin{itemize}

\item
%% The first line contains a \emph{multiple assignment}: the variables
%% \code{a} and \code{b} simultaneously get the new values 0 and 1.  On the
%% last line this is used again, demonstrating that the expressions on
%% the right-hand side are all evaluated first before any of the
%% assignments take place.  The right-hand side expressions are evaluated 
%% from the left to the right.
最初の行には \emph{複数同時の代入 (multiple assignment)} が入っています:
変数 \code{a} と \code{b} は、それぞれ同時に新しい値 0 と 1 に
なっています。この代入は最後の行でも再度使われており、代入が
行われる前に右辺の式がまず評価されます。右辺の式は左から右へと
順番に評価されます。

\item
%% The \keyword{while} loop executes as long as the condition (here:
%% \code{b < 10}) remains true.  In Python, like in C, any non-zero
%% integer value is true; zero is false.  The condition may also be a
%% string or list value, in fact any sequence; anything with a non-zero
%% length is true, empty sequences are false.  The test used in the
%% example is a simple comparison.  The standard comparison operators are
%% written the same as in C: \code{<} (less than), \code{>} (greater than),
%% \code{==} (equal to), \code{<=} (less than or equal to),
%% \code{>=} (greater than or equal to) and \code{!=} (not equal to).
\keyword{while} は、条件 (ここでは \code{b < 10}) が真である限り
実行を繰り返し (ループし) ます。Python では、C 言語と同様に、ゼロでない
整数値は真となり、ゼロは偽です。条件式は文字列値やリスト値、
実際には任意のシーケンス型でもかまいません。例中で使われている条件テスト
は単なる比較です。標準的な比較演算子は C 言語と同様です: すなわち、
\code{<} (より小さい)、
\code{>} (より大きい)、
\code{==} (等しい)、
\code{<=} (より小さいか等しい)、
\code{>=} (より大きいか等しい)、 および \code{!=} (等しくない) 、
です。

\item
%% The \emph{body} of the loop is \emph{indented}: indentation is Python's
%% way of grouping statements.  Python does not (yet!) provide an
%% intelligent input line editing facility, so you have to type a tab or
%% space(s) for each indented line.  In practice you will prepare more
%% complicated input for Python with a text editor; most text editors have
%% an auto-indent facility.  When a compound statement is entered
%% interactively, it must be followed by a blank line to indicate
%% completion (since the parser cannot guess when you have typed the last
%% line).  Note that each line within a basic block must be indented by
%% the same amount.
ループの\emph{本体 (body)} は\emph{インデント (indent, 字下げ)} 
されています: インデントは Python において実行文をグループにまとめる
方法です。Python は (いまだに!) 賢い入力行編集機能を提供していないので、
インデントされた各行を入力するにはタブや (複数個の) スペースを
使わなければなりません。実際には、Python へのより複雑な入力を準備する
にはテキストエディタを使うことになるでしょう; ほとんどのテキスト
エディタは自動インデント機能を持っています。
複合文を対話的に入力するときには、(パーザはいつ最後の行を入力
したのか推し量ることができないので) 入力の完了を示すために最後に空行を
続けなければなりません。基本ブロックの各行は同じだけインデントされて
いなければならないので注意してください。

\item
%% The \keyword{print} statement writes the value of the expression(s) it is
%% given.  It differs from just writing the expression you want to write
%% (as we did earlier in the calculator examples) in the way it handles
%% multiple expressions and strings.  Strings are printed without quotes,
%% and a space is inserted between items, so you can format things nicely,
%% like this:
\keyword{print} は指定した (1 つまたは複数の) 式の値を書き出します。
\keyword{print} は、(電卓の例でしたように) 単に値を出力したい式を書くの
とは、複数の式や文字列を扱う方法が違います。
文字列は引用符無しで出力され、複数の要素の間にはスペースが挿入されるので、
以下のように出力をうまく書式化できます。

\begin{verbatim}
>>> i = 256*256
>>> print 'The value of i is', i
The value of i is 65536
\end{verbatim}

%% A trailing comma avoids the newline after the output:
末尾にコンマを入れると、出力を行った後に改行されません:

\begin{verbatim}
>>> a, b = 0, 1
>>> while b < 1000:
...     print b,
...     a, b = b, a+b
... 
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
\end{verbatim}

%% Note that the interpreter inserts a newline before it prints the next
%% prompt if the last line was not completed.

インタプリタは、最後に入力した行がまだ完全な文になっていない場合、
改行をはさんで次のプロンプトを出力することに注意してください。

\end{itemize}


\chapter{その他の制御フローツール \label{moreControl}} % More Control Flow Tools

%% Besides the \keyword{while} statement just introduced, Python knows
%% the usual control flow statements known from other languages, with
%% some twists.

今しがた紹介した \keyword{while} 文の他に、Python では他の言語で
おなじみの普通の制御フロー文を備えていますが、これらには多少
ひねりを加えてあります。

\section{\keyword{if} 文 \label{if}} % \keyword{if} Statements

%% Perhaps the most well-known statement type is the
%% \keyword{if} statement.  For example:

おそらく最もおなじみの文型は \keyword{if} 文でしょう。
例えば、

\begin{verbatim}
>>> x = int(raw_input("Please enter an integer: "))
>>> if x < 0:
...      x = 0
...      print 'Negative changed to zero'
... elif x == 0:
...      print 'Zero'
... elif x == 1:
...      print 'Single'
... else:
...      print 'More'
... 
\end{verbatim}

%% There can be zero or more \keyword{elif} parts, and the
%% \keyword{else} part is optional.  The keyword `\keyword{elif}' is
%% short for `else if', and is useful to avoid excessive indentation.  An 
%% \keyword{if} \ldots\ \keyword{elif} \ldots\ \keyword{elif} \ldots\ sequence
%% %    Weird spacings happen here if the wrapping of the source text
%% %    gets changed in the wrong way.
%% is a substitute for the \keyword{switch} or
%% \keyword{case} statements found in other languages.

\keyword{elif} 部はゼロ個またはそれ以上にできます。
\keyword{else} 部を付けることもできます。
キーワード `\keyword{elif}' は `else if' を短くしたもので、
過剰なインデントを避けるのに役立ちます。
一連の \keyword{if} \ldots\ \keyword{elif} \ldots\ \keyword{elif} \ldots\ 
は、他の言語における \emph{switch} 文や \emph{case} 文の代用と
なります。

\section{\keyword{for} 文 \label{for}} % \keyword{for} Statements

%% The \keyword{for}\stindex{for} statement in Python differs a bit from
%% what you may be used to in C or Pascal.  Rather than always
%% iterating over an arithmetic progression of numbers (like in Pascal),
%% or giving the user the ability to define both the iteration step and
%% halting condition (as C), Python's
%% \keyword{for}\stindex{for} statement iterates over the items of any
%% sequence (a list or a string), in the order that they appear in
%% the sequence.  For example (no pun intended):
%% % One suggestion was to give a real C example here, but that may only
%% % serve to confuse non-C programmers.

Python の \keyword{for}\stindex{for} 文は、読者が C 言語や Pascal 言語
で使いなれているかもしれない \keyword{for} 文とは少し違います。
(Pascal のように) 常に算術型の数列にわたる反復を行ったり、
(C のように) 繰返しステップと停止条件を両方ともユーザが定義できるように
するのとは違い、Python の \keyword{for}\stindex{for} 文は、任意の
シーケンス型 (リストまたは文字列) にわたって反復を行います。反復の順番は
シーケンス中に要素が現れる順番です。
(for example というしゃれではないけれど) 例えば 、
% One suggestion was to give a real C example here, but that may only
% serve to confuse non-C programmers.

\begin{verbatim}
>>> # いくつかの文字列の長さを測る:
... a = ['cat', 'window', 'defenestrate']
>>> for x in a:
...     print x, len(x)
... 
cat 3
window 6
defenestrate 12
\end{verbatim}

%% It is not safe to modify the sequence being iterated over in the loop
%% (this can only happen for mutable sequence types, such as lists).  If
%% you need to modify the list you are iterating over (for example, to
%% duplicate selected items) you must iterate over a copy.  The slice
%% notation makes this particularly convenient:

反復操作の対象になっているシーケンスをループので書き換える操作
(リストのような、変更可能 (mutable) なシーケンス型でおきます) は、安全
ではありません。もし反復処理を行う対象とするリスト型を変更したいのなら、
(対象の要素を複製するなどして) コピーに対して反復を行わなければ
なりません。この操作にはスライス表記を使うと特に便利です:


\begin{verbatim}
>>> for x in a[:]: # リスト全体のスライス・コピーを作る
...    if len(x) > 6: a.insert(0, x)
... 
>>> a
['defenestrate', 'cat', 'window', 'defenestrate']
\end{verbatim}


\section{\function{range()} 関数 \label{range}} % The \function{range()} Function

%% If you do need to iterate over a sequence of numbers, the built-in
%% function \function{range()} comes in handy.  It generates lists
%% containing arithmetic progressions:

数列にわたって反復を行う必要がある場合、組み込み関数 \function{range()} 
が便利です。この関数は算術型の数列が入ったリストを生成します。

\begin{verbatim}
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{verbatim}

%% The given end point is never part of the generated list;
%% \code{range(10)} generates a list of 10 values, the legal
%% indices for items of a sequence of length 10.  It is possible to let
%% the range start at another number, or to specify a different increment
%% (even negative; sometimes this is called the `step'):

指定した終端値は生成されるリストには入りません。
\code{range(10)} は 10 個の値からなるリストを生成し、
長さ 10 のシーケンスにおける各項目のインデクスとなります。
range を別の数から開始したり、他の増加量 (負の増加量でさえも;
増加量は時に `ステップ(step)' と呼ばれることもあります) を指定する
こともできます:

\begin{verbatim}
>>> range(5, 10)
[5, 6, 7, 8, 9]
>>> range(0, 10, 3)
[0, 3, 6, 9]
>>> range(-10, -100, -30)
[-10, -40, -70]
\end{verbatim}

%% To iterate over the indices of a sequence, combine
%% \function{range()} and \function{len()} as follows:

あるシーケンスにわたってインデクスで反復を行うには、
\function{range()} と \function{len()} を次のように組み合わせます:

\begin{verbatim}
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print i, a[i]
... 
0 Mary
1 had
2 a
3 little
4 lamb
\end{verbatim}


\section{\keyword{break} 文と \keyword{continue} 文と
         ループの \keyword{else} 節
         \label{break}}
% \keyword{break} and \keyword{continue} Statements, and
%          \keyword{else} Clauses on Loops

%% The \keyword{break} statement, like in C, breaks out of the smallest
%% enclosing \keyword{for} or \keyword{while} loop.

\keyword{break} 文は、C 言語と同じく、最も内側の
\keyword{for} または \keyword{while} ループを中断します。

%% The \keyword{continue} statement, also borrowed from C, continues
%% with the next iteration of the loop.

\keyword{continue} 文は、これもまた C 言語から借りてきたものですが、
ループを次の反復処理に飛ばします。

%% Loop statements may have an \code{else} clause; it is executed when
%% the loop terminates through exhaustion of the list (with
%% \keyword{for}) or when the condition becomes false (with
%% \keyword{while}), but not when the loop is terminated by a
%% \keyword{break} statement.  This is exemplified by the following loop,
%% which searches for prime numbers:

ループ文は \keyword{else} 節を持つことができます; \keyword{else} 節は、
(\keyword{for} で) 反復処理対象のリストを使い切ってループが終了したとき、
または (\keyword{while} で) 条件が偽になったときに実行されますが、
\keyword{break} 文でループが終了したときは実行されません。
この動作を、素数を探す下記のループを例にとって示します:

\begin{verbatim}
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...            print n, 'equals', x, '*', n/x
...            break
...     else:
...          # 因数が見つからずにループが終了
...          print n, 'is a prime number'
... 
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
\end{verbatim}


\section{\keyword{pass} 文 \label{pass}} % \keyword{pass} Statements

%% The \keyword{pass} statement does nothing.
%% It can be used when a statement is required syntactically but the
%% program requires no action.
%% For example:

\keyword{pass} 文は何もしません。\keyword{pass} は、文を書くことが
構文上要求されているが、プログラム上何の動作もする必要がない時に
使われます。

\begin{verbatim}
>>> while True:
...       pass # キーボード割り込み (keyboard interrupt) をbusy-wait で待つ  
... 
\end{verbatim}


\section{関数を定義する \label{functions}} % Defining Functions

%% We can create a function that writes the Fibonacci series to an
%% arbitrary boundary:

フィボナッチ数列 (Fibonacci series) を任意の上限値まで書き出すような
関数を作成できます:

\begin{verbatim}
>>> def fib(n):    # n までのフィボナッチ級数を出力する
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while b < n:
...         print b,
...         a, b = b, a+b
... 
>>> # 今しがた定義した関数を呼び出す:
... fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
\end{verbatim}

%% The keyword \keyword{def} introduces a function \emph{definition}.  It
%% must be followed by the function name and the parenthesized list of
%% formal parameters.  The statements that form the body of the function
%% start at the next line, and must be indented.  The first statement of
%% the function body can optionally be a string literal; this string
%% literal is the function's \index{documentation strings}documentation
%% string, or \dfn{docstring}.\index{docstrings}\index{strings, documentation}

\keyword{def} は関数の\emph{定義 (definition)} を導くキーワードです。
\keyword{def} の後には、関数名と仮引数 (formal parameter) を
丸括弧で囲んだリストを続けなければなりません。関数の実体を
校正する実行文は次の行から始め、インデントされていなければなりません。
関数の本体の記述する文の最初の行は文字列リテラルにすることもできます;
その場合、文字列は関数の \index{documentation strings}
ドキュメンテーション文字列 (documentation string)、または
\dfn{docstring}\index{docstrings}\index{strings, documentation} 
です。

%% There are tools which use docstrings to automatically produce online
%% or printed documentation, or to let the user interactively browse
%% through code; it's good practice to include docstrings in code that
%% you write, so try to make a habit of it.

ドキュメンテーション文字列を使ったツールには、オンライン文書や
印刷文書を自動的に生成したり、ユーザが対話的にコードを閲覧できる
ようにするものがあります; 自分が書くコードにドキュメンテーション
文字列を入れるのはよい習慣です。書く癖をつけるようにしてください。

%% The \emph{execution} of a function introduces a new symbol table used
%% for the local variables of the function.  More precisely, all variable
%% assignments in a function store the value in the local symbol table;
%% whereas variable references first look in the local symbol table, then
%% in the global symbol table, and then in the table of built-in names.
%% Thus,  global variables cannot be directly assigned a value within a
%% function (unless named in a \keyword{global} statement), although
%% they may be referenced.

関数を \emph{実行 (execution)} すると、関数のローカル変数のために
使われる新たなシンボルテーブル (symbol table) が取り込まれます。
もっと正確にいうと、関数内で変数への代入を行うと、その値はすべて
このローカルなシンボルテーブルに記憶されます; 一方、変数の参照を
行うと、まずローカルなシンボルテーブルが検索され、その後グローバル
なシンボルテーブルを調べ、最後に組み込みの名前テーブルを調べます。
従って、関数の中では、グローバルな変数を参照することはできますが、
直接値を代入することは (\keyword{global} 文で名前を挙げておかない限り) 
できません。

%% The actual parameters (arguments) to a function call are introduced in
%% the local symbol table of the called function when it is called; thus,
%% arguments are passed using \emph{call by value} (where the
%% \emph{value} is always an object \emph{reference}, not the value of
%% the object).\footnote{
%%          Actually, \emph{call by object reference} would be a better
%%          description, since if a mutable object is passed, the caller
%%          will see any changes the callee makes to it (items
%%          inserted into a list).
%% } When a function calls another function, a new local symbol table is
%% created for that call.

関数を呼び出す際の実際のパラメタ (引数) は、関数が呼び出されるときに
関数のローカルなシンボルテーブル内に取り込まれます; そうすることで、
引数は \emph{値渡し (call by value)} で関数に渡されることになります
(ここでの \emph{値 (value)} とは常にオブジェクトへの
\emph{参照 (reference)} をいい、オブジェクトの値そのものでは
ありません)
\footnote{
実際には、\emph{オブジェクトへの参照渡し (call by object reference) }
と書けばよいのかもしれません。というのは、変更可能なオブジェクトが
渡されると、関数の呼び出し側は、呼び出された側の関数がオブジェクト
に (リストに値が挿入されるといった) 何らかの変更に出くわすことに
なるからです。}
。
ある関数がほかの関数を呼び出すときには、新たな呼び出しのために
ローカルなシンボルテーブルが新たに作成されます。

%% A function definition introduces the function name in the current
%% symbol table.  The value of the function name
%% has a type that is recognized by the interpreter as a user-defined
%% function.  This value can be assigned to another name which can then
%% also be used as a function.  This serves as a general renaming
%% mechanism:

関数の定義を行うと、関数名は現在のシンボルテーブル内に取り入れられます。
関数名の値は、インタプリタからはユーザ定義関数 (user-defined function)
として認識される型を持ちます。この値は別の名前に代入して、
その名前を後に関数として使うこともできます。
これは一般的な名前変更のメカニズムとして働きます。

\begin{verbatim}
>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
1 1 2 3 5 8 13 21 34 55 89
\end{verbatim}

%% You might object that \code{fib} is not a function but a procedure.  In
%% Python, like in C, procedures are just functions that don't return a
%% value.  In fact, technically speaking, procedures do return a value,
%% albeit a rather boring one.  This value is called \code{None} (it's a
%% built-in name).  Writing the value \code{None} is normally suppressed by
%% the interpreter if it would be the only value written.  You can see it
%% if you really want to:

\code{fib} は関数ではなく手続き (procedure) だと異論があるかも
しれませんね。Python では C 言語と同様、手続きはただの関数で、
値を返さないに過ぎません。技術的に言えば、実際には手続きも
ややつまらない値ですが値を返しています。この値は \code{None}
と呼ばれます (これは組み込みの名前です)。\code{None} だけを
書き出そうとすると、インタプリタは通常出力を抑制します。
本当に出力したいのなら、以下のようにすると見ることができます:

\begin{verbatim}
>>> print fib(0)
None
\end{verbatim}

%% It is simple to write a function that returns a list of the numbers of
%% the Fibonacci series, instead of printing it:

フィボナッチ数列の数からなるリストを出力する代わりに、値を返すような
関数を書くのは簡単です:

\begin{verbatim}
>>> def fib2(n): #  n までのフィボナッチ級数を返す
...     """Return a list containing the Fibonacci series up to n."""
...     result = []
...     a, b = 0, 1
...     while b < n:
...         result.append(b)    # 下記参照
...         a, b = b, a+b
...     return result
... 
>>> f100 = fib2(100)    # 関数を呼び出す
>>> f100                # 結果を出力する
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{verbatim}

%% This example, as usual, demonstrates some new Python features:

例によって、この例は Python の新しい機能を示しています:

\begin{itemize}

\item
%% The \keyword{return} statement returns with a value from a function.
%% \keyword{return} without an expression argument returns \code{None}.
%% Falling off the end of a procedure also returns \code{None}.
\keyword{return} 文では、関数から一つ値を返します。
\keyword{return} の引数となる式がない場合、 \code{None} が返ります。
手続きが終了したときにも \code{None} が返ります。

\item
%% The statement \code{result.append(b)} calls a \emph{method} of the list
%% object \code{result}.  A method is a function that `belongs' to an
%% object and is named \code{obj.methodname}, where \code{obj} is some
%% object (this may be an expression), and \code{methodname} is the name
%% of a method that is defined by the object's type.  Different types
%% define different methods.  Methods of different types may have the
%% same name without causing ambiguity.  (It is possible to define your
%% own object types and methods, using \emph{classes}, as discussed later
%% in this tutorial.)
%% The method \method{append()} shown in the example, is defined for
%% list objects; it adds a new element at the end of the list.  In this
%% example it is equivalent to \samp{result = result + [b]}, but more
%% efficient.
文 \code{result.append(b)} では、リストオブジェクト \code{result}
の \emph{メソッド (method)} を呼び出しています。
メソッドとは、オブジェクトに `属している' 関数のことで、
\code{obj} を何らかのオブジェクト (式であっても構いません)、
\code{methodname} をそのオブジェクトで定義されているメソッド名
とすると、\code{obj.methodname} と書き表されます。
異なる型は異なるメソッドを定義しています。異なる型のメソッドで
同じ名前のメソッドを持つことができ、あいまいさを生じることはありません。
(自前のオブジェクト型とメソッドを定義することもできます。これには、
後でこのチュートリアルで述べる \emph{クラス (class)} を使います。)
例で示されているメソッド \method{append()} は、リストオブジェクトで
定義されています; このメソッドはリストの末尾に新たな要素を追加します。
この例での \method{append()} は \samp{result = result + [b]} と等価
ですが、より効率的です。

\end{itemize}

\section{関数定義についてもう少し \label{defining}} % More on Defining Functions

%% It is also possible to define functions with a variable number of
%% arguments.  There are three forms, which can be combined.

可変個の引数を伴う関数を定義することもできます。引数の定義方法には
 3 つの形式があり、それらを組み合わせることができます。

\subsection{デフォルトの引数値 \label{defaultArgs}} % Default Argument Values

%% The most useful form is to specify a default value for one or more
%% arguments.  This creates a function that can be called with fewer
%% arguments than it is defined

もっとも便利なのは、一つ以上の引数に対してデフォルトの値を指定する
形式です。この形式を使うと、定義されている引数より少ない個数の引数
で呼び出せる関数を作成します:


\begin{verbatim}
def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
    while True:
        ok = raw_input(prompt)
        if ok in ('y', 'ye', 'yes'): return True
        if ok in ('n', 'no', 'nop', 'nope'): return False
        retries = retries - 1
        if retries < 0: raise IOError, 'refusenik user'
        print complaint
\end{verbatim}

%% This function can be called either like this:
%% \code{ask_ok('Do you really want to quit?')} or like this:
%% \code{ask_ok('OK to overwrite the file?', 2)}.

この関数は、 \code{ask_ok('Do you really want to quit?')} のようにも、
\code{ask_ok('OK to overwrite the file?', 2)} のようにも呼び出す
ことができます。

%% The default values are evaluated at the point of function definition
%% in the \emph{defining} scope, so that

デフォルト値は、関数が定義された時点で、関数を \emph{定義している} 側の
スコープ (scope) で評価されるので、

\begin{verbatim}
i = 5

def f(arg=i):
    print arg

i = 6
f()
\end{verbatim}

%% will print \code{5}.

は \code{5} を出力します。

%% \strong{Important warning:}  The default value is evaluated only once.
%% This makes a difference when the default is a mutable object such as a
%% list or dictionary.  For example, the following function accumulates
%% the arguments passed to it on subsequent calls:

\strong{重要な警告:}  デフォルト値は 1 度だけしか評価されません。
デフォルト値がリストや辞書のような変更可能なオブジェクトの時には
その影響がでます。例えば以下の関数は、後に続く関数呼び出しで
関数に渡されている引数を累積します:

\begin{verbatim}
def f(a, L=[]):
    L.append(a)
    return L

print f(1)
print f(2)
print f(3)
\end{verbatim}

%% This will print

このコードは、

\begin{verbatim}
[1]
[1, 2]
[1, 2, 3]
\end{verbatim}

を出力します。

%% If you don't want the default to be shared between subsequent calls,
%% you can write the function like this instead:

後続の関数呼び出しでデフォルト値を共有したくなければ、
代わりに以下のように関数を書くことができます:

\begin{verbatim}
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
\end{verbatim}

\subsection{キーワード引数 \label{keywordArgs}} % Keyword Arguments

%% Functions can also be called using
%% keyword arguments of the form \samp{\var{keyword} = \var{value}}.  For
%% instance, the following function:

関数を \samp{\var{keyword} = \var{value}} という形式のキーワード引数を
使って呼び出すこともできます。例えば、以下の関数:

\begin{verbatim}
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print "-- This parrot wouldn't", action,
    print "if you put", voltage, "volts through it."
    print "-- Lovely plumage, the", type
    print "-- It's", state, "!"
\end{verbatim}

%% could be called in any of the following ways:

は、以下のいずれの方法でも呼び出せます:

\begin{verbatim}
parrot(1000)
parrot(action = 'VOOOOOM', voltage = 1000000)
parrot('a thousand', state = 'pushing up the daisies')
parrot('a million', 'bereft of life', 'jump')
\end{verbatim}

%% but the following calls would all be invalid:

しかし、以下の呼び出しはすべて不正なものです:

\begin{verbatim}
parrot()                     # 必要な引数がない
parrot(voltage=5.0, 'dead')  # キーワード引数の後に非キーワード引数がある
parrot(110, voltage=220)     # 引数に対して値が重複している
parrot(actor='John Cleese')  # 未知のキーワードを使用している
\end{verbatim}

%% In general, an argument list must have any positional arguments
%% followed by any keyword arguments, where the keywords must be chosen
%% from the formal parameter names.  It's not important whether a formal
%% parameter has a default value or not.  No argument may receive a
%% value more than once --- formal parameter names corresponding to
%% positional arguments cannot be used as keywords in the same calls.
%% Here's an example that fails due to this restriction:

一般に、引数リストでは、固定引数 (positional argument) の後ろに
キーワード引数を置かねばならず、キーワードは仮引数名から選ばなければ
なりません。仮引数がデフォルト値を持っているかどうかは重要では
ありません。引数はいずれも一つ以上の値を受け取りません ---
同じ関数呼び出しの中では、固定引数に対応づけられた仮引数名を
キーワードとして使うことはできません。この制限のために
実行が失敗する例を以下に示します。

\begin{verbatim}
>>> def function(a):
...     pass
... 
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: function() got multiple values for keyword argument 'a'
\end{verbatim}

%% When a final formal parameter of the form \code{**\var{name}} is
%% present, it receives a \ulink{dictionary}{../lib/typesmapping.html}
%% containing all keyword arguments except for those corresponding to
%% a formal parameter.  This may be
%% combined with a formal parameter of the form
%% \code{*\var{name}} (described in the next subsection) which receives a
%% tuple containing the positional arguments beyond the formal parameter
%% list.  (\code{*\var{name}} must occur before \code{**\var{name}}.)
%% For example, if we define a function like this:

仮引数の最後に \code{**\var{name}} の形式のものがあると、
それまでの仮引数に対応したものをのぞくすべてのキーワード引数が入った
\ulink{辞書}{../lib/typesmapping.html} を受け取ります。
 \code{**\var{name}} は \code{*\var{name}} の形式をとる、仮引数のリスト
を超えた固定引数の入ったタプルを受け取る引数 (次の節で述べます) 
と組み合わせることができます。
(\code{*\var{name}} は \code{**\var{name}} より前になければなりません)。
例えば、ある関数の定義を以下:

\begin{verbatim}
def cheeseshop(kind, *arguments, **keywords):
    print "-- Do you have any", kind, '?'
    print "-- I'm sorry, we're all out of", kind
    for arg in arguments: print arg
    print '-'*40
    keys = keywords.keys()
    keys.sort()
    for kw in keys: print kw, ':', keywords[kw]
\end{verbatim}

%% It could be called like this:

のようにすると、呼び出しは以下:

\begin{verbatim}
cheeseshop('Limburger', "It's very runny, sir.",
           "It's really very, VERY runny, sir.",
           client='John Cleese',
           shopkeeper='Michael Palin',
           sketch='Cheese Shop Sketch')
\end{verbatim}

%% and of course it would print:

のようになり、もちろん以下のように出力されます:

\begin{verbatim}
-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
\end{verbatim}

%% Note that the \method{sort()} method of the list of keyword argument
%% names is called before printing the contents of the \code{keywords}
%% dictionary; if this is not done, the order in which the arguments are
%% printed is undefined.

キーワード引数名のリストに対して \method{sort()} を呼び出した後に
\code{keywords} 辞書の内容を出力していることに注意してください;
\method{sort()} が呼び出されていないと、引数が出力される順番は
不確定となります。

\subsection{任意引数リスト \label{arbitraryArgs}} % Arbitrary Argument Lists

%% Finally, the least frequently used option is to specify that a
%% function can be called with an arbitrary number of arguments.  These
%% arguments will be wrapped up in a tuple.  Before the variable number
%% of arguments, zero or more normal arguments may occur.

最後に、最も使うことの少ない選択肢として、関数が任意の個数の引数で
呼び出せるよう指定する方法があります。これらの引数はタプルに
くるまれます。可変個の引数の前に、ゼロ個かそれ以上の引数があっても
構いません。

\begin{verbatim}
def fprintf(file, format, *args):
    file.write(format % args)
\end{verbatim}

\subsection{引数リストのアンパック\label{unpacking-arguments}} 
引数がすでにリストやタプルになっていて、個別な固定引数を要求する
関数呼び出しに渡すためにアンパックする必要がある場合には、逆の
状況が起こります。例えば、組み込み関数 \function{range()} は
引数 \var{start} と \var{stop} を別に与える必要があります。
個別に引数を与えることができない場合、関数呼び出しを
\code{*} 演算子を使って書き、リストやタプルから引数をアンパック
します:
 
\begin{verbatim} 
>>> range(3, 6)             # 個別の引数を使った通常の呼び出し
[3, 4, 5] 
>>> args = [3, 6] 
>>> range(*args)            # リストからアンパックされた引数での呼び出し
[3, 4, 5] 
\end{verbatim} 


%% In the same fashion, dictionaries can deliver keyword arguments with the
%% \code{**}-operator:

同じやりかたで、\code{**}オペレータを使って辞書でもキーワード引数を 
渡すことができます:

\begin{verbatim}
>>> def parrot(voltage, state='a stiff', action='voom'):
...     print "-- This parrot wouldn't", action,
...     print "if you put", voltage, "volts through it.",
...     print "E's", state, "!"
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
\end{verbatim}

\subsection{ラムダ形式 \label{lambda}} % Lambda Forms

%% By popular demand, a few features commonly found in functional
%% programming languages like Lisp have been added to Python.  With the
%% \keyword{lambda} keyword, small anonymous functions can be created.
%% Here's a function that returns the sum of its two arguments:
%% \samp{lambda a, b: a+b}.  Lambda forms can be used wherever function
%% objects are required.  They are syntactically restricted to a single
%% expression.  Semantically, they are just syntactic sugar for a normal
%% function definition.  Like nested function definitions, lambda forms
%% can reference variables from the containing scope:

多くの人の要望により、Lispのような関数型プログラミング言語によくある
いくつかの機能が Python に加えられました。
キーワード \keyword{lambda} を使うと、名前のない小さな関数を生成できます。
例えば \samp{lambda a, b: a+b} は、二つの引数の和を返す関数です。
ラムダ形式 (lambda form) は、関数オブジェクトが要求されている場所
にならどこでも使うことができます。ラムダ形式は、構文上単一の式に
制限されています。意味付け的には、ラムダ形式はただ通常の関数に
構文的な糖衣をかぶせたものに過ぎません。入れ子構造になった関数定義
と同様、ラムダ形式もそれを取り囲むスコープから変数を参照することが
できます。

\begin{verbatim}
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
\end{verbatim}


\subsection{ドキュメンテーション文字列 \label{docstrings}} % Documentation Strings

%% There are emerging conventions about the content and formatting of
%% documentation strings.

ドキュメンテーション文字列については、その内容と書式に関する
慣習ができつつあります。
\index{docstrings}\index{documentation strings}
\index{strings, documentation}

%% The first line should always be a short, concise summary of the
%% object's purpose.  For brevity, it should not explicitly state the
%% object's name or type, since these are available by other means
%% (except if the name happens to be a verb describing a function's
%% operation).  This line should begin with a capital letter and end with
%% a period.

最初の行は、常に対象物の目的を短く簡潔にまとめたものでなくてはなりません。
簡潔に書くために、対象物の名前や型を明示する必要はありません。
名前や型は他の方法でも得られるからです (名前がたまたま関数の演算内容
を記述する動詞である場合は例外です)。
最初の行は大文字で始まり、ピリオドで終わっていなければなりません。

%% If there are more lines in the documentation string, the second line
%% should be blank, visually separating the summary from the rest of the
%% description.  The following lines should be one or more paragraphs
%% describing the object's calling conventions, its side effects, etc.

ドキュメンテーション文字列中にさらに記述すべき行がある場合、
二行目は空行にし、まとめの行と残りの記述部分を視覚的に分離
します。つづく行は一つまたはそれ以上の段落で、対象物の
呼び出し規約や副作用について記述します。

%% The Python parser does not strip indentation from multi-line string
%% literals in Python, so tools that process documentation have to strip
%% indentation if desired.  This is done using the following convention.
%% The first non-blank line \emph{after} the first line of the string
%% determines the amount of indentation for the entire documentation
%% string.  (We can't use the first line since it is generally adjacent
%% to the string's opening quotes so its indentation is not apparent in
%% the string literal.)  Whitespace ``equivalent'' to this indentation is
%% then stripped from the start of all lines of the string.  Lines that
%% are indented less should not occur, but if they occur all their
%% leading whitespace should be stripped.  Equivalence of whitespace
%% should be tested after expansion of tabs (to 8 spaces, normally).

Python のパーザは複数行にわたる Python 文字列リテラルからインデントを
剥ぎ取らないので、ドキュメントを処理するツールでは必要に応じて
インデントを剥ぎ取らなければなりません。この処理は以下の規約に従って
行います。最初の行の \emph{後にある} 空行でない最初の行が、ドキュメント
全体のインデントの量を決めます。 (最初の行は通常、文字列を開始する
クオートに隣り合っているので、インデントが文字列リテラル中に現れない
ためです。) このインデント量と ``等価な'' 空白が、文字列のすべての
行頭から剥ぎ取られます。インデントの量が少ない行を書いてはならないの
ですが、もしそういう行があると、先頭の空白すべてが剥ぎ取られます。
インデントの空白の大きさが等しいかどうかは、タブ文字を (通常は 8 文字の
スペースとして) 展開した後に調べられます。

%% Here is an example of a multi-line docstring:

以下に複数行のドキュメンテーション文字列の例を示します:

\begin{verbatim}
>>> def my_function():
...     """Do nothing, but document it.
... 
...     No, really, it doesn't do anything.
...     """
...     pass
... 
>>> print my_function.__doc__
Do nothing, but document it.

    No, really, it doesn't do anything.
    
\end{verbatim}



\chapter{データ構造 \label{structures}} % Data Structures

%% This chapter describes some things you've learned about already in
%% more detail, and adds some new things as well.

この章では、すでに学んだことについてより詳しく説明するとともに、
いくつか新しいことを追加します。


\section{リスト型についてもう少し \label{moreLists}} % More on Lists

%% The list data type has some more methods.  Here are all of the methods
%% of list objects:

リストデータ型には、他にもいくつかメソッドがあります。リストオブジェクト
のすべてのメソッドを以下に示します:

\begin{methoddesc}[list]{append}{x}
%% Add an item to the end of the list;
%% equivalent to \code{a[len(a):] = [\var{x}]}.
リストの末尾に要素を一つ追加します。
\code{a[len(a):] = [\var{x}]} と等価です。
\end{methoddesc}

\begin{methoddesc}[list]{extend}{L}
%% Extend the list by appending all the items in the given list;
%% equivalent to \code{a[len(a):] = \var{L}}.
指定したリスト中のすべての要素を対象のリストに追加し、リストを
拡張します。
\code{a[len(a):] = \var{L}} と等価です。
\end{methoddesc}

\begin{methoddesc}[list]{insert}{i, x}
%% Insert an item at a given position.  The first argument is the index
%% of the element before which to insert, so \code{a.insert(0, \var{x})}
%% inserts at the front of the list, and \code{a.insert(len(a), \var{x})}
%% is equivalent to \code{a.append(\var{x})}.
指定した位置に要素を挿入します。
第 1 引数は、リストのインデクスで、そのインデクスを持つ要素の直前に挿入
が行われます。従って、\code{a.insert(0, \var{x})} はリストの先頭に挿入
を行います。また \code{a.insert(len(a), \var{x})} は \code{a.append(x)} 
と等価です。
\end{methoddesc}

\begin{methoddesc}[list]{remove}{x}
%% Remove the first item from the list whose value is \var{x}.
%% It is an error if there is no such item.
リスト中で、値 \var{x} を持つ最初の要素を削除します。
該当する項目がなければエラーとなります。
\end{methoddesc}

\begin{methoddesc}[list]{pop}{\optional{i}}
%% Remove the item at the given position in the list, and return it.  If
%% no index is specified, \code{a.pop()} removes and returns the last item
%% in the list.  (The square brackets
%% around the \var{i} in the method signature denote that the parameter
%% is optional, not that you should type square brackets at that
%% position.  You will see this notation frequently in the
%% \citetitle[../lib/lib.html]{Python Library Reference}.)
リスト中の指定された位置にある要素をリストから削除して、その要素を
返します。インデクスが指定されなければ、\code{a.pop()} はリストの
末尾の要素を削除して、返します。この場合も要素は削除されます。
(メソッドの用法 (signature) で \var{i} の両側にある角括弧は、
この引数がオプションであることを表しているだけなので、角括弧を
入力する必要はありません。この表記法は
\citetitle[../lib/lib.html]{Python Library Reference}
の中で頻繁に見ることになるでしょう。)
\end{methoddesc}

\begin{methoddesc}[list]{index}{x}
%% Return the index in the list of the first item whose value is \var{x}.
%% It is an error if there is no such item.
リスト中で、値 \var{x} を持つ最初の要素のインデクスを返します。
該当する項目がなければエラーとなります。
\end{methoddesc}

\begin{methoddesc}[list]{count}{x}
%% Return the number of times \var{x} appears in the list.
リストでの \var{x} の出現回数を返します。
\end{methoddesc}

\begin{methoddesc}[list]{sort}{}
%% Sort the items of the list, in place.
リストの項目を、インプレース演算 (in place、元のデータを演算結果で
置き換えるやりかた) でソートします。
\end{methoddesc}

\begin{methoddesc}[list]{reverse}{}
%% Reverse the elements of the list, in place.
リストの要素を、インプレース演算で逆順にします。
\end{methoddesc}

%% An example that uses most of the list methods:

以下にリストのメソッドをほぼ全て使った例を示します:

\begin{verbatim}
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print a.count(333), a.count(66.25), a.count('x')
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
\end{verbatim}


\subsection{リストをスタックとして使う \label{lists-as-stacks}} % Using Lists as Stacks
\sectionauthor{Ka-Ping Yee}{ping@lfw.org}

%% The list methods make it very easy to use a list as a stack, where the
%% last element added is the first element retrieved (``last-in,
%% first-out'').  To add an item to the top of the stack, use
%% \method{append()}.  To retrieve an item from the top of the stack, use
%% \method{pop()} without an explicit index.  For example:

リスト型のメソッドのおかげで、簡単にリストをスタックとして使えます。
スタックでは、最後に追加された要素が最初に取り出されます
(``last-in, first-out'') 。スタックの一番上に要素を追加するには
\method{append()} を使います。スタックの一番上から要素を取り出すには
\method{pop()} をインデクスを指定せずに使います。
例えば以下のようにします:

\begin{verbatim}
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
\end{verbatim}


\subsection{リストをキューとして使う \label{lists-as-queues}} % Using Lists as Queues
\sectionauthor{Ka-Ping Yee}{ping@lfw.org}

%% You can also use a list conveniently as a queue, where the first
%% element added is the first element retrieved (``first-in,
%% first-out'').  To add an item to the back of the queue, use
%% \method{append()}.  To retrieve an item from the front of the queue,
%% use \method{pop()} with \code{0} as the index.  For example:

リストをキュー (queue) として手軽に使うこともできます。
キューでは、最初に追加された要素が最初に取り出されます
(``first-in, first-out'')。キューの末尾に項目を追加するには
\method{append()} を使います。キューの先頭から項目を取り出すには 
インデクスに \code{0} を指定して \method{pop()} を使います。
例えば以下のようにします:

\begin{verbatim}
>>> queue = ["Eric", "John", "Michael"]
>>> queue.append("Terry")           # Terry が到着 (arrive) する
>>> queue.append("Graham")          # Graham が到着する
>>> queue.pop(0)
'Eric'
>>> queue.pop(0)
'John'
>>> queue
['Michael', 'Terry', 'Graham']
\end{verbatim}


\subsection{実用的なプログラミングツール \label{functional}} % Functional Programming Tools

%% There are three built-in functions that are very useful when used with
%% lists: \function{filter()}, \function{map()}, and \function{reduce()}.

組み込み関数には、リストで使うと非常に便利なものが三つあります:
\function{filter()} 、 \function{map()} 、\function{reduce()} です。

%% \samp{filter(\var{function}, \var{sequence})} returns a sequence
%% consisting of those items from the
%% sequence for which \code{\var{function}(\var{item})} is true.
%% If \var{sequence} is a \class{string} or \class{tuple}, the result will
%% be of the same type; otherwise, it is always a \class{list}.
%% For example, to compute some primes:

\samp{filter(\var{function}, \var{sequence})} は、
シーケンス \var{sequence} 中の要素 \var{item} から、
\code{\var{function}(\var{item})} が真となるような要素からなる
シーケンスを返します。
もし \var{sequence} が \class{string}か \class{tuple}なら、
返り値も同じタイプになります。そうでなければ \class{list}になります。
例えば、いくつかの素数を計算するには以下のようにします:

\begin{verbatim}
>>> def f(x): return x % 2 != 0 and x % 3 != 0
...
>>> filter(f, range(2, 25))
[5, 7, 11, 13, 17, 19, 23]
\end{verbatim}

%% \samp{map(\var{function}, \var{sequence})} calls
%% \code{\var{function}(\var{item})} for each of the sequence's items and
%% returns a list of the return values.  For example, to compute some
%% cubes:

\samp{map(\var{function}, \var{sequence})} は、
シーケンス \var{sequence} の各要素 \var{item} に対して
\code{\var{function}(\var{item})} を呼び出し、その戻り値からなる
リストを返します。例えば、三乗された値の列を計算するには以下のように
します:

\begin{verbatim}
>>> def cube(x): return x*x*x
...
>>> map(cube, range(1, 11))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
\end{verbatim}

%% More than one sequence may be passed; the function must then have as
%% many arguments as there are sequences and is called with the
%% corresponding item from each sequence (or \code{None} if some sequence
%% is shorter than another). For example:

\begin{verbatim}
>>> seq = range(8)
>>> def add(x, y): return x+y
...
>>> map(add, seq, seq)
[0, 2, 4, 6, 8, 10, 12, 14]
\end{verbatim}

%% \samp{reduce(\var{function}, \var{sequence})} returns a single value
%% constructed by calling the binary function \var{function} on the first two
%% items of the sequence, then on the result and the next item, and so
%% on.  For example, to compute the sum of the numbers 1 through 10:

\samp{reduce(\var{function}, \var{sequence})} は単一の値を返します。
この値は 2 つの引数をとる関数 \var{function} をシーケンス \var{sequence} の最初の
二つの要素を引数として呼び出し、次にその結果とシーケンスの次の要素を
引数にとり、以降これを繰り返すことで構成します。
例えば、 1 から 10 までの数の総和を計算するには以下のようにします:

\begin{verbatim}
>>> def add(x,y): return x+y
...
>>> reduce(add, range(1, 11))
55
\end{verbatim}

%% If there's only one item in the sequence, its value is returned; if
%% the sequence is empty, an exception is raised.

シーケンス中にただ一つしか要素がなければ、その値自体が返されます;
シーケンスが空なら、例外が送出されます。

%% A third argument can be passed to indicate the starting value.  In this
%% case the starting value is returned for an empty sequence, and the
%% function is first applied to the starting value and the first sequence
%% item, then to the result and the next item, and so on.  For example,

3 つめの引数をわたして、初期値を指定することもできます。
この場合、空のシーケンスを渡すと初期値が返されます。それ以外の場合には、
まず初期値とシーケンス中の最初の要素に対して関数が適用され、次いでその結果
とシーケンスの次の要素に対して適用され、以降これが繰り返されます。例えば
以下のようになります:

\begin{verbatim}
>>> def sum(seq):
...     def add(x,y): return x+y
...     return reduce(add, seq, 0)
... 
>>> sum(range(1, 11))
55
>>> sum([])
0
\end{verbatim}

%% Don't use this example's definition of \function{sum()}: since summing
%% numbers is such a common need, a built-in function
%% \code{sum(\var{sequence})} is already provided, and works exactly like
%% this.
%% \versionadded{2.3}

(2.3 以降では) 実際には、上の例のように \function{sum()} を定義しないでください:
数値の合計は広く必要とされている操作なので、すでに組み込み関数 
\code{sum(\var{sequence})} が提供されており、上の例と全く同様に
動作します。
\versionadded{2.3}

\subsection{リストの内包表記} % List Comprehensions

%% List comprehensions provide a concise way to create lists without resorting
%% to use of \function{map()}, \function{filter()} and/or \keyword{lambda}.
%% The resulting list definition tends often to be clearer than lists built
%% using those constructs.  Each list comprehension consists of an expression
%% followed by a \keyword{for} clause, then zero or more \keyword{for} or
%% \keyword{if} clauses.  The result will be a list resulting from evaluating
%% the expression in the context of the \keyword{for} and \keyword{if} clauses
%% which follow it.  If the expression would evaluate to a tuple, it must be
%% parenthesized.

リストの内包表記 (list comprehension) は、リストの生成を
\function{map()} や \function{filter()} や \keyword{lambda} の使用に
頼らずに行うための簡潔な方法を提供しています。
結果として得られるリストの定義は、しばしば上記の構文を使ってリストを
生成するよりも明快になります。各々のリストの内包表記は、
式、続いて \keyword{for} 節、そしてその後ろに続くゼロ個かそれ以上の
\keyword{for} 節または \keyword{if} 節からなります。
式をタプルで評価したいなら、丸括弧で囲わなければなりません。

\begin{verbatim}
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> vec = [2, 4, 6]
>>> [3*x for x in vec]
[6, 12, 18]
>>> [3*x for x in vec if x > 3]
[12, 18]
>>> [3*x for x in vec if x < 2]
[]
>>> [[x,x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
>>> [x, x**2 for x in vec]  # エラー - タプルには丸かっこが必要
  File "<stdin>", line 1, in ?
    [x, x**2 for x in vec]
               ^
SyntaxError: invalid syntax
>>> [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]
>>> vec1 = [2, 4, 6]
>>> vec2 = [4, 3, -9]
>>> [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
>>> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
>>> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
\end{verbatim}

%% List comprehensions are much more flexible than \function{map()}
%% and can be applied to complex expressions and nested functions:

リストの内包表記は \function{map()} よりもはるかに柔軟性があり、
複雑な式や入れ子になった関数でも利用できます:

\begin{verbatim}
>>> [str(round(355/113.0, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
\end{verbatim}


\section{\keyword{del} 文 \label{del}} % The \keyword{del} statement

%% There is a way to remove an item from a list given its index instead
%% of its value: the \keyword{del} statement.  This can also be used to
%% remove slices from a list (which we did earlier by assignment of an
%% empty list to the slice).  For example:
%% of its value: the \keyword{del} statement.  This differs from the
%% \method{pop()}) method which returns a value.  The \keyword{del}
%% statement can also be used to remove slices from a list or clear the
%% entire list (which we did earlier by assignment of an empty list to
%% the slice).  For example:

指定された値の要素をリストから削除する代わりに、インデクスで指定する
方法があります: それが \keyword{del} 文です。これは\method{pop()}メソッ
ドとちがい、値を返しません。\keyword{del}文はリストから
スライスを除去したり、リスト全体を削除することもできます (以前はスライスに空のリストを代入
して行っていました)。例えば以下のようにします:

\begin{verbatim}
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
\end{verbatim}

%% \keyword{del} can also be used to delete entire variables:

\keyword{del} は変数全体の削除にも使えます:

\begin{verbatim}
>>> del a
\end{verbatim}

%% Referencing the name \code{a} hereafter is an error (at least until
%% another value is assigned to it).  We'll find other uses for
%% \keyword{del} later.

この文の後で名前 \code{a} を参照すると、(別の値を \code{a} に
代入するまで) エラーになります。\keyword{del} の別の用途について
はまた後で取り上げます。


\section{タプルとシーケンス \label{tuples}} % Tuples and Sequences

%% We saw that lists and strings have many common properties, such as
%% indexing and slicing operations.  They are two examples of
%% \ulink{\emph{sequence}} data types}{../lib/typesseq.html}.  Since Python is an evolving language,
%% other sequence data types may be added.  There is also another
%% standard sequence data type: the \emph{tuple}.

リストや文字列には、インデクスやスライスを使った演算のように、
数多くの共通の性質があることを見てきました。これらは
\ulink{\emph{シーケンス (sequence)} データ型}{../lib/typesseq.html} 
の二つの例です。Python はまだ
進歩の過程にある言語なので、他のシーケンスデータ型が追加されるかも
しれません。標準のシーケンス型はもう一つあります: \emph{タプル (tuple)}
型です。

%% A tuple consists of a number of values separated by commas, for
%% instance:

タプルはコンマで区切られたいくつかの値からなります。例えば以下の
ように書きます:

\begin{verbatim}
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # タプルを入れ子にしてもよい
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
\end{verbatim}

%% As you see, on output tuples are alway enclosed in parentheses, so
%% that nested tuples are interpreted correctly; they may be input with
%% or without surrounding parentheses, although often parentheses are
%% necessary anyway (if the tuple is part of a larger expression).

ご覧のように、タプルは常に丸括弧で囲われています。これは、入れ子に
なったタプルが正しく解釈されるようにするためです; 入力の際には
丸括弧なしでもかまいませんが、結局 (タプルがより大きな式の
一部分の場合) たいてい必要となります。

%% Tuples have many uses.  For example: (x, y) coordinate pairs, employee
%% records from a database, etc.  Tuples, like strings, are immutable: it
%% is not possible to assign to the individual items of a tuple (you can
%% simulate much of the same effect with slicing and concatenation,
%% though).  It is also possible to create tuples which contain mutable
%% objects, such as lists.

タプルの用途はたくさんあります。例えば、(x, y) 座標対、データベースから
取り出した従業員レコードなどです。タプルは文字列と同じく、変更不能です:
タプルの個々の要素に代入を行うことはできません (スライスと連結を使って
同じ効果を実現することはできますが)。リストのような変更可能な
オブジェクトの入ったタプルを作成することもできます。

%% A special problem is the construction of tuples containing 0 or 1
%% items: the syntax has some extra quirks to accommodate these.  Empty
%% tuples are constructed by an empty pair of parentheses; a tuple with
%% one item is constructed by following a value with a comma
%% (it is not sufficient to enclose a single value in parentheses).
%% Ugly, but effective.  For example:

問題は 0 個または 1 個の項目からなるタプルの構築です: これらの操作を
行うため、構文には特別な細工がされています。空のタプルは
空の丸括弧ペアで構築できます; 一つの要素を持つタプルは、
値の後ろにコンマを続ける (単一の値を丸括弧で囲むだけでは不十分です)
ことで構築できます。美しくはないけれども、効果的です。例えば以下の
ようにします:

\begin{verbatim}
>>> empty = ()
>>> singleton = 'hello',    # <-- 末尾のコンマに注目
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
\end{verbatim}

%% The statement \code{t = 12345, 54321, 'hello!'} is an example of
%% \emph{tuple packing}: the values \code{12345}, \code{54321} and
%% \code{'hello!'} are packed together in a tuple.  The reverse operation
%% is also possible:

文 \code{t = 12345, 54321, 'hello!'} は
\emph{タプルのパック (tuple packing)} の例です: 値 \code{12345} 、
\code{54321} 、および \code{'hello!'} が一つのタプルにパックされます。
逆の演算も可能です:

\begin{verbatim}
>>> x, y, z = t
\end{verbatim}

%% This is called, appropriately enough, \emph{sequence unpacking}.
%% Sequence unpacking requires the list of variables on the left
%% have the same number of elements as the length of the sequence.  Note
%% that multiple assignment is really just a combination of tuple packing
%% and sequence unpacking!

この操作は、\emph{シーケンスのアンパック (sequence unpacking)} とでも
呼ぶべきものです。シーケンスのアンパックでは、左辺に列挙されている
変数が、右辺のシーケンスの長さと同じであることが要求されます。
複数同時の代入が実はタプルのパックとシーケンスのアンパックを
組み合わせたものに過ぎないことに注意してください！

%% There is a small bit of asymmetry here:  packing multiple values
%% always creates a tuple, and unpacking works for any sequence.

この操作にはわずかな非対称性があります: 複数の値をパックすると
常にタプルが生成されますが、アンパックはどのシーケンスにも働きます。

% XXX Add a bit on the difference between tuples and lists.

\section{集合型 \label{sets}} % Sets

% Python also includes a data type for \emph{sets}.  A set is an unordered
% collection with no duplicate elements.  Basic uses include membership
% testing and eliminating duplicate entries.  Set objects also support
% mathematical operations like union, intersection, difference, and
% symmetric difference.

Python には、\emph{集合 (set)} を扱うためのデータ型もあります。集合
とは、重複する要素をもたない、順序づけられていない要素の集まりです。
Set オブジェクトは、結合 (union)、交差 (intersection)、差分 (difference)、
対象差 (symmetric difference) といった数学的な演算もサポートしています。

簡単なデモンストレーションを示します:

\begin{verbatim}
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> fruit = set(basket)               # 重複のない集合を作成
>>> fruit
set(['orange', 'pear', 'apple', 'banana'])
>>> 'orange' in fruit                 # 高速なメンバシップテスト
True
>>> 'crabgrass' in fruit
False

>>> # 二つの単語の文字を例にした集合間の演算
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # a 内の一意な文字
set(['a', 'r', 'b', 'c', 'd'])
>>> a - b                              # a にあって b にない文字
set(['r', 'd', 'b'])
>>> a | b                              # a か b にある文字
set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])
>>> a & b                              # a と b の双方にある文字
set(['a', 'c'])
>>> a ^ b                              # a または b の片方だけにある文字
set(['r', 'd', 'b', 'm', 'z', 'l'])
\end{verbatim}

\section{辞書 \label{dictionaries}} % Dictionaries

%% Another useful data type built into Python is the 
%% \ulink{\emph{dictionary}}{../lib/typesmapping.html}.
%% Dictionaries are sometimes found in other languages as ``associative
%% memories'' or ``associative arrays''.  Unlike sequences, which are
%% indexed by a range of numbers, dictionaries are indexed by \emph{keys},
%% which can be any immutable type; strings and numbers can always be
%% keys.  Tuples can be used as keys if they contain only strings,
%% numbers, or tuples; if a tuple contains any mutable object either
%% directly or indirectly, it cannot be used as a key.  You can't use
%% lists as keys, since lists can be modified in place using 
%% index. assignments, slice assignments, or methods like
%% \method{append()} and \method{extend()}.

もう一つ、有用な型が Python に組み込まれています。それは 
\ulink{\emph{辞書 (dictionary)}}{../lib/typesmapping.html}
 です。辞書は他の言語にも ``連想記憶 (associated
memory)'' や ``連想配列 (associative array)'' として存在することがあります。
ある範囲の数でインデクス化されているシーケンスと異なり、辞書は \emph{キー (key)} 
でインデクス化されています。このキーは何らかの変更不能な型になります;
文字列、数値、およびタプルは常にキーにすることができます; ただし、タプルに
何らかの変更可能なオブジェクトが含まれている場合にはキーに使うことは
できません。リストをキーとして使うことはできません。これは、リストに
スライスやインデクス指定の代入を行ったり、
\method{append()} や \method{extend()}のようなメソッドを使うと、
インプレースで変更することができるためです。

%% It is best to think of a dictionary as an unordered set of
%% \emph{key: value} pairs, with the requirement that the keys are unique
%% (within one dictionary).
%% A pair of braces creates an empty dictionary: \code{\{\}}.
%% Placing a comma-separated list of key:value pairs within the
%% braces adds initial key:value pairs to the dictionary; this is also the
%% way dictionaries are written on output.

辞書は順序付けのされていない \emph{キー(key): 値(value)} のペアからなり、
キーが (辞書の中で) 一意でければならない、と考えると最もよいでしょう。
波括弧 (brace) のペア: \code{\{\}} は空の辞書を生成します。
カンマで区切られた key: value のペアを波括弧ペアの間に入れると、
辞書の初期値となる key: value が追加されます; この表現方法は
出力時に辞書が書き出されるのと同じ方法です。

%% The main operations on a dictionary are storing a value with some key
%% and extracting the value given the key.  It is also possible to delete
%% a key:value pair
%% with \code{del}.
%% If you store using a key that is already in use, the old value
%% associated with that key is forgotten.  It is an error to extract a
%% value using a non-existent key.

辞書での主な操作は、ある値を何らかのキーを付けて記憶することと、
キーを指定して値を取り出すことです。 \code{del} で key: value のペアを
削除することもできます。
すでに使われているキーを使って値を記憶すると、以前そのキーに関連
づけられていた値は忘れ去られてしまいます。存在しないキーを使って
値を取り出そうとするとエラーになります。

%% The \method{keys()} method of a dictionary object returns a list of all
%% the keys used in the dictionary, in random order (if you want it
%% sorted, just apply the \method{sort()} method to the list of keys).  To
%% check whether a single key is in the dictionary, either use the dictionary's
%% \method{has_key()} method or the \keyword{in} keyword.


辞書オブジェクトの \method{keys()} メソッドは、辞書で使われている
全てのキーからなるリストを適当な順番で返します (リストをソート
したいなら、このキーのリストに \method{sort()} を使ってください)。
ある単一のキーが辞書にあるかどうか調べるには、辞書の \method{has_key()} 
メソッドか、\keyword{in}キーワード を使います。

%% Here is a small example using a dictionary:

以下に、辞書を使った小さな例を示します:

\begin{verbatim}
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> tel.keys()
['guido', 'irv', 'jack']
>>> tel.has_key('guido')
1
>>> 'guido' in tel
True
\end{verbatim}

%% The \function{dict()} constructor builds dictionaries directly from
%% lists of key-value pairs stored as tuples.  When the pairs form a
%% pattern, list comprehensions can compactly specify the key-value list.

\function{dict()} コンストラクタは、キーと値のペアをタプルにしたもの
からなるリストを使って直接辞書を生成します。キーと値のペアが
あるパターンをなしているなら、リストの内包表現を使えばキーと値の
リストをコンパクトに指定できます。

\begin{verbatim}
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
>>> dict([(x, x**2) for x in (2, 4, 6)])     # リスト内包表現を利用
{2: 4, 4: 16, 6: 36}
\end{verbatim}

%% Later in the tutorial, we will learn about Generator Expressions
%% which are even better suited for the task of supplying key-values pairs to
%% the \function{dict()} constructor.

チュートリアルの後部では、キー=値ペアを\function{dict()}コンストラクタ
に渡すために適したジェネレータ式について学習します。

%% When the keys are simple strings, it is sometimes easier to specify
%% pairs using keyword arguments:

キーが単純な文字列の場合、キーワード引数を使って定義する方が単純な場合
もあります。

\begin{verbatim}
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'jack': 4098, 'guido': 4127}
\end{verbatim}


\section{ループのテクニック \label{loopidioms}} % Looping Techniques

%% When looping through dictionaries, the key and corresponding value can
%% be retrieved at the same time using the \method{iteritems()} method.

辞書の内容にわたってループを行う際、\method{iteritems()} メソッドを使うと、
キーとそれに対応する値を同時に取り出せます。

\begin{verbatim}
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.iteritems():
...     print k, v
...
gallahad the pure
robin the brave
\end{verbatim}
 
%% When looping through a sequence, the position index and corresponding
%% value can be retrieved at the same time using the
%% \function{enumerate()} function.
  
%% begin{verbatim} 
%% >>> for i, v in enumerate(['tic', 'tac', 'toe']):
%% ...     print i, v
%% ...
%% 0 tic
%% 1 tac
%% 2 toe
%% end{verbatim}

シーケンスにわたるループを行う際、\function{enumerate()} 関数を使うと、要素の
インデクスと要素を同時に取り出すことができます。

\begin{verbatim} 
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print i, v
...
0 tic
1 tac
2 toe
\end{verbatim}

%% To loop over two or more sequences at the same time, the entries
%% can be paired with the \function{zip()} function.

二つまたはそれ以上のシーケンス型を同時にループするために、
関数 \function{zip()} を使って各要素をひと組みにすることができます。

\begin{verbatim}
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print 'What is your %s?  It is %s.' % (q, a)
... 
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
\end{verbatim}

%% To loop over a sequence in reverse, first specify the sequence 
%% in a forward direction and then call the \function{reversed()} 
%% function. 

シーケンスを逆方向に渡ってループするには、まずシーケンスの範囲を順方向に指定し、
次いで関数\function{reversed()} を呼び出します。
 
\begin{verbatim} 
>>> for i in reversed(xrange(1,10,2)): 
...     print i 
... 
9 
7 
5 
3 
1 
\end{verbatim} 

% To loop over a sequence in sorted order, use the \function{sorted()}
% function which returns a new sorted list while leaving the source
% unaltered.

シーケンスを並び順にループするには、\function{sorted()} 関数を使います。
この関数は元の配列を変更せず、並べ変え済みの新たな配列を返します。

\begin{verbatim}
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print f
... 	
apple
banana
orange
pear
\end{verbatim}

\section{条件についてもう少し \label{conditions}} % More on Conditions

%% The conditions used in \code{while} and \code{if} statements above can
%% contain other operators besides comparisons.

\code{while} や \code{if} 文 で使った条件 (condiction) には、
値の比較だけでなく、他の演算子も使うことができます、

%% The comparison operators \code{in} and \code{not in} check whether a value
%% occurs (does not occur) in a sequence.  The operators \code{is} and
%% \code{is not} compare whether two objects are really the same object; this
%% only matters for mutable objects like lists.  All comparison operators
%% have the same priority, which is lower than that of all numerical
%% operators.

比較演算子 \code{in} および \code{not in} は、ある値があるシーケンス中に
存在するか (または存在しないか) どうかを調べます。演算子 \code{is} 
および \code{is not} は、二つのオブジェクトが実際に同じオブジェクト
であるかどうかを調べます; この比較は、リストのような変更可能な
オブジェクトにだけ意味があります。全ての比較演算子は同じ優先順位を
持っており、ともに数値演算子よりも低い優先順位となります。

%% Comparisons can be chained.  For example, \code{a < b == c} tests
%% whether \code{a} is less than \code{b} and moreover \code{b} equals
%% \code{c}.

比較は連鎖 (chain) させることができます。例えば、
\code{a < b == c} は、\code{a} が \code{b} より小さく、
かつ \code{b} と \code{c} が等しいかどうか、をテストします。

%% Comparisons may be combined using the Boolean operators \code{and} and
%% \code{or}, and the outcome of a comparison (or of any other Boolean
% +expression) may be negated with \code{not}.  These have lower
% +priorities than comparison operators; between them, \code{not} has
% +the highest priority and \code{or} the lowest, so that
% +\code{A and not B or C} is equivalent to \code{(A and (not B)) or C}.
% +As always, parentheses can be used to express the desired composition.

比較演算はブール演算子 \code{and} や \code{or} で組み合わせられます。また、
比較演算 (あるいは何らかのブール式) の結果の否 (negate) は\code{not} で
とれます。これらの演算子は全て、比較演算子よりも低い優先順位になっています。
\code{A and not B or C} と \code{(A and (not B)) or C} が等価になるように、
ブール演算子の中で、\code{not} の優先順位が最も高く、\code{or} が最も
低くなっています。もちろん、丸括弧を使えば望みの組み合わせを表現できます。

%% The Boolean operators \code{and} and \code{or} are so-called
%% \emph{short-circuit} operators: their arguments are evaluated from
%% left to right, and evaluation stops as soon as the outcome is
%% determined.  For example, if \code{A} and \code{C} are true but
%% \code{B} is false, \code{A and B and C} does not evaluate the
%% expression \code{C}.  When used as a general value and not as a
%% Boolean, the return value of a short-circuit operator is the last
%% evaluated argument.

ブール演算子 \code{and} と \code{or} は、いわゆる
\emph{短絡 (short-circuit)} 演算子です: これらの演算子の引数は
左から右へと順に評価され、結果が確定した時点で評価を止めます。
例えば、\code{A} と \code{C} は真で \code{B} が偽のとき、
\code{A and B and C} は式 \code{C} を評価しません。
一般に、短絡演算子の戻り値をブール値ではなくて一般的な値として用いると、
値は最後に評価された引数になります。

%% It is possible to assign the result of a comparison or other Boolean
%% expression to a variable.  For example,

比較や他のブール式の結果を変数に代入することもできます。例えば、

\begin{verbatim}
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
\end{verbatim}

%% Note that in Python, unlike C, assignment cannot occur inside expressions.
%% C programmers may grumble about this, but it avoids a common class of
%% problems encountered in C programs: typing \code{=} in an expression when
%% \code{==} was intended.

Python では、C 言語と違って、式の内部で代入を行えないので注意してください。
C 言語のプログラマは不満を呈するかもしれませんが、この仕様は、 C 言語
プログラムで遭遇する、式の中で \code{==} のつもりで \code{=} とタイプ
してしまうといったありふれた問題を回避します。 

\section{シーケンスとその他の型の比較 \label{comparing}} % Comparing Sequences and Other Types

%% Sequence objects may be compared to other objects with the same
%% sequence type.  The comparison uses \emph{lexicographical} ordering:
%% first the first two items are compared, and if they differ this
%% determines the outcome of the comparison; if they are equal, the next
%% two items are compared, and so on, until either sequence is exhausted.
%% If two items to be compared are themselves sequences of the same type,
%% the lexicographical comparison is carried out recursively.  If all
%% items of two sequences compare equal, the sequences are considered
%% equal.  If one sequence is an initial sub-sequence of the other, the
%% shorter sequence is the smaller (lesser) one.  Lexicographical
%% ordering for strings uses the \ASCII{} ordering for individual
%% characters.  Some examples of comparisons between sequences of the
%% same type:

シーケンスオブジェクトは同じシーケンス型の他のオブジェクトと比較できます。
比較には \emph{辞書的な (lexicographical)} 順序が用いられます:
まず、最初の二つの要素を比較し、その値が等しくなければその時点で
比較結果が決まります。等しければ次の二つの要素を比較し、以降
シーケンスの要素が尽きるまで続けます。比較しようとする二つの要素が
いずれも同じシーケンス型であれば、そのシーケンス間での辞書比較を再帰的に行います。
二つのシーケンスの全ての要素の比較結果が等しくなれば、シーケンスは等しいと
みなされます。片方のシーケンスがもう一方の先頭部分にあたる部分シーケンス
ならば、短い方のシーケンスが小さい (劣位の) シーケンスとみなされます。
文字列に対する辞書的な順序づけには、個々の文字ごとに \ASCII{} 順序を
用います。
以下に、同じ型のオブジェクトを持つシーケンス間での比較を行った例を示します:

\begin{verbatim}
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
\end{verbatim}

%% Note that comparing objects of different types is legal.  The outcome
%% is deterministic but arbitrary: the types are ordered by their name.
%% Thus, a list is always smaller than a string, a string is always
%% smaller than a tuple, etc.  \footnote{
%%         The rules for comparing objects of different types should
%%         not be relied upon; they may change in a future version of
%%         the language.
%% }  Mixed numeric types are compared according to their numeric value, so
%% 0 equals 0.0, etc.

違う型のオブジェクト間の比較は認められていることに注意してください。
比較結果は決定性がありますが、その決め方は、型は型の名前で順番づけられる、
という恣意的なものです。従って、リスト (list) 型は常に文字列 (string)
型よりも小さく、文字列型は常にタプル (tuple) よりも小さい、といった
具合になります。\footnote{
異なる型のオブジェクトを比較するための規則を今後にわたって当てに
してはなりません; Python 言語の将来のバージョンでは変更されるかも
しれません。
}

型混合の数値の比較は、数値そのものに従って比較
されるので、例えば 0 は 0.0 と等しい、という結果になります。


\chapter{モジュール \label{modules}} % Modules

%% If you quit from the Python interpreter and enter it again, the
%% definitions you have made (functions and variables) are lost.
%% Therefore, if you want to write a somewhat longer program, you are
%% better off using a text editor to prepare the input for the interpreter
%% and running it with that file as input instead.  This is known as creating a
%% \emph{script}.  As your program gets longer, you may want to split it
%% into several files for easier maintenance.  You may also want to use a
%% handy function that you've written in several programs without copying
%% its definition into each program.

Python インタプリタを終了させ、再び起動すると、これまでに行ってきた
定義 (関数や変数) は失われています。ですから、より長いプログラムを
書きたいなら、テキストエディタを使ってインタプリタへの入力を用意して
おき、手作業の代わりにファイルを入力に使って動作させるとよいでしょう。
この作業を \emph{スクリプト (script)} の作成と言います; プログラムが
長くなるにつれ、メンテナンスを楽にするために、スクリプトをいくつかの
ファイルに分割したくなるかもしれません。また、いくつかのプログラムで
書いてきた便利な関数について、その定義をコピーすることなく個々の
プログラムで使いたいと思うかもしれません。

%% To support this, Python has a way to put definitions in a file and use
%% them in a script or in an interactive instance of the interpreter.
%% Such a file is called a \emph{module}; definitions from a module can be
%% \emph{imported} into other modules or into the \emph{main} module (the
%% collection of variables that you have access to in a script
%% executed at the top level
%% and in calculator mode).

こういった要求をサポートするために、Python では定義をファイルに書いて
おき、スクリプトの中やインタプリタの対話インスタンス上で使う方法が
あります。
このファイルを \emph{モジュール (module)} と呼びます; モジュール
にある定義は、他のモジュールや \emph{main} モジュール (実行の
トップレベルや電卓モードでアクセスできる変数の集まりを指します)
に \emph{import} (取り込み) することができます。

%% A module is a file containing Python definitions and statements.  The
%% file name is the module name with the suffix \file{.py} appended.  Within
%% a module, the module's name (as a string) is available as the value of
%% the global variable \code{__name__}.  For instance, use your favorite text
%% editor to create a file called \file{fibo.py} in the current directory
%% with the following contents:

モジュールは Python の定義や文が入ったファイルです。
ファイル名はモジュール名に接尾語 \file{,py} がついたものになります。
モジュールの中では、(文字列の) モジュール名をグローバル変数
\code{__name__} で取得できます。例えば、お気に入りのテキストエディタ
を使って、現在のディレクトリに以下の内容のファイル \file{fibo.py} を
作成してみましょう:

\begin{verbatim}
# フィボナッチ数列モジュール

def fib(n):    # nまで加算されるフィボナッチ級数を印字
    a, b = 0, 1
    while b < n:
        print b,
        a, b = b, a+b

def fib2(n): # nまで加算されるフィボナッチ級数を返す
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
\end{verbatim}

%% Now enter the Python interpreter and import this module with the
%% following command:

次に Python インタプリタに入り、モジュールを以下のコマンドで
import しましょう。

\begin{verbatim}
>>> import fibo
\end{verbatim}

%% This does not enter the names of the functions defined in \code{fibo} 
%% directly in the current symbol table; it only enters the module name
%% \code{fibo} there.
%% Using the module name you can access the functions:

この操作では、\code{fibo} で定義された関数の名前を直接現在の
シンボルテーブルに入力することはありません; 単にモジュール名 \code{fibo}
だけをシンボルテーブルに入れます。
関数にはモジュール名を使ってアクセスします:

\begin{verbatim}
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
\end{verbatim}

%% If you intend to use a function often you can assign it to a local name:

関数を度々使うのなら、ローカルな名前に代入できます:

\begin{verbatim}
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{verbatim}


\section{モジュールについてもうすこし \label{moreModules}} % More on Modules

%% A module can contain executable statements as well as function
%% definitions.
%% These statements are intended to initialize the module.
%% They are executed only the
%% \emph{first} time the module is imported somewhere.\footnote{
%%         In fact function definitions are also `statements' that are
%%         `executed'; the execution enters the function name in the
%%         module's global symbol table.
%% }

モジュールには、関数定義に加えて実行文を入れることができます。
これらの実行文はモジュールを初期化するためのものです。
これらの実行文は、モジュールがどこかで\emph{最初に} import された
時にだけ実行されます。\footnote{実際には、関数定義も `実行' される `文'
です; モジュールを実行すると、関数名はモジュールのグローバルな
シンボルテーブルに入力されます。}

%% Each module has its own private symbol table, which is used as the
%% global symbol table by all functions defined in the module.
%% Thus, the author of a module can use global variables in the module
%% without worrying about accidental clashes with a user's global
%% variables.
%% On the other hand, if you know what you are doing you can touch a
%% module's global variables with the same notation used to refer to its
%% functions,
%% \code{modname.itemname}.

各々のモジュールは、自前のプライベートなシンボルテーブルを持っていて、
モジュールで定義されている関数はこのテーブルをグローバルな
シンボルテーブルとして使います。
したがって、モジュールの作者は、ユーザのグローバル変数と偶然的な衝突が
起こる心配をせずに、グローバルな変数をモジュールで使うことができます。
一方、自分が行っている操作をきちんと理解していれば、モジュール内の
関数を参照するのと同じ表記法 \code{modname.itemname} で、モジュールの
グローバル変数をいじることもできます。	

%% Modules can import other modules.  It is customary but not required to
%% place all \keyword{import} statements at the beginning of a module (or
%% script, for that matter).  The imported module names are placed in the
%% importing module's global symbol table.

モジュールが他のモジュールを import することもできます。\keyword{import}
文は全てモジュールの先頭に (さらに言えばスクリプトでも) 置きますが、
これは慣習であって必須ではありません。import されたモジュール名は
import を行っているモジュールのグローバルなシンボルテーブルに置かれます。

%% There is a variant of the \keyword{import} statement that imports
%% names from a module directly into the importing module's symbol
%% table.  For example:

\keyword{import} 文には、あるモジュール内の名前を、import を実行
しているモジュールのシンボルテーブル内に直接取り込むという変型が
あります。例えば:

\begin{verbatim}
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{verbatim}

%% This does not introduce the module name from which the imports are taken
%% in the local symbol table (so in the example, \code{fibo} is not
%% defined).

この操作は、import の対象となるモジュール名をローカルな
シンボルテーブル内に取り入れることはありません (従って上の例では、
\code{fibo} は定義されません)。

%% There is even a variant to import all names that a module defines:

モジュールで定義されている名前を全て import するという変型もあります:

\begin{verbatim}
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{verbatim}

%% This imports all names except those beginning with an underscore
%% (\code{_}).

上の操作は、アンダースコア (\code{_}) で開始する名前以外の全ての名前を
import します。


\subsection{モジュール検索パス \label{searchPath}} % The Module Search Path

%% \indexiii{module}{search}{path}
%% When a module named \module{spam} is imported, the interpreter searches
%% for a file named \file{spam.py} in the current directory,
%% and then in the list of directories specified by
%% the environment variable \envvar{PYTHONPATH}.  This has the same syntax as
%% the shell variable \envvar{PATH}, that is, a list of
%% directory names.  When \envvar{PYTHONPATH} is not set, or when the file
%% is not found there, the search continues in an installation-dependent
%% default path; on \UNIX, this is usually \file{.:/usr/local/lib/python}.

\indexiii{module}{search}{path}
\module{spam} という名前のモジュールが import されると、インタプリタ
は \file{spam.py} という名前のファイルを現在のディレクトリ内で探し、
次に環境変数\envvar{PYTHONPATH} に指定されているディレクトリのリスト
から探します。\envvar{PYTHONPATH} はシェル変数 \envvar{PATH} と
同じ構文、すなわちディレクトリ名を並べたものです。\envvar{PYTHONPATH}
が設定されていないか、探しているファイルが見つからなかった場合は、
検索対象をインストール方法に依存するデフォルトのパスにして続けます;
\UNIX では、このパスは通常 \file{.:/usr/locall/lib/python} です。

%% Actually, modules are searched in the list of directories given by the 
%% variable \code{sys.path} which is initialized from the directory 
%% containing the input script (or the current directory),
%% \envvar{PYTHONPATH} and the installation-dependent default.  This allows
%% Python programs that know what they're doing to modify or replace the 
%% module search path.  Note that because the directory containing the
%% script being run is on the search path, it is important that the
%% script not have the same name as a standard module, or Python will
%% attempt to load the script as a module when that module is imported.
%% This will generally be an error.  See section~\ref{standardModules},
%% ``Standard Modules,'' for more information.

実際には、モジュールは変数 \code{sys.path} で指定されたディレクトリの
リストから検索されます。\code{sys.path} は、入力とするスクリプトの
入ったディレクトリ (現在のディレクトリ)、\envvar{PYTHONPATH}、
およびインストール方法依存のデフォルト値を使って初期化されます。
Python プログラマは、自分の行っている操作を理解しているなら、
この変数を使ってモジュール検索パスを修正したり置き換えたりすることが
できます。
起動しようとするスクリプトの入ったディレクトリが検索パス上にある
ため、スクリプトが標準モジュールと同じ名前をもたないようにすることが
重要です。さもなければ、Python が標準モジュールを import するときに
スクリプトをモジュールとして import しようと試みてしまうので注意
してください。このような誤りを犯すと、通常はエラーになります。
詳しくは ~\ref{standardModules} 節、``標準モジュール.'' を参照して
ください。


\subsection{``コンパイル'' された Python ファイル} % ``Compiled'' Python files

%% As an important speed-up of the start-up time for short programs that
%% use a lot of standard modules, if a file called \file{spam.pyc} exists
%% in the directory where \file{spam.py} is found, this is assumed to
%% contain an already-``byte-compiled'' version of the module \module{spam}.
%% The modification time of the version of \file{spam.py} used to create
%% \file{spam.pyc} is recorded in \file{spam.pyc}, and the
%% \file{.pyc} file is ignored if these don't match.

たくさんの標準モジュールを使うような短いプログラムで重要となる
起動時間の高速化を行うために、\file{spam.py} が見つかったディレクトリに
\file{spam.pyc} という名前のファイルがあった場合には、このファイルを
モジュール \module{spam} の ``バイトコンパイルされた'' バージョン
であると仮定します。
\file{spam.pyc} を生成するのに使われたバージョンの \file{spam.py} の
ファイル修正時刻が \file{spam.pyc} に記録されており、この値が
一致しなければ \file{spam.pyc} ファイルは無視されます。

%% Normally, you don't need to do anything to create the
%% \file{spam.pyc} file.  Whenever \file{spam.py} is successfully
%% compiled, an attempt is made to write the compiled version to
%% \file{spam.pyc}.  It is not an error if this attempt fails; if for any
%% reason the file is not written completely, the resulting
%% \file{spam.pyc} file will be recognized as invalid and thus ignored
%% later.  The contents of the \file{spam.pyc} file are platform
%% independent, so a Python module directory can be shared by machines of
%% different architectures.

通常、\file{spam.pyc} ファイルを生成するために何かをする必要は
ありません。\file{spam.py} が無事コンパイルされると、常に
コンパイルされたバージョンを \file{spam.pyc} へ書き出すよう
試みます。この試みが失敗してもエラーにはなりません;
何らかの理由でファイルが完全に書き出されなかった場合、作成された
 \file{smap.pyc} は無効であるとみなされ、それ以後無視されます。
\file{spam.pyc} ファイルの内容はプラットフォームに依存しないので、
Python のモジュールのディレクトリは異なるアーキテクチャのマシン間で
共有することができます。

%% Some tips for experts:

エキスパートへの助言: 

\begin{itemize}

\item
%% When the Python interpreter is invoked with the \programopt{-O} flag,
%% optimized code is generated and stored in \file{.pyo} files.
%% The optimizer currently doesn't help much; it only removes
%% \keyword{assert} statements and \code{SET_LINENO} instructions.
%% When \programopt{-O} is used, \emph{all} bytecode is optimized;
%% \code{.pyc} files are ignored and \code{.py} files are compiled to
%% optimized bytecode.
Python インタプリタを \programopt{-O} フラグ付きで起動すると、
最適化 (optimize) されたコードが生成されて \file{.pyo} ファイルに
保存されます。最適化機構は今のところあまり役に立っていません;
最適化機構は \keyword{assert} 文と \code{SET_LINENO} 命令を除去
しているだけです。\programopt{-O} を使うと、\emph{すべての} 
バイトコードが最適化されます; \code{.pyc} ファイルは無視され、
\code{.py} ファイルは最適化されたバイトコードにコンパイルされます。

\item
%% Passing two \programopt{-O} flags to the Python interpreter
%% (\programopt{-OO}) will cause the bytecode compiler to perform
%% optimizations that could in some rare cases result in malfunctioning
%% programs.  Currently only \code{__doc__} strings are removed from the
%% bytecode, resulting in more compact \file{.pyo} files.  Since some
%% programs may rely on having these available, you should only use this
%% option if you know what you're doing.
二つの \programopt{-O} フラグ (\programopt{-OO}) を Python インタプリタへ
渡すと、バイトコードコンパイラは、
まれにプログラムが正しく動作しなくなるかもしれないような最適化を
実行します。
現状では、ただ \code{__doc__} 文字列をバイトコードから除去して、
よりコンパクトな \file{.pyo} ファイルにするだけです。
この文字列が利用できることをあてにしているプログラムがあるかもしれない
ので、自分の行っている操作が何かわかっているときにだけこのオプションを
使うべきです。

\item
%% A program doesn't run any faster when it is read from a \file{.pyc} or
%% \file{.pyo} file than when it is read from a \file{.py} file; the only
%% thing that's faster about \file{.pyc} or \file{.pyo} files is the
%% speed with which they are loaded.
\file{.pyc} ファイルや \file{.pyo} ファイルから
読み出されたとしても、プログラムは何ら高速に動作するわけでは
ありません。\file{.pyc} ファイルや \file{.pyo} ファイルで高速化される
のは、読み込まれるときの速度だけです。

\item
%% When a script is run by giving its name on the command line, the
%% bytecode for the script is never written to a \file{.pyc} or
%% \file{.pyo} file.  Thus, the startup time of a script may be reduced
%% by moving most of its code to a module and having a small bootstrap
%% script that imports that module.  It is also possible to name 
%% \file{.pyc} or \file{.pyo} file directly on the command line.

スクリプトの名前をコマンドラインで指定して実行した場合、
そのスクリプトのバイトコードが \file{.pyc} や \file{.pyo} に
書き出されることはありません。従って、スクリプトのほとんどのコードを
モジュールに移し、そのモジュールを import する小さなブートストラップ
スクリプトを作れば、スクリプトの起動時間を短縮できるときがあります。
\file{.pyc} または \file{.pyo} ファイルの名前を直接コマンドラインに
指定することもできます。

\item
%% It is possible to have a file called \file{spam.pyc} (or
%% \file{spam.pyo} when \programopt{-O} is used) without a file
%% \file{spam.py} for the same module.  This can be used to distribute a
%% library of Python code in a form that is moderately hard to reverse
%% engineer.
一つのモジュールについて、ファイル \file{spam.py} のない
\file{spam.pyc} (\programopt{-O} を使ったときは \file{spam.pyo}) 
があってもかまいません。この仕様は、Python コードでできたライブラリを
リバースエンジニアリングがやや困難な形式で配布するために使えます。

\item
%% The module \ulink{\module{compileall}}{../lib/module-compileall.html}%
%% {}\refstmodindex{compileall} can create
%% \file{.pyc} files (or \file{.pyo} files when \programopt{-O} is used) for
%% all modules in a directory.
\ulink{\module{compileall}}{../lib/module-compileall.html}%
{}\refstmodindex{compileall} は、\file{.pyc} ファイル
(または \programopt{-O} を使ったときは\file{.pyo} ファイル) を
ディレクトリ内の全てのモジュールに対して生成することができます。

\end{itemize}


\section{標準モジュール \label{standardModules}} % Standard Modules

%% Python comes with a library of standard modules, described in a separate
%% document, the \citetitle[../lib/lib.html]{Python Library Reference}
%% (``Library Reference'' hereafter).  Some modules are built into the
%% interpreter; these provide access to operations that are not part of
%% the core of the language but are nevertheless built in, either for
%% efficiency or to provide access to operating system primitives such as
%% system calls.  The set of such modules is a configuration option which
%% also dependson the underlying platform  For example,
%% the \module{amoeba} module is only provided on systems that somehow
%% support Amoeba primitives.  One particular module deserves some
%% attention: \ulink{\module{sys}}{../lib/module-sys.html}%
%% {}\refstmodindex{sys}, which is built into every
%% Python interpreter.  The variables \code{sys.ps1} and
%% \code{sys.ps2} define the strings used as primary and secondary
%% prompts:

Python には標準モジュールのライブラリが付属しています。ライブラリは
独立したドキュメント \citetitle[../lib/lib.html]{Python ライブラリ
リファレンス (Python Library Reference)}  (以降 
``ライブラリリファレンス'') で記述されています。
モジュールによってはインタプリタに組み込まれたものがあります; 
インタプリタに組み込まれているモジュールが提供しているのは、
言語の中核の部分ではありませんが、効率化のためや、システムコールのような
オペレーティングシステムの根本機能へのアクセス手段を提供するための
操作です。これらのモジュールのセットは設定時に選択可能で、また
根底にあるプラットフォームにも依存します。例えば、\module{amoeba} 
モジュールは、 Amoeba の根本機能を何らかの形でサポートしているような
システムでのみ提供されます。
とりわけ、注目に値するモジュールが一つあります:
\ulink{\module{sys}}{../lib/module-sys.html}
{}\refstmodindex{sys} はどの Python インタプリタにも
組み込まれています。変数 \code{sys.ps1} と \code{sys.ps2} は、それぞれ
一次プロンプトと二次プロンプトとして使われる文字列を定義しています:

\begin{verbatim}
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print 'Yuck!'
Yuck!
C> 
\end{verbatim}

%% These two variables are only defined if the interpreter is in
%% interactive mode.

これらの二つの変数は、インタプリタが対話モードにあるときだけ
定義されています。

%% The variable \code{sys.path} is a list of strings that determine the
%% interpreter's search path for modules. It is initialized to a default
%% path taken from the environment variable \envvar{PYTHONPATH}, or from
%% a built-in default if \envvar{PYTHONPATH} is not set.  You can modify
%% it using standard list operations: 

変数 \code{sys.path} は文字列からなるリストで、インタプリタがモジュール
を検索するときのパスを決定します。
\code{sys.path} は環境変数 \envvar{PYTHONPATH} から得たデフォルトパスに、
\envvar{PYTHONPATH} が設定されていなければ組み込みのデフォルト値に設定
されます。標準的なリスト操作で変更することができます:

\begin{verbatim}
>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')
\end{verbatim}

\section{\function{dir()} 関数 \label{dir}} % The \function{dir()} Function

%% The built-in function \function{dir()} is used to find out which names
%% a module defines.  It returns a sorted list of strings:

組込み関数 \function{dir()} は、あるモジュールがどんな名前を定義して
いるか調べるために使われます。
\function{dir()} はソートされた文字列のリストを返します:

\begin{verbatim}
>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
 '__stdin__', '__stdout__', '_getframe', 'api_version', 'argv', 
 'builtin_module_names', 'byteorder', 'callstats', 'copyright',
 'displayhook', 'exc_clear', 'exc_info', 'exc_type', 'excepthook',
 'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
 'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
 'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
 'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
 'version', 'version_info', 'warnoptions']
\end{verbatim}

%% Without arguments, \function{dir()} lists the names you have defined
%% currently:

引数がなければ、\function{dir()} は現在定義している名前を列挙します。

\begin{verbatim}
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo', 'sys']
\end{verbatim}

%% Note that it lists all types of names: variables, modules, functions, etc.

変数、モジュール、関数、その他の、すべての種類の名前をリストすることに
注意してください。

%% \function{dir()} does not list the names of built-in functions and
%% variables.  If you want a list of those, they are defined in the
%% standard module \module{__builtin__}\refbimodindex{__builtin__}:

\function{dir()} は、組込みの関数や変数の名前はリストしません。
これらの名前からなるリストが必要なら、標準モジュール 
\module{__builtin__}\refbimodindex{__builtin__} で定義されています:

\begin{verbatim}
>>> import __builtin__
>>> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'DeprecationWarning',
 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
 'FloatingPointError', 'FutureWarning', 'IOError', 'ImportError',
 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError', 
 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError',
 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError',
 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True',
 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
 'UserWarning', 'ValueError', 'Warning', 'WindowsError',
 'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__',
 '__name__', 'abs', 'apply', 'basestring', 'bool', 'buffer',
 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile',
 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex',
 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
 'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit', 'range',
 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set',
 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super',
 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
\end{verbatim}


\section{パッケージ \label{packages}} % Packages

%% Packages are a way of structuring Python's module namespace
%% by using ``dotted module names''.  For example, the module name
%% \module{A.B} designates a submodule named \samp{B} in a package named
%% \samp{A}.  Just like the use of modules saves the authors of different
%% modules from having to worry about each other's global variable names,
%% the use of dotted module names saves the authors of multi-module
%% packages like NumPy or the Python Imaging Library from having to worry
%% about each other's module names.

パッケージ (package) は、Python のモジュール名前空間
を ``ドット付きモジュール名 (dotted module names)'' を使って
構造化する手段です。例えば、モジュール名 \module{A.B} は、
\samp{A} というパッケージのサブモジュール \samp{B} を表します。
ちょうど、モジュールを利用すると、別々のモジュールの著者が互いの
グローバル変数名について心配しなくても済むようになるのと同じように、
ドット付きモジュール名を利用すると、
NumPy や Python Imaging Library のように複数モジュールからなる
パッケージの著者が、互いのモジュール名について心配しなくても済むように
なります。

%% Suppose you want to design a collection of modules (a ``package'') for
%% the uniform handling of sound files and sound data.  There are many
%% different sound file formats (usually recognized by their extension,
%% for example: \file{.wav}, \file{.aiff}, \file{.au}), so you may need
%% to create and maintain a growing collection of modules for the
%% conversion between the various file formats.  There are also many
%% different operations you might want to perform on sound data (such as
%% mixing, adding echo, applying an equalizer function, creating an
%% artificial stereo effect), so in addition you will be writing a
%% never-ending stream of modules to perform these operations.  Here's a
%% possible structure for your package (expressed in terms of a
%% hierarchical filesystem):

音声ファイルや音声データを一様に扱うためのモジュールのコレクション
(``パッケージ'') を設計したいと仮定しましょう。音声ファイルには
多くの異なった形式がある (通常は拡張子、例えば \file{.wav}, 
\file{.aiff}, \file{.au} などで認識されます) ので、
様々なファイル形式間で変換を行うためのモジュールからなる、
次第に増えていくモジュールのコレクションを作成したりメンテナンス
したりする必要がありかもしれません。また、音声データに対して
実行したい様々な独自の操作 (ミキシング、エコーの追加、
イコライザ関数の適用、人工的なステレオ効果の作成など) があるかも
しれません。そうなると、こうした操作を実行するモジュールを果てしなく
書くことになるでしょう。以下に (階層的なファイルシステムで表現した) 
パッケージの構造案を示します:

\begin{verbatim}
Sound/                          トップレベルのパッケージ
      __init__.py               サウンドパッケージを初期化する
      Formats/                  ファイルフォーマット変換用の下位パッケージ
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      Effects/                  サウンド効果用の下位パッケージ
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      Filters/                  フィルタ用の下位パッケージ
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
\end{verbatim}

%% When importing the package, Python searches through the directories
%% on \code{sys.path} looking for a subdirectory containing the
%% top-level package.

パッケージを import する際、 Python は \code{sys.path} 上のディレクトリ
を検索して、トップレベルのパッケージの入ったサブディレクトリを探します。

%% The \file{__init__.py} files are required to make Python treat the
%% directories as containing packages; this is done to prevent
%% directories with a common name, such as \samp{string}, from
%% unintentionally hiding valid modules that occur later on the module
%% search path. In the simplest case, \file{__init__.py} can just be an
%% empty file, but it can also execute initialization code for the
%% package or set the \code{__all__} variable, described later.

あるディレクトリを、パッケージが入ったディレクトリとしてPython に
扱わせるには、ファイル \file{__init__.py} が必要です:
このファイルを置かなければならないのは、\samp{string} のような
よくある名前のディレクトリにより、モジュール検索パスの後の方で見つかる
正しいモジュールが意図せず隠蔽されてしまうのを防ぐためです。
最も簡単なケースでは \file{__init__.py} はただの空ファイルで
構いませんが、\file{__init__.py} ではパッケージのための初期化コード
を実行したり、後述の \code{__all__} 変数を設定してもかまいません。

%% Users of the package can import individual modules from the
%% package, for example:

パッケージのユーザは、個々のモジュールをパッケージから import 
することができます。例えば:

\begin{verbatim}
import Sound.Effects.echo
\end{verbatim}

%% This loads the submodule \module{Sound.Effects.echo}.  It must be referenced
%% with its full name.

この操作はサブモジュール \module{Sound.Effects.echo} をロードします。
このモジュールは、以下のように完全な名前で参照しなければなりません:

\begin{verbatim}
Sound.Effects.echo.echofilter(input, output, delay=0.7, atten=4)
\end{verbatim}

%% An alternative way of importing the submodule is:

サブモジュールを import するもう一つの方法を示します:

\begin{verbatim}
from Sound.Effects import echo
\end{verbatim}

%% This also loads the submodule \module{echo}, and makes it available without
%% its package prefix, so it can be used as follows:

これもサブモジュール \module{echo} をロードし、\module{echo} を
パッケージ名を表す接頭辞なしで利用できるようにします。従って以下のように
用いることができます:

\begin{verbatim}
echo.echofilter(input, output, delay=0.7, atten=4)
\end{verbatim}

%% Yet another variation is to import the desired function or variable directly:

さらにもう一つのバリエーションとして、必要な関数や変数を直接 import する
方法があります:

\begin{verbatim}
from Sound.Effects.echo import echofilter
\end{verbatim}

%% Again, this loads the submodule \module{echo}, but this makes its function
%% \function{echofilter()} directly available:

この操作も同様にサブモジュール \module{echo} をロードしますが、
\function{echofilter} を直接利用できるようにします。


\begin{verbatim}
echofilter(input, output, delay=0.7, atten=4)
\end{verbatim}

%% Note that when using \code{from \var{package} import \var{item}}, the
%% item can be either a submodule (or subpackage) of the package, or some 
%% other name defined in the package, like a function, class or
%% variable.  The \code{import} statement first tests whether the item is
%% defined in the package; if not, it assumes it is a module and attempts
%% to load it.  If it fails to find it, an
%% \exception{ImportError} exception is raised.

\code{from \var{package} import \var{item}} を使う場合、\var{item} は
パッケージ \var{package} のサブモジュール (またはサブパッケージ) でも
かまいませんし、関数やクラス、変数のような、\var{package} で定義されて
いる別の名前でもかまわないことに注意してください。
\code{import} 文はまず、\var{item} がパッケージ内で定義されているか
どうか調べます; 定義されていなければ、\var{item} はモジュール
名であると仮定して、モジュールをロードしようと試みます。もし
モジュールが見つからなければ、\exception{ImportError} が送出されます。

%% Contrarily, when using syntax like \code{import
%% \var{item.subitem.subsubitem}}, each item except for the last must be
%% a package; the last item can be a module or a package but can't be a
%% class or function or variable defined in the previous item.

反対に、\code{import \var{item.subitem.subsubitem}} のような構文を
使った場合、最後の \code{subsubitem} を除く各要素はパッケージで
なければなりません; 最後の要素はモジュールかパッケージにできますが、
一つ前の要素で定義されているクラスや関数や変数にはできません。

\subsection{パッケージから * を import する \label{pkg-import-star}} % Importing * From a Package
%The \code{__all__} Attribute

\ttindex{__all__}

%% Now what happens when the user writes \code{from Sound.Effects import
%% *}?  Ideally, one would hope that this somehow goes out to the
%% filesystem, finds which submodules are present in the package, and
%% imports them all.  Unfortunately, this operation does not work very
%% well on Mac and Windows platforms, where the filesystem does not
%% always have accurate information about the case of a filename!  On
%% these platforms, there is no guaranteed way to know whether a file
%% \file{ECHO.PY} should be imported as a module \module{echo},
%% \module{Echo} or \module{ECHO}.  (For example, Windows 95 has the
%% annoying practice of showing all file names with a capitalized first
%% letter.)  The DOS 8+3 filename restriction adds another interesting
%% problem for long module names.

それでは、ユーザが \code{from Sound.Effects import *} と書いたら、
どうなるのでしょうか？ 理想的には、何らかの方法でファイルシステムが
調べられ、そのパッケージにどんなサブモジュールがあるかを調べ上げ、
全てを import する、という処理を望むことでしょう。残念ながら、
この操作は Mac や Windows のプラットフォームではうまく動作しません。
これらのプラットフォームでは、ファイルシステムはファイル名の
大小文字の区別について正しい情報をもっているとは限らないからです！
こうしたプラットフォームでは、ファイル \file{ECHO.PY} を
モジュール \module{echo} として import すべきか、\module{Echo} と
すべきかが分かる確かな方法がないからです (例えば、 Windows 95 は
すべてのファイル名の最初の文字を大文字にして表示するという困った
慣習があります)。また、DOS の 8+3 のファイル名制限のせいで、
長いモジュール名に関して別の奇妙な問題が追加されています。

%% The only solution is for the package author to provide an explicit
%% index of the package.  The import statement uses the following
%% convention: if a package's \file{__init__.py} code defines a list
%% named \code{__all__}, it is taken to be the list of module names that
%% should be imported when \code{from \var{package} import *} is
%% encountered.  It is up to the package author to keep this list
%% up-to-date when a new version of the package is released.  Package
%% authors may also decide not to support it, if they don't see a use for
%% importing * from their package.  For example, the file
%% \file{Sounds/Effects/__init__.py} could contain the following code:

唯一の解決策は、パッケージの作者にパッケージの索引を明示的に提供
させるというものです。
import 文は次の規約を使います: パッケージの \file{__init__.py} コード
に \code{__all__} という名前のリストが定義されていれば、
\code{from \var{package} import *} が現れたときに import する
リストとして使います。新たなパッケージがリリースされるときに
リストを最新の状態に更新するのはパッケージの作者の責任となります。
自分のパッケージから * を import するという使い方に同意できなければ、
パッケージの作者は \file{__init__.py} をサポートしないことにしても
かまいません。
例えば、ファイル \code{Sounds/Effects/__init__.py} には、次のような
コードを入れてもよいかもしれません:

\begin{verbatim}
__all__ = ["echo", "surround", "reverse"]
\end{verbatim}

%% This would mean that \code{from Sound.Effects import *} would
%% import the three named submodules of the \module{Sound} package.

このコードは、 \code{from Sound.Effects import *} とすると、
 \module{Sound} パッケージから指定された 3 つのサブモジュールが 
import されることになっている、ということを意味します。

%% If \code{__all__} is not defined, the statement \code{from Sound.Effects
%% import *} does \emph{not} import all submodules from the package
%% \module{Sound.Effects} into the current namespace; it only ensures that the
%% package \module{Sound.Effects} has been imported (possibly running any
%% initialization code in \file{__init__.py}) and then imports whatever names are
%% defined in the package.  This includes any names defined (and
%% submodules explicitly loaded) by \file{__init__.py}.  It also includes any
%% submodules of the package that were explicitly loaded by previous
%% import statements.  Consider this code:

もしも \code{__all__} が定義されていなければ、実行文
\code{from Sound.Effects import *} は、パッケージ \module{Sound.Effects} 
の全てのサブモジュールを現在の名前空間の中へ import \emph{しません};
この文は単に (場合によっては初期化コード \file{__init__.py} を実行して) 
パッケージ \module{Sound.Effects} が import されたということを確認し、
そのパッケージで定義されている名前を全て import するだけです。
import される名前には、\file{__init__.py} で定義された名前 
(と、明示的にロードされたサブモジュール) が含まれます。
パッケージのサブモジュールで、以前の import 文で明示的にロードされた
ものも含みます。以下のコードを考えてください:

\begin{verbatim}
import Sound.Effects.echo
import Sound.Effects.surround
from Sound.Effects import *
\end{verbatim}

%% In this example, the echo and surround modules are imported in the
%% current namespace because they are defined in the
%% \module{Sound.Effects} package when the \code{from...import} statement
%% is executed.  (This also works when \code{__all__} is defined.)

上の例では、echo と surround モジュールが現在の名前空間に
import されます。これらのモジュールは \code{from...import} 文が
実行された際に \module{Sound.Effects} 内で定義されているからです
(この機構は\code{__all__} が定義されているときにも働きます)。

%% Note that in general the practice of importing \code{*} from a module or
%% package is frowned upon, since it often causes poorly readable code.
%% However, it is okay to use it to save typing in interactive sessions,
%% and certain modules are designed to export only names that follow
%% certain patterns.

一般的には、モジュールやパッケージから \code{*} を import するという
やり方には賛同できません。というのは、この操作を行うとしばしば可読性に
乏しいコードになるからです。しかし、対話セッションでキータイプの量を
減らすために使うのは構わないでしょう。それに、特定のモジュールでは、
特定のパターンに従った名前のみを公開 (export) するように設計されています。

%% Remember, there is nothing wrong with using \code{from Package
%% import specific_submodule}!  In fact, this is the
%% recommended notation unless the importing module needs to use
%% submodules with the same name from different packages.

\code{from package import specific_submodule} を使っても何も問題は
ないことに留意してください！実際この表記法は、import を行うモジュールが
他のパッケージかと同じ名前を持つサブモジュールを使わなければ
ならない場合を除いて推奨される方式です。


\subsection{パッケージ内での参照} % Intra-package References

%% The submodules often need to refer to each other.  For example, the
%% \module{surround} module might use the \module{echo} module.  In
%% fact,
%% such references
%% are so common that the \keyword{import} statement first looks in the
%% containing package before looking in the standard module search path.
%% Thus, the \module{surround} module can simply use \code{import echo} or
%% \code{from echo import echofilter}.  If the imported module is not
%% found in the current package (the package of which the current module
%% is a submodule), the \keyword{import} statement looks for a top-level module
%% with the given name.

サブモジュール同士で互いに参照を行う必要がしばしば起こります。
例えば、\module{surround} モジュールは \module{echo} モジュールを
使うかもしれません。実際には、このような参照はよくあることなので、
\keyword{import} 文を実行すると、まず最初に import 文の入っている
パッケージを検索し、その後になって標準のモジュール検索パスを
見に行きます。こうして、\module{surround} モジュールは単に \code{import echo}
や  \code{from echo import echofilter} を使うことができます。
import されたモジュールが現在のパッケージ (現在のモジュールを
サブモジュールにしているパッケージ) 内に見つからなかった場合、
\keyword{import} 文は指定した名前のトップレベルのモジュールを検索
します。

%% When packages are structured into subpackages (as with the
%% \module{Sound} package in the example), there's no shortcut to refer
%% to submodules of sibling packages - the full name of the subpackage
%% must be used.  For example, if the module
%% \module{Sound.Filters.vocoder} needs to use the \module{echo} module
%% in the \module{Sound.Effects} package, it can use \code{from
%% Sound.Effects import echo}.

パッケージが (前述の例の \module{Sound} パッケージのように) 
サブパッケージの集まりに構造化されている場合、兄弟関係にある
パッケージを短縮された記法で参照する方法は存在しません - サブパッケージ
の完全な名前を使わなければなりません。例えば、モジュール
\module{Sound.Filters.vocoder} で \module{Sound.Effects} パッケージの
\module{echo} モジュールを使いたいとすると、
\code{from Sound.Effects import echo} を使うことはできます。

%% +Starting with Python 2.5, in addition to the implicit relative imports
%% +described above, you can write explicit relative imports with the
%% +\code{from module import name} form of import statement. These explicit
%% +relative imports use leading dots to indicate the current and parent
%% +packages involved in the relative import. From the \module{surround}
%% +module for example, you might use:

Python 2.5 からは、上で説明した暗黙の相対importに加えて、明示的な
相対importを　\code{from module import name} の形式のimport文で利用で
きます。
この明示的な相対importでは、先頭のドットで現在および親パッケージを指定
して相対importを行います。 \module{surround}モジュールの例では、以下の
ように記述できます:


\begin{verbatim}
from . import echo
from .. import Formats
from ..Filters import equalizer
\end{verbatim}

%% +Note that both explicit and implicit relative imports are based on the
%% +name of the current module. Since the name of the main module is always
%% +\code{"__main__"}, modules intended for use as the main module of a
%% +Python application should always use absolute imports.

明示的および暗黙的な相対importのどちらもカレントモジュールの名前をベー
スにすることに注意してください。メインモジュールの名前は常に
\code{"__main__"} なので、Pythonアプリケーションのメインモジュールとし
て利用されることを意図しているモジュールでは絶対importを利用するべきで
す。



\subsection{複数ディレクトリ中のパッケージ} % Packages in Multiple Directories

%% Packages support one more special attribute, \member{__path__}.  This
%% is initialized to be a list containing the name of the directory
%% holding the package's \file{__init__.py} before the code in that file
%% is executed.  This variable can be modified; doing so affects future
%% searches for modules and subpackages contained in the package.

パッケージのサポートする特殊な属性には、もう一つ \member{__path__} が
あります。この属性は、パッケージの \file{__init__.py} 中のコードが
実行されるよりも前に、\file{__init__.py} の収められているディレクトリ名
の入ったリストになるよう初期化されます。
この変数は変更することができます; 変更を加えると、以降そのパッケージに
入っているモジュールやサブパッケージの検索に影響します。

%% While this feature is not often needed, it can be used to extend the
%% set of modules found in a package.

この機能はほとんど必要にはならないのですが、パッケージ内に見つかる
モジュールのセットを拡張するために使うことができます。



\chapter{入力と出力 \label{io}} % Input and Output

%% There are several ways to present the output of a program; data can be
%% printed in a human-readable form, or written to a file for future use.
%% This chapter will discuss some of the possibilities.

プログラムの出力をもたらす方法はいくつかあります; データは人間が可読
な形で出力することも、将来使うためにファイルに書くこともできます。
この章では、こうした出力のいくつかの可能性について議論します。


\section{ファンシーな出力の書式化 \label{formatting}} % Fancier Output Formatting

%% So far we've encountered two ways of writing values: \emph{expression
%% statements} and the \keyword{print} statement.  (A third way is using
%% the \method{write()} method of file objects; the standard output file
%% can be referenced as \code{sys.stdout}.  See the Library Reference for
%% more information on this.)

これまでのところ、値を出力する二つの方法: \emph{式でできた文 (expression
statement)} と \keyword{print} 文が出てきました。(第三は
ファイルオブジェクトの \method{write()} を使う方法です; 標準出力
を表すファイルは \code{sys.stdout} で参照できます。詳細は
ライブラリリファレンスを参照してください。)

%% Often you'll want more control over the formatting of your output than
%% simply printing space-separated values.  There are two ways to format
%% your output; the first way is to do all the string handling yourself;
%% using string slicing and concatenation operations you can create any
%% lay-out you can imagine.  The standard module
%% \module{string}\refstmodindex{string} contains some useful operations
%% for padding strings to a given column width; these will be discussed
%% shortly.  The second way is to use the \code{\%} operator with a
%% string as the left argument.  The \code{\%} operator interprets the
%% left argument much like a \cfunction{sprintf()}-style format
%% string to be applied to the right argument, and returns the string
%% resulting from this formatting operation.

出力を書式化する際に、単に値をスペースで区切って出力するよりも
もっときめ細かな制御をしたいと思うことがしばしばあるでしょう。
出力を書式化するには二つの方法があります; 第一の方法は、全ての
文字列を自分で処理するというものです; 文字列のスライスや結合といった操作を
使えば、思い通りのレイアウトを作成することができます。
標準モジュール \module{string}\refstmodindex{string} には、
文字列を指定されたカラム幅にそろえるための便利な操作がいくつか
あります; これらの操作については後で簡単に説明します。
第二の方法は \code{\%} 演算子を使い、文字列を演算子の左引数
(left argument) として使う方法です。\code{\%} 演算子は、左引数を
\cfunction{sprintf()} のような形式で解釈して右引数に適用し、
その書式化操作で得られた文字列を返します。

%% One question remains, of course: how do you convert values to strings?
%% Luckily, Python has ways to convert any value to a string: pass it to
%% the \function{repr()}  or \function{str()} functions.  Reverse quotes
%% (\code{``}) are equivalent to \function{repr()}, but they are no
%% longer used in modern Python code and will likely not be in future
%% versions of the language.


もちろん、一つ問題があります。値をどうやって文字列に変換したら
いいのでしょうか？幸運なことに、Python には値を文字列に変換する方法が
あります: 値を \function{repr()} か \function{str()} 関数に渡して
ください。逆クオート (\code{``}) は \function{repr()} と等しい
操作ですが、最近のPythonコードでは使われませんし、将来のバージョンには
含まれないでしょう。

%% The \function{str()} function is meant to return representations of
%% values which are fairly human-readable, while \function{repr()} is
%% meant to generate representations which can be read by the interpreter
%% (or will force a \exception{SyntaxError} if there is not equivalent
%% syntax).  For objects which don't have a particular representation for
%% human consumption, \function{str()} will return the same value as
%% \function{repr()}.  Many values, such as numbers or structures like
%% lists and dictionaries, have the same representation using either
%% function.  Strings and floating point numbers, in particular, have two
%% distinct representations.

\function{str()} 関数は、値を表現するときにかなり人間にとって可読な
ものにするためのものです。一方、\function{repr()} は
インタプリタで読めるような表現にする (あるいは、等価な値を表現する
ための構文がない場合には \exception{SyntaxError} を送出させる) 
ためのものです。
人間が利用するための特別な表現をもたないオブジェクトでは、
\function{str()} は \function{repr()} と同じ値を返します。
数値や、リストや辞書といった構造体のような多くの値は、どちらの関数でも
同じ表現になります。文字列と浮動小数点は特別で、二つの
別個の表現となります。

%% Some examples:

下にいくつか例を挙げます:

\begin{verbatim}
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(0.1)
'0.1'
>>> repr(0.1)
'0.10000000000000001'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print s
The value of x is 32.5, and y is 40000...
>>> # 文字列への repr() はクォートとバックスラッシュが付加される:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print hellos
'hello, world\n'
>>> # repr() の引数は Python オブジェクトの場合もある:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
>>> # 逆クォートは対話セッショで便利である:
... `x, y, ('spam', 'eggs')`
"(32.5, 40000, ('spam', 'eggs'))"
\end{verbatim}

%% Here are two ways to write a table of squares and cubes:

以下に 2 乗と 3 乗の値からなる表を書く二つの方法を示します:

\begin{verbatim}
>>> for x in range(1, 11):
...     print repr(x).rjust(2), repr(x*x).rjust(3),
...     # 上の行の末尾のコンマに注意
...     print repr(x*x*x).rjust(4)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
>>> for x in range(1,11):
...     print '%2d %3d %4d' % (x, x*x, x*x*x)
... 
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
\end{verbatim}

%% (Note that one space between each column was added by the way
%% \keyword{print} works: it always adds spaces between its arguments.)

(各カラムの間のスペース一個は \keyword{print} の働きで追加されて
いることに注意してください: \keyword{print} は引数間に常に
空白を追加します)

%% This example demonstrates the function \method{rjust()},
%% which right-justifies a string in a field of a given width by padding
%% it with spaces on the left.  There are similar methods
%% \method{ljust()} and \method{center()}.  These
%% functions do not write anything, they just return a new string.  If
%% the input string is too long, they don't truncate it, but return it
%% unchanged; this will mess up your column lay-out but that's usually
%% better than the alternative, which would be lying about a value.  (If
%% you really want truncation you can always add a slice operation, as in
%% \samp{ljust(x,~n)[0:n]}.)

この例では、メソッド \method{rjust()} を実際に利用しています。
\method{rjust()} は文字列を指定された幅のフィールド内に
右詰めで入るように、左に空白を追加します。同様のメソッドとして、
\method{ljust()} と \method{center()} が
あります。これらのメソッドは何か出力を行うわけではなく、ただ新しい文字列を
返します。入力文字列が長すぎる場合、文字列を切り詰めることはせず、
ただ値をそのまま返します; この仕様のために、カラムのレイアウトが
滅茶苦茶になるかもしれませんが、嘘の値が代わりに書き出される
よりはましです。(本当に切り詰めを行いたいのなら、全てのカラムに
\samp{x.ljust(n)[:n]}) のようにスライス表記を加える
こともできます。)

%% There is another method, \method{zfill()}, which pads a
%% numeric string on the left with zeros.  It understands about plus and
%% minus signs:

もう一つのメソッド、 \function{zfill()} は、数値文字列
の左側をゼロ詰めします。このメソッドは正と負の符号を正しく扱います:

\begin{verbatim}
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
\end{verbatim}

%% Using the \code{\%} operator looks like this:

\code{\%} 演算子を使う場合は以下のようになります:

\begin{verbatim}
>>> import math
>>> print 'The value of PI is approximately %5.3f.' % math.pi
The value of PI is approximately 3.142.
\end{verbatim}

%% If there is more than one format in the string, you need to pass a
%% tuple as right operand, as in this example:

文字列の中に複数の書式がある場合には、以下の例のように、右側の被演算子
にタプルを渡す必要があります:

\begin{verbatim}
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print '%-10s ==> %10d' % (name, phone)
... 
Jack       ==>       4098
Dcab       ==>       7678
Sjoerd     ==>       4127
\end{verbatim}

%% Most formats work exactly as in C and require that you pass the proper
%% type; however, if you don't you get an exception, not a core dump.
%% The \code{\%s} format is more relaxed: if the corresponding argument is
%% not a string object, it is converted to string using the
%% \function{str()} built-in function.  Using \code{*} to pass the width
%% or precision in as a separate (integer) argument is supported.  The
%% C formats \code{\%n} and \code{\%p} are not supported.

ほとんどの書式化は C 言語と同じように動作し、正しい型を渡す
必要があります; しかし、正しい型を渡さなかった場合にはコアダンプ
ではなく例外の送出になります。書式 \code{\%s} はもっと寛大です:
対応する引数が文字列オブジェクトでなければ、組込み関数 \function{str()} 
を使って文字列に変換してくれます。また、数値表現の桁幅や精度を別個の
(整数の) 引数として渡せるよう、\code{*} がサポートされています。
C 言語の書式 \code{\%n} と \code{\%p} はサポートされていません。

%% If you have a really long format string that you don't want to split
%% up, it would be nice if you could reference the variables to be
%% formatted by name instead of by position.  This can be done by using
%% form \code{\%(name)format}, as shown here:

もしも長い書式化文字列があり、それを分割したくない場合には、
変数を引数の位置ではなく、変数の名前で参照できるとよいでしょう。
以下の形式 \code{\%(name)format} を使えば可能になります:

\begin{verbatim}
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print 'Jack: %(Jack)d; Sjoerd: %(Sjoerd)d; Dcab: %(Dcab)d' % table
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
\end{verbatim}

%% This is particularly useful in combination with the new built-in
%% \function{vars()} function, which returns a dictionary containing all
%% local variables.

全てのローカルな変数が入った辞書を返す、新たに紹介する組み込み関数
 \function{vars()} と組み合わせると特に便利です。

\section{ファイルを読み書きする \label{files}} % Reading and Writing Files

% Opening files 
%% \function{open()}\bifuncindex{open} returns a file
%% object\obindex{file}, and is most commonly used with two arguments:
%% \samp{open(\var{filename}, \var{mode})}.

\function{open()}\bifuncindex{open} はファイルオブジェクトを
返します。\obindex{file} \function{open()} は、
\samp{open(\var{filename}, \var{mode})} のように二つの引数を伴って
呼び出されることがほとんどです。

\begin{verbatim}
>>> f=open('/tmp/workfile', 'w')
>>> print f
<open file '/tmp/workfile', mode 'w' at 80a0960>
\end{verbatim}

%% The first argument is a string containing the filename.  The second
%% argument is another string containing a few characters describing the
%% way in which the file will be used.  \var{mode} can be \code{'r'} when
%% the file will only be read, \code{'w'} for only writing (an existing
%% file with the same name will be erased), and \code{'a'} opens the file
%% for appending; any data written to the file is automatically added to
%% the end.  \code{'r+'} opens the file for both reading and writing.
%% The \var{mode} argument is optional; \code{'r'} will be assumed if
%% it's omitted.

最初の引数はファイル名の入った文字列です。二つめの引数もまた文字列で、
ファイルをどのように使うかを示す数個の文字が入っています。
\var{mode} は、ファイルが読み出し専用なら \code{'r'} 、
書き込み専用 (同名の既存のファイルがあれば消去されます) なら \code{'w'} 
とします。\code{'a'} はファイルを追記用に開きます; ファイルに書き込まれた
内容は自動的にファイルの終端に追加されます。\code{'r+'} はファイルを読み
書き両用に開きます。\var{mode} 引数はオプションです; 省略された場合には
\code{'r'} であると仮定します。

%% On Windows and the Macintosh, \code{'b'} appended to the
%% mode opens the file in binary mode, so there are also modes like
%% \code{'rb'}, \code{'wb'}, and \code{'r+b'}.  Windows makes a
%% distinction between text and binary files; the end-of-line characters
%% in text files are automatically altered slightly when data is read or
%% written.  This behind-the-scenes modification to file data is fine for
%% \ASCII{} text files, but it'll corrupt binary data like that in \file{JPEG} or
%% \file{EXE} files.  Be very careful to use binary mode when reading and
%% writing such files.

Windows や Macintosh では、\var{mode} に \code{'b'} を追加すると
ファイルをバイナリモードで開きます。したがって、 \code{'rb'}, 
\code{'wb'}, \code{'r+b'} といったモードがあります。
Windows はテキストファイルとバイナリファイルを区別しています;
テキストファイルでは、読み書きの際に行末文字が自動的に少し変更
されます。
この舞台裏でのファイルデータ変更は、\ASCII{} でできたテキストファイル
では差し支えないものですが、\file{JPEG} や \file{EXE} ファイルのような
バイナリデータは破損してしまうことになるでしょう。
こうしたファイルを読み書きする際にはバイナリモードを使うよう十分
注意してください。

\subsection{ファイルオブジェクトのメソッド \label{fileMethods}} % Methods of File Objects

%% The rest of the examples in this section will assume that a file
%% object called \code{f} has already been created.

この節の以降の例は、\code{f} というファイルオブジェクトが既に
生成されているものと仮定します。

%% To read a file's contents, call \code{f.read(\var{size})}, which reads
%% some quantity of data and returns it as a string.  \var{size} is an
%% optional numeric argument.  When \var{size} is omitted or negative,
%% the entire contents of the file will be read and returned; it's your
%% problem if the file is twice as large as your machine's memory.
%% Otherwise, at most \var{size} bytes are read and returned.  If the end
%% of the file has been reached, \code{f.read()} will return an empty
%% string (\code {""}).

ファイルの内容を読み出すには、\code{f.read(\var{size})} を呼び出します。
このメソッドはある量のデータを読み出して、文字列として返します。
\var{size} はオプションの数値引数です。\var{size} が省略されたり
負の数であった場合、ファイルの内容全てを読み出して返します; ただし、
ファイルがマシンのメモリの二倍の大きさもある場合にはどうなるか
わかりません。
\var{size} が負でない数ならば、最大で \var{size} バイトを読み出して
返します。ファイルの終端にすでに達していた場合、\code{f.read()} は
空の文字列 (\code{""}) を返します。

\begin{verbatim}
>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
\end{verbatim}

%% \code{f.readline()} reads a single line from the file; a newline
%% character (\code{\e n}) is left at the end of the string, and is only
%% omitted on the last line of the file if the file doesn't end in a
%% newline.  This makes the return value unambiguous; if
%% \code{f.readline()} returns an empty string, the end of the file has
%% been reached, while a blank line is represented by \code{'\e n'}, a
%% string containing only a single newline.  

\code{f.readline()} はファイルから 1 行だけを読み取ります;
改行文字 (\code{\e n}) は読み出された文字列の終端に残ります。
改行が省略されるのは、ファイルが改行で終わっていない場合の最終行
のみです。これは、戻り値があいまいでないようにするためです;
\code{f.readline()} が空の文字列を返したら、ファイルの終端に
達したことが分かります。一方、空行は \code{'\e n'} 、すなわち
改行 1 文字だけからなる文字列で表現されます。

\begin{verbatim}
>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''
\end{verbatim}

%% \code{f.readlines()} returns a list containing all the lines of data
%% in the file.  If given an optional parameter \var{sizehint}, it reads
%% that many bytes from the file and enough more to complete a line, and
%% returns the lines from that.  This is often used to allow efficient
%% reading of a large file by lines, but without having to load the
%% entire file in memory.  Only complete lines will be returned.

\code{f.readlines()} は、ファイルに入っているデータの全ての行からなる
リストを返します。オプションのパラメタ \var{sizehint} が指定されて
いれば、ファイルから指定されたバイト数を読み出し、さらに一行を完成
させるのに必要なだけを読み出して、読み出された行からなる
リストを返します。このメソッドは巨大なファイルを行単位で効率的に
読み出すためによく使われます。未完成の行が返されることはありません。

\begin{verbatim}
>>> f.readlines()
['This is the first line of the file.\n', 'Second line of the file\n']
\end{verbatim}

%% An alternate approach to reading lines is to loop over the file object.
%% This is memory efficient, fast, and leads to simpler code:

行を読む別のアプローチは、ファイルオブジェクトについてループをおこなう
ことです。これは省メモリで、速く、コードがよりシンプルになります:

\begin{verbatim}
>>> for line in f:
        print line,
        
This is the first line of the file.
Second line of the file
\end{verbatim}

%% The alternative approach is simpler but does not provide as fine-grained
%% control.  Since the two approaches manage line buffering differently,
%% they should not be mixed.

この方法はシンプルですが細かなコントロールをすることができません。
行バッファを管理する方法が異なるので、これらを混在させて使うことはできま
せん。

%% \code{f.write(\var{string})} writes the contents of \var{string} to
%% the file, returning \code{None}.  

\code{f.write(\var{string})} は、 \var{string} の内容をファイルに
書き込み、\code{None} を返します。

\begin{verbatim}
>>> f.write('This is a test\n')
\end{verbatim}

%% To write something other than a string, it needs to be converted to a
%% string first:

文字列以外のものを出力したい場合、まず文字列に変換してやる必要が
あります:
\begin{verbatim}
>>> value = ('the answer', 42)
>>> s = str(value)
>>> f.write(s)
\end{verbatim}

%% \code{f.tell()} returns an integer giving the file object's current
%% position in the file, measured in bytes from the beginning of the
%% file.  To change the file object's position, use
%% \samp{f.seek(\var{offset}, \var{from_what})}.  The position is
%% computed from adding \var{offset} to a reference point; the reference
%% point is selected by the \var{from_what} argument.  A
%% \var{from_what} value of 0 measures from the beginning of the file, 1
%% uses the current file position, and 2 uses the end of the file as the
%% reference point.  \var{from_what} can be omitted and defaults to 0,
%% using the beginning of the file as the reference point.

\code{f.tell()} は、ファイルオブジェクトが指しているあるファイル中の
位置を示す整数を、ファイルの先頭からのバイト数で図った値で返します。
ファイルオブジェクトの位置を変更するには、\samp{f.seek(\var{offset}, 
\var{from_what})} を使います。ファイル位置は基準点 (reference point)
にオフセット値 \var{offset} を足して計算されます;
参照点は \var{from_what} 引数で選びます。
\var{from_what} の値が 0 ならばファイルの先頭から測り、
1 ならば現在のファイル位置を使い、2 ならばファイルの終端を
参照点として使います。
\var{from_what} は省略することができ、デフォルトの値は 0 、すなわち
参照点としてファイルの先頭を使います。

\begin{verbatim}
>>> f = open('/tmp/workfile', 'r+')
>>> f.write('0123456789abcdef')
>>> f.seek(5)     # ファイルの第6バイトへ行く
>>> f.read(1)        
'5'
>>> f.seek(-3, 2) # 終端から前へ第3バイトへ行く
>>> f.read(1)
'd'
\end{verbatim}

%% When you're done with a file, call \code{f.close()} to close it and
%% free up any system resources taken up by the open file.  After calling
%% \code{f.close()}, attempts to use the file object will automatically fail.

ファイルが用済みになったら、\code{f.close()} を呼び出してファイルを
閉じ、ファイルを開くために取られていたシステム資源を解放します。
\code{f.close()} を呼び出した後、そのファイルオブジェクトを使おうと
すると自動的に失敗します。

\begin{verbatim}
>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: I/O operation on closed file
\end{verbatim}

%% File objects have some additional methods, such as
%% \method{isatty()} and \method{truncate()} which are less frequently
%% used; consult the Library Reference for a complete guide to file
%% objects.

ファイルオブジェクトには、他にも \method{isatty()} や \method{truncate()} 
といった、あまり使われないメソッドがあります; 
ファイルオブジェクトについての完全なガイドは、ライブラリリファレンスを
参照してください。

\subsection{\module{pickle} モジュール \label{pickle}} % The \module{pickle} Module
\refstmodindex{pickle}

%% Strings can easily be written to and read from a file. Numbers take a
%% bit more effort, since the \method{read()} method only returns
%% strings, which will have to be passed to a function like
%% \function{int()}, which takes a string like \code{'123'} and
%% returns its numeric value 123.  However, when you want to save more
%% complex data types like lists, dictionaries, or class instances,
%% things get a lot more complicated.

文字列をファイルに読み書きするのは簡単にできます。数値でもほんの
わずかに苦労するくらいです。というのは、\method{read()} は文字列だけを
返すので、\code{'123'} のような文字列を受け取って、その数値 123 を返す
\function{int()} のような関数に対して文字列を渡してやらなければ
ならないからです。ところが、リストや辞書、クラスのインスタンスのように、
もっと複雑なデータ型を保存したいなら、事態はもっと複雑になります。

%% Rather than have users be constantly writing and debugging code to
%% save complicated data types, Python provides a standard module called
%% \module{pickle}.  This is an amazing module that can take almost
%% any Python object (even some forms of Python code!), and convert it to
%% a string representation; this process is called \dfn{pickling}.  
%% Reconstructing the object from the string representation is called
%% \dfn{unpickling}.  Between pickling and unpickling, the string
%% representing the object may have been stored in a file or data, or
%% sent over a network connection to some distant machine.

複雑なデータ型を保存するためのコードを利用者に毎回毎回書かせて
デバッグさせる代わりに、Python では \module{pickle} という標準
モジュールを用意しています。\module{pickle} は驚くべきモジュールで、
ほとんどどんな Python オブジェクトも (ある形式の Python コード
でさえも!) 受け取って文字列表現へ変換できます。
この変換過程は \dfn{pickling} (ピクルス (漬物) 化、以降 pickle 化) 
と呼ばれます。文字列表現からオブジェクトを再構成する操作は
\dfn{unpickling} (逆 pickle 化)と呼びます。
pickle 化や unpickle 化の間、オブジェクトを表現する文字列は
ファイルやデータに保存したり、ネットワーク接続を介して離れたマシンに
送信したりできます。

%% If you have an object \code{x}, and a file object \code{f} that's been
%% opened for writing, the simplest way to pickle the object takes only
%% one line of code:

オブジェクト \code{x} と、書込み用に開かれているファイルオブジェクト
\code{f} があると仮定すると、オブジェクトを pickle 化する最も簡単な
方法は、たった一行のコードしか必要ありません:

\begin{verbatim}
pickle.dump(x, f)
\end{verbatim}
%% To unpickle the object again, if \code{f} is a file object which has
%% been opened for reading:

逆 pickle 化して再びオブジェクトに戻すには、
\code{f} を読取り用に開かれているファイル・オブジェクトと仮定して:

\begin{verbatim}
x = pickle.load(f)
\end{verbatim}

とします。

%% (There are other variants of this, used when pickling many objects or
%% when you don't want to write the pickled data to a file; consult the
%% complete documentation for 
%% \ulink{\module{pickle}}{../lib/module-pickle.html} in the
%% \citetitle[../lib/]{Python Library Reference}.)

(逆 pickle 化にはいくつか変型があり、たくさんのオブジェクトを pickle 化
したり、 pickle 化されたデータをファイルに書きたくないときに使われます。
完全なドキュメントについては、
\citetitle[../lib/]{ライブラリリファレンス} の 
\ulink{\module{pickle}}{../lib/module-pickle.html}
を調べてください。)

%% \ulink{\module{pickle}}{../lib/module-pickle.html} is the standard way to make Python objects which can
%% be stored and reused by other programs or by a future invocation of
%% the same program; the technical term for this is a
%% \dfn{persistent} object.  Because \ulink{\module{pickle}}{../lib/module-pickle.html} is so widely used,
%% many authors who write Python extensions take care to ensure that new
%% data types such as matrices can be properly pickled and unpickled.

\ulink{\module{pickle}}{../lib/module-pickle.html}
は、Python のオブジェクトを保存できるようにし、
他のプログラムや、同じプログラムが将来起動されたときに再利用
できるようにする標準の方法です; 技術的な用語でいうと \dfn{persistent}
(永続性) オブジェクトです。
\ulink{\module{pickle}}{../lib/module-pickle.html}
はとても広範に使われている
ので、Python 拡張モジュールの多くの作者は、行列のような新たなデータ型が
正しく pickle 化/unpickle 化できるよう気をつけています。

\chapter{エラーと例外 \label{errors}} % Errors and Exceptions

%% Until now error messages haven't been more than mentioned, but if you
%% have tried out the examples you have probably seen some.  There are
%% (at least) two distinguishable kinds of errors:
%% \emph{syntax errors} and \emph{exceptions}.

これまでエラーメッセージについては簡単に触れるだけでしたが、チュートリアル
中の例を自分で試していたら、実際にいくつかのエラーメッセージを見ている
ことでしょう。エラーには (少なくとも) 二つのはっきり異なる種類があります:
それは \emph{構文エラー (syntax error)} と\emph{例外 (exception)} です。

\section{構文エラー \label{syntaxErrors}} % Syntax Errors

%% Syntax errors, also known as parsing errors, are perhaps the most common
%% kind of complaint you get while you are still learning Python:

構文エラーは構文解析エラー (parsing error) としても知られており、
まだ Python を学習中なら、おそらくもっともよく受け取る種の文句でしょう:

\begin{verbatim}
>>> while True print 'Hello world'
  File "<stdin>", line 1, in ?
    while True print 'Hello world'
                   ^
SyntaxError: invalid syntax
\end{verbatim}

%% The parser repeats the offending line and displays a little `arrow'
%% pointing at the earliest point in the line where the error was
%% detected.  The error is caused by (or at least detected at) the token
%% \emph{preceding} the arrow: in the example, the error is detected at
%% the keyword \keyword{print}, since a colon (\character{:}) is missing
%% before it.  File name and line number are printed so you know where to
%% look in case the input came from a script.

パーサは違反の起きている行を繰り返し、小さな `矢印' を表示して、
違反の起きている行中でエラーが検出された最初の位置を示します。
エラーは矢印の\emph{直前の} トークンでひき起こされています (または、
少なくともそこで検出されています)。
上述の例の中では、エラーは \keyword{print} で検出されています。
コロン (\character{:}) がその前に無いからです。
入力がスクリプトから来ている場合は、どこを見ればよいか分かるように
ファイル名と行番号が出力されます。

\section{例外 \label{exceptions}} % Exceptions

%% Even if a statement or expression is syntactically correct, it may
%% cause an error when an attempt is made to execute it.
%% Errors detected during execution are called \emph{exceptions} and are
%% not unconditionally fatal: you will soon learn how to handle them in
%% Python programs.  Most exceptions are not handled by programs,
%% however, and result in error messages as shown here:

たとえ文や式が構文的に正しくても、実行しようとしたときにエラーが
発生するかもしれません。
実行中に検出されたエラーは \emph{例外 (exception)} と呼ばれ、
常に致命的とは限りません: Python プログラムで例外をどのように扱うかは、
すぐに習得することでしょう。ほとんどの例外はプログラムで処理されず、
以下に示されるようなメッセージになります:

\begin{verbatim}
>>> 10 * (1/0)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ZeroDivisionError: integer division or modulo by zero
>>> 4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: cannot concatenate 'str' and 'int' objects
\end{verbatim}

%% The last line of the error message indicates what happened.
%% Exceptions come in different types, and the type is printed as part of
%% the message: the types in the example are
%% \exception{ZeroDivisionError}, \exception{NameError} and
%% \exception{TypeError}.
%% The string printed as the exception type is the name of the built-in
%% name for the exception that occurred.  This is true for all built-in
%% exceptions, but need not be true for user-defined exceptions (although
%% it is a useful convention).
%% Standard exception names are built-in identifiers (not reserved
%% keywords).

エラーメッセージの最終行は何が起こったかを示しています。
例外は様々な例外型 (type) で起こり、その型がエラーメッセージの
一部として出力されます: 上の例での型は \exception{ZeroDivisionError},
\exception{NameError}, \exception{TypeError} です。
例外型として出力される文字列は、発生した例外の組み込み名です。
これは全ての組み込み例外について成り立ちますが、
ユーザ定義の例外では (成り立つようにするのは有意義な慣習ですが)
必ずしも成り立ちません。
標準例外の名前は組み込みの識別子です (予約語ではありません)。

%% The rest of the line provides detail based on the type of exception
%%and what caused it.

残りの行は例外の詳細で、その例外の型と何が起きたかに依存します。

%% The preceding part of the error message shows the context where the
%% exception happened, in the form of a stack traceback.
%% In general it contains a stack traceback listing source lines; however,
%% it will not display lines read from standard input.

エラーメッセージの先頭部分では、例外が発生した実行コンテキスト
(context) を、スタックのトレースバック (stack traceback) の
形式で示しています。一般には、この部分にはソースコード行を
リストしたトレースバックが表示されます; しかし、標準入力から
読み取られた行については表示しません。

%% The \citetitle[../lib/module-exceptions.html]{Python Library
%% Reference} lists the built-in exceptions and their meanings.

\citetitle[../lib/module-exceptions.html]{Python ライブラリリファレンス}
には、組み込み例外とその意味がリストされています。


\section{例外を処理する \label{handling}} % Handling Exceptions

%% It is possible to write programs that handle selected exceptions.
%% Look at the following example, which asks the user for input until a
%% valid integer has been entered, but allows the user to interrupt the
%% program (using \kbd{Control-C} or whatever the operating system
%% supports); note that a user-generated interruption is signalled by
%% raising the \exception{KeyboardInterrupt} exception.

例外を選別して処理するようなプログラムを書くことができます。
以下の例を見てください。この例では、有効な文字列が入力されるまで
ユーザに入力を促しますが、ユーザがプログラムに
(\kbd{Control-C} か、またはオペレーティングシステムがサポート
している何らかのキーを使って) 割り込みをかけてプログラムを
中断させることができるようにしています; ユーザが生成した割り込みは、
\exception{KeyboardInterrupt} 例外が送出されることで通知される
ということに注意してください。

\begin{verbatim}
>>> while True:
...     try:
...         x = int(raw_input("Please enter a number: "))
...         break
...     except ValueError:
...         print "Oops!  That was no valid number.  Try again..."
...     
\end{verbatim}

%% The \keyword{try} statement works as follows.

\keyword{try} 文は下記のように動作します。

\begin{itemize}
\item
%% First, the \emph{try clause} (the statement(s) between the
%% \keyword{try} and \keyword{except} keywords) is executed.
まず、 \emph{try 節 (try clause)} (キーワード \keyword{try} と 
\keyword{except} のあいだの文) が実行されます。

\item
%% If no exception occurs, the \emph{except\ clause} is skipped and
%% execution of the \keyword{try} statement is finished.
何も例外が発生しなければ、\emph{except 節} をスキップして 
\keyword{try} 文の実行を終えます。

\item
%% If an exception occurs during execution of the try clause, the rest of
%% the clause is skipped.  Then if its type matches the exception named
%% after the \keyword{except} keyword, the except clause is executed, and
%% then execution continues after the \keyword{try} statement.

try 節内の実行中に例外が発生すると、その節の残りは飛ばされます。
次に、例外型が \keyword{except} キーワードの後に指定されている
例外に一致する場合、except 節が実行
された後、 \keyword{try} 節の後の文に実行が継続されます。

\item
%% If an exception occurs which does not match the exception named in the
%% except clause, it is passed on to outer \keyword{try} statements; if
%% no handler is found, it is an \emph{unhandled exception} and execution
%% stops with a message as shown above.
もしも except 節で指定された例外と一致しない例外が発生すると、
その例外は \keyword{try} 文の外側に渡されます。例外に対する
ハンドラ (handler、処理部) がどこにもなければ、
\emph{処理されない例外 (unhandled exception)} となり、
上記に示したようなメッセージを出して実行を停止します。

\end{itemize}

%% A \keyword{try} statement may have more than one except clause, to
%% specify handlers for different exceptions.  At most one handler will
%% be executed.  Handlers only handle exceptions that occur in the
%% corresponding try clause, not in other handlers of the same
%% \keyword{try} statement.  An except clause may name multiple exceptions
%% as a parenthesized list, for example:

一つの \keyword{try} 文に複数の except 節を設けて、さまざまな例外に
対するハンドラを指定することができます。同時に一つ以上のハンドラが
実行されることはありません。ハンドラは対応する try 節内で発生した
例外だけを処理し、同じ try 節内の別の例外ハンドラで起きた例外は
処理しません。except 節には複数の例外を丸括弧で囲ったタプルにして
渡すことができます。例えば以下のようにします:

\begin{verbatim}
... except (RuntimeError, TypeError, NameError):
...     pass
\end{verbatim}

%% The last except clause may omit the exception name(s), to serve as a
%% wildcard.  Use this with extreme caution, since it is easy to mask a
%% real prognnnnramming error in this way!  It can also be used to print an
%% error message and then re-raise the exception (allowing a caller to
%% handle the exception as well):

最後の except 節では例外名を省いて、ワイルドカード (wildcard、総称記号)
にすることができます。ワイルドカードの except 節は非常に注意して使って
ください。というのは、ワイルドカードは通常のプログラムエラーをたやすく
隠してしまうからです！ワイルドカードの except 節はエラーメッセージを
出力した後に例外を再送出する (関数やメソッドの呼び出し側が同様にして
例外を処理できるようにする) 用途にも使えます:

\begin{verbatim}
import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except IOError, (errno, strerror):
    print "I/O error(%s): %s" % (errno, strerror)
except ValueError:
    print "Could not convert data to an integer."
except:
    print "Unexpected error:", sys.exc_info()[0]
    raise
\end{verbatim}

%% The \keyword{try} \ldots\ \keyword{except} statement has an optional
%% \emph{else clause}, which, when present, must follow all except
%% clauses.  It is useful for code that must be executed if the try
%% clause does not raise an exception.  For example:

\keyword{try} \ldots\ \keyword{except} 文には、オプションで
\emph{else 節 (else clause)} を設けることができます。\keyword{else}
節を設ける場合、全ての \keyword{except} 節よりも後ろに置かねばなりません。
\keyword{except} 節は、try 節で全く例外が送出されなかったときに
実行されるコードを書くのに役立ちます。例えば以下のようにします:

\begin{verbatim}
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print 'cannot open', arg
    else:
        print arg, 'has', len(f.readlines()), 'lines'
        f.close()
\end{verbatim}

%% The use of the \keyword{else} clause is better than adding additional
%% code to the \keyword{try} clause because it avoids accidentally
%% catching an exception that wasn't raised by the code being protected
%% by the \keyword{try} \ldots\ \keyword{except} statement.

追加のコードを追加するのは \keyword{try} 節の後ろよりも \keyword{else} 
節の方がよいでしょう。なぜなら、そうすることで
\keyword{try} \ldots\ \keyword{except} 文で保護したいコードから
送出されたもの以外の例外を偶然に捕捉してしまうという事態を避けられる
からです。

%% When an exception occurs, it may have an associated value, also known as
%% the exception's \emph{argument}.
%% The presence and type of the argument depend on the exception type.

例外が発生するとき、例外に関連付けられた値を持つことができます。
この値は例外の例外の\emph{引数 (argument)} としても知られています。
引数の有無と引数の型がどうなっているかは例外の型に依存します。

%% The except clause may specify a variable after the exception name (or tuple).
%% The variable is bound to an exception instance with the arguments stored
%% in \code{instance.args}.  For convenience, the exception instance
%% defines \method{__getitem__} and \method{__str__} so the arguments can
%% be accessed or printed directly without having to reference \code{.args}.

except 節では、例外名 (または例外名タプル) の後に変数を指定することが
できます。この変数は例外インスタンスに結び付けられており、
 \code{instance.args} に例外インスタンス生成時の引数が入っています。
例外インスタンスには \method{__getitem__} および \method{__str__} が
定義されており、\code{.args} を参照しなくても引数に直接アクセスしたり
印字したりできるように利便性が図られています。

%% But use of \code{.args} is discouraged.  Instead, the preferred use is to pass
%% a single argument to an exception (which can be a tuple if multiple arguments
%% are needed) and have it bound to the \code{message} attribute.  One my also
%% instantiate an exception first before raising it and add any attributes to it
%% as desired.

しかし \code{.args}の利用は推奨されません。そのかわりに、例外へ
引数を1つだけ渡してください（複数の値が必要な場合にはタプルを使用でき
ます）。そしてそれを \code{message}属性に結びつけます。
例外をraiseする前にインスタンス化をするときだけでなく、必要に応じて
属性を追加できます。


\begin{verbatim}
>>> try:
...    raise Exception('spam', 'eggs')
... except Exception, inst:
...    print type(inst)     # 例外インスタンス
...    print inst.args      # .args に記憶されている引数
...    print inst           # __str__ で引数を直接出力できる
...    x, y = inst          # __getitem__ で引数を直接アンパックできる
...    print 'x =', x
...    print 'y =', y
...
<type 'instance'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
\end{verbatim}

%% If an exception has an argument, it is printed as the last part
%% (`detail') of the message for unhandled exceptions.

処理されない例外の場合、例外が引数を持っていれば、メッセージの
最後の (`詳細説明の') 部分に出力されます。

%% Exception handlers don't just handle exceptions if they occur
%% immediately in the try clause, but also if they occur inside functions
%% that are called (even indirectly) in the try clause.
%% For example:

例外ハンドラは、try 節でじかに発生した例外を処理するだけではなく、
その try 節から呼び出された関数の内部で発生した例外も処理します
(間接的に呼ばれていてもです) 。例えば:

\begin{verbatim}
>>> def this_fails():
...     x = 1/0
... 
>>> try:
...     this_fails()
... except ZeroDivisionError, detail:
...     print 'Handling run-time error:', detail
... 
Handling run-time error: integer division or modulo by zero
\end{verbatim}


\section{例外を送出する \label{raising}} % Raising Exceptions

%% The \keyword{raise} statement allows the programmer to force a
%% specified exception to occur.
%% For example:

\keyword{raise} 文を使うと、プログラマは指定した例外を強制的に
送出させられます。例えば:

\begin{verbatim}
>>> raise NameError, 'HiThere'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: HiThere
\end{verbatim}

%% The first argument to \keyword{raise} names the exception to be
%% raised.  The optional second argument specifies the exception's
%% argument.  Alternatively, the above could be written as
%% \code{raise NameError('HiThere')}.  Either form works fine, but there
%% seems to be a growing stylistic preference for the latter.


\keyword{raise} の第一引数には、ひき起こすべき例外を指定します。
オプションの第二引数では例外の引数を指定します。
同じことを　\code{raise NameError('HiThere')}　としても記述できます。
どちらの形式でもうまく動きますが後者のほうがスタイルがよくみえます。


%% If you need to determine whether an exception was raised but don't
%% intend to handle it, a simpler form of the \keyword{raise} statement
%% allows you to re-raise the exception:

例外が発生したかどうかは判定したいが、その処理を行おうとは思っていない
場合、単純な形式の \keyword{raise} 文を使って例外を再送出させることが
できます:

\begin{verbatim}
>>> try:
...     raise NameError, 'HiThere'
... except NameError:
...     print 'An exception flew by!'
...     raise
...
An exception flew by!
Traceback (most recent call last):
  File "<stdin>", line 2, in ?
NameError: HiThere
\end{verbatim}


\section{ユーザ定義の例外 \label{userExceptions}} % User-defined Exceptions

%% Programs may name their own exceptions by creating a new exception
%% class.  Exceptions should typically be derived from the
%% \exception{Exception} class, either directly or indirectly.  For
%% example:

プログラム上で新しい例外クラスを作成することで、独自の例外を指定する
ことができます。例外は、典型的に \exception{Exception} クラスから、
直接または間接的に導出したものです。例えば:

\begin{verbatim}
>>> class MyError(Exception):
...     def __init__(self, value):
...         self.value = value
...     def __str__(self):
...         return repr(self.value)
... 
>>> try:
...     raise MyError(2*2)
... except MyError, e:
...     print 'My exception occurred, value:', e.value
... 
My exception occurred, value: 4
>>> raise MyError, 'oops!'
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
__main__.MyError: 'oops!'
\end{verbatim}

%% In this example, the default \method{__init__} of \class{Exception}
%% has been overridden.  The new behavior simply creates the \var{value}
%% attribute.  This replaces the default behavior of creating the
%% \var{args} attribute.

この例では\class{Exception}のデフォルト\method{__init__}がオーバーライ
ドされています。新しいふるまいでは、単に \var{value}属性を作ります。
これはデフォルトの\var{args}属性を作成するふるまいを置き換えています。

%% Exception classes can be defined which do anything any other class can
%% do, but are usually kept simple, often only offering a number of
%% attributes that allow information about the error to be extracted by
%% handlers for the exception.  When creating a module that can raise
%% several distinct errors, a common practice is to create a base class
%% for exceptions defined by that module, and subclass that to create
%% specific exception classes for different error conditions:

例外クラスでは、他のクラスができることなら何でも定義することが
できますが、通常は単純なものにしておきます。たいていは、いくつかの
属性だけを提供し、例外が発生したときにハンドラがエラーに関する情報
を取り出せるようにする程度にとどめます。
複数の別個の例外を送出するようなモジュールを作成する際には、
そのモジュールで定義されている例外の基底クラスを作成するのが
一般的なならわしです:

\begin{verbatim}
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
\end{verbatim}

%% Most exceptions are defined with names that end in ``Error,'' similar
%% to the naming of the standard exceptions.

ほとんどの例外は、標準の例外の名前付けと同様に、 ``Error,'' 
で終わる名前で定義されています。

%% Many standard modules define their own exceptions to report errors
%% that may occur in functions they define.  More information on classes
%% is presented in chapter \ref{classes}, ``Classes.''

多くの標準モジュールでは、モジュールで定義されている関数内で発生する
可能性のあるエラーを報告させるために、独自の例外を定義しています。
クラスについての詳細な情報は \ref{classes} 章、 ``クラス'' で
提供されています。


\section{後片付け動作を定義する \label{cleanup}} % Defining Clean-up Actions

%% The \keyword{try} statement has another optional clause which is
%% intended to define clean-up actions that must be executed under all
%% circumstances.  For example:

\keyword{try} 文にはもう一つオプションの節があります。この節は
クリーンアップ動作を定義するためのもので、どんな状況でも必ず
実行されます。例えば:

\begin{verbatim}
>>> try:
...     raise KeyboardInterrupt
... finally:
...     print 'Goodbye, world!'
... 
Goodbye, world!
Traceback (most recent call last):
  File "<stdin>", line 2, in ?
KeyboardInterrupt
\end{verbatim}

%% A \emph{finally clause} is always executed before leaving the
%% \keyword{try} statement, whether an exception has occurred or not.
%% When an exception has occurred in the \keyword{try} clause and has not
%% been handled by an \keyword{except} clause (or it has occurred in a
%% \keyword{except} or \keyword{else} clause), it is re-raised after the
%% \keyword{finally} clause has been executed.  The \keyword{finally} clause
%% is also executed ``on the way out'' when any other clause of the
%% \keyword{try} statement is left via a \keyword{break}, \keyword{continue}
%% or \keyword{return} statement.  A more complicated example:

\emph{finally 節 (finally clause)} は、
\keyword{try} 節で例外が発生したかどうかに関係なく常に\keyword{try}節のあとに実
行されます。
\keyword{try}節の中で例外が発生して、\keyword{except}節でハンドルされ
ていない場合、または\keyword{except}節か\keyword{else}節で例外が発生し
た場合は、\keyword{finally} 節を実行した後、その例外を再送出します。
\keyword{finally} 節はまた、\keyword{try} 節から \keyword{break} 文や 
\keyword{continue} 文、\keyword{return} 文経由で抜ける際にも、
 ``抜ける途中で'' 実行されます。
より複雑な例です:

\begin{verbatim}
>>> def divide(x, y):
...     try:
...         result = x / y
...     except ZeroDivisionError:
...         print "division by zero!"
...     else:
...         print "result is", result
...     finally:
...         print "executing finally clause"
...
>>> divide(2, 1)
result is 2
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'
\end{verbatim}

%% As you can see, the \keyword{finally} clause is executed in any
%% event.  The \exception{TypeError} raised by dividing two strings
%% is not handled by the \keyword{except} clause and therefore
%% re-raised after the \keyword{finally} clauses has been executed.

見てわかるとおり、\keyword{finally}節はどの場合にも実行されています。
文字列を割り算することで発生した　\exception{TypeError} は
\keyword{except}節でハンドルされていませんので、\keyword{finally}節
実行後に再度raiseされています。

%% In real world applications, the \keyword{finally} clause is useful
%% for releasing external resources (such as files or network connections),
%% regardless of whether the use of the resource was successful.

実世界のアプリケーションでは、\keyword{finally}節は(ファイルやネットワー
ク接続などの)外部リソースを利用の成否にかかわらず開放するために便利です。

%% \section{Predefined Clean-up Actions \label{cleanup-with}}
\section{定義済み完了処理 \label{cleanup-with}}

%% Some objects define standard clean-up actions to be undertaken when
%% the object is no longer needed, regardless of whether or not the
%% operation using the object succeeded or failed.
%% Look at the following example, which tries to open a file and print
%% its contents to the screen.

オブジェクトのなかには、その利用の成否にかかわらず、不要になった際に
実行される標準的な完了処理が定義されているものがあります。
以下の、ファイルをオープンして内容を画面に表示する例をみてください:

\begin{verbatim}
for line in open("myfile.txt"):
    print line
\end{verbatim}

%% The problem with this code is that it leaves the file open for an
%% indeterminate amount of time after the code has finished executing.
%% This is not an issue in simple scripts, but can be a problem for
%% larger applications. The \keyword{with} statement allows
%% objects like files to be used in a way that ensures they are
%% always cleaned up promptly and correctly.

このコードの問題点は、このコードが実行されてから、ファイルをいつまで
openしたままでいるかわからないことです。
これは単純なスクリプトでは問題になりませんが、大きなアプリケーションで
は問題になりえます。\keyword{with}文はファイルのようなオブジェクトが
常に、即座に正しく完了されることを保証します。

\begin{verbatim}
with open("myfile.txt") as f:
    for line in f:
        print line
\end{verbatim}

%% After the statement is executed, the file \var{f} is always closed,
%% even if a problem was encountered while processing the lines. Other
%% objects which provide predefined clean-up actions will indicate
%% this in their documentation.

文が実行されたあと、行の処理中に問題があったかどうかに関係なく、ファイ
ル\var{f}は常にcloseされます。他の定義済み完了処理をもつオブジェクト
については、それぞれのドキュメントで示されます。

\chapter{クラス \label{classes}} % Classes

%% Python's class mechanism adds classes to the language with a minimum
%% of new syntax and semantics.  It is a mixture of the class mechanisms
%% found in \Cpp{} and Modula-3.  As is true for modules, classes in Python
%% do not put an absolute barrier between definition and user, but rather
%% rely on the politeness of the user not to ``break into the
%% definition.''  The most important features of classes are retained
%% with full power, however: the class inheritance mechanism allows
%% multiple base classes, a derived class can override any methods of its
%% base class or classes, and a method can call the method of a base class with the
%% same name.  Objects can contain an arbitrary amount of private data.

Python では、最小限の構文と意味付けを使ってクラス (class) のメカニズム
を言語に追加しています。Python のクラスは、\Cpp{} と Modula-3 で
見られるクラスメカニズムを混合したものです。モジュールがそうであるように、
Python におけるクラスでは、クラス定義とユーザとの間に絶対的な障壁を
おかず、ユーザが礼儀正しく、 ``定義に首を突っ込む'' ことはないと
あてにしています。とはいえ、クラスにおける最も重要な機能はそのままに、
完全な力を持っています: クラスの継承 (inheritance) メカニズムでは、
複数の基底クラスを持つことができ、導出されたクラスでは基底クラスの
任意のメソッドをオーバライド (override, 上書き) することができます。
メソッドでは、基底クラスのメソッドを同じ名前で呼び出すことができます。
オブジェクトには任意のプライベートなデータを入れることができます。

%% In \Cpp{} terminology, all class members (including the data members) are
%% \emph{public}, and all member functions are \emph{virtual}.  There are
%% no special constructors or destructors.  As in Modula-3, there are no
%% shorthands for referencing the object's members from its methods: the
%% method function is declared with an explicit first argument
%% representing the object, which is provided implicitly by the call.  As
%% in Smalltalk, classes themselves are objects, albeit in the wider
%% sense of the word: in Python, all data types are objects.  This
%% provides semantics for importing and renaming.  Unlike
%% \Cpp{} or Modula-3, built-in types can be used as base classes for
%% extension by the user.  Also, like in \Cpp{} but unlike in Modula-3, most
%% built-in operators with special syntax (arithmetic operators,
%% subscripting etc.) can be redefined for class instances.

\Cpp{} の用語では、全てのクラスメンバ (データメンバも含む) は
\emph{public} (公開されたデータ) であり、メンバ関数はすべて
\emph{仮想関数 (virtual)} です。特別なコンストラクタ (constructor:
生成関数) やデストラクタ (destructor: 破壊関数) はありません。Module-3
にあるような、オブジェクトのメンバをメソッドから参照するために短縮した
記法は使えません: メソッド関数の宣言では、オブジェクト自体を表すパラメ
タ第一引数に明示せねばなりません。第一引数のオブジェクトはメソッド呼び
出しの際に暗黙の引数として渡されます。Smalltalk に似て、クラスはそれ自
体がオブジェクトです。とはいえ、これは広義のオブジェクトという意味で、
Python では全てのデータ型はオブジェクトです。このことは、import や名前
変更といった操作のセマンティクスにつながります。
\Cpp{} や Modula-3 と違って、ユーザは組込みの型を基底クラスにして拡張
を行えます。また、\Cpp{} とは同じで Modula-3 とは違う点として、特別な
構文を伴うほとんどの組み込み演算子 (算術演算子 (arithmetic operator)
や添字表記) はクラスインスタンスで使うために再定義できます。

\section{用語について一言 \label{terminology}} % A Word About Terminology

%% Lacking universally accepted terminology to talk about classes, I will
%% make occasional use of Smalltalk and \Cpp{} terms.  (I would use Modula-3
%% terms, since its object-oriented semantics are closer to those of
%% Python than \Cpp, but I expect that few readers have heard of it.)

クラスに関して広範に受け入れられている用語定義がないので、
Smalltalk と \Cpp{} の用語を場合に応じて使っていくことに
します。 (オブジェクト指向における意味付けの方法は \Cpp よりも 
Modula-3 のほうが Python に近いので Modula-3 の用語を使いたいのですが、
ほとんどの読者はそれを耳にしたことがないと思います。)

%% Objects have individuality, and multiple names (in multiple scopes)
%% can be bound to the same object.  This is known as aliasing in other
%% languages.  This is usually not appreciated on a first glance at
%% Python, and can be safely ignored when dealing with immutable basic
%% types (numbers, strings, tuples).  However, aliasing has an
%% (intended!) effect on the semantics of Python code involving mutable
%% objects such as lists, dictionaries, and most types representing
%% entities outside the program (files, windows, etc.).  This is usually
%% used to the benefit of the program, since aliases behave like pointers
%% in some respects.  For example, passing an object is cheap since only
%% a pointer is passed by the implementation; and if a function modifies
%% an object passed as an argument, the caller will see the change --- this
%% obviates the need for two different argument passing mechanisms as in
%% Pascal.

オブジェクトには個体性があり、同一のオブジェクトに (複数のスコープの) 
複数の名前を割り当てることができます。この機能は他の言語では
別名 (ailias) づけとして知られています。Python を一見しただけでは、
別名づけの重要性は分からないことが多く、変更不能な基本型 (数値、文字列、
タプル) を扱うときには無視して差し支えありません。
しかしながら、別名付けには、リストや辞書、またプログラムの外部
にある実体 (ファイル、ウィンドウ、など) を表現するためのほとんどの型
が入った Python コードで意味付けを行う上で (意図的な！) 効果があります。
別名付けはいくつかの点でポインタのように振舞うので、通常はプログラムに
利するように使われます。例えば、オブジェクトの受け渡しは、実装上は
ポインタが渡されるだけなのでコストの低い操作になります; また、関数が
あるオブジェクトを引数として渡されたとき、関数の呼び出し側から
オブジェクトに対する変更を見ることができます --- これにより、
Pascal にあるような二つの引数渡し機構をもつ必要をなくしています。


\section{Python のスコープと名前空間 \label{scopes}} % Python Scopes and Name Spaces

%% Before introducing classes, I first have to tell you something about
%% Python's scope rules.  Class definitions play some neat tricks with
%% namespaces, and you need to know how scopes and namespaces work to
%% fully understand what's going on.  Incidentally, knowledge about this
%% subject is useful for any advanced Python programmer.

クラスを紹介する前に、Python のスコープ規則についてあることを話して
おかなければなりません。クラス定義はある巧みなトリックを名前空間に
施すので、何が起こっているのかを完全に理解するには、スコープと
名前空間がどのように動作するかを理解する必要があります。
ちなみに、この問題に関する知識は全ての Python プログラマにとって
有用です。

%% Let's begin with some definitions.

まず定義から始めましょう。

%% A \emph{namespace} is a mapping from names to objects.  Most
%% namespaces are currently implemented as Python dictionaries, but
%% that's normally not noticeable in any way (except for performance),
%% and it may change in the future.  Examples of namespaces are: the set
%% of built-in names (functions such as \function{abs()}, and built-in
%% exception names); the global names in a module; and the local names in
%% a function invocation.  In a sense the set of attributes of an object
%% also form a namespace.  The important thing to know about namespaces
%% is that there is absolutely no relation between names in different
%% namespaces; for instance, two different modules may both define a
%% function ``maximize'' without confusion --- users of the modules must
%% prefix it with the module name.

\emph{名前空間 (namespace)} とは、
名前からオブジェクトへの対応付け (mapping) です。
ほとんどの名前空間は、現状では Python の辞書として実装されていますが、
そのことは通常は (パフォーマンス以外では) 目立つことはないし、
将来は変更されるかもしれません。
名前空間の例には、組込み名の集合 (\function{abs()} 等の関数や組込み
例外名)、モジュールないのグローバルな名前; 関数を呼び出したときの
ローカルな名前、があります。その意味では、オブジェクトの属性から
なる集合もまた、名前空間を形成します。名前空間について知っておくべき
重要なことは、異なった名前空間にある名前の間には全く関係がないと
いうことです; 例えば、二つの別々のモジュールの両方で関数 
``maximize'' という関数を定義することができ、定義自体は混同され
ることはありません  --- モジュールのユーザは名前の前にモジュール名を
つけなければなりません。

%% By the way, I use the word \emph{attribute} for any name following a
%% dot --- for example, in the expression \code{z.real}, \code{real} is
%% an attribute of the object \code{z}.  Strictly speaking, references to
%% names in modules are attribute references: in the expression
%% \code{modname.funcname}, \code{modname} is a module object and
%% \code{funcname} is an attribute of it.  In this case there happens to
%% be a straightforward mapping between the module's attributes and the
%% global names defined in the module: they share the same namespace!
%% \footnote{
%%         Except for one thing.  Module objects have a secret read-only
%%         attribute called \member{__dict__} which returns the dictionary
%%         used to implement the module's namespace; the name
%%         \member{__dict__} is an attribute but not a global name.
%%         Obviously, using this violates the abstraction of namespace
%%         implementation, and should be restricted to things like
%%         post-mortem debuggers.
%% }

ところで、\emph{属性}という言葉は、ドットに続く名前すべてに対して
使っています --- 例えば式 \code{z.real} で、\code{real} は
オブジェクト \code{z} の属性です。厳密にいえば、モジュール内の名前に
対する参照は属性の参照です: 式 \code{modname.funcname} では、
\code{modname} はあるモジュールオブジェクトで、\code{funcname} は
その属性です。この場合には、たまたまモジュールの属性とモジュール内の
グローバルな名前の間には
この場合はたまたま、モジュールの属性とモジュールで定義されている
グローバル名の間には、直接的な対応付けがされます: これらの名前は
同じ名前空間を共有しているのです！
\footnote{例外が一つあります。
モジュールオブジェクトには、秘密の読取り専用の属性 \member{__dict__} 
があり、モジュールの名前空間を実装するために使われている辞書を返します;
\member{__dict__} という名前は属性ですが、グローバルな名前では
ありません。この属性を利用すると名前空間の実装に対する抽象化を
侵すことになるので、プログラムを検死するデバッガのような用途に限る
べきです。}

%% Attributes may be read-only or writable.  In the latter case,
%% assignment to attributes is possible.  Module attributes are writable:
%% you can write \samp{modname.the_answer = 42}.  Writable attributes may
%% also be deleted with the \keyword{del} statement.  For example,
%% \samp{del modname.the_answer} will remove the attribute
%% \member{the_answer} from the object named by \code{modname}.

属性は読取り専用にも、書き込み専用にもできます。
後者の場合、属性に代入することができます。
モジュール属性は書込み可能です: \samp{modname.the_answer = 42} と書く
ことができます。書込み可能な属性は、\keyword{del} 文で削除することも
できます。例えば、\samp{del modname.the_answer} は、\code{modname} 
で指定されたオブジェクトから属性 \member{the_answer} を除去します。

%% Name spaces are created at different moments and have different
%% lifetimes.  The namespace containing the built-in names is created
%% when the Python interpreter starts up, and is never deleted.  The
%% global namespace for a module is created when the module definition
%% is read in; normally, module namespaces also last until the
%% interpreter quits.  The statements executed by the top-level
%% invocation of the interpreter, either read from a script file or
%% interactively, are considered part of a module called
%% \module{__main__}, so they have their own global namespace.  (The
%% built-in names actually also live in a module; this is called
%% \module{__builtin__}.)

名前空間は様々な時点で作成され、その寿命も様々です。
組み込みの名前が入った名前空間は Python インタプリタが起動するときに
作成され、決して削除されることはありません。モジュールのグローバルな
名前空間は、モジュール定義が読み込まれたときに作成されます; 通常、
モジュールの名前空間は、インタプリタが終了するまで残ります。
インタプリタのトップレベルで実行された文は、スクリプトファイルから
読み出されたものでも対話的に読み出されたものでも、\module{__main__}
という名前のモジュールの一部分であるとみなされるので、独自の
名前空間を持つことになります。(組み込みの名前は実際にはモジュール内
に存在します; そのモジュールは \module{__builtin__} と呼ばれています。)

%% The local namespace for a function is created when the function is
%% called, and deleted when the function returns or raises an exception
%% that is not handled within the function.  (Actually, forgetting would
%% be a better way to describe what actually happens.)  Of course,
%% recursive invocations each have their own local namespace.

関数のローカルな名前空間は、関数が呼び出されたときに作成され、
関数から戻ったときや、関数内で例外が送出され、かつ関数内で処理され
なかった場合に削除されます。
(実際には、忘れられる、と言ったほうが起きていることをよく表して
います。) もちろん、再帰呼出しのときには、各々の呼び出しで各自の
ローカルな名前空間があります。

%% A \emph{scope} is a textual region of a Python program where a
%% namespace is directly accessible.  ``Directly accessible'' here means
%% that an unqualified reference to a name attempts to find the name in
%% the namespace.

\emph{スコープ (scope)} とは、ある名前空間が直接アクセスできる
(directly accessible) ような、Python プログラムのテキスト上の領域
です。
``直接アクセス可能'' とは、限定なし (unqualified) である名前を参照
した際に、その名前空間から名前を見つけようと試みることを意味します。


%% Although scopes are determined statically, they are used dynamically.
%% At any time during execution, there are at least three nested scopes whose
%% namespaces are directly accessible: the innermost scope, which is searched
%% first, contains the local names; the namespaces of any enclosing
%% functions, which are searched starting with the nearest enclosing scope;
%% the middle scope, searched next, contains the current module's global names;
%% and the outermost scope (searched last) is the namespace containing built-in
%% names.

スコープは静的に決定されますが、動的に使用されます。
実行中はいつでも、直接名前空間にアクセス可能な、少なくとも三つの
入れ子になったスコープがあります: 
最初に検索される最も内側のスコープには、ローカルな名前が入っています;
あるいは、最も内側のスコープを囲んでいる関数群のスコープで、最も
近傍のスコープから検索を始めます; 中間のスコープが次に検索され、
このスコープには現在のモジュールのグローバルな名前が入っています;
(最後に検索される) 最も外側のスコープは、組み込みの名前が入った
名前空間です。

%% If a name is declared global, then all references and assignments go
%% directly to the middle scope containing the module's global names.
%% Otherwise, all variables found outside of the innermost scope are read-only
%% (an attempt to write to such a variable will simply create a \emph{new}
%% local variable in the innermost scope, leaving the identically named
%% outer variable unchanged).

名前がグローバルであると宣言されている場合、その名前に対する参照や
代入は全て、モジュールのグローバルな名前の入った中間のスコープに
対して直接行われます。そうでない場合、最も内側のスコープより外側に
ある変数は全て読み出し専用(そのような変数に対する書き込みは、単に
\emph{新しい}ローカル変数もっとも内側のスコープで作成し、外部のスコー
プの値は変化しません)となります。

%% Usually, the local scope references the local names of the (textually)
%% current function.  Outside functions, the local scope references
%% the same namespace as the global scope: the module's namespace.
%% Class definitions place yet another namespace in the local scope.

通常、ローカルスコープは (プログラムテキスト上の) 現在の関数の
ローカルな名前を参照します。関数の外側では、ローカルスコープは
グローバルな名前空間と同じ名前空間: モジュールの名前空間を参照します。
クラスを定義すると、ローカルスコープの中にもう一つ名前空間が置かれ
ます。

%% It is important to realize that scopes are determined textually: the
%% global scope of a function defined in a module is that module's
%% namespace, no matter from where or by what alias the function is
%% called.  On the other hand, the actual search for names is done
%% dynamically, at run time --- however, the language definition is
%% evolving towards static name resolution, at ``compile'' time, so don't
%% rely on dynamic name resolution!  (In fact, local variables are
%% already determined statically.)

スコープはテキスト上で決定されていると理解することが重要です:
モジュール内で定義される関数のグローバルなスコープは、
関数がどこから呼び出されても、どんな別名をつけて呼び出されても、
そのモジュールの名前空間になります。反対に、実際の名前の検索は
実行時に動的に行われます --- とはいえ、言語の定義は、``コンパイル'' 
時の静的な名前解決の方向に進化しているので、
動的な名前解決に頼ってはいけません！ (事実、ローカルな変数は既に
静的に決定されています。)

%% A special quirk of Python is that assignments always go into the
%% innermost scope.  Assignments do not copy data --- they just
%% bind names to objects.  The same is true for deletions: the statement
%% \samp{del x} removes the binding of \code{x} from the namespace
%% referenced by the local scope.  In fact, all operations that introduce
%% new names use the local scope: in particular, import statements and
%% function definitions bind the module or function name in the local
%% scope.  (The \keyword{global} statement can be used to indicate that
%% particular variables live in the global scope.)

Python 特有の癖として、代入を行うと名前がいつも最も内側のスコープに
入るというものがあります。代入はデータのコピーを行いません ---
単に名前をオブジェクトに結びつける (bind) だけです。オブジェクトの削除
でも同じです: \samp{del x} は、\code{x} をローカルスコープが参照している
名前空間から削除します。実際、新たな名前を導入する操作は全てローカル
スコープを用います: とりわけ、 import 文や関数定義は、モジュールや
関数の名前をローカルスコープに結び付けます。(\keyword{global} 文を使えば、
特定の変数がグローバルスコープにあることを示せます。)

\section{クラス初見 \label{firstClasses}} % A First Look at Classes

%% Classes introduce a little bit of new syntax, three new object types,
%% and some new semantics.

クラスでは、新しい構文を少しと、三つの新たなオブジェクト型、そして
新たな意味付けをいくつか取り入れています。

\subsection{クラス定義の構文 \label{classDefinition}} % Class Definition Syntax

%% The simplest form of class definition looks like this:

クラス定義の最も単純な形式は、以下のようになります:

\begin{verbatim}
class ClassName:
    <文-1>
    .
    .
    .
    <文-N>
\end{verbatim}

%% Class definitions, like function definitions
%% (\keyword{def} statements) must be executed before they have any
%% effect.  (You could conceivably place a class definition in a branch
%% of an \keyword{if} statement, or inside a function.)

関数定義 (\keyword{def} 文) と同様、クラス定義が効果をもつには
まず実行しなければなりません。
(クラス定義を \keyword{if} 文の分岐先や関数内部に置くことも、
考え方としてはありえます。)

%% In practice, the statements inside a class definition will usually be
%% function definitions, but other statements are allowed, and sometimes
%% useful --- we'll come back to this later.  The function definitions
%% inside a class normally have a peculiar form of argument list,
%% dictated by the calling conventions for methods --- again, this is
%% explained later.

実際には、クラス定義の内側にある文は、通常は関数定義になりますが、
他の文を書くこともでき、それがそれが役に立つこともあります --- 
これについては後で述べます。クラス内の関数定義は通常、メソッドの
呼び出し規約で決められた独特の形式の引数リストを持ちます ---
これについても後で述べます。

%% When a class definition is entered, a new namespace is created, and
%% used as the local scope --- thus, all assignments to local variables
%% go into this new namespace.  In particular, function definitions bind
%% the name of the new function here.

クラス定義に入ると、新たな名前空間が作成され、ローカルな
名前空間として使われます --- 従って、ローカルな変数に対する
全ての代入はこの新たな名前空間に名要ります。特に、関数定義を
行うと、新たな関数の名前はこの名前空間に結び付けられます。

%% When a class definition is left normally (via the end), a \emph{class
%% object} is created.  This is basically a wrapper around the contents
%% of the namespace created by the class definition; we'll learn more
%% about class objects in the next section.  The original local scope
%% (the one in effect just before the class definitions was entered) is
%% reinstated, and the class object is bound here to the class name given
%% in the class definition header (\class{ClassName} in the example).

クラス定義から普通に (定義の終端に到達して) 抜けると、
\emph{クラスオブジェクト (class object) } が生成されます。
クラスオブジェクトは、基本的にはクラス定義で作成された名前空間の
内容をくるむラッパ (wrapper) です; クラスオブジェクトについては
次の節で詳しく学ぶことにします。(クラス定義に入る前に有効だった)
元のローカルスコープが復帰し、生成されたクラスオブジェクトは
復帰したローカルスコープにクラス定義のヘッダで指定した名前
(上の例では \class{ClassName}) で結び付けられます。

\subsection{クラスオブジェクト \label{classObjects}} % Class Objects

%% Class objects support two kinds of operations: attribute references
%% and instantiation.

クラス・オブジェクトでは２種類の演算: 属性参照とインスタンス生成を
サポートしています。

%% \emph{Attribute references} use the standard syntax used for all
%% attribute references in Python: \code{obj.name}.  Valid attribute
%% names are all the names that were in the class's namespace when the
%% class object was created.  So, if the class definition looked like
%% this:

\emph{属性参照 (attribute reference)} は、Python におけるすべての
属性参照で使われている標準的な構文、 \code{obj.name} を使います。
クラスオブジェクトが生成された際にクラスの名前空間にあった名前すべてが
有効な属性名です。従って、以下のようなクラス定義:

\begin{verbatim}
class MyClass:
    "A simple example class"
    i = 12345
    def f(self):
        return 'hello world'
\end{verbatim}

%% then \code{MyClass.i} and \code{MyClass.f} are valid attribute
%% references, returning an integer and a method object, respectively.
%% Class attributes can also be assigned to, so you can change the value
%% of \code{MyClass.i} by assignment.  \member{__doc__} is also a valid
%% attribute, returning the docstring belonging to the class: \code{"A
%% simple example class"}). 

では、\code{MyClass.i} と \code{MyClass.f} は妥当な属性参照であり、
それぞれ整数と関数オブジェクトを返します。
クラス属性に代入を行うこともできます。従って、\code{MyClass.i} の値を
代入して変更できます。
\code{__doc__} も有効な属性で、そのクラスに属している docstring、
この場合は \code{"A simple example class"} を返します。

%% Class \emph{instantiation} uses function notation.  Just pretend that
%% the class object is a parameterless function that returns a new
%% instance of the class.  For example (assuming the above class):

クラスの \emph{インスタンス生成 (instantiation)} には関数のような
表記法を使います。クラスオブジェクトのことを、単にクラスの新しい
インスタンスを返すパラメタを持たない関数かのように扱います。
例えば (上記のクラスでいえば):

\begin{verbatim}
x = MyClass()
\end{verbatim}

%% creates a new \emph{instance} of the class and assigns this object to
%% the local variable \code{x}.

は、クラスの新しい\emph{インスタンス (instance)} を生成し、
そのオブジェクトをローカル変数 \code{x} へ代入します。

%% The instantiation operation (``calling'' a class object) creates an
%% empty object.  Many classes like to create objects with instances
%% customized to a specific initial state. 
%% Therefore a class may define a special method named
%% \method{__init__()}, like this:

インスタンス生成操作 (クラスオブジェクトの ``呼出し'') を行うと、
空のオブジェクト (empty object) を生成します。多くのクラスは、
オブジェクトを作成する際に、カスタマイズされた特定の初期状態に
なってほしいと望んで
います。従って、クラスでは \method{__init__()} という名前の特別な
メソッド定義することができます。例えば以下のようにします:

\begin{verbatim}
    def __init__(self):
        self.data = []
\end{verbatim}

%% When a class defines an \method{__init__()} method, class
%% instantiation automatically invokes \method{__init__()} for the
%% newly-created class instance.  So in this example, a new, initialized
%% instance can be obtained by:

クラスが \method{__init__()} メソッドを定義している場合、
クラスのインスタンスを生成すると、新しく生成された
クラスインスタンスに対して自動的に \method{__init__()} を呼び出します。
従って、この例では、新たな初期済みのインスタンスを以下のように
して得ることができます:

\begin{verbatim}
x = MyClass()
\end{verbatim}

%% Of course, the \method{__init__()} method may have arguments for
%% greater flexibility.  In that case, arguments given to the class
%% instantiation operator are passed on to \method{__init__()}.  For
%% example,

もちろん、より大きな柔軟性を持たせるために、\method{__init__()} 
メソッドに複数の引数をもたせることができます。
その場合、クラスのインスタンス生成操作に渡された引数は
\method{__init__()} に渡されます。例えば以下のように:

\begin{verbatim}
>>> class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
... 
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
\end{verbatim}


\subsection{インスタンスオブジェクト \label{instanceObjects}} % Instance Objects

%% Now what can we do with instance objects?  The only operations
%% understood by instance objects are attribute references.  There are
%% two kinds of valid attribute names, data attributes and methods.

ところで、インスタンスオブジェクトを使うと何ができるのでしょうか？
インスタンスオブジェクトが理解できる唯一の操作は、属性の参照です。
有効な属性の名前には二種類(データ属性およびメソッド)あります。

%% \emph{data attributes} correspond to
%% ``instance variables'' in Smalltalk, and to ``data members'' in
%% \Cpp.  Data attributes need not be declared; like local variables,
%% they spring into existence when they are first assigned to.  For
%% example, if \code{x} is the instance of \class{MyClass} created above,
%% the following piece of code will print the value \code{16}, without
%% leaving a trace:

\emph{データ属性 (data attribute)} は、これは Smalltalk の ``インスタンス変数'' (instance
variable) や \Cpp の ``データメンバ'' (data member) に相当します。
データ属性を宣言する必要はありません; ローカルな変数と同様に、
これらの属性は最初に代入された時点で湧き出てきます。例えば、
上で生成した \class{MyClass} のインスタンス \code{x} に対して、
以下のコード断片を実行すると、値 \code{16} を印字し、\code{x} の
痕跡は残りません。

\begin{verbatim}
x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print x.counter
del x.counter
\end{verbatim}

%% The other kind of instance attribute reference is a \emph{method}.
%% A method is a function that ``belongs to'' an
%% object.  (In Python, the term method is not unique to class instances:
%% other object types can have methods as well.  For example, list objects have
%% methods called append, insert, remove, sort, and so on.  However,
%% in the following discussion, we'll use the term method exclusively to mean
%% methods of class instance objects, unless explicitly stated otherwise.)

もうひとつのインスタンス属性は
\emph{メソッド (method)} です。メソッドとは、オブジェクトに ``属している'' 
関数のことです。(Python では、メソッドという用語はクラスインスタンス
だけのものではありません: オブジェクト型にもメソッドを持つことができます。
例えば、リストオブジェクトには、 append, insert, remove, sort などといった
メソッドがあります。とはいえ、以下では特に明記しない限り、クラスの
インスタンスオブジェクトのメソッドだけを意味するものとして使うことに
します。)

%% Valid method names of an instance object depend on its class.  By
%% definition, all attributes of a class that are function 
%% objects define corresponding methods of its instances.  So in our
%% example, \code{x.f} is a valid method reference, since
%% \code{MyClass.f} is a function, but \code{x.i} is not, since
%% \code{MyClass.i} is not.  But \code{x.f} is not the same thing as
%% \code{MyClass.f} --- it is a \obindex{method}\emph{method object}, not
%% a function object.

インスタンスオブジェクトで有効なメソッド名は、そのクラスによります。
定義により、クラスの全てのo関数オブジェクトである属性が
インスタンスオブジェクトの妥当なメソッド名に決まります。
従って、例では、
\code{MyClass.f} は関数なので、 \code{x.f} はメソッドの参照として有効です。
しかし、\code{MyClass.i} は関数ではないので、 \code{x.i} はメソッドの参照
として有効ではありません。\code{x.f} は \code{MyClass.f} と同じものでは
ありません --- 関数オブジェクトではなく、
\obindex{method}\emph{メソッドオブジェクト (method object)} です。


\subsection{メソッドオブジェクト \label{methodObjects}} % Method Objects

%% Usually, a method is called right after it is bound:

普通、メソッドはバインドされた直後に呼び出されます:

\begin{verbatim}
x.f()
\end{verbatim}

%% In the \class{MyClass} example, this will return the string \code{'hello world'}.
%% However, it is not necessary to call a method right away:
%% \code{x.f} is a method object, and can be stored away and called at a
%% later time.  For example:

\class{MyClass}の例では、上のコードは文字列 \code{'hello world'} を返すでしょう。
しかしながら、必ずしもメソッドをその場で呼び出さなければならない
わけではありません: \code{x.f} はメソッドオブジェクトであり、
どこかに記憶しておいて後で呼び出すことができます。例えば以下のコード:

\begin{verbatim}
xf = x.f
while True:
    print xf()
\end{verbatim}

%% will continue to print \samp{hello world} until the end of time.

は、 \samp{hello world} を時が終わるまで印字し続けるでしょう。

%% What exactly happens when a method is called?  You may have noticed
%% that \code{x.f()} was called without an argument above, even though
%% the function definition for \method{f} specified an argument.  What
%% happened to the argument?  Surely Python raises an exception when a
%% function that requires an argument is called without any --- even if
%% the argument isn't actually used...

メソッドが呼び出されるときには実際には何が起きているのでしょうか？
\method{f} の関数定義では引数を一つ指定していたにもかかわらず、
上記では \code{x.f()} が引数なしで呼び出されたことに気付いているかも
しれませんね。引数はどうなったのでしょうか？ たしか、引数が必要な関数を
引数無しで呼び出すと、Python が例外を送出するはずです --- たとえその
引数が実際には使われなくても…。

%% Actually, you may have guessed the answer: the special thing about
%% methods is that the object is passed as the first argument of the
%% function.  In our example, the call \code{x.f()} is exactly equivalent
%% to \code{MyClass.f(x)}.  In general, calling a method with a list of
%% \var{n} arguments is equivalent to calling the corresponding function
%% with an argument list that is created by inserting the method's object
%% before the first argument.

実際、もう答は想像できているかもしれませんね: メソッドについて
特別なこととして、オブジェクトが関数の第 1 引数として渡される、
ということがあります。我々の例では、\code{x.f()} という呼び出しは、
\code{MyClass.f(x)} と厳密に等価なものです。
一般に、\var{n} 個の引数リストもったメソッドの呼出しは、
そのメソッドのオブジェクトを最初の引数の前に挿入した引数リストで
メソッドに対応する関数を呼び出すことと等価です。

%% If you still don't understand how methods work, a look at the
%% implementation can perhaps clarify matters.  When an instance
%% attribute is referenced that isn't a data attribute, its class is
%% searched.  If the name denotes a valid class attribute that is a
%% function object, a method object is created by packing (pointers to)
%% the instance object and the function object just found together in an
%% abstract object: this is the method object.  When the method object is
%% called with an argument list, it is unpacked again, a new argument
%% list is constructed from the instance object and the original argument
%% list, and the function object is called with this new argument list.

もしもまだメソッドの働きかたを理解できなければ、一度実装を見てみると
事情がよく分かるかもしれません。
データ属性ではないインスタンス属性が参照された時は、
そのクラスが検索されます。その名前が有効なクラス属性を表している
関数オブジェクトなら、インスタンスオブジェクトと見つかった
関数オブジェクト (へのポインタ) を抽象オブジェクト: すなわちメソッド
オブジェクトにパック (pack) して作成します。
メソッドオブジェクトは、引数リストを伴って呼び出される際に再度
アンパック (unpack) され、新たな引数リストがインスタンスオブジェクト
とオリジナルの引数リストから新たな引数リストが構成され、新たな引数
リストを使って関数オブジェクトを呼び出します。


\section{いろいろな注意点 \label{remarks}} % Random Remarks

%% [These should perhaps be placed more carefully...]

% [これらはおそらくもっと注意深く配置すべきだろう…]


%% Data attributes override method attributes with the same name; to
%% avoid accidental name conflicts, which may cause hard-to-find bugs in
%% large programs, it is wise to use some kind of convention that
%% minimizes the chance of conflicts.  Possible conventions include
%% capitalizing method names, prefixing data attribute names with a small
%% unique string (perhaps just an underscore), or using verbs for methods
%% and nouns for data attributes.

データ属性は同じ名前のメソッド属性を上書きしてしまいます;
大規模なプログラムでみつけにくいバグを引き起こすことがある
この偶然的な名前の衝突を避けるには、衝突の可能性を最小限にするような
規約を使うのが賢明です。
可能な規約としては、メソッド名を大文字で始める、データ属性名の先頭に
短い一意的な文字列 (あるいはただの下線) をつける、またメソッドには動詞、
データ属性には名詞を用いる、などがあります。

%% Data attributes may be referenced by methods as well as by ordinary
%% users (``clients'') of an object.  In other words, classes are not
%% usable to implement pure abstract data types.  In fact, nothing in
%% Python makes it possible to enforce data hiding --- it is all based
%% upon convention.  (On the other hand, the Python implementation,
%% written in C, can completely hide implementation details and control
%% access to an object if necessary; this can be used by extensions to
%% Python written in C.)

データ属性は、メソッドから参照できると同時に、通常のオブジェクトの
ユーザ (``クライアント'') からも参照できます。言い換えると、
クラスは純粋な抽象データ型として使うことができません。実際、
Python では、データ隠蔽を補強するための機構はなにもありません ---
データの隠蔽はすべて規約に基づいています。(逆に、C 言語で書かれた
Python の実装では実装の詳細を完全に隠蔽し、必要に応じてオブジェクト
へのアクセスを制御できます; この機構は C 言語で書かれた Python 拡張
で使うことができます)

%% Clients should use data attributes with care --- clients may mess up
%% invariants maintained by the methods by stamping on their data
%% attributes.  Note that clients may add data attributes of their own to
%% an instance object without affecting the validity of the methods, as
%% long as name conflicts are avoided --- again, a naming convention can
%% save a lot of headaches here.

クライアントはデータ属性を注意深く扱うべきです --- クライアントは、
メソッドを使うことで維持しているデータ属性の不変式を踏みにじり、
台無しにするかもしれません。
クライアントは、名前の衝突が回避されている限り、メソッドの有効性に
影響を及ぼすことなくインスタンスに独自の属性を追加することができる、
ということに注意してください --- ここでも、名前付けの規約は
頭痛の種を無くしてくれます。


%% There is no shorthand for referencing data attributes (or other
%% methods!) from within methods.  I find that this actually increases
%% the readability of methods: there is no chance of confusing local
%% variables and instance variables when glancing through a method.

データ属性を (またはその他のメソッドも！) メソッドの中で参照するための
短縮された記法はありません。私は、この仕様が実際にメソッドの
可読性を高めていると考えています: あるメソッドを眺めているときに
ローカルな変数とインスタンス変数を混同する可能性はまったくありません。

%% Often, the first argument of a method is called
%% \code{self}.  This is nothing more than a convention: the name
%% \code{self} has absolutely no special meaning to Python.  (Note,
%% however, that by not following the convention your code may be less
%% readable to other Python programmers, and it is also conceivable that
%% a \emph{class browser} program might be written that relies upon such a
%% convention.)

しばしば、メソッドの最初の引数を、しばしば \code{self} と呼びます。
この名前付けは単なる慣行でしかありません: \code{self} という名前は、
Python では何ら特殊な意味を持ちません。 (とはいえ、この慣行に従わないと、
コードは他の Python プログラマにとってやや読みにくいものとなります。
また、 \emph{クラスブラウザ (class browser)} プログラムがこの慣行を
あてにして書かれているかもしれません。)

%% Any function object that is a class attribute defines a method for
%% instances of that class.  It is not necessary that the function
%% definition is textually enclosed in the class definition: assigning a
%% function object to a local variable in the class is also ok.  For
%% example:

クラス属性である関数オブジェクトはいずれも、そのクラスのインスタンス
のためのメソッドを定義しています。関数定義は、テキスト上では
クラス定義の中に入っていなければならないわけではありません:
関数オブジェクトをクラスのローカルな変数の中に代入するのも OK です。
例えば以下のコードのようにします:

\begin{verbatim}
# クラスの外側で定義された関数
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'hello world'
    h = g
\end{verbatim}

%% Now \code{f}, \code{g} and \code{h} are all attributes of class
%% \class{C} that refer to function objects, and consequently they are all
%% methods of instances of \class{C} --- \code{h} being exactly equivalent
%% to \code{g}.  Note that this practice usually only serves to confuse
%% the reader of a program.

これで、\code{f}、 \code{g} 、および \code{h} は、すべて
\class{C} の属性であり関数オブジェクトを参照しています。
従って、これら全ては、\class{C} のインスタンスのメソッドとなります --- 
\code{h} は \code{g} と全く等価です。これを実践しても、大抵は
単にプログラムの読者に混乱をもたらすだけなので注意してください。


%% Methods may call other methods by using method attributes of the
%% \code{self} argument:

メソッドは、\code{self} 引数のメソッド属性を使って、
他のメソッドを呼び出すことができます:

\begin{verbatim}
class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)
\end{verbatim}

%% Methods may reference global names in the same way as ordinary
%% functions.  The global scope associated with a method is the module
%% containing the class definition.  (The class itself is never used as a
%% global scope!)  While one rarely encounters a good reason for using
%% global data in a method, there are many legitimate uses of the global
%% scope: for one thing, functions and modules imported into the global
%% scope can be used by methods, as well as functions and classes defined
%% in it.  Usually, the class containing the method is itself defined in
%% this global scope, and in the next section we'll find some good
%% reasons why a method would want to reference its own class!

メソッドは、通常の関数と同じようにして、グローバルな名前を参照しても
かまいません。あるメソッドに関連付けられたグローバルなスコープは、
クラス定義の入っているモジュールになります。 (クラス自体はグローバルな
スコープとして用いられることはありません！) メソッドでグローバルな
データを使う良い理由はほとんどありませんが、グローバルなスコープを
使う合法的な使い方は多々あります: 一つ挙げると、メソッド内では、
グローバルなスコープに import された関数やモジュールや、
その中で定義された関数やクラスを使うことができます。
通常、メソッドの入っているクラス自体はグローバルなスコープ内で
定義されています。次の章では、メソッドが自分のクラスを参照する理由
として正当なものを見てみましょう！


\section{継承 \label{inheritance}} % Inheritance

%% Of course, a language feature would not be worthy of the name ``class''
%% without supporting inheritance.  The syntax for a derived class
%% definition looks like this:

言うまでもなく、継承の概念をサポートしない言語機能は ``クラス'' と呼ぶに
値しません。導出クラス (derived class) を定義する構文は以下のように
なります:

\begin{verbatim}
class DerivedClassName(BaseClassName):
    <文-1>
    .
    .
    .
    <文-N>
\end{verbatim}

%% The name \class{BaseClassName} must be defined in a scope containing
%% the derived class definition.  In place of a base class name, other
%% arbitrary expression is also allowed.  This can be useful, for
%% example, when the base class is defined in another module:

基底クラス (base class) の名前 \class{BaseClassName} は、
派生クラス定義の入っているスコープで定義されていなければなりません。
基底クラス名のかわりに任意の式を入れることもできます。
これは以下のように、


\begin{verbatim}
class DerivedClassName(modname.BaseClassName):
\end{verbatim}

基底クラスが別モジュールで定義されているときに便利なことがあります。

%% Execution of a derived class definition proceeds the same as for a
%% base class.  When the class object is constructed, the base class is
%% remembered.  This is used for resolving attribute references: if a
%% requested attribute is not found in the class, search proceeds to look in the
%% base class.  This rule is applied recursively if the base class itself
%% is derived from some other class.

導出クラス定義の実行は、基底クラスの場合と同じように進められます。
クラスオブジェクトが構築される時、基底クラスが記憶されます。
記憶された基底クラスは、属性参照を解決するために使われます:
要求された属性がクラスに見つからなかった場合、基底クラスに検索
が進みます。この規則は、基底クラスが他の何らかのクラスから導出された
ものであった場合、再帰的に適用されます。

%% There's nothing special about instantiation of derived classes:
%% \code{DerivedClassName()} creates a new instance of the class.  Method
%% references are resolved as follows: the corresponding class attribute
%% is searched, descending down the chain of base classes if necessary,
%% and the method reference is valid if this yields a function object.

導出クラスのインスタンス化では、特別なことは何もありません:
\code{DerivedClassName()} はクラスの新たなインスタンスを生成します。
メソッドの参照は以下のようにしてい解決されます: まず対応するクラス属性
が検索されます。検索は、必要に応じ、基底クラス連鎖を下って行われ、
検索の結果として何らかの関数オブジェクトがもたらされた場合、
メソッド参照は有効なものとなります。

%% Derived classes may override methods of their base classes.  Because
%% methods have no special privileges when calling other methods of the
%% same object, a method of a base class that calls another method
%% defined in the same base class may end up calling a method of
%% a derived class that overrides it.  (For \Cpp{} programmers: all methods
%% in Python are effectively \keyword{virtual}.)

導出クラスは基底クラスのメソッドを上書き (override) してもかまいません。
メソッドは同じオブジェクトの別のメソッドを呼び出す際に何ら特殊な権限を
持ちません。このため、ある基底クラスのメソッドが、同じ基底クラスで
定義されているもう一つのメソッド呼び出しを行っている場合、
導出クラスで上書きされた何らかのメソッドが呼び出されることになる
かもしれません。
(\Cpp{} プログラマへ:  Python では、すべてのメソッドは
事実上 \keyword{virtual} です。)

%% An overriding method in a derived class may in fact want to extend
%% rather than simply replace the base class method of the same name.
%% There is a simple way to call the base class method directly: just
%% call \samp{BaseClassName.methodname(self, arguments)}.  This is
%% occasionally useful to clients as well.  (Note that this only works if
%% the base class is defined or imported directly in the global scope.)

導出クラスで上書きしているメソッドでは、実際は単に基底クラスの
同名のメソッドを置き換えるだけではなく、拡張を行いたいかもしれません。
基底クラスのメソッドを直接呼び出す簡単な方法があります: 単に
\samp{BaseClassName.methodname(self, arguments)} を呼び出すだけです。
この仕様は、場合によってはクライアントでも役に立ちます。
(この呼び出し方が動作するのは、基底クラスがグローバルなスコープ内で
定義されているか、直接 import されている場合だけなので注意してください。)


\subsection{多重継承 \label{multiple}} % Multiple Inheritance

%% Python supports a limited form of multiple inheritance as well.  A
%% class definition with multiple base classes looks like this:

Python では、限られた形式の多重継承 (multiple inheritance) も
サポートしています。複数の基底クラスをもつクラス定義は以下のように
なります:

\begin{verbatim}
class DerivedClassName(Base1, Base2, Base3):
    <文-1>
    .
    .
    .
    <文-N>
\end{verbatim}

%% The only rule necessary to explain the semantics is the resolution
%% rule used for class attribute references.  This is depth-first,
%% left-to-right.  Thus, if an attribute is not found in
%% \class{DerivedClassName}, it is searched in \class{Base1}, then
%% (recursively) in the base classes of \class{Base1}, and only if it is
%% not found there, it is searched in \class{Base2}, and so on.

多重継承への意味付けを説明する上で必要な唯一の規則は、クラス属性の
参照を行うときに用いられる名前解決の規則 (resolution rule) です。
解決規則は深さ優先 (depth-first)、左から右へ (left-to-right) と
なっています。従って、ある属性が \class{DerivedClassName} で
見つからなければ \class{Base1} で検索され、次に \class{Base1} の
基底クラスで (再帰的に) 検索されます。それでも見つからなければ
はじめて \class{Base2} で検索される、といった具合です。

%% (To some people breadth first --- searching \class{Base2} and
%% \class{Base3} before the base classes of \class{Base1} --- looks more
%% natural.  However, this would require you to know whether a particular
%% attribute of \class{Base1} is actually defined in \class{Base1} or in
%% one of its base classes before you can figure out the consequences of
%% a name conflict with an attribute of \class{Base2}.  The depth-first
%% rule makes no differences between direct and inherited attributes of
%% \class{Base1}.)

(人によっては、幅優先 (breadth first) --- \class{Base2} と 
\class{Base3} を検索してから \class{Base1} の基底クラスで検索する --- 
のほうが自然のように見えます。しかしながら、幅優先の検索では、
\class{Base1} の特定の属性のうち、実際に定義されているのが
\class{Base1} なのか、その基底クラスなのかを知らなければ、
\class{Base2} の属性との名前衝突がどんな結果をもたらすのか
分からないことになります。深さ優先規則では、 \class{Base1} の直接の
属性と継承された属性とを区別しません。)

%% It is clear that indiscriminate use of multiple inheritance is a
%% maintenance nightmare, given the reliance in Python on conventions to
%% avoid accidental name conflicts.  A well-known problem with multiple
%% inheritance is a class derived from two classes that happen to have a
%% common base class.  While it is easy enough to figure out what happens
%% in this case (the instance will have a single copy of ``instance
%% variables'' or data attributes used by the common base class), it is
%% not clear that these semantics are in any way useful.

Python では偶然的な名前の衝突を慣習に頼って回避しているので、
見境なく多重継承の使用すると、メンテナンスの悪夢に陥ることは明らかです。
多重継承に関するよく知られた問題は、二つのクラスから導出された
クラスがたまたま共通の基底クラスを持つ場合です。
この場合になにが起こるかを結論することは簡単です (インスタンスは
共通の基底クラスで使われている ``インスタンス変数'' の単一の
コピーを持つことになります) が、この意味付けが何の役に立つのかは
明らかではありません。


%% XXX Add rules for new-style MRO?

\section{プライベート変数 \label{private}} % Private Variables

%% There is limited support for class-private
%% identifiers.  Any identifier of the form \code{__spam} (at least two
%% leading underscores, at most one trailing underscore) is now textually
%% replaced with \code{_classname__spam}, where \code{classname} is the
%% current class name with leading underscore(s) stripped.  This mangling
%% is done without regard to the syntactic position of the identifier, so
%% it can be used to define class-private instance and class variables,
%% methods, variables stored in globals, and even variables stored in instances.
%% private to this class on instances of \emph{other} classes.  Truncation
%% may occur when the mangled name would be longer than 255 characters.
%% Outside classes, or when the class name consists of only underscores,
%% no mangling occurs.

クラスプライベート (class-private) の識別子に関して限定的なサポート
がなされています。\code{__spam} (先頭に二個以上の下線文字、末尾に
高々一個の下線文字) という形式の識別子、テキスト上では
\code{_classname__spam} へと置換されるようになりました。
ここで \code{classname} は、現在のクラス名から先頭の下線文字を
はぎとった名前になります。このような難号化 (mangle) は、識別子の
文法的な位置にかかわらず行われるので、クラスプライベートな
インスタンス変数やクラス変数、メソッド、グローバル変数、そしてインスタ
ンスに含まれる変数を
定義するために利用できます。また、このクラスにとってプライベートな
インスタンス変数を \emph{他の} クラスのインスタンスに格納するために
使うことさえできます。難号化した名前が 255 文字より長くなるときは、
切り詰めが起こるかもしれません。
クラスの外側や、クラス名が下線文字だけからできているときには、
難号化加工は起こりません。

%% Name mangling is intended to give classes an easy way to define
%% ``private'' instance variables and methods, without having to worry
%% about instance variables defined by derived classes, or mucking with
%% instance variables by code outside the class.  Note that the mangling
%% rules are designed mostly to avoid accidents; it still is possible for
%% a determined soul to access or modify a variable that is considered
%% private.  This can even be useful in special circumstances, such as in
%% the debugger, and that's one reason why this loophole is not closed.
%% (Buglet: derivation of a class with the same name as the base class
%% makes use of private variables of the base class possible.)

名前の難号化は、クラスにおいて、 ``プライベートな'' インスタンス変数や
メソッドを定義する際に、導出クラスで定義されるインスタンス変数を気に
したり、クラスの外側のコードからインスタンス変数をいじりまわすことが
ないように簡単に定義できるようにするためのものです。
難号化の規則は主に不慮の事故を防ぐためのものだということに注意して
ください; 確信犯的な方法で、プライベートとされている変数にアクセス
したり変更することは依然として可能なのです。デバッガのような特殊な
状況では、この仕様は便利ですらあります。そのため、この抜け穴は
塞がれていません。
(些細なバグ: 基底クラスと同じ名前のクラスを導出すると、基底クラスの
プライベート変数を使えるようになります。)

%% Notice that code passed to \code{exec}, \code{eval()} or
%% \code{execfile()} does not consider the classname of the invoking 
%% class to be the current class; this is similar to the effect of the 
%% \code{global} statement, the effect of which is likewise restricted to 
%% code that is byte-compiled together.  The same restriction applies to
%% \code{getattr()}, \code{setattr()} and \code{delattr()}, as well as
%% when referencing \code{__dict__} directly.

\code{exec} や \code{eval()} や \code{execfile()} へ渡されたコードでは、
呼出し元のクラス名を現在のクラスと見なさないことに注意してください;
この仕様は \code{global} 文の効果と似ており、その効果もまた同様に、
バイトコンパイルされたコードに制限されています。
同じ制約が \code{getattr()} と \code{setattr()} と \code{delattr()} 
にも適用されます。また、\code{__dict__} を直接参照するときにも適用されます。


\section{残りのはしばし \label{odds}} % Odds and Ends

%% Sometimes it is useful to have a data type similar to the Pascal
%% ``record'' or C ``struct'', bundling together a few of named data
%% items.  An empty class definition will do nicely:

Pascal の ``レコード (record)'' や、C 言語の ``構造体 (struct)''
のような、名前つきのデータ要素を一まとめにするデータ型があると
便利なことがたまにあります。空のクラス定義を使うとうまくできます:

\begin{verbatim}
class Employee:
    pass

john = Employee() # 空の従業員レコードを造る

# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
\end{verbatim}

%% A piece of Python code that expects a particular abstract data type
%% can often be passed a class that emulates the methods of that data
%% type instead.  For instance, if you have a function that formats some
%% data from a file object, you can define a class with methods
%% \method{read()} and \method{readline()} that gets the data from a string
%% buffer instead, and pass it as an argument.
                                           %  (Unfortunately, this
%technique has its limitations: a class can't define operations that
%are accessed by special syntax such as sequence subscripting or
%arithmetic operators, and assigning such a ``pseudo-file'' to
%\code{sys.stdin} will not cause the interpreter to read further input
%from it.)

ある特定の抽象データ型を要求する Python コードの断片には、
そのデータ型のメソッドをエミュレーションするクラスを代わりに渡す
ことができます。例えば、ファイルオブジェクトから何らかのデータを書式化
する関数がある場合、\method{read()} と \method{readline()} を持つクラス
を定義して、ファイルではなく文字列バッファからデータを書式するように
しておき、引数として渡すことができます。


%% Instance method objects have attributes, too: \code{m.im_self} is the
%% instance object with the method \method{m}, and \code{m.im_func} is the
%% function object corresponding to the method.

インスタンスメソッドオブジェクトにもまた、属性があります: 
\code{m.im_self} はメソッド\method{m}の属しているインスタンスオブジェクトで、
\code{m.im_func} はメソッドに対応する関数オブジェクトです。

\subsection{例外はクラスであってもよい \label{exceptionClasses}} % Exceptions Can Be Classes

%% User-defined exceptions are identified by classes as well.  Using this
%% mechanism it is possible to create extensible hierarchies of exceptions.

ユーザ定義の例外をクラスとして識別することもできます。このメカニズムを
使って、拡張可能な階層化された例外を作成することができます。

%% There are two new valid (semantic) forms for the raise statement:

新しく二つの (意味付け的な) 形式の raise 文ができました:

\begin{verbatim}
raise Class, instance

raise instance
\end{verbatim}

%% In the first form, \code{instance} must be an instance of
%% \class{Class} or of a class derived from it.  The second form is a
%% shorthand for:

第一の形式では、\code{instance} は \class{Class} またはその導出クラスの
インスタンスでなければなりません。
第二の形式は以下の表記:

\begin{verbatim}
raise instance.__class__, instance
\end{verbatim}

の短縮された記法です。

%% An except clause may list classes as well as string objects.  A class
%% in an except clause is compatible with an exception if it is the same
%% class or a base class thereof (but not the other way around --- an
%% except clause listing a derived class is not compatible with a base
%% class).  For example, the following code will print B, C, D in that
%% order:

except 節には、文字列オブジェクトだけでなくクラスを並べることができます。
except 節のクラスは、同じクラスか基底クラスの例外のときに互換 (compatible)
となります (逆方向では成り立ちません --- 導出クラスの例外がリストされている 
except 節は基底クラスの例外と互換ではありません)。
例えば、次のコードは、 B, C, D を順序通りに出力します:

\begin{verbatim}
class B:
    pass
class C(B):
    pass
class D(C):
    pass

for c in [B, C, D]:
    try:
        raise c()
    except D:
        print "D"
    except C:
        print "C"
    except B:
        print "B"
\end{verbatim}

%% Note that if the except clauses were reversed (with
%% \samp{except B} first), it would have printed B, B, B --- the first
%% matching except clause is triggered.

except 節が逆に並んでいた場合 (\samp{except B} が最初にくる場合)、
B, B, B と出力されるはずだったことに注意してください --- 最初に
一致した except 節が駆動されるのです。

%% When an error message is printed for an unhandled exception, the
%% exception's class name is printed, then a colon and a space, and
%% finally the instance converted to a string using the built-in function
%% \function{str()}.

処理されないクラスの例外に対してエラーメッセージが出力されるとき、
まずクラス名が出力され、続いてコロン、スペース、最後に組み込み関数
 \function{str()} を使って文字列に変換したインスタンスが出力されます。

%% \section{Iterators\label{iterators}}

\section{イテレータ (iterator)\label{iterators}}
   
%% By now you have probably noticed that most container objects can looped over
%% using a \code{for} statement:

すでに気づいているでしょうが、\code{for} 文を使うとほとんどの
コンテナオブジェクトにわたってループを行うことができます:
   
\begin{verbatim}
for element in [1, 2, 3]:
    print element
for element in (1, 2, 3):
    print element
for key in {'one':1, 'two':2}:
    print key
for char in "123":
    print char
for line in open("myfile.txt"):
    print line
\end{verbatim}
   
%% This style of access is clear, concise, and convenient.  The use of iterators
%% pervades and unifies Python.  Behind the scenes, the \code{for} statement calls
%% \function{iter()} on the container object.  The function returns an iterator
%% object that defines the method \method{next()} which accesses elements in the
%% container one at a time.  When there are no more elements, \method{next()}
%% raises a \exception{StopIteration} exception which tells the \code{for} loop
%% to terminate.  This example shows how it all works:

こうしたアクセス方法は明確で、簡潔で、かつ便利なものです。イテレータの使用は
Python 全体に普及していて、統一性をもたらしています。背後では、\code{for} 文は
コンテナオブジェクトの \function{iter()} を呼び出しています。この関数は
\method{next()} メソッドの定義されたイテレータオブジェクトを返します。
\method{next()} メソッドは一度コンテナ内の要素に一度に一つづつアクセスします。
コンテナ内にアクセスすべき要素がなくなると、\method{next()} は
\exception{StopIteration} 例外を送出し、\code{for} ループを終了させます。
実際にどのように動作するかを以下の例に示します:
   
\begin{verbatim}
>>> s = 'abc'
>>> it = iter(s)
>>> it
<iterator object at 0x00A1DB50>
>>> it.next()
'a'
>>> it.next()
'b'
>>> it.next()
'c'
>>> it.next()
   
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
    it.next()
StopIteration
\end{verbatim}
   
%% Having seen the mechanics behind the iterator protocol, it is easy to add
%% iterator behavior to your classes.  Define a \method{__iter__()} method
%% which returns an object with a \method{next()} method.  If the class defines
%% \method{next()}, then \method{__iter__()} can just return \code{self}:

イテレータプロトコルの背後にあるメカニズムを一度目にすれば、自作のクラスに
イテレータとしての振る舞いを追加するのは簡単です。\method{__iter__()} メソッド
を定義して、\method{next()} メソッドを持つオブジェクトを返すようにしてください。
クラス自体で \method{next()} を定義している場合、\method{__iter__()} では
単に \code{self} を返すようにできます:
   
\begin{verbatim}
class Reverse:
    "Iterator for looping over a sequence backwards"
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> for char in Reverse('spam'):
...     print char
...
m
a
p
s
\end{verbatim}
   
   
%% \section{Generators\label{generators}}

\section{ジェネレータ (generator)\label{generators}}
   
%% Generators are a simple and powerful tool for creating iterators.  They are
%% written like regular functions but use the \keyword{yield} statement whenever
%% they want to return data.  Each time the \method{next()} is called, the
%% generator resumes where it left-off (it remembers all the data values and
%% which statement was last executed).  An example shows that generators can
%% be trivially easy to create:

ジェネレータは、イテレータを作成するための簡潔で強力なツールです。
ジェネレータは通常の関数のように書かれますが、何らかのデータを返すときには
\keyword{yield} 文を使います。 \method{next()} が呼び出されるたびに、
ジェネレータは以前に中断した処理を再開します (ジェネレータは、全てのデータ値と
最後にどの文が実行されたかを記憶しています)。以下の例を見れば、ジェネレータ
がとても簡単に作成できることがわかります:
   
\begin{verbatim}
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
		
>>> for char in reverse('golf'):
...     print char
...
f
l
o
g	
\end{verbatim}
   
%% Anything that can be done with generators can also be done with class based
%% iterators as described in the previous section.  What makes generators so
%% compact is that the \method{__iter__()} and \method{next()} methods are
%% created automatically.

ジェネレータを使ってできることは、前節で記述したクラスに基づいたイテレータを
使えばできます。ジェネレータを使うとコンパクトに記述できるのは、
\method{__iter__()} と \method{next()} メソッドが自動的に作成されるからです。
   
%% Another key feature is that the local variables and execution state
%% are automatically saved between calls.  This made the function easier to write
%% and much more clear than an approach using instance variables like
%% \code{self.index} and \code{self.data}.

ジェネレータのもう一つの重要な機能は、呼び出しごとにローカル変数と実行状態が
自動的に保存されるということです。これにより、\code{self.index} や 
\code{self.data} といったインスタンス変数を使ったアプローチよりも簡単に
関数を書くことができるようになります。
   
%% In addition to automatic method creation and saving program state, when
%% generators terminate, they automatically raise \exception{StopIteration}.
%% In combination, these features make it easy to create iterators with no
%% more effort than writing a regular function.

メソッドを自動生成したりプログラムの実行状態を自動保存するほかに、
ジェネレータは終了時に自動的に \exception{StopIteration} を送出します。
これらの機能を組み合わせると、通常の関数を書くのに比べ、全く苦労する
ことなく簡単にイテレータを生成できます。

\section{ジェネレータ式\label{genexps}} % Generator Expressions

% Some simple generators can be coded succinctly as expressions using a syntax
% similar to list comprehensions but with parentheses instead of brackets.  These
% expressions are designed for situations where the generator is used right
% away by an enclosing function.  Generator expressions are more compact but
% less versatile than full generator definitions and tend to be more memory
% friendly than equivalent list comprehensions.

単純なジェネレータなら、式を使って簡潔にコードする方法があります。
リスト内包に似た構文の式ですが、各括弧ではなく丸括弧を使います。
ジェネレータ式は、関数の中でジェネレータをすぐに使いたいような状況
のために用意されています。ジェネレータ式はコンパクトですが、
完全なジェネレータに比べてちょっと融通の効かないところがあります。
同じ内容を返すリスト内包よりはメモリに優しいことが多いという利点も
あります。

例:

\begin{verbatim}
>>> sum(i*i for i in range(10))                 # 平方和を求める
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))         # 内積を求める
260

>>> from math import pi, sin
>>> sine_table = dict((x, sin(x*pi/180)) for x in range(0, 91))

>>> unique_words = set(word  for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1,-1,-1))
['f', 'l', 'o', 'g']

\end{verbatim}

 
 

\chapter{標準ライブラリミニツアー\label{briefTour}} 

\section{オペレーティングシステムへのインタフェース\label{os-interface}} 
 
%% The \ulink{\module{os}}{../lib/module-os.html} 
%% module provides dozens of functions for interacting with the 
%% operating system: 
 
\ulink{\module{os}}{../lib/module-os.html} モジュールは、
オペレーティングシステムと対話するための何ダースもの関数を
提供しています:
 
\begin{verbatim} 
>>> import os 
>>> os.system('time 0:02') 
0 
>>> os.getcwd()      # 現在の作業ディレクトリを返す
'C:\\Python24' 
>>> os.chdir('/server/accesslogs') 
\end{verbatim} 
 
%% Be sure to use the \samp{import os} style instead of 
%% \samp{from os import *}.  This will keep \function{os.open()} from 
%% shadowing the builtin \function{open()} function which operates much 
%% differently. 

\samp{from os import *} ではなく、 \samp{import os} 形式を使う
ようにしてください。そうすることで、
動作が大きく異なる組み込み関数 \function{open()} が
\function{os.open()} で隠蔽されるのを避けられます。
 
\bifuncindex{help}
%% The builtin \function{dir()} and \function{help()} functions are useful 
%% as interactive aids for working with large modules like \module{os}: 
 
組み込み関数 \function{dir()} および \function{help()} は、
\module{os} のような大規模なモジュールで作業をするときに、対話的な
操作上の助けになります:
 
\begin{verbatim} 
>>> import os 
>>> dir(os) 
<returns a list of all module functions> 
>>> help(os) 
<returns an extensive manual page created from the module's docstrings> 
\end{verbatim} 
 
%% For daily file and directory management tasks, the 
%% \ulink{\module{shutil}}{../lib/module-shutil.html} 
%% module provides a higher level interface that is easier to use: 
 
ファイルやディレクトリの日常的な管理作業のために、
より簡単に使える高レベルインタフェースが
\ulink{\module{shutil}}{../lib/module-shutil.html} 
モジュールで提供されています:
 
\begin{verbatim} 
>>> import shutil 
>>> shutil.copyfile('data.db', 'archive.db') 
>>> shutil.move('/build/executables', 'installdir') 
\end{verbatim} 
 
 
\section{ファイルのワイルドカード表記\label{file-wildcards}} 
 
%% The \ulink{\module{glob}}{../lib/module-glob.html} 
%% module provides a function for making file lists from directory 
%% wildcard searches: 
 
\ulink{\module{glob}}{../lib/module-glob.html} モジュールでは、
ディレクトリのワイルドカード検索からファイルのリストを生成する
ための関数を提供しています:
 
\begin{verbatim} 
>>> import glob 
>>> glob.glob('*.py') 
['primes.py', 'random.py', 'quote.py'] 
\end{verbatim} 
 
 
\section{コマンドライン引数\label{command-line-arguments}} 
 
%% Common utility scripts often need to process command line arguments. 
%% These arguments are stored in the 
%% \ulink{\module{sys}}{../lib/module-sys.html}\ module's \var{argv} 
%% attribute as a list.  For instance the following output results from 
%% running \samp{python demo.py one two three} at the command line: 

広く使われているユーティリティスクリプトでは、しばしばコマンドライン
引数の処理を呼び出します。これらの引数は
\ulink{\module{sys}}{../lib/module-sys.html}\ モジュールの \var{argv} 
属性にリストとして記憶されます。例えば、以下の出力は、
\samp{python demo.py one two three} をコマンドライン上で起動した際に
得られるものです:
 
\begin{verbatim} 
>>> import sys 
>>> print sys.argv 
['demo.py', 'one', 'two', 'three'] 
\end{verbatim} 
 
%% The \ulink{\module{getopt}}{../lib/module-getopt.html} 
%% module processes \var{sys.argv} using the conventions of the \UNIX{} 
%% \function{getopt()} function.  More powerful and flexible command line 
%% processing is provided by the 
%% \ulink{\module{optparse}}{../lib/module-optparse.html} module. 
 
\ulink{\module{getopt}}{../lib/module-getopt.html} 
モジュールは、\var{sys.argv} を \UNIX{} の \function{getopt()} 関数の
慣習に従って処理します。より強力で柔軟性のあるコマンドライン処理機能は、
\ulink{\module{optparse}}{../lib/module-optparse.html} モジュールで
提供されています。 
 
 
\section{エラー出力のリダイレクトとプログラムの終了\label{stderr}} 
 
%% The \ulink{\module{sys}}{../lib/module-sys.html} 
%% module also has attributes for \var{stdin}, \var{stdout}, and 
%% \var{stderr}.  The latter is useful for emitting warnings and error 
%% messages to make them visible even when \var{stdout} has been redirected: 
 
\ulink{\module{sys}}{../lib/module-sys.html} モジュールには、
\var{stdin}、 \var{stdout}、および \var{stderr} を表す属性値も
存在します。後者の \var{stderr} は、警告やエラーメッセージを出力して、
\var{stdout} がリダイレクトされた場合でもそれらが読めるようにする
上で便利です:
 
\begin{verbatim} 
>>> sys.stderr.write('Warning, log file not found starting a new one\n') 
Warning, log file not found starting a new one 
\end{verbatim} 
 
%% The most direct way to terminate a script is to use \samp{sys.exit()}. 

\samp{sys.exit()} は、スクリプトを終了させるもっとも直接的な方法です。
 
 
\section{文字列のパターンマッチング\label{string-pattern-matching}} 
 
%% The \ulink{\module{re}}{../lib/module-re.html} 
%% module provides regular expression tools for advanced string processing. 
%% For complex matching and manipulation, regular expressions offer succinct, 
%% optimized solutions: 
 
\ulink{\module{re}}{../lib/module-re.html} 
モジュールでは、より高度な文字列処理のための正規表現 (regular expression) 
を提供しています。正規表現は複雑な一致検索や操作に対して簡潔で最適化
された解決策を与えます:
 
\begin{verbatim} 
>>> import re 
>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest') 
['foot', 'fell', 'fastest'] 
>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat') 
'cat in the hat' 
\end{verbatim} 
 
%% When only simple capabilities are needed, string methods are preferred 
%% because they are easier to read and debug: 
 
最小限の機能だけが必要なら、読みやすくデバッグしやすい文字列メソッドの
方がお勧めです:
 
\begin{verbatim} 
>>> 'tea for too'.replace('too', 'two') 
'tea for two' 
\end{verbatim} 
 
\section{数学\label{mathematics}} 
 
%% The \ulink{\module{math}}{../lib/module-math.html} module gives 
%% access to the underlying C library functions for floating point math: 
 
\ulink{\module{math}}{../lib/module-math.html} モジュールでは、
根底にある浮動小数点演算のための C 言語ライブラリ関数にアクセス
する手段を提供しています:
 
\begin{verbatim} 
>>> import math 
>>> math.cos(math.pi / 4.0) 
0.70710678118654757 
>>> math.log(1024, 2) 
10.0 
\end{verbatim} 
 
%% The \ulink{\module{random}}{../lib/module-random.html} 
%% module provides tools for making random selections: 
 
\ulink{\module{random}}{../lib/module-random.html} 
モジュールでは、乱数に基づいた要素選択のためのツールを提供しています:
 
\begin{verbatim} 
>>> import random 
>>> random.choice(['apple', 'pear', 'banana']) 
'apple' 
>>> random.sample(xrange(100), 10)   # 要素を戻さないサンプリング
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33] 
>>> random.random()    # ランダムな浮動小数点数
0.17970987693706186 
>>> random.randrange(6)    # range(6) からランダムに選ばれた整数
4 
\end{verbatim} 
 
 
\section{インターネットへのアクセス\label{internet-access}} 
 
%% There are a number of modules for accessing the internet and processing 
%% internet protocols. Two of the simplest are 
%% \ulink{\module{urllib2}}{../lib/module-urllib2.html} 
%% for retrieving data from urls and 
%% \ulink{\module{smtplib}}{../lib/module-smtplib.html} 
%% for sending mail: 

インターネットにアクセスしたり、インターネットプロトコルを処理したり
するための数多くのモジュールがあります。その中でも最も単純な二つ
のモジュールは、URL を指定してデータを取得するための
\ulink{\module{urllib2}}{../lib/module-urllib2.html} 
と、メイルを送信するための
\ulink{\module{smtplib}}{../lib/module-smtplib.html} 
です: 
 
\begin{verbatim} 
>>> import urllib2 
>>> for line in urllib2.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'): 
...     if 'EST' in line or 'EDT' in line:      # look for Eastern Time 
...         print line 
 
<BR>Nov. 25, 09:43:32 PM EST 
 
>>> import smtplib 
>>> server = smtplib.SMTP('localhost') 
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org', 
"""To: jcaesar@example.org 
From: soothsayer@example.org 

Beware the Ides of March. 
""") 
>>> server.quit() 
\end{verbatim} 
 
 
\section{日付と時刻\label{dates-and-times}} 
 
%% The \ulink{\module{datetime}}{../lib/module-datetime.html} module 
%% supplies classes for manipulating dates and times in both simple 
%% and complex ways. While date and time arithmetic is supported, the 
%% focus of the implementation is on efficient member extraction for 
%% output formatting and manipulation.  The module also supports objects 
%% that are time zone aware. 
 
\ulink{\module{datetime}}{../lib/module-datetime.html} モジュールは、
日付や時刻を操作するためのクラスを、単純な方法と複雑な方法の両方で
供給しています。日付や時刻に対する算術がサポートされている一方、
実装では出力の書式化や操作のための効率的なデータメンバ抽出に
重点を置いています。
このモジュールでは、タイムゾーンに対応したオブジェクトもサポート
しています。
 
\begin{verbatim} 
# dates are easily constructed and formatted 
>>> from datetime import date 
>>> now = date.today() 
>>> now 
datetime.date(2003, 12, 2) 
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B") 
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December' 
 
# dates support calendar arithmetic 
>>> birthday = date(1964, 7, 31) 
>>> age = now - birthday 
>>> age.days 
14368 
\end{verbatim} 
 
 
\section{データ圧縮\label{data-compression}} 
 
%% Common data archiving and compression formats are directly supported 
%% by modules including: 
%% \ulink{\module{zlib}}{../lib/module-zlib.html}, 
%% \ulink{\module{gzip}}{../lib/module-gzip.html}, 
%% \ulink{\module{bz2}}{../lib/module-bz2.html}, 
%% \ulink{\module{zipfile}}{../lib/module-zipfile.html}, and 
%% \ulink{\module{tarfile}}{../lib/module-tarfile.html}. 
 
データの書庫化や圧縮で広く使われている形式については、
\ulink{\module{zlib}}{../lib/module-zlib.html}、
\ulink{\module{gzip}}{../lib/module-gzip.html}、
\ulink{\module{bz2}}{../lib/module-bz2.html}、
\ulink{\module{zipfile}}{../lib/module-zipfile.html}、および
\ulink{\module{tarfile}}{../lib/module-tarfile.html} と
いったモジュールで直接サポートしています。
 
\begin{verbatim} 
>>> import zlib 
>>> s = 'witch which has which witches wrist watch' 
>>> len(s) 
41 
>>> t = zlib.compress(s) 
>>> len(t) 
37 
>>> zlib.decompress(t) 
'witch which has which witches wrist watch' 
>>> zlib.crc32(s) 
226805979
\end{verbatim} 
 
 
\section{パフォーマンスの計測\label{performance-measurement}} 
 
%% Some Python users develop a deep interest in knowing the relative 
%% performance between different approaches to the same problem. 
%% Python provides a measurement tool that answers those questions 
%% immediately. 
 
Python ユーザの中には、同じ問題を異なったアプローチで解いた
際の相対的なパフォーマンスについて知りたいという深遠な興味を
抱いている人がいます。Python では、そういった疑問に即座に答える
計測ツールを提供しています。
 
%% For example, it may be tempting to use the tuple packing and unpacking 
%% feature instead of the traditional approach to swapping arguments. 
%% The \ulink{\module{timeit}}{../lib/module-timeit.html} module 
%% quickly demonstrates a modest performance advantage:
 
例えば、引数の入れ替え操作に対して、伝統的なアプローチの代わりに
タプルのパックやアンパックを使ってみたい気持ちになるかもしれません。
\ulink{\module{timeit}}{../lib/module-timeit.html} モジュールを
使えば、パフォーマンス上の利点はほぼ互角だとわかります:
 
\begin{verbatim} 
>>> from timeit import Timer 
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit() 
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
\end{verbatim} 
 
%% In contrast to \module{timeit}'s fine level of granularity, the 
%% \ulink{\module{profile}}{../lib/module-profile.html} and \module{pstats} 
%% modules provide tools for identifying time critical sections in larger 
%% blocks of code. 
 
\module{timeit} では高い粒度レベルを提供しているのに対し、
\ulink{\module{profile}}{../lib/module-profile.html} や \module{pstats} 
モジュールではより大きなコードブロックにおいて律速となる部分を
判定するためのツールを提供しています。
 
\section{品質管理\label{quality-control}} 
 
%% One approach for developing high quality software is to write tests for 
%% each function as it is developed and to run those tests frequently during 
%% the development process. 
 
高い品質のソフトウェアを開発するための一つのアプローチは、全ての関数
に対して開発と同時にテストを書き、開発の過程で頻繁にテストを走らせる
というものです。
 
%% The \ulink{\module{doctest}}{../lib/module-doctest.html} module provides 
%% a tool for scanning a module and validating tests embedded in a program's 
%% docstrings.  Test construction is as simple as cutting-and-pasting a 
%% typical call along with its results into the docstring.  This improves 
%% the documentation by providing the user with an example and it allows the 
%% doctest module to make sure the code remains true to the documentation: 

\ulink{\module{doctest}}{../lib/module-doctest.html} モジュールでは、
モジュールを検索して、プログラムの docstring に埋め込まれたテストの
評価を行うためのツールを提供しています。テストの作り方は単純で、
典型的な呼び出し例とその結果を docstring にカット\& ペーストすると
いうものです。この作業は、ユーザに使用例を与えるという意味で
ドキュメントの情報を増やすと同時に、ドキュメントに書かれている内容が
正しいかどうか doctest モジュールが確認できるようにしています: 
 
\begin{verbatim} 
def average(values): 
    """Computes the arithmetic mean of a list of numbers. 
 
    >>> print average([20, 30, 70]) 
    40.0 
    """ 
    return sum(values, 0.0) / len(values) 
 
import doctest 
doctest.testmod()   # automatically validate the embedded tests 
\end{verbatim} 
 
%% The \ulink{\module{unittest}}{../lib/module-unittest.html} module is not 
%% as effortless as the \module{doctest} module, but it allows a more 
%% comprehensive set of tests to be maintained in a separate file: 
 
\ulink{\module{unittest}}{../lib/module-unittest.html} モジュールは
\module{doctest} モジュールほど気楽に使えるものではありませんが、
より網羅的なテストセットを別のファイルで管理することができます: 
 
\begin{verbatim} 
import unittest 
 
class TestStatisticalFunctions(unittest.TestCase): 
 
    def test_average(self): 
        self.assertEqual(average([20, 30, 70]), 40.0) 
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3) 
        self.assertRaises(ZeroDivisionError, average, []) 
        self.assertRaises(TypeError, average, 20, 30, 70) 
 
unittest.main() # Calling from the command line invokes all tests 
\end{verbatim} 
 
\section{バッテリー同梱\label{batteries-included}} 
 
%% Python has a ``batteries included'' philosophy.  This is best seen 
%% through the sophisticated and robust capabilities of its larger 
%% packages. For example: 
 
Python には ``バッテリー同梱 (batteries included)'' 哲学が
あります。この哲学は、洗練され、安定した機能を持つ Python の膨大な
パッケージ群に如実に表れています。例えば:

\begin{itemize} 
%% \item The \ulink{\module{xmlrpclib}}{../lib/module-xmlrpclib.html} and 
%% \ulink{\module{SimpleXMLRPCServer}}{../lib/module-SimpleXMLRPCServer.html} 
%% modules make implementing remote procedure calls into an almost trivial 
%% task.  Despite the module names, no direct knowledge or handling of XML is needed. 

\item {The \ulink{\module{xmlrpclib}}{../lib/module-xmlrpclib.html} および
\ulink{\module{SimpleXMLRPCServer}}{../lib/module-SimpleXMLRPCServer.html} 
モジュールは、遠隔手続き呼び出し (remote procedure call) を全く
たいしたことのない作業に変えてしまいます。モジュール名とは違い、XML を扱う
ための直接的な知識は必要ありません。}

%% \item The \ulink{\module{email}}{../lib/module-email.html} 
%% package is a library for managing email messages, 
%% including MIME and other RFC 2822-based message documents.  Unlike 
%% \module{smtplib} and \module{poplib} which actually send and receive 
%% messages, the email package has a complete toolset for building or 
%% decoding complex message structures (including attachments) 
%% and for implementing internet encoding and header protocols. 
 
\item {The \ulink{\module{email}}{../lib/module-email.html} 
パッケージは、MIME やその他の  RFC 2822 に基づくメッセージ文書を含む
電子メイルメッセージを管理するためのライブラリです。
実際にメッセージを送信したり受信したりする \module{smtplib} や
\module{poplib} と違って、email パッケージには (添付文書を
含む) 複雑なメッセージ構造の構築やデコードを行ったり、
インターネット標準のエンコードやヘッダプロトコルの実装を行ったり
するための完全なツールセットを備えています。}
 
%% \item The \ulink{\module{xml.dom}}{../lib/module-xml.dom.html} and 
%% \ulink{\module{xml.sax}}{../lib/module-xml.sax.html} packages provide 
%% robust support for parsing this popular data interchange format.  Likewise, 
%% the \module{csv} module supports direct reads and writes in a common 
%% database format.  Together, these modules and packages greatly simplify 
%% data interchange between python applications and other tools. 
 
\item {\ulink{\module{xml.dom}}{../lib/module-xml.dom.html} および
\ulink{\module{xml.sax}}{../lib/module-xml.sax.html} パッケージでは、
一般的なデータ交換形式である XML を解析するための頑健なサポートを
提供しています。同様に、\module{csv} モジュールでは、広く用いられている
データベース形式のデータを直接読み書きする機能をサポートしています。
これらのモジュールやパッケージは併用することで、Python アプリケーション
と他のツール群との間でのデータ交換を劇的に簡単化します。}
 
%% \item Internationalization is supported by a number of modules including 
%% \ulink{\module{gettext}}{../lib/module-gettext.html}, 
%% \ulink{\module{locale}}{../lib/module-locale.html}, and the 
%% \ulink{\module{codecs}}{../lib/module-codecs.html} package. 
    
\item {国際化に関する機能は、
\ulink{\module{gettext}}{../lib/module-gettext.html}、
\ulink{\module{locale}}{../lib/module-locale.html}、および
\ulink{\module{codecs}}{../lib/module-codecs.html} パッケージ
といったモジュール群でサポートされています。}
\end{itemize}

\chapter{標準ライブラリミニツアー -- その 2\label{briefTourTwo}}
% Brief Tour of the Standard Library -- Part II

もう一つのツアーでは、プロフェッショナルプログラミングを支える
もっと高度なモジュールをカバーします。ここで挙げるモジュールは、
小さなスクリプトの開発ではほとんど使いません。

\section{出力のフォーマット\label{output-formatting}}
% Output Formatting

% The \ulink{\module{repr}}{../lib/module-repr.html} module provides a
% version of \function{repr()} customized for abbreviated displays of large 
% or deeply nested containers:

\ulink{\module{repr}}{../lib/module-repr.html} モジュールでは、
大きなコンテナや、深くネストしたコンテナを省略して表示するバージョンの
\function{repr()} を提供しています:

\begin{verbatim}
    >>> import repr   
    >>> repr.repr(set('supercalifragilisticexpialidocious'))
    "set(['a', 'c', 'd', 'e', 'f', 'g', ...])"
\end{verbatim}

% The \ulink{\module{pprint}}{../lib/module-pprint.html} module offers
% more sophisticated control over printing both built-in and user defined
% objects in a way that is readable by the interpreter.  When the result
% is longer than one line, the ``pretty printer'' adds line breaks and
% indentation to more clearly reveal data structure:

\ulink{\module{pprint}}{../lib/module-pprint.html} モジュールを使うと、
組み込み型やユーザ定義型がより洗練された形式で出力されるよう制御できます。
出力が複数行にわたる場合には、``pretty printer'' が改行を追加して、
入れ子構造を理解しやすいようにインデントを挿入します:

\begin{verbatim}
    >>> import pprint
    >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
    ...     'yellow'], 'blue']]]
    ...
    >>> pprint.pprint(t, width=30)
    [[[['black', 'cyan'],
       'white',
       ['green', 'red']],
      [['magenta', 'yellow'],
       'blue']]]
\end{verbatim}

% The \ulink{\module{textwrap}}{../lib/module-textwrap.html} module
% formats paragraphs of text to fit a given screen width:

\ulink{\module{textwrap}}{../lib/module-textwrap.html} モジュールは、
一段落の文を指定したスクリーン幅にぴったり収まるように調整します:

\begin{verbatim}
    >>> import textwrap
    >>> doc = """The wrap() method is just like fill() except that it returns
    ... a list of strings instead of one big string with newlines to separate
    ... the wrapped lines."""
    ...
    >>> print textwrap.fill(doc, width=40)
    The wrap() method is just like fill()
    except that it returns a list of strings
    instead of one big string with newlines
    to separate the wrapped lines.
\end{verbatim}

% The \ulink{\module{locale}}{../lib/module-locale.html} module accesses
% a database of culture specific data formats.  The grouping attribute
% of locale's format function provides a direct way of formatting numbers
% with group separators:

\ulink{\module{locale}}{../lib/module-locale.html} モジュールは、文化ごと
に特化したデータ表現形式のデータベースにアクセスします。 \module{locale}
の \function{format} 関数の grouping 属性を使えば、数値の各桁を適切な
区切り文字でグループ化してフォーマットできます:

\begin{verbatim}
    >>> import locale
    >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
    'English_United States.1252'
    >>> conv = locale.localeconv()          # get a mapping of conventions
    >>> x = 1234567.8
    >>> locale.format("%d", x, grouping=True)
    '1,234,567'
    >>> locale.format("%s%.*f", (conv['currency_symbol'],
    ...	      conv['frac_digits'], x), grouping=True)
    '$1,234,567.80'
\end{verbatim}


\section{文字列テンプレート\label{templating}} % Templating

% The \ulink{\module{string}}{../lib/module-string.html} module includes a
% versatile \class{Template} class with a simplified syntax suitable for
% editing by end-users.  This allows users to customize their applications
% without having to alter the application.

\ulink{\module{string}}{../lib/module-string.html} モジュールには、
柔軟で、エンドユーザが簡単に編集できる簡単な構文を備えた\class{Template} 
クラスが入っています。このクラスを使うと、ユーザがアプリケーションの出力
をカスタマイズしたいときに全てを置き換えなくてもすみます。

% The format uses placeholder names formed by \samp{\$} with valid Python
% identifiers (alphanumeric characters and underscores).  Surrounding the
% placeholder with braces allows it to be followed by more alphanumeric letters
% with no intervening spaces.  Writing \samp{\$\$} creates a single escaped
% \samp{\$}:

テンプレートでは、\samp{\$} と有効な Python 識別子名 (英数字と
アンダースコア) からなるプレースホルダ名を使います。プレースホルダの
周りを丸括弧で囲えば、間にスペースをはさまなくても後ろに英数文字を
続けられます。\samp{\$\$} のようにすると、\samp{\$} 自体をエスケープ
できます:

\begin{verbatim}
>>> from string import Template
>>> t = Template('${village}folk send $$10 to $cause.')
>>> t.substitute(village='Nottingham', cause='the ditch fund')
'Nottinghamfolk send $10 to the ditch fund.'
\end{verbatim}

% The \method{substitute} method raises a \exception{KeyError} when a
% placeholder is not supplied in a dictionary or a keyword argument. For
% mail-merge style applications, user supplied data may be incomplete and the
% \method{safe_substitute} method may be more appropriate --- it will leave
% placeholders unchanged if data is missing:

\method{substitute} メソッドは、プレースホルダに相当する値が辞書や
キーワード引数にない場合に \exception{KeyError} を送出します。
メールマージ型アプリケーションの場合、ユーザが入力するデータは不完全
なことがあるので、欠落したデータがあるとプレースホルダをそのままにして
出力する \method{safe_substitute} メソッドを使う方が適切でしょう:

\begin{verbatim}
>>> t = Template('Return the $item to $owner.')
>>> d = dict(item='unladen swallow')
>>> t.substitute(d)
Traceback (most recent call last):
  . . .
KeyError: 'owner'
>>> t.safe_substitute(d)
'Return the unladen swallow to $owner.'
\end{verbatim}

% Template subclasses can specify a custom delimiter.  For example, a batch
% renaming utility for a photo browser may elect to use percent signs for
% placeholders such as the current date, image sequence number, or file format:

\class{Template} をサブクラス化すると、区切り文字を自作できます。例えば、
画像ブラウザ用にバッチで名前を変更するユーティリティを作っていたとして、
現在の日付や画像のシーケンス番号、ファイル形式といったプレースホルダに
パーセント記号を選んだとします:

\begin{verbatim}
>>> import time, os.path
>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
>>> class BatchRename(Template):
...     delimiter = '%'
>>> fmt = raw_input('Enter rename style (%d-date %n-seqnum %f-format):  ')
Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f

>>> t = BatchRename(fmt)
>>> date = time.strftime('%d%b%y')
>>> for i, filename in enumerate(photofiles):
...     base, ext = os.path.splitext(filename)
...     newname = t.substitute(d=date, n=i, f=ext)
...     print '%s --> %s' % (filename, newname)

img_1074.jpg --> Ashley_0.jpg
img_1076.jpg --> Ashley_1.jpg
img_1077.jpg --> Ashley_2.jpg
\end{verbatim}

% Another application for templating is separating program logic from the
% details of multiple output formats.  This makes it possible to substitute
% custom templates for XML files, plain text reports, and HMTL web reports.

テンプレートのもう一つの用途は、複数ある出力様式からのプログラムロジック
の分離です。テンプレートを使えば、カスタムのテンプレートを XML ファイル
用や平文テキストのレポート、 HTML で書かれた web レポート用などに
置き換えられます。

\section{バイナリデータレコードの操作\label{binary-formats}}
% Working with Binary Data Record Layouts
% The \ulink{\module{struct}}{../lib/module-struct.html} module provides
% \function{pack()} and \function{unpack()} functions for working with
% variable length binary record formats.  The following example shows how
% to loop through header information in a ZIP file (with pack codes
% \code{"H"} and \code{"L"} representing two and four byte unsigned
% numbers respectively):

\ulink{\module{struct}}{../lib/module-struct.html} モジュールでは、
可変長のバイナリレコード形式を操作する\function{pack()} や 
\function{unpack()} といった関数を提供しています。以下の例では、
ZIP ファイルのヘッダ情報にわたってループする方法を示しています
(2バイトと 4 バイトの符号無し整数を表すパックコード \code{"H"} 
と\code{"L"} を使っています):

\begin{verbatim}
    import struct

    data = open('myfile.zip', 'rb').read()
    start = 0
    for i in range(3):                      # show the first 3 file headers
        start += 14
        fields = struct.unpack('LLLHH', data[start:start+16])
        crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

        start += 16
        filename = data[start:start+filenamesize]
        start += filenamesize
        extra = data[start:start+extra_size]
        print filename, hex(crc32), comp_size, uncomp_size

        start += extra_size + comp_size     # skip to the next header
\end{verbatim}


\section{マルチスレッド処理\label{multi-threading}} % Multi-threading

% Threading is a technique for decoupling tasks which are not sequentially
% dependent.  Threads can be used to improve the responsiveness of
% applications that accept user input while other tasks run in the
% background.  A related use case is running I/O in parallel with
% computations in another thread.

スレッド処理 (threading) とは、順序的な依存関係にない複数のタスクを
分割するテクニックです。スレッド処理は、ユーザの入力を受け付けつつ、
背後で別のタスクを動かすようなアプリケーションの応答性を高めます。
主なユースケースには、 I/O を別のスレッドの計算処理と並列して
動作させるというものがあります。

% The following code shows how the high level
% \ulink{\module{threading}}{../lib/module-threading.html} module can run
% tasks in background while the main program continues to run:

以下のコードでは、高水準のモジュール
\ulink{\module{threading}}{../lib/module-threading.html} で
メインのプログラムを動かしながら背後で別のタスクを動作させられる
ようにする方法を示しています:

\begin{verbatim}
    import threading, zipfile

    class AsyncZip(threading.Thread):
        def __init__(self, infile, outfile):
            threading.Thread.__init__(self)        
            self.infile = infile
            self.outfile = outfile
        def run(self):
            f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
            f.write(self.infile)
            f.close()
            print 'Finished background zip of: ', self.infile

    background = AsyncZip('mydata.txt', 'myarchive.zip')
    background.start()
    print 'The main program continues to run in foreground.'
    
    background.join()    # Wait for the background task to finish
    print 'Main program waited until background was done.'
\end{verbatim}

% The principal challenge of multi-threaded applications is coordinating
% threads that share data or other resources.  To that end, the threading
% module provides a number of synchronization primitives including locks,
% events, condition variables, and semaphores.

マルチスレッドアプリケーションを作る上で最も難しい問題は、データやリソース
を共有するスレッド間の調整 (coordination) です。この問題を解決するため、
\module{threading} モジュールではロックやイベント、状態変数、セマフォ
といった数々の同期プリミティブを提供しています。

% While those tools are powerful, minor design errors can result in
% problems that are difficult to reproduce.  So, the preferred approach
% to task coordination is to concentrate all access to a resource
% in a single thread and then use the
% \ulink{\module{Queue}}{../lib/module-Queue.html} module to feed that
% thread with requests from other threads.  Applications using
% \class{Queue} objects for inter-thread communication and coordination
% are easier to design, more readable, and more reliable.

こうしたツールは強力な一方、ちょっとした設計上の欠陥で再現困難な
問題を引き起こすことがあります。したがって、タスク間調整では
\ulink{\module{Queue}}{../lib/module-Queue.html} モジュールを使って
他のスレッドから一つのスレッドにリクエストを送り込み、
一つのリソースへのアクセスをできるだけ一つのスレッドに集中させる
アプローチを勧めます。スレッド間の通信や調整に\class{Queue} 
オブジェクトを使うと、設計が容易になり、可読性が高まり、信頼性が増します。

\section{ログ記録\label{logging}} % Logging

% The \ulink{\module{logging}}{../lib/module-logging.html} module offers
% a full featured and flexible logging system.  At its simplest, log
% messages are sent to a file or to \code{sys.stderr}:

\ulink{\module{logging}}{../lib/module-logging.html} モジュールでは、
数多くの機能をそなえた柔軟性のあるログ記録システムを提供しています。
最も簡単な使い方では、ログメッセージをファイルや \code{sys.stderr}
に送信します:

\begin{verbatim}
    import logging
    logging.debug('Debugging information')
    logging.info('Informational message')
    logging.warning('Warning:config file %s not found', 'server.conf')
    logging.error('Error occurred')
    logging.critical('Critical error -- shutting down')
\end{verbatim}

上記のコードは以下のような出力になります:

\begin{verbatim}
    WARNING:root:Warning:config file server.conf not found
    ERROR:root:Error occurred
    CRITICAL:root:Critical error -- shutting down
\end{verbatim}

% By default, informational and debugging messages are suppressed and the
% output is sent to standard error.  Other output options include routing
% messages through email, datagrams, sockets, or to an HTTP Server.  New
% filters can select different routing based on message priority:
% \constant{DEBUG}, \constant{INFO}, \constant{WARNING}, \constant{ERROR},
% and \constant{CRITICAL}.

デフォルトでは、単なる情報やデバッグメッセージの出力は抑制され、
出力は標準エラーに送信されます。選択可能な送信先には、email、データグラム、
ソケット、 HTTP サーバへの送信などがあります。新たにフィルタを作成
すると、\constant{DEBUG}, \constant{INFO}, \constant{WARNING}, 
\constant{ERROR}, \constant{CRITICAL} といったメッセージのプライオリティに
従って配送先を変更できます。

% The logging system can be configured directly from Python or can be
% loaded from a user editable configuration file for customized logging
% without altering the application.

ログ記録システムは Python から直接設定できますし、アプリケーションを
変更しなくてもカスタマイズできるよう、ユーザが編集できる設定ファイル
でも設定できます。

\section{弱参照\label{weak-references}} % Weak References

Python は自動的にメモリを管理します (ほとんどのオブジェクトの参照回数を
カウントし、ガベージコレクションによって循環参照を除去します)。
オブジェクトに対する最後の参照がなくなってしばらくするとメモリは解放
されます。

このようなアプローチはほとんどのアプリケーションでうまく動作しますが、
中にはオブジェクトをどこか別の場所で利用するまでの間だけ追跡しておきたい
場合もあります。残念ながら、オブジェクトを追跡するだけでは、オブジェクトに
対する恒久的な参照を作ることになってしまいます。
\ulink{\module{weakref}}{../lib/module-weakref.html} モジュールでは、
オブジェクトを参照を作らずに追跡するためのツールを提供しています。
弱参照オブジェクトが不要になると、弱参照 (weakref) テーブルから自動的に
除去され、コールバック関数がトリガされます。弱参照を使う典型的な
応用例には、作成コストの大きいオブジェクトのキャッシュがあります:

\begin{verbatim}
    >>> import weakref, gc
    >>> class A:
    ...     def __init__(self, value):
    ...             self.value = value
    ...     def __repr__(self):
    ...             return str(self.value)
    ...
    >>> a = A(10)                   # create a reference
    >>> d = weakref.WeakValueDictionary()
    >>> d['primary'] = a            # does not create a reference
    >>> d['primary']                # fetch the object if it is still alive
    10
    >>> del a                       # remove the one reference
    >>> gc.collect()                # run garbage collection right away
    0
    >>> d['primary']                # entry was automatically removed
    Traceback (most recent call last):
      File "<pyshell#108>", line 1, in -toplevel-
        d['primary']                # entry was automatically removed
      File "C:/PY24/lib/weakref.py", line 46, in __getitem__
        o = self.data[key]()
    KeyError: 'primary'
\end{verbatim}

\section{リスト操作のためのツール\label{list-tools}}
% Tools for Working with Lists

% Many data structure needs can be met with the built-in list type.
% However, sometimes there is a need for alternative implementations
% with different performance trade-offs.

多くのデータ構造は、組み込みリスト型を使った実装で事足ります。
とはいえ、時には組み込みリストとは違うパフォーマンス上のトレードオフを
持つような実装が必要になこともあります。

% The \ulink{\module{array}}{../lib/module-array.html} module provides an
% \class{array()} object that is like a list that stores only homogenous
% data and stores it more compactly.  The following example shows an array
% of numbers stored as two byte unsigned binary numbers (typecode
% \code{"H"}) rather than the usual 16 bytes per entry for regular lists
% of python int objects:

\ulink{\module{array}}{../lib/module-array.html} モジュールでは、
同じ形式のデータだけをコンパクトに
保存できる、リスト型に似た\class{array()} オブジェクトを提供しています。
以下の例では、通常要素あたり 16 バイトを必要とする Python 整数型の
リストの代りに、 2 バイトの符号無しの 2 進数 (タイプコード \code{"H"})
を使っている数値アレイを示します:

\begin{verbatim}
    >>> from array import array
    >>> a = array('H', [4000, 10, 700, 22222])
    >>> sum(a)
    26932
    >>> a[1:3]
    array('H', [10, 700])
\end{verbatim}

% The \ulink{\module{collections}}{../lib/module-collections.html} module
% provides a \class{deque()} object that is like a list with faster
% appends and pops from the left side but slower lookups in the middle.
% These objects are well suited for implementing queues and breadth first
% tree searches:

\ulink{\module{collections}}{../lib/module-collections.html} モジュールでは、
リスト型に似た \class{deque()} オブジェクトを提供しています。
\class{deque()} オブジェクトでは、データの追加と左端からの取り出しが高速
な半面、中間にある値の検索が低速になります。こうしたオブジェクトは
キューの実装や幅優先 (breadth first) のツリー探索に向いています:

\begin{verbatim}
    >>> from collections import deque
    >>> d = deque(["task1", "task2", "task3"])
    >>> d.append("task4")
    >>> print "Handling", d.popleft()
    Handling task1

    unsearched = deque([starting_node])
    def breadth_first_search(unsearched):
        node = unsearched.popleft()
        for m in gen_moves(node):
            if is_goal(m):
                return m
            unsearched.append(m)
\end{verbatim}

% In addition to alternative list implementations, the library also offers
% other tools such as the \ulink{\module{bisect}}{../lib/module-bisect.html}
% module with functions for manipulating sorted lists:

リストのもう一つの実装の他に、このライブラリではソート済みのリストを
操作するための関数を備えた\ulink{\module{bisect}}{../lib/module-bisect.html}
のようなツールも提供しています:

\begin{verbatim}
    >>> import bisect
    >>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
    >>> bisect.insort(scores, (300, 'ruby'))
    >>> scores
    [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
\end{verbatim}

% The \ulink{\module{heapq}}{../lib/module-heapq.html} module provides
% functions for implementing heaps based on regular lists.  The lowest
% valued entry is always kept at position zero.  This is useful for
% applications which repeatedly access the smallest element but do not
% want to run a full list sort:

\ulink{\module{heapq}}{../lib/module-heapq.html} モジュールでは、
通常のリストでヒープを実装するための関数を提供しています。
ヒープでは、最も低い値をもつエントリがつねにゼロの位置に配置
されます。ヒープは、毎回リストをソートすることなく、最小の値をもつ
要素に繰り返しアクセスするようなアプリケーションで便利です:

\begin{verbatim}
    >>> from heapq import heapify, heappop, heappush
    >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
    >>> heapify(data)                      # rearrange the list into heap order
    >>> heappush(data, -5)                 # add a new entry
    >>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
    [-5, 0, 1]
\end{verbatim}


\section{10 進浮動小数演算\label{decimal-fp}} % Decimal Floating Point Arithmetic

% The \ulink{\module{decimal}}{../lib/module-decimal.html} module offers a
% \class{Decimal} datatype for decimal floating point arithmetic.  Compared to
% the built-in \class{float} implementation of binary floating point, the new
% class is especially helpful for financial applications and other uses which
% require exact decimal representation, control over precision, control over
% rounding to meet legal or regulatory requirements, tracking of significant
% decimal places, or for applications where the user expects the results to
% match calculations done by hand.

\ulink{\module{decimal}}{../lib/module-decimal.html} では、 10 進浮動小数の
算術演算をサポートする \class{Decimal} データ型を提供しています。
組み込みの 2 進浮動小数の実装である \class{float} に比べて、この新たな
クラスがとりわけ便利なのは、厳密な 10 進表記や計算精度の制御、法的または
規制上の理由に基づく値丸めの制御、有効桁数の追跡が必要になる金融計算など
のアプリケーションや、ユーザが手計算の結果と同じ演算結果を期待するような
アプリケーションの場合です。

% For example, calculating a 5\%{} tax on a 70 cent phone charge gives
% different results in decimal floating point and binary floating point.
% The difference becomes significant if the results are rounded to the
% nearest cent:

例えば、 70 セントの電話代にかかる 5\%{} の税金を計算しようとすると、
10 進の浮動小数点値と 2 進の浮動小数点値では違う結果になってしまいます。
例えば以下のような例では、計算結果を四捨五入してセント単位にしようと
すると違いがはっきり現れます:

\begin{verbatim}
>>> from decimal import *       
>>> Decimal('0.70') * Decimal('1.05')
Decimal("0.7350")
>>> .70 * 1.05
0.73499999999999999       
\end{verbatim}

% The \class{Decimal} result keeps a trailing zero, automatically inferring four
% place significance from multiplicands with two place significance.  Decimal reproduces
% mathematics as done by hand and avoids issues that can arise when binary
% floating point cannot exactly represent decimal quantities.

\class{Decimal} を使った計算では、末尾桁のゼロが保存されており、有効数字2桁の
被乗数から自動的に有効数字を  4 桁と判断しています。\class{Decimal} は
手計算と同じ方法で計算を行い、 2 進浮動小数点が 10 進小数成分を正確に
表現できないことによって起きる問題を回避しています。

% Exact representation enables the \class{Decimal} class to perform
% modulo calculations and equality tests that are unsuitable for binary
% floating point:

\class{Decimal} クラスは厳密な値を表現できるため、2 進浮動小数点数
では期待通りに計算できないようなモジュロの計算や等値テストも実現
できます:

\begin{verbatim}
>>> Decimal('1.00') % Decimal('.10')
Decimal("0.00")
>>> 1.00 % 0.10
0.09999999999999995
       
>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> sum([0.1]*10) == 1.0
False      
\end{verbatim}

% The \module{decimal} module provides arithmetic with as much precision as
% needed:

\module{decimal} モジュールを使うと、必要なだけの精度で算術演算を行えます:

\begin{verbatim}
>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal("0.142857142857142857142857142857142857")
\end{verbatim}
    

\chapter{さあ何を？ \label{whatNow}} % What Now?

%% Reading this tutorial has probably reinforced your interest in using
%% Python --- you should be eager to apply Python to solving your
%% real-world problems.  Where should you go to learn more?

このチュートリアルを読んだことで、おそらく Python を使ってみようと
いう関心はますます強くなったことでしょう --- 現実世界の問題を解決
するために、Python を適用してみたくなったはずです。さて、それでは
どこで勉強をしたらよいのでしょうか？

このチュートリアルはPythonのドキュメンテーションセットの一部です。
%% Some other documents in the set are:

セットの中の他のドキュメンテーションをいくつか紹介します:
\begin{itemize}

\item \citetitle[../lib/lib.html]{Python Library Reference}:

%%You should browse through this manual, which gives complete (though
%%terse) reference material about types, functions, and the modules in
%%the standard library.  The standard Python distribution includes a
%%\emph{lot} of additional code.  There are modules to read \UNIX{}
%%mailboxes, retrieve documents via HTTP, generate random numbers, parse
%%command-line options, write CGI programs, compress data, and many other tasks.
%%Skimming through the Library Reference will give you an idea of
%%what's available.

このマニュアルをざっと眺めておくと便利です。このマニュアルは
型、関数、標準ライブラリのモジュールについての完全なリファレンスです。
標準的なPython配布物は \emph{たくさんの} 追加コードを含んでいます。
\UNIX{}　メールボックスの読み込み、HTTPによるドキュメント取得、
乱数の生成、コマンドラインオプションの構文解析、CGIプログラムの作成、
データ圧縮やその他たくさんのタスクのためのモジュールがあります。
ライブラリリファレンスをざっと見ることで、何が利用できるかのイメージを
つかむことができます。

\item \citetitle[../inst/inst.html]{Installing Python Modules}
%%explains how to install external modules written by other Python
%%users.

Pythonユーザによって書かれた外部モジュールをどうやってインストールする
かを説明しています。

\item \citetitle[../ref/ref.html]{Language Reference}: A detailed 
%%explanation of Python's syntax and semantics.  It's heavy reading, 
%%but is useful as a complete guide to the language itself.

Pythonの文法とセマンティクスを説明しています。
読むのは大変ですが、言語の完全なガイドとして有用です。

\end{itemize}

More Python resources:

\begin{itemize}




%% \item \url{http://www.python.org}:  The major Python Web site.  It contains
%%  code, documentation, and pointers to Python-related pages around the
%%  Web.  This Web site is mirrored in various places around the
%%  world, such as Europe, Japan, and Australia; a mirror may be faster
%% than the main site, depending on your geographical location. 

\item \url{http://www.python.org}: 主要な Python Web サイト。
このサイトには、コード、ドキュメント、そして Web のあちこちの
Python に関連したページへのポインタがあります。
この Web サイトは世界のあちこちのさまざまな場所、例えばヨーロッパ、
日本、オーストラリアなどでミラーされています。地理的な位置によっては、
メインのサイトよりミラーのほうが速いかもしれません。

%% \item \url{http://docs.python.org}:  Fast access to Python's 
%% documentation.

\item \url{http://docs.python.org}:  Pythonドキュメントへの素早いアク
  セスを提供します。


%% Many more user-created Python modules
%% can be found in a third-party repository at
%% \ulink{Python Package Index}{http://www.python.org/pypi} (PyPI).

\ulink{Python Package Index}{http://www.python.org/pypi} (PyPI).
にあるサードパーティ製モジュール
リポジトリに行けば、さらに多くのユーザによって作成された Python モジュール
を見つけることができます。


%% \item \url{http://cheeseshop.python.org}: 
%% The Python Package Index, nicknamed the Cheese Shop, 
%% is an index of user-created Python modules that are available for 
%% download.  Once you begin releasing code, you can register it 
%% here so that others can find it.

\item \url{http://cheeseshop.python.org}: 
Python パッケージインデックス、愛称はCheese Shopです。
ユーザ作成のダウンロードできるPythonモジュール索引です。
コードのリリースをしたら、ここに登録することで他の人が見つけられます。

%% \item \url{http://aspn.activestate.com/ASPN/Python/Cookbook/}: The
%% Python Cookbook is a sizable collection of code examples, larger
%% modules, and useful scripts.  Particularly notable contributions are
%% collected in a book also titled \citetitle{Python Cookbook} (O'Reilly
%% \& Associates, ISBN 0-596-00797-3.)

\item \url{http://aspn.activestate.com/ASPN/Python/Cookbook/}: Python
  クックブックはコード例、モジュール、実用的なスクリプトの巨大なコレ
  クションです。
  主要なものは同名の本\citetitle{Python Cookbook} (O'Reilly
 \& Associates, ISBN 0-596-00797-3.)に収録されています。


\end{itemize}

%% For Python-related questions and problem reports, you can post to the
%% newsgroup \newsgroup{comp.lang.python}, or send them to the mailing
%% list at \email{python-list@python.org}.  The newsgroup and mailing list
%% are gatewayed, so messages posted to one will automatically be
%% forwarded to the other.  There are around 120 postings a day,
Python に関する質問をしたり、問題を報告するために、
ニュースグループ \newsgroup{comp.lang.python} に投稿したり、
\email{python-list@python.org} のメーリングリストに送信することが
できます。ニュースグループとメーリングリストは相互接続されて
いるので、どちらかにポストされたメッセージは自動的にもう一方にも
転送されます。
一日に約 120 通程度、
% Postings figure based on average of last six months activity as
% reported by www.egroups.com; Jan. 2000 - June 2000: 21272 msgs / 182
% days = 116.9 msgs / day and steadily increasing.
%% asking (and answering) questions, suggesting new features, and
%% announcing new modules.  Before posting, be sure to check the list of
%% \ulink{Frequently Asked Questions}{http://www.python.org/doc/faq/} 
%% (also called the FAQ), or look for it in the
%% \file{Misc/} directory of the Python source distribution.  Mailing
%% list archives are available at \url{http://www.python.org/pipermail/}.
%% The FAQ answers many of the questions that come up again and again,
%% and may already contain the solution for your problem.
質問を (そしてその解凍)、新機能の提案、新たなモジュールのアナウンス
が投稿されています。
投稿する前に、必ず
\ulink{よく出される質問}{http://www.python.org/doc/faq/}
(Frequently Asked Questions, FAQ とも言います) 
のリストを確認するか、Python ソースコード配布物の \file{Misc/} 
ディレクトリを探すようにしてください。
メーリングリストのアーカイブは \url{http://mail.python.org/pipermail/} で
入手することができます。
FAQ では、何度も繰り返し現れる質問の多くに答えています。読者の抱えている
問題に対する解答がすでに入っているかもしれません。


\appendix

\chapter{対話入力編集とヒストリ置換 \label{interacting}}
% Interactive Input Editing and History Substitution

%% Some versions of the Python interpreter support editing of the current
%% input line and history substitution, similar to facilities found in
%% the Korn shell and the GNU Bash shell.  This is implemented using the
%% \emph{GNU Readline} library, which supports Emacs-style and vi-style
%% editing.  This library has its own documentation which I won't
%% duplicate here; however, the basics are easily explained.  The
%% interactive editing and history described here are optionally
%% available in the \UNIX{} and Cygwin versions of the interpreter.

あるバージョンの Python インタプリタでは、Korn シェルや GNU Bash
シェルに見られる機能に似た、現在の入力行に対する編集機能や
ヒストリ置換機能をサポートしています。
この機能は \emph{GNU Readline} ライブラリを使って実装されています。
このライブラリは Emacs スタイルと vi スタイルの編集をサポート
しています。ライブラリには独自のドキュメントがあり、ここでそれを
繰り返すつもりはありません; とはいえ、基本について簡単に解説する
ことにします。ここで述べる対話的な編集とヒストリについては、
\UNIX{} 版と Cygwin 版のインタプリタでオプションとして利用
することができます。

%% This chapter does \emph{not} document the editing facilities of Mark
%% Hammond's PythonWin package or the Tk-based environment, IDLE,
%% distributed with Python.  The command line history recall which
%% operates within DOS boxes on NT and some other DOS and Windows flavors 
%% is yet another beast.

この章では、Mark Hammond の PythonWin パッケージや、
Python とともに配布される Tk ベースの環境である IDLE にある
編集機能については解説\emph{しません}。
NT 上の DOS ボックスやその他の DOS および Windows 類で働く
コマンド行ヒストリ呼出しもまた別のものです。

\section{行編集 \label{lineEditing}} % Line Editing

%% If supported, input line editing is active whenever the interpreter
%% prints a primary or secondary prompt.  The current line can be edited
%% using the conventional Emacs control characters.  The most important
%% of these are: \kbd{C-A} (Control-A) moves the cursor to the beginning
%% of the line, \kbd{C-E} to the end, \kbd{C-B} moves it one position to
%% the left, \kbd{C-F} to the right.  Backspace erases the character to
%% the left of the cursor, \kbd{C-D} the character to its right.
%% \kbd{C-K} kills (erases) the rest of the line to the right of the
%% cursor, \kbd{C-Y} yanks back the last killed string.
%% \kbd{C-underscore} undoes the last change you made; it can be repeated
%% for cumulative effect.

入力行の編集がサポートされている場合、インタプリタが一次または二次
プロンプトを出力している際にはいつでも有効になっています。現在の行は、
慣例的な Emacs 制御文字を使って編集することができます。
そのうち最も重要なものとして、以下のようなキーがあります:
\kbd{C-A} (Control-A) はカーソルを行の先頭へ移動させます。
\kbd{C-E} は末尾へ移動させます。
\kbd{C-B} は逆方向へ一つ移動させます。
\kbd{C-F} は順方向へ移動させます。
Backspace は逆方向に向かって文字を消します。
\kbd{C-D} は順方向に向かって消します。
\kbd{C-K} は順方向に向かって行の残りを kill し (消し) ます 、
\kbd{C-Y} は最後に kill された文字列を再び yank し (取り出し) ます。
\kbd{C-underscore} 最後の変更を元に戻します; これは、繰り返して
どんどんさかのぼることができます。

\section{ヒストリ置換 \label{history}} % History Substitution

%% History substitution works as follows.  All non-empty input lines
%% issued are saved in a history buffer, and when a new prompt is given
%% you are positioned on a new line at the bottom of this buffer.
%% \kbd{C-P} moves one line up (back) in the history buffer,
%% \kbd{C-N} moves one down.  Any line in the history buffer can be
%% edited; an asterisk appears in front of the prompt to mark a line as
%% modified.  Pressing the \kbd{Return} key passes the current line to
%% the interpreter.  \kbd{C-R} starts an incremental reverse search;
%% \kbd{C-S} starts a forward search.

ヒストリ置換は次のように働きます。入力された行のうち、空行でない
実行された行はすべてヒストリバッファに保存されます。そして、プロンプト
が呈示されるときには、ヒストリバッファの最も下の新たな行に移動
します。\kbd{C-P} はヒストリバッファの中を一行だけ上に移動し (戻し)
ます。\kbd{C-N} は 1 行だけ下に移動します。ヒストリバッファの
どの行も編集することができます。行が編集されると、それを示すために
プロンプトの前にアスタリスクが表示されます \footnote{
訳注: これはデフォルト設定の Readline では現れません。
\code{set mark-modified-lines on} という行を
\file{\~{}/.inputrc} または
環境変数 \envvar{INPUTRC} が指定するファイルに置くことによって
現れるようになります。
}。
\kbd{Return} キーを押すと現在行がインタプリタへ渡されます。
\kbd{C-R} はインクリメンタルな逆方向サーチ (reverse search) を開始し、
\kbd{C-S} は順方向サーチ (forward search) を開始します。

\section{キー割り当て \label{keyBindings}} % Key Bindings

%% The key bindings and some other parameters of the Readline library can
%% be customized by placing commands in an initialization file called
%% \file{\~{}/.inputrc}.  Key bindings have the form

Readline ライブラリのキー割り当て (key binding) やその他のパラメタ
は、\file{\~{}/.inputrc} という初期化ファイル\footnote{
訳注: このファイル名は
環境変数 \envvar{INPUTRC} がもしあればその指定が優先されます。
}にコマンドを置くことでカスタマイズできます。
キー割り当ての形式は

\begin{verbatim}
key-name: function-name
\end{verbatim}

%% or

または

\begin{verbatim}
"string": function-name
\end{verbatim}

%% and options can be set with

で、オプションの設定方法は

\begin{verbatim}
set option-name value
\end{verbatim}

%% For example:

です。例えば、以下のように設定します:

\begin{verbatim}
# vi スタイルの編集を選択する:
set editing-mode vi

# 一行だけを使って編集する:
set horizontal-scroll-mode On

# いくつかのキーを再束縛する:
Meta-h: backward-kill-word
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
\end{verbatim}

%% Note that the default binding for \kbd{Tab} in Python is to insert a
%% \kbd{Tab} character instead of Readline's default filename completion
%% function.  If you insist, you can override this by putting

Python では、\kbd{Tab} に対するデフォルトの割り当ては TAB の挿入です。
Readline のデフォルトであるファイル名補完関数ではないので注意して
ください。
もし、どうしても Readline のデフォルトを割り当てたいのなら、
\file{\~{}/.inputrc} に

\begin{verbatim}
Tab: complete
\end{verbatim}

%% in your \file{\~{}/.inputrc}.  (Of course, this makes it harder to
%% type indented continuation lines if you're accustomed to using
%% \kbd{Tab} for that purpose.)

を入れれば設定を上書きすることができます。 (もちろん、\kbd{Tab} 
を使って補完を行うのに慣れている場合、この設定を行うと
インデントされた継続行を入力しにくくなります。)

%% Automatic completion of variable and module names is optionally
%% available.  To enable it in the interpreter's interactive mode, add
%% the following to your startup file:\footnote{
%%   Python will execute the contents of a file identified by the
%%   \envvar{PYTHONSTARTUP} environment variable when you start an
%%   interactive interpreter.}
%% \refstmodindex{rlcompleter}\refbimodindex{readline}

変数名とモジュール名の自動的な補完がオプションとして利用できます。
補完をインタプリタの対話モードで有効にするには、
以下の設定をスタートアップファイルに追加します: \footnote{
Python は、対話インタプリタを開始する時に \envvar{PYTHONSTARTUP} 
環境変数が指定するファイルの内容を実行します。}
\refstmodindex{rlcompleter}\refbimodindex{readline}

\begin{verbatim}
import rlcompleter, readline
readline.parse_and_bind('tab: complete')
\end{verbatim}

%% This binds the \kbd{Tab} key to the completion function, so hitting
%% the \kbd{Tab} key twice suggests completions; it looks at Python
%% statement names, the current local variables, and the available module
%% names.  For dotted expressions such as \code{string.a}, it will
%% evaluate the expression up to the final \character{.} and then
%% suggest completions from the attributes of the resulting object.  Note
%% that this may execute application-defined code if an object with a
%% \method{__getattr__()} method is part of the expression.

この設定は、\kbd{Tab} キーを補完関数に束縛します。従って、
\kbd{Tab} キーを二回たたくと補完候補が示されます; 補完機能は
Python の文の名前、現在のローカル変数、および利用可能なモジュール名を
検索します。\code{string.a} のようなドットで区切られた式については、
最後の \character{.} までの式を評価し、結果として得られたオブジェクトの
属性から補完候補を示します。
\method{__getattr__()} メソッドを持ったオブジェクトが式に含まれている
場合、\method{__getattr__()} がアプリケーション定義のコードを実行する
かもしれないので注意してください。

%% A more capable startup file might look like this example.  Note that
%% this deletes the names it creates once they are no longer needed; this
%% is done since the startup file is executed in the same namespace as
%% the interactive commands, and removing the names avoids creating side
%% effects in the interactive environments.  You may find it convenient
%% to keep some of the imported modules, such as \module{os}, which turn
%% out to be needed in most sessions with the interpreter.

より良くできたスタートアップファイルは以下例のようになります。
この例では、作成した名前が不要になると削除されるので気をつけてください;
これは、スタートアップファイルが対話コマンドと同じ名前空間で実行され
ているので、不要な名前を除去して対話環境に副作用を生まないように
するためです。import されたモジュールのうち、\module{os} のような
インタプリタのほとんどのセッションで必要なものについては、残しておくと
便利に思うかもしれません。

\begin{verbatim}
# Add auto-completion and a stored history file of commands to your Python
# interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
# bound to the Esc key by default (you can change it - see readline docs).
#
# Store the file in ~/.pystartup, and set an environment variable to point
# to it, e.g. "export PYTHONSTARTUP=/max/home/itamar/.pystartup" in bash.
#
# Note that PYTHONSTARTUP does *not* expand "~", so you have to put in the
# full path to your home directory.

import atexit
import os
import readline
import rlcompleter

historyPath = os.path.expanduser("~/.pyhistory")

def save_history(historyPath=historyPath):
    import readline
    readline.write_history_file(historyPath)

if os.path.exists(historyPath):
    readline.read_history_file(historyPath)

atexit.register(save_history)
del os, atexit, readline, rlcompleter, save_history, historyPath
\end{verbatim}


\section{解説 \label{commentary}} % Commentary

%% This facility is an enormous step forward compared to earlier versions
%% of the interpreter; however, some wishes are left: It would be nice if
%% the proper indentation were suggested on continuation lines (the
%% parser knows if an indent token is required next).  The completion
%% mechanism might use the interpreter's symbol table.  A command to
%% check (or even suggest) matching parentheses, quotes, etc., would also
%% be useful.

この機能は、初期の版のインタプリタに比べれば大きな進歩です;
とはいえ、まだいくつかの要望が残されています: 例えば、
行を継続するときに正しいインデントが呈示されたら快適でしょう (パーサは
次の行でインデントトークンが必要かどうかを知っています)。
補完機構がインタプリタのシンボルテーブルを使ってもよいかもしれません。
かっこやクォートなどの対応をチェックする (あるいは指示する) コマンドも
有用でしょう。


\chapter{浮動小数点演算、その問題と制限\label{fp-issues}}
\sectionauthor{Tim Peters}{tim_one@users.sourceforge.net}
%% Floating Point Arithmetic:  Issues and Limitations

%% Floating-point numbers are represented in computer hardware as
%% base 2 (binary) fractions.  For example, the decimal fraction

浮動小数点数は、計算機ハードウェアの中では、
基数を 2 とする (2進法の) 分数として表現されています。
例えば、小数

\begin{verbatim}
0.125
\end{verbatim}

%% has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction

は、 1/10 + 2/100 + 5/1000 という値を持ちますが、これと同様に、
2 進法の分数

\begin{verbatim}
0.001
\end{verbatim}

%% has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
%% the only real difference being that the first is written in base 10
%% fractional notation, and the second in base 2.

は 0/2 + 0/4 + 1/8 という値になります。これら二つの分数は同じ値を
持っていますが、ただ一つ、最初の分数は基数 10 で記述されており、
二番目の分数は基数 2 で記述されていることが違います。

%% Unfortunately, most decimal fractions cannot be represented exactly as
%% binary fractions.  A consequence is that, in general, the decimal
%% floating-point numbers you enter are only approximated by the binary
%% floating-point numbers actually stored in the machine.

残念なことに、ほとんどの小数は 2 進法の分数として正確に表わすことが
できません。その結果、一般に、入力した 10 進の浮動小数点数は、
2 進法の浮動小数点数で近似された後、実際にマシンに記憶されます。

%% The problem is easier to understand at first in base 10.  Consider the
%% fraction 1/3.  You can approximate that as a base 10 fraction:

最初は基数 10 を使うと問題を簡単に理解できます。分数 1/3 を考えて
みましょう。分数 1/3 は、基数 10 の分数として、以下のように近似する
ことができます:

\begin{verbatim}
0.3
\end{verbatim}

%% or, better,

さらに正確な近似は、

\begin{verbatim}
0.33
\end{verbatim}

%% or, better,

です。さらに正確に近似すると、

\begin{verbatim}
0.333
\end{verbatim}

%% and so on.  No matter how many digits you're willing to write down, the
%% result will never be exactly 1/3, but will be an increasingly better
%% approximation to 1/3.

となり、以後同様です。何個桁数を増やして書こうが、結果は決して厳密な
 1/3 にはなりません。しかし、少しづつ正確な近似にはなっていくでしょう。

%% In the same way, no matter how many base 2 digits you're willing to
%% use, the decimal value 0.1 cannot be represented exactly as a base 2
%% fraction.  In base 2, 1/10 is the infinitely repeating fraction

同様に、基数を 2 とした表現で何桁使おうとも、10 進数の 0.1 は 基数を
2 とした分数で正確に表現することはできません。
基数 2 では、1/10 は循環小数 (repeating fraction)

\begin{verbatim}
0.0001100110011001100110011001100110011001100110011...
\end{verbatim}

%% Stop at any finite number of bits, and you get an approximation.  This
%% is why you see things like:

となります。どこか有限の桁で止めると、近似値を得ることになります。
これこそが、以下のような事態:

\begin{verbatim}
>>> 0.1
0.10000000000000001
\end{verbatim}

に出くわす理由です。

%% On most machines today, that is what you'll see if you enter 0.1 at
%% a Python prompt.  You may not, though, because the number of bits
%% used by the hardware to store floating-point values can vary across
%% machines, and Python only prints a decimal approximation to the true
%% decimal value of the binary approximation stored by the machine.  On
%% most machines, if Python were to print the true decimal value of
%% the binary approximation stored for 0.1, it would have to display

今日では、ほとんどのマシンでは、0.1 を Python のプロンプトから入力すると
上のような結果を目にします。そうならないかもしれませんが、これは
ハードウェアが浮動小数点数を記憶するのに用いているビット数がマシンに
よって異なり、Python は単にマシンに 2 進で記憶されている、真の 10 進の
値を近似した値を、されに 10 進で近似して出力するだけだからです。
ほとんどのマシンでは、Python が 0.1 を記憶するために 2 進近似した
真の値を 10 進で表すと、以下のような出力

\begin{verbatim}
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
\end{verbatim}

%% instead!  The Python prompt uses the builtin
%% \function{repr()} function to obtain a string version of everything it
%% displays.  For floats, \code{repr(\var{float})} rounds the true
%% decimal value to 17 significant digits, giving

になるでしょう！ Python プロンプトは、文字列表現を得るために
何に対しても \function{repr()} を使います。
浮動小数点数の場合、 \code{repr(\var{float})} は真の 10 進値を
有効数字 17 桁で丸め、以下のような表示

\begin{verbatim}
0.10000000000000001
\end{verbatim}

を行います。

%% \code{repr(\var{float})} produces 17 significant digits because it
%% turns out that's enough (on most machines) so that
%% \code{eval(repr(\var{x})) == \var{x}} exactly for all finite floats
%% \var{x}, but rounding to 16 digits is not enough to make that true.

\code{repr(\var{float})} が有効数字 17桁 の値を生成するのは、この値
が (ほとんどのマシン上で) 、全ての有限の浮動小数点数 \var{x} について
\code{eval(repr(\var{x})) == \var{x}} が成り立つのに十分で、
かつ有効数字 16 桁に丸めると成り立たないからです。

%% Note that this is in the very nature of binary floating-point: this is
%% not a bug in Python, and it is not a bug in your code either. You'll
%% see the same kind of thing in all languages that support your
%% hardware's floating-point arithmetic (although some languages may
%% not \emph{display} the difference by default, or in all output modes).

これは 2 進法の浮動小数点の性質です: Python のバグでも、ソースコードのバ
グでもなく、浮動小数点演算を扱えるハードウェア上の、すべての言語で同じ
類の現象が発生します (ただし、言語によっては、デフォルトのモードや
全ての出力モードでその差を \emph{表示しない} かもしれません)。

%% Python's builtin \function{str()} function produces only 12
%% significant digits, and you may wish to use that instead.  It's
%% unusual for \code{eval(str(\var{x}))} to reproduce \var{x}, but the
%% output may be more pleasant to look at:

Python の組み込みの \function{str()} 関数は有効数字 12 桁しか生成
しません。このため、この関数を代わりに使用したいと思うかもしれません。
この関数は \code{eval(str(\var{x}))} としたときに \var{x} を再現
しないことが多いですが、出力を目で見るには好ましいかもしれません:

\begin{verbatim}
>>> print str(0.1)
0.1
\end{verbatim}

%% It's important to realize that this is, in a real sense, an illusion:
%% the value in the machine is not exactly 1/10, you're simply rounding
%% the \emph{display} of the true machine value.

現実という考えからは、上の表示は錯覚であると気づくのは重要なことです:
マシン内の値は厳密に 1/10 ではなく、単に真のマシン内の 
\emph{表示される値} を丸めているだけなのです。

%% Other surprises follow from this one.  For example, after seeing

まだ驚くべきことがあります。例えば、以下

\begin{verbatim}
>>> 0.1
0.10000000000000001
\end{verbatim}

%% you may be tempted to use the \function{round()} function to chop it
%% back to the single digit you expect.  But that makes no difference:

を見て、\function{round()} 関数を使って桁を切り捨て、期待する 1 桁に
したい誘惑にかられたとします。しかし、結果は依然同じ値です:

\begin{verbatim}
>>> round(0.1, 1)
0.10000000000000001
\end{verbatim}

%% The problem is that the binary floating-point value stored for "0.1"
%% was already the best possible binary approximation to 1/10, so trying
%% to round it again can't make it better:  it was already as good as it
%% gets.

問題は、"0.1" を表すために記憶されている 2 進表現の浮動小数点数の値は、
すでに 1/10 に対する最良の近似になっており、値を再度丸めようとしても
これ以上ましにはならないということです: すでに値は、\function{round()}
で得られる値になっているというわけです。

%% Another consequence is that since 0.1 is not exactly 1/10, 
%% summing ten values of 0.1 may not yield exactly 1.0, either:

もう一つの重要なことは、0.1 が正確に 1/10 ではないため、0.1 を
10 個加算すると厳密に 1.0 にはならないこともある、ということです:

\begin{verbatim}
>>> sum = 0.0
>>> for i in range(10):
...     sum += 0.1
...
>>> sum
0.99999999999999989
\end{verbatim}

%% Binary floating-point arithmetic holds many surprises like this.  The
%% problem with "0.1" is explained in precise detail below, in the
%% "Representation Error" section.  See
%% \citetitle[http://www.lahey.com/float.htm]{The Perils of Floating
%% Point} for a more complete account of other common surprises.

2 進の浮動小数点数に対する算術演算は、このような意外性をたくさん持って
います。"0.1" に関する問題は、以下の "表現エラー" の章で詳細に説明します。
2 進法の浮動小数点演算にともなうその他のよく知られた意外な事象に関しては
\citetitle[http://www.lahey.com/float.htm]{The Perils of Floating Point}
を参照してください。

%% As that says near the end, ``there are no easy answers.''  Still,
%% don't be unduly wary of floating-point!  The errors in Python float
%% operations are inherited from the floating-point hardware, and on most
%% machines are on the order of no more than 1 part in 2**53 per
%% operation.  That's more than adequate for most tasks, but you do need
%% to keep in mind that it's not decimal arithmetic, and that every float
%% operation can suffer a new rounding error.

究極的にいうと、``容易な答えはありません''。ですが、浮動小数点数の
ことを過度に警戒しないでください！ Python の float 型操作における
エラーは浮動小数点処理ハードウェアから受けついたものであり、
ほとんどのマシン上では一つの演算あたり高々 2**53 分の 1 です。
この誤差はほとんどの作業で相当以上のものですが、浮動小数点演算は
10 進の演算えはなく、浮動小数点の演算を新たに行うと、新たな
丸め誤差の影響を受けることを心にとどめておいてください。

%% While pathological cases do exist, for most casual use of
%% floating-point arithmetic you'll see the result you expect in the end
%% if you simply round the display of your final results to the number of
%% decimal digits you expect.  \function{str()} usually suffices, and for
%% finer control see the discussion of Pythons's \code{\%} format
%% operator: the \code{\%g}, \code{\%f} and \code{\%e} format codes
%% supply flexible and easy ways to round float results for display.

異常なケースが存在する一方で、普段の浮動小数点演算の利用では、
単に最終的な結果の値を必要な 10 進の桁数に丸めて表示するのなら、
最終的には期待通りの結果を得ることになるでしょう。
こうした操作は普通 \function{str()} で事足りますし、よりきめ細かな
制御をしたければ、 Python の \code{\%} 書式化演算子についての議論を
参照してください: \code{\%g} 、\code{\%f} 、および \code{\%e} といった
書式化コードでは、浮動小数点数を表示用に丸めるための柔軟性のある、
簡単な手段を提供しています。


\section{表現エラー
         \label{fp-error}} % Representation Error

%% This section explains the ``0.1'' example in detail, and shows how
%% you can perform an exact analysis of cases like this yourself.  Basic
%% familiarity with binary floating-point representation is assumed.

この章では、``0.1'' の例について詳細に説明し、このようなケースに
対してどのようにすれば正確な分析を自分で行えるかを示します。
ここでは、 2 進法表現の浮動小数点数についての基礎的な知識があるものとして
話を進めます。

%% \dfn{Representation error} refers to the fact that some (most, actually)
%% decimal fractions cannot be represented exactly as binary (base 2)
%% fractions.  This is the chief reason why Python (or Perl, C, \Cpp,
%% Java, Fortran, and many others) often won't display the exact decimal
%% number you expect:

\dfn{表現エラー} は、いくつかの (実際にはほとんどの) 10 進の小数が
 2 進法 (基数 2 ) の分数として表現できないという事実に関係しています。
これは Python (あるいは Perl、 C、 \Cpp 、Japa、Fortran 、および
その他多く) が期待通りの正確な 10 進数を表示できない主要な理由です:

\begin{verbatim}
>>> 0.1
0.10000000000000001
\end{verbatim}

%% Why is that?  1/10 is not exactly representable as a binary fraction.
%% Almost all machines today (November 2000) use IEEE-754 floating point
%% arithmetic, and almost all platforms map Python floats to IEEE-754
%% "double precision".  754 doubles contain 53 bits of precision, so on
%% input the computer strives to convert 0.1 to the closest fraction it can
%% of the form \var{J}/2**\var{N} where \var{J} is an integer containing
%% exactly 53 bits.  Rewriting

なぜこうなるのでしょうか？ 1/10 は 2 進法の分数で厳密に表現することが
できません。今日 (2000年11月) のマシンは、ほとんどすべて IEEE-754
浮動小数点演算を使用しており、ほとんどすべてのプラットフォームでは
Python の浮動小数点を IEEE-754 における "倍精度 (double precision)" 
に対応付けます。754 の double には 53 ビットの精度を持つ数が入るので、
計算機に入力を行おうとすると、可能な限り 0.1 を最も近い値の分数に変換
し、\var{J}/2**\var{N} の形式にしようと努力します。
\var{J} はちょうど 53 ビットの精度の整数です。

\begin{verbatim}
 1 / 10 ~= J / (2**N)
\end{verbatim}

%% as

を書き直すと、

\begin{verbatim}
J ~= 2**N / 10
\end{verbatim}

となります。
%% and recalling that \var{J} has exactly 53 bits (is \code{>= 2**52} but
%% \code{< 2**53}), the best value for \var{N} is 56:

\var{J} は厳密に 53 ビットの精度を持っている
(\code{>= 2**52} だが \code{< 2**53} ) ことを思い出すと、
\var{N} として最適な値は 56 になります:

\begin{verbatim}
>>> 2**52
4503599627370496L
>>> 2**53
9007199254740992L
>>> 2**56/10
7205759403792793L
\end{verbatim}

%% That is, 56 is the only value for \var{N} that leaves \var{J} with
%% exactly 53 bits.  The best possible value for \var{J} is then that
%% quotient rounded:

すなわち、56 は \var{J} をちょうど 53 ビットの精度のままに保つ
\var{N} の唯一の値です。\var{J} の取りえる値はその商を丸めた
ものです:

\begin{verbatim}
>>> q, r = divmod(2**56, 10)
>>> r
6L
\end{verbatim}

%% Since the remainder is more than half of 10, the best approximation is
%% obtained by rounding up:

残りは 10 の半分以上なので、最良の近似は丸め値を一つ増やした (round up) 
ものになります:


\begin{verbatim}
>>> q+1
7205759403792794L
\end{verbatim}

%% Therefore the best possible approximation to 1/10 in 754 double
%% precision is that over 2**56, or

従って、754 倍精度における 1/10 の取りえる最良の近似は 2**56 以上
の値、もしくは

\begin{verbatim}
7205759403792794 / 72057594037927936
\end{verbatim}

%% Note that since we rounded up, this is actually a little bit larger than
%% 1/10; if we had not rounded up, the quotient would have been a little
%% bit smaller than 1/10.  But in no case can it be \emph{exactly} 1/10!

となります。丸め値を 1 増やしたので、この値は実際には 1/10 より少し小
さいことに注意してください; 丸め値を 1 増やさない場合、商は
1/10 よりもわずかに小さくなります。しかし、どちらにしろ
\emph{厳密に} 1/10 ではありません！

%% So the computer never ``sees'' 1/10:  what it sees is the exact
%% fraction given above, the best 754 double approximation it can get:

つまり、計算機は 1/10 を ``理解する'' ことは決してありません: 
計算機が理解できるのは、上記のような厳密な分数であり、
754 の倍精度浮動小数点数で得られるもっともよい近似は:

\begin{verbatim}
>>> .1 * 2**56
7205759403792794.0
\end{verbatim}

となります。

%% If we multiply that fraction by 10**30, we can see the (truncated)
%% value of its 30 most significant decimal digits:

この分数に 10**30 を掛ければ、 有効数字 30 桁の十進数の 
(切り詰められた) 値を見ることができます:

\begin{verbatim}
>>> 7205759403792794 * 10**30 / 2**56
100000000000000005551115123125L
\end{verbatim}

%% meaning that the exact number stored in the computer is approximately
%% equal to the decimal value 0.100000000000000005551115123125.  Rounding
%% that to 17 significant digits gives the 0.10000000000000001 that Python
%% displays (well, will display on any 754-conforming platform that does
%% best-possible input and output conversions in its C library --- yours may
%% not!).

これは、計算機が記憶している正確な数値が、10 進数値
0.100000000000000005551115123125 にほぼ等しいということです。この値を
有効数字 17 桁で丸めると、Python が表示する値は 0.10000000000000001 に
なります (もちろんこのような値になるのは、 IEEE 754 に適合していて、C
ライブラリで可能な限り正確に値の入出力を行った場合だけです ---
読者の計算機ではそうではないかもしれません！)


\chapter{歴史とライセンス} % History and License
\input{license}

\chapter{日本語訳について}
\input{jptranslation}

\input{glossary}
\input{tut.ind}

\end{document}

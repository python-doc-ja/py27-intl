--- Python-Docs-2.4/./ref/ref5.tex	2004-11-11 15:14:05.000000000 +0900
+++ Python-Docs-2.5/./ref/ref5.tex	2006-06-14 15:29:07.000000000 +0900
@@ -22,9 +22,9 @@
 
 When a description of an arithmetic operator below uses the phrase
 ``the numeric arguments are converted to a common type,'' the
-arguments are coerced using the coercion rules listed at the end of
-chapter \ref{datamodel}.  If both arguments are standard numeric
-types, the following coercions are applied:
+arguments are coerced using the coercion rules listed at
+~\ref{coercion-rules}.  If both arguments are standard numeric types,
+the following coercions are applied:
 
 \begin{itemize}
 \item	If either argument is a complex number, the other is converted
@@ -155,8 +155,7 @@
 
 \begin{productionlist}
   \production{test}
-             {\token{and_test} ( "or" \token{and_test} )*
-              | \token{lambda_form}}
+             {\token{or_test} | \token{lambda_form}}
   \production{testlist}
              {\token{test} ( "," \token{test} )* [ "," ]}
   \production{list_display}
@@ -262,7 +261,7 @@
 dictionary to store the corresponding datum.
 
 Restrictions on the types of the key values are listed earlier in
-section \ref{types}.  (To summarize,the key type should be hashable,
+section \ref{types}.  (To summarize, the key type should be hashable,
 which excludes all mutable objects.)  Clashes between duplicate keys
 are not detected; the last datum (textually rightmost in the display)
 stored for a given key value prevails.
@@ -392,7 +391,8 @@
 
 A slicing selects a range of items in a sequence object (e.g., a
 string, tuple or list).  Slicings may be used as expressions or as
-targets in assignment or del statements.  The syntax for a slicing:
+targets in assignment or \keyword{del} statements.  The syntax for a
+slicing:
 \obindex{sequence}
 \obindex{string}
 \obindex{tuple}
@@ -777,6 +777,13 @@
     * y + x \%{} y} be very close to \code{x}.
 }.
 
+In addition to performing the modulo operation on numbers, the \code{\%}
+operator is also overloaded by string and unicode objects to perform
+string formatting (also known as interpolation). The syntax for string
+formatting is described in the
+\citetitle[../lib/typesseq-strings.html]{Python Library Reference},
+section ``Sequence Types''.
+
 \deprecated{2.3}{The floor division operator, the modulo operator,
 and the \function{divmod()} function are no longer defined for complex
 numbers.  Instead, convert to a floating point number using the
@@ -900,7 +907,10 @@
 the values of two objects.  The objects need not have the same type.
 If both are numbers, they are converted to a common type.  Otherwise,
 objects of different types \emph{always} compare unequal, and are
-ordered consistently but arbitrarily.
+ordered consistently but arbitrarily.  You can control comparison
+behavior of objects of non-builtin types by defining a \code{__cmp__}
+method or rich comparison methods like \code{__gt__}, described in
+section~\ref{specialnames}.
 
 (This unusual definition of comparison was used to simplify the
 definition of operations like sorting and the \keyword{in} and
@@ -945,7 +955,8 @@
   a dictionary for emptiness by comparing it to \code{\{\}}.}
 
 \item
-Most other types compare unequal unless they are the same object;
+Most other objects of builtin types compare unequal unless they are
+the same object;
 the choice whether one object is considered smaller or larger than
 another one is made arbitrarily but consistently within one
 execution of a program.
@@ -960,7 +971,7 @@
 object is a member of a set if the set is a sequence and contains an
 element equal to that object.  However, it is possible for an object
 to support membership tests without being a sequence.  In particular,
-dictionaries support memership testing as a nicer way of spelling
+dictionaries support membership testing as a nicer way of spelling
 \code{\var{key} in \var{dict}}; other mapping types may follow suit.
 
 For the list and tuple types, \code{\var{x} in \var{y}} is true if and
@@ -1010,7 +1021,8 @@
 
 \begin{productionlist}
   \production{expression}
-             {\token{or_test} | \token{lambda_form}}
+             {\token{or_test} [\token{if} \token{or_test} \token{else}
+              \token{test}] | \token{lambda_form}}
   \production{or_test}
              {\token{and_test} | \token{or_test} "or" \token{and_test}}
   \production{and_test}
@@ -1021,14 +1033,19 @@
 
 In the context of Boolean operations, and also when expressions are
 used by control flow statements, the following values are interpreted
-as false: \code{None}, numeric zero of all types, empty sequences
-(strings, tuples and lists), and empty mappings (dictionaries).  All
-other values are interpreted as true.
+as false: \code{False}, \code{None}, numeric zero of all types, and empty
+strings and containers (including strings, tuples, lists, dictionaries,
+sets and frozensets).  All other values are interpreted as true.
 
 The operator \keyword{not} yields \code{True} if its argument is false,
 \code{False} otherwise.
 \opindex{not}
 
+The expression \code{\var{x} if \var{C} else \var{y}} first evaluates
+\var{C} (\emph{not} \var{x}); if \var{C} is true, \var{x} is evaluated and
+its value is returned; otherwise, \var{y} is evaluated and its value is
+returned.  \versionadded{2.5}
+
 The expression \code{\var{x} and \var{y}} first evaluates \var{x}; if
 \var{x} is false, its value is returned; otherwise, \var{y} is
 evaluated and the resulting value is returned.
@@ -1146,7 +1163,7 @@
   \hline
     \lineii{\code{\&}}				{Bitwise AND}
   \hline
-    \lineii{\code{<}\code{<}, \code{>}\code{>}}	{Shifts}
+    \lineii{\code{<<}, \code{>>}}		{Shifts}
   \hline
     \lineii{\code{+}, \code{-}}{Addition and subtraction}
   \hline

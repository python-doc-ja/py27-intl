--- Python-Docs-2.4/./api/utilities.tex	2004-08-11 04:01:50.000000000 +0900
+++ Python-Docs-2.5/./api/utilities.tex	2006-03-01 21:43:53.000000000 +0900
@@ -8,7 +8,7 @@
 
 \section{Operating System Utilities \label{os}}
 
-\begin{cfuncdesc}{int}{Py_FdIsInteractive}{FILE *fp, char *filename}
+\begin{cfuncdesc}{int}{Py_FdIsInteractive}{FILE *fp, const char *filename}
   Return true (nonzero) if the standard I/O file \var{fp} with name
   \var{filename} is deemed interactive.  This is the case for files
   for which \samp{isatty(fileno(\var{fp}))} is true.  If the global
@@ -34,7 +34,7 @@
   Return true when the interpreter runs out of stack space.  This is a
   reliable check, but is only available when \constant{USE_STACKCHECK}
   is defined (currently on Windows using the Microsoft Visual \Cpp{}
-  compiler and on the Macintosh).  \constant{USE_CHECKSTACK} will be
+  compiler).  \constant{USE_STACKCHECK} will be
   defined automatically; you should never change the definition in
   your own code.
 \end{cfuncdesc}
@@ -91,7 +91,7 @@
 
 \section{Importing Modules \label{importing}}
 
-\begin{cfuncdesc}{PyObject*}{PyImport_ImportModule}{char *name}
+\begin{cfuncdesc}{PyObject*}{PyImport_ImportModule}{const char *name}
   This is a simplified interface to
   \cfunction{PyImport_ImportModuleEx()} below, leaving the
   \var{globals} and \var{locals} arguments set to \NULL.  When the
@@ -148,7 +148,7 @@
   case).
 \end{cfuncdesc}
 
-\begin{cfuncdesc}{PyObject*}{PyImport_AddModule}{char *name}
+\begin{cfuncdesc}{PyObject*}{PyImport_AddModule}{const char *name}
   Return the module object corresponding to a module name.  The
   \var{name} argument may be of the form \code{package.module}.
   First check the modules dictionary if there's one there, and if not,
@@ -369,7 +369,7 @@
 \end{cfuncdesc}
 
 \begin{cfuncdesc}{PyObject*}{PyMarshal_ReadObjectFromString}{char *string,
-                                                             int len}
+                                                             Py_ssize_t len}
   Return a Python object from the data stream in a character buffer
   containing \var{len} bytes pointed to by \var{string}.  On error,
   sets the appropriate exception (\exception{EOFError} or
@@ -539,7 +539,7 @@
   Convert a Python integer to a C \ctype{long int}.
 
   \item[\samp{k} (integer) {[unsigned long]}]
-  Convert a Python integer to a C \ctype{unsigned long} without
+  Convert a Python integer or long integer to a C \ctype{unsigned long} without
   overflow checking.  \versionadded{2.3}
 
   \item[\samp{L} (integer) {[PY_LONG_LONG]}]
@@ -548,11 +548,15 @@
   \ctype{_int64} on Windows).
 
   \item[\samp{K} (integer) {[unsigned PY_LONG_LONG]}]
-  Convert a Python integer to a C \ctype{unsigned long long}
+  Convert a Python integer or long integer to a C \ctype{unsigned long long}
   without overflow checking.  This format is only available on
   platforms that support \ctype{unsigned long long} (or
   \ctype{unsigned _int64} on Windows).  \versionadded{2.3}
 
+  \item[\samp{n} (integer) {[Py_ssize_t]}]
+  Convert a Python integer or long integer to a C \ctype{Py_ssize_t}.
+  \versionadded{2.5}
+
   \item[\samp{c} (string of length 1) {[char]}]
   Convert a Python character, represented as a string of length 1, to
   a C \ctype{char}.
@@ -687,21 +691,21 @@
 \cfunction{PyArg_Parse*()} functions return true, otherwise they
 return false and raise an appropriate exception.
 
-\begin{cfuncdesc}{int}{PyArg_ParseTuple}{PyObject *args, char *format,
+\begin{cfuncdesc}{int}{PyArg_ParseTuple}{PyObject *args, const char *format,
                                          \moreargs}
   Parse the parameters of a function that takes only positional
   parameters into local variables.  Returns true on success; on
   failure, it returns false and raises the appropriate exception.
 \end{cfuncdesc}
 
-\begin{cfuncdesc}{int}{PyArg_VaParse}{PyObject *args, char *format,
+\begin{cfuncdesc}{int}{PyArg_VaParse}{PyObject *args, const char *format,
                                          va_list vargs}
   Identical to \cfunction{PyArg_ParseTuple()}, except that it accepts a
   va_list rather than a variable number of arguments.
 \end{cfuncdesc}
 
 \begin{cfuncdesc}{int}{PyArg_ParseTupleAndKeywords}{PyObject *args,
-                       PyObject *kw, char *format, char *keywords[],
+                       PyObject *kw, const char *format, char *keywords[],
                        \moreargs}
   Parse the parameters of a function that takes both positional and
   keyword parameters into local variables.  Returns true on success;
@@ -709,13 +713,13 @@
 \end{cfuncdesc}
 
 \begin{cfuncdesc}{int}{PyArg_VaParseTupleAndKeywords}{PyObject *args,
-                       PyObject *kw, char *format, char *keywords[],
+                       PyObject *kw, const char *format, char *keywords[],
                        va_list vargs}
   Identical to \cfunction{PyArg_ParseTupleAndKeywords()}, except that it
   accepts a va_list rather than a variable number of arguments.
 \end{cfuncdesc}
 
-\begin{cfuncdesc}{int}{PyArg_Parse}{PyObject *args, char *format,
+\begin{cfuncdesc}{int}{PyArg_Parse}{PyObject *args, const char *format,
                                     \moreargs}
   Function used to deconstruct the argument lists of ``old-style''
   functions --- these are functions which use the
@@ -727,8 +731,8 @@
   purpose.
 \end{cfuncdesc}
 
-\begin{cfuncdesc}{int}{PyArg_UnpackTuple}{PyObject *args, char *name,
-                                          int min, int max, \moreargs}
+\begin{cfuncdesc}{int}{PyArg_UnpackTuple}{PyObject *args, const char *name,
+                                          Py_ssize_t min, Py_ssize_t max, \moreargs}
   A simpler form of parameter retrieval which does not use a format
   string to specify the types of the arguments.  Functions which use
   this method to retrieve their parameters should be declared as
@@ -774,7 +778,7 @@
   \versionadded{2.2}
 \end{cfuncdesc}
 
-\begin{cfuncdesc}{PyObject*}{Py_BuildValue}{char *format,
+\begin{cfuncdesc}{PyObject*}{Py_BuildValue}{const char *format,
                                             \moreargs}
   Create a new value based on a format string similar to those
   accepted by the \cfunction{PyArg_Parse*()} family of functions and a
@@ -836,14 +840,40 @@
     Convert a plain C \ctype{int} to a Python integer object.
 
     \item[\samp{b} (integer) {[char]}]
-    Same as \samp{i}.
+    Convert a plain C \ctype{char} to a Python integer object.
 
     \item[\samp{h} (integer) {[short int]}]
-    Same as \samp{i}.
+    Convert a plain C \ctype{short int} to a Python integer object.
 
     \item[\samp{l} (integer) {[long int]}]
     Convert a C \ctype{long int} to a Python integer object.
 
+    \item[\samp{B} (integer) {[unsigned char]}]
+    Convert a C \ctype{unsigned char} to a Python integer object.
+
+    \item[\samp{H} (integer) {[unsigned short int]}]
+    Convert a C \ctype{unsigned short int} to a Python integer object.
+
+    \item[\samp{I} (integer/long) {[unsigned int]}]
+    Convert a C \ctype{unsigned int} to a Python integer object
+    or a Python long integer object, if it is larger than \code{sys.maxint}.
+
+    \item[\samp{k} (integer/long) {[unsigned long]}]
+    Convert a C \ctype{unsigned long} to a Python integer object
+    or a Python long integer object, if it is larger than \code{sys.maxint}.
+
+    \item[\samp{L} (long) {[PY_LONG_LONG]}]
+    Convert a C \ctype{long long} to a Python long integer object. Only
+    available on platforms that support \ctype{long long}.
+
+    \item[\samp{K} (long) {[unsigned PY_LONG_LONG]}]
+    Convert a C \ctype{unsigned long long} to a Python long integer object.
+    Only available on platforms that support \ctype{unsigned long long}.
+
+    \item[\samp{n} (int) {[Py_ssize_t]}]
+    Convert a C \ctype{Py_ssize_t} to a Python integer or long integer.
+    \versionadded{2.5}
+
     \item[\samp{c} (string of length 1) {[char]}]
     Convert a C \ctype{int} representing a character to a Python
     string of length 1.

\chapter{例外処理 \label{exceptionHandling}}

この章で説明する関数を使うと、Pythonの例外の処理や送出ができるように
なります。Pythonの例外処理の基本をいくらか理解することが大切です。
例外は\UNIX{} \cdata{errno}変数にやや似た機能を果たします: 発生した
中で最も新しいエラーの(スレッド毎の)グローバルなインジケータがあります。
実行に成功した場合にはほとんどの関数がこれをクリアしませんが、失敗したときには
エラーの原因を示すために設定します。ほとんどの関数はエラーインジケータも
返し、通常は関数がポインタを返すことになっている場合は\NULL{}であり、
関数が整数を返す場合は\code{-1}です。(例外: \cfunction{PyArg_*()}関数は
実行に成功したときに\code{1}を返し、失敗したときに\code{0}を返します).

ある関数が呼び出した関数がいくつか失敗したために、その関数が失敗しなければ
ならないとき、一般的にエラーインジケータを設定しません。呼び出した関数が
すでに設定しています。エラーを処理して例外をクリアするか、あるいは
(オブジェクト参照またはメモリ割り当てのような)それが持つどんなリソースも
取り除いた後に戻るかのどちらか一方を行う責任があります。エラーを処理する
準備をしていなければ、普通に続けるべきでは\emph{ありません}。エラーのために
戻る場合は、エラーが設定されていると呼び出し元に知らせることが大切です。
エラーが処理されていない場合または丁寧に伝えられている場合には、
Python/C APIのさらなる呼び出しは意図した通りには動かない可能性があり、
不可解な形で失敗するかもしれません。

エラーインジケータは\withsubitem{(in module sys)}{
  \ttindex{exc_type}\ttindex{exc_value}\ttindex{exc_traceback}}
Python変数\code{sys.exc_type}, \code{sys.exc_value} および
\code{sys.exc_traceback}に対応する三つのPythonオブジェクトからからなります。
いろいろな方法でエラーインジケータとやりとりするためにAPI関数が存在します。
各スレッドに別々のエラーインジケータがあります。

% XXX Order of these should be more thoughtful.
% Either alphabetical or some kind of structure.

\begin{cfuncdesc}{void}{PyErr_Print}{}
  \code{sys.stderr}へ標準トレースバックをプリントし、エラーインジケータを
  クリアします。エラーインジケータが設定されているときにだけ、この関数を
  呼び出してください。(それ以外の場合、致命的なエラーを引き起こすでしょう!)
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_Occurred}{}
  エラーインジケータが設定されているかテストします。設定されている場合は、
  例外の\emph{型}(\cfunction{PyErr_Set*()}関数の一つあるいは
  \cfunction{PyErr_Restore()}への最も新しい呼び出しに対する第一引数)を返します。
  設定されていない場合は\NULL を返します。あなたは戻り値への参照を持っていませんので、
  それに\cfunction{Py_DECREF()}する必要はありません。\note{戻り値を特定の例外と
  比較しないでください。その代わり、下に示す\cfunction{PyErr_ExceptionMatches()}を
  使ってください。(比較は簡単に失敗するでしょう。なぜなら、例外はクラスではなく
  インスタンスかもしれないし、あるいは、クラス例外の場合は期待される例外の
  サブクラスかもしれないからです。)}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_ExceptionMatches}{PyObject *exc}
  \samp{PyErr_GivenExceptionMatches(PyErr_Occurred(), \var{exc})}と同じ。
  例外が実際に設定されたときにだけ、これを呼び出だすべきです。例外が発生
  していないならば、メモリアクセス違反が起きるでしょう。
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_GivenExceptionMatches}{PyObject *given, PyObject *exc}
  \var{given}例外が\var{exc}の例外と一致するなら真を返します。これは\var{exc}が
  クラスオブジェクトである場合も真を返します。これは\var{given}がサブクラスの
  インスタンスであるときも真を返します。\var{exc}がタプルならば、タプル内
  (と再帰的にサブタプル内)のすべての例外が一致するか調べられます。
  \var{given}が\NULL ならば、メモリアクセス違反が起きるでしょう。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_NormalizeException}{PyObject**exc, PyObject**val, PyObject**tb}
  ある状況では、以下の\cfunction{PyErr_Fetch()}が返す値は
  ``正規化されていない''可能性があります。つまり、\code{*\var{exc}}は
  クラスオブジェクトだが\code{*\var{val}}は同じクラスのインスタンスでは
  ないという意味です。この関数はそのような場合にそのクラスをインスタンス化
  するために使われます。その値がすでに正規化されている場合は何も起きません。
  遅延正規化はパフォーマンスを改善するために実装されています。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_Clear}{}
  エラーインジケータをクリアします。エラーインジケータが設定されていないならば、
  効果はありません。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_Fetch}{PyObject **ptype, PyObject **pvalue,
                                     PyObject **ptraceback}
  エラーインジケータをアドレスを渡す三つの変数の中へ取り出します。
  エラーインジケータが設定されていない場合は、三つすべての変数を\NULL に
  設定します。エラーインジケータが設定されている場合はクリアされ、
  あなたは取り出されたそれぞれのオブジェクトへの参照を持つことになります。
  型オブジェクトが\NULL{}でないときでさえ、その値とトレースバックオブジェクトは
  \NULL{}かもしれません。\note{通常、この関数は例外を扱う必要のあるコード
  あるいはエラーインジケータを一時的に保存して元に戻す必要のあるコードに
  よってのみ使用されます。}
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_Restore}{PyObject *type, PyObject *value,
                                       PyObject *traceback}
  三つのオブジェクトからエラーインジケータを設定します。エラーインジケータが
  すでに設定されている場合は、最初にクリアされます。オブジェクトが\NULL ならば、
  エラーインジケータがクリアされます。\NULL{}のtypeと非\NULL{}のvalueあるいは
  tracebackを渡してはいけません。例外の型(type)はクラスであるべきです。
  無効な例外の型(type)あるいは値(value)を渡してはいけません。
  (これらの規則を破ると後で気付きにくい問題の原因となるでしょう。)
  この呼び出しはそれぞれのオブジェクトへの参照を取り除きます: あなたは
  呼び出しの前にそれぞれのオブジェクトへの参照を持たなければならないのであり、
  また呼び出しの後にはもはやこれらの参照を持っていません。
  (これを理解していない場合は、この関数を使ってはいけません。注意しておきます。)
  \note{通常この関数はエラーインジケータを一時的に保存し元に戻す必要のある
  コードによってのみに使われます。現在の例外状態を保存するためには
  \cfunction{PyErr_Fetch()}を使ってください。}
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetString}{PyObject *type, const char *message}
  これはエラーインジケータを設定するための最も一般的な方法です。第一引数は
  例外の型を指定します。通常は標準例外の一つ、例えば\cdata{PyExc_RuntimeError}です。
  その参照カウントを増加させる必要はありません。第二引数はエラーメッセージで、
  文字列オブジェクトへ変換されます。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetObject}{PyObject *type, PyObject *value}
  この関数は\cfunction{PyErr_SetString()}に似ていますが、
  例外の``値(value)''として任意のPythonオブジェクトを指定することができます。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_Format}{PyObject *exception,
                                           const char *format, \moreargs}
  この関数はエラーインジケータを設定し\NULL を返します。
  \var{exception}はPython例外(インスタンスではなくクラス)であるべきです。
  \var{format}は文字列であるべきであり、\cfunction{printf()}に似た
  書式化コードを含んでいます。書式化コードの前の\code{幅.精度(width.precision)}は
  解析されますが、幅の部分は無視されます。

%  \begin{tableii}{c|l}{character}{文字}{意味}
%    \lineii{c}{文字、\ctype{int}引数として}
%    \lineii{d}{10進数、\ctype{int}引数として}
%    \lineii{x}{16進数、\ctype{int}引数として}
%    \lineii{s}{文字列、\ctype{char *}引数として}
%    \lineii{p}{16進法のポインタ、\ctype{void *}引数として}
%  \end{tableii}
  % This should be exactly the same as the table in PyString_FromFormat.
  % One should just refer to the other.

  % The descriptions for %zd and %zu are wrong, but the truth is complicated
  % because not all compilers support the %z width modifier -- we fake it
  % when necessary via interpolating PY_FORMAT_SIZE_T.

  % %u, %lu, %zu should have "new in Python 2.5" blurbs.

  \begin{tableiii}{l|l|l}{member}{書式文字}{型}{コメント}
    \lineiii{\%\%}{\emph{n/a}}{リテラルの \% 文字。}
    \lineiii{\%c}{int}{一文字. Cのintで表現される。}
    \lineiii{\%d}{int}{\code{printf("\%d")} と完全に同じ。}
    \lineiii{\%u}{unsigned int}{\code{printf("\%u")} と完全に同じ。}
    \lineiii{\%ld}{long}{\code{printf("\%ld")} と完全に同じ。}
    \lineiii{\%lu}{unsigned long}{\code{printf("\%lu")} と完全に同じ。}
    \lineiii{\%zd}{Py_ssize_t}{\code{printf("\%zd")} と完全に同じ。}
    \lineiii{\%zu}{size_t}{\code{printf("\%zu")} と完全に同じ.}
    \lineiii{\%i}{int}{\code{printf("\%i")} と完全に同じ。}
    \lineiii{\%x}{int}{\code{printf("\%x")} と完全に同じ。}
    \lineiii{\%s}{char*}{NULL終端の C の文字配列。}
    \lineiii{\%p}{void*}{C ポインタの16進表現。
        プラットフォームのprintfによらず、必ずリテラル \code{0x} が頭につくことが保証される
        という以外、\code{printf("\%p")}とほぼ同じ。}
  \end{tableiii}

  認識できない書式化文字があると書式化文字列の残りすべてがそのまま
  結果の文字列へコピーされ、余分の引数はどれも捨てられます。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetNone}{PyObject *type}
  これは\samp{PyErr_SetObject(\var{type}, Py_None)}を省略したものです。
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_BadArgument}{}
  これは\samp{PyErr_SetString(PyExc_TypeError, \var{message})}を省略したもので、
  ここで\var{message}は組み込み操作が不正な引数で呼び出されたということを表しています。
  主に内部で使用するためのものです。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_NoMemory}{}
  これは\samp{PyErr_SetNone(PyExc_MemoryError)}を省略したもので、
  \NULL{}を返します。したがって、メモリ不足になったとき、
  オブジェクト割り当て関数は\samp{return PyErr_NoMemory();}と
  書くことができます。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_SetFromErrno}{PyObject *type}
  Cライブラリ関数がエラーを返してC変数\cdata{errno}を設定したときに、
  これは例外を発生させるために便利な関数です。第一要素が
  整数\cdata{errno}値で、第二要素が
  (\cfunction{strerror()}\ttindex{strerror()}から得られる)対応する
  エラーメッセージであるタプルオブジェクトを構成します。それから、
  \samp{PyErr_SetObject(\var{type}, \var{object})}を呼び出します。
  \UNIX では、\cdata{errno}値が\constant{EINTR}であるとき、すなわち
  割り込まれたシステムコールを表しているとき、これは
  \cfunction{PyErr_CheckSignals()}を呼び出し、それがエラーインジケータを
  設定した場合は設定されたままにしておきます。関数は常に\NULL を返します。
  したがって、システムコールがエラーを返したとき、システムコールの
  ラッパー関数は\samp{return PyErr_SetFromErrno(\var{type});}と
  書くことができます。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_SetFromErrnoWithFilename}{PyObject *type,
                                                             const char *filename}
  \cfunction{PyErr_SetFromErrno()}に似ていて、\var{filename}が\NULL でない場合に、
  それが\var{type}のコンストラクタに第三引数として渡されるというふるまいが追加
  されています。\exception{IOError}と\exception{OSError}のような例外の場合では、
  これが例外インスタンスの\member{filename}属性を定義するために使われます。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_SetFromWindowsErr}{int ierr}
  これは\exception{WindowsError}を発生させるために便利な関数です。
  \cdata{0}の\var{ierr}とともに呼び出された場合、\cfunction{GetLastError()}が
  返すエラーコードが代りに使われます。\var{ierr}あるいは
  \cfunction{GetLastError()}によって与えられるエラーコードのWindows用の説明を
  取り出すために、Win32関数\cfunction{FormatMessage()}を呼び出します。それから、
  第一要素が\var{ierr}値で第二要素が(\cfunction{FormatMessage()}から得られる)
  対応するエラーメッセージであるタプルオブジェクトを構成します。そして、
  \samp{PyErr_SetObject(\var{PyExc_WindowsError}, \var{object})}を呼び出します。
  この関数は常に\NULL を返します。
  利用可能範囲: Windows。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_SetExcFromWindowsErr}{PyObject *type,
	                                                 int ierr}
  \cfunction{PyErr_SetFromWindowsErr()}に似ていて、送出する例外の型を
  指定する引数が追加されています。
  利用可能範囲: Windows。
  \versionadded{2.3}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_SetFromWindowsErrWithFilename}{int ierr,
                                                                const char *filename}
  \cfunction{PyErr_SetFromWindowsErr()}に似ていて、\var{filename}が\NULL でない場合には
  \exception{WindowsError}のコンストラクタへ第三引数として渡されるという振る舞いが
  追加されています。
  利用可能範囲: Windows。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_SetExcFromWindowsErrWithFilename}
	{PyObject *type, int ierr, char *filename}
  \cfunction{PyErr_SetFromWindowsErrWithFilename()}に似ていて、
  発生させる例外の型を指定する引数が追加されています。
  利用可能範囲: Windows。
  \versionadded{2.3}
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_BadInternalCall}{}
  \samp{PyErr_SetString(PyExc_TypeError, \var{message})}を省略したものです。
  ここで\var{message}は内部操作(例えば、Python/C API関数)が不正な引数と
  ともに呼び出されたということを示しています。主に内部で使用するためのもの
  です。
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_WarnEx}{PyObject *category, char *message, int stacklevel}
  警告メッセージを出します。\var{category}引数は警告カテゴリ(以下を参照)
  かまたは\NULL で、\var{message}引数はメッセージ文字列です。\var{stacklevel}は
  フレームの数を示す正の整数です; 警告はそのスタックフレームの中の実行している行から
  発行されます。\var{stacklevel}が1だと、 \cfunction{PyErr_WarnEx()} が、2だと
  その上の関数が、Warningの発行元になります。

  この関数は通常警告メッセージを\var{sys.stderr}へプリントします。
  けれども、ユーザが警告をエラーへ変更するように指定することも可能です。
  そのような場合には、これは例外を発生させます。警告機構がもつ問題のために
  その関数が例外を発生させるということも可能です。(実装ではその厄介な仕事を
  行うために\module{warnings}モジュールをインポートします)。
  例外が発生させられなければ、戻り値は\code{0}です。あるいは、例外が発生させ
  られると\code{-1}です。(警告メッセージが実際にプリントされるかどうかを決定
  することはできず、また何がその例外の原因なのかを決定することもできない。
  これは意図的なものです。)例外が発生した場合、呼び出し元は通常の例外処理を
  行います(例えば、\cfunction{Py_DECREF()}は参照を持っており、エラー値を
  返します)。

  警告カテゴリは\cdata{Warning}のサブクラスでなければならない。
  デフォルト警告カテゴリは\cdata{RuntimeWarning}です。
  標準Python警告カテゴリは\samp{PyExc_}にPython例外名が続く名前の
  グローバル変数を用いて変更できます。これらは型\ctype{PyObject*}を
  持ち、すべてクラスオブジェクトです。それらの名前は
  \cdata{PyExc_Warning}, \cdata{PyExc_UserWarning},
  \cdata{PyExc_UnicodeWarning}, \cdata{PyExc_DeprecationWarning},
  \cdata{PyExc_SyntaxWarning}, \cdata{PyExc_RuntimeWarning},
  \cdata{PyExc_FutureWarning} です。
  \cdata{PyExc_Warning}は\cdata{PyExc_Exception}のサブクラスです。
  その他の警告カテゴリは\cdata{PyExc_Warning}のサブクラスです。

  警告をコントロールするための情報については、\module{warnings}モジュールの
  ドキュメンテーションとコマンドライン・ドキュメンテーションの
  \programopt{-W}オプションを参照してください。
  警告コントロールのためのC APIはありません。
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_Warn}{PyObject *category, char *message}
  警告メッセージを出します。\var{category}引数は警告カテゴリ(以下を参照)
  かまたは\NULL で、\var{message}引数はメッセージ文字列です。
  警告は 、 \cfunction{PyErr_WarnEx()} を \var{stacklevel} に 1 を指定した時と同じく、
  \cfunction{PyErr_Warn()} を呼び出した関数から発行されます。

  非推奨; \cfunction{PyErr_WarnEx()} を使って下さい。
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_WarnExplicit}{PyObject *category,
                const char *message, const char *filename, int lineno,
                const char *module, PyObject *registry}
  すべての警告の属性を明示的に制御した警告メッセージを出します。
  これはPython関数\function{warnings.warn_explicit()}の直接的なラッパで、
  さらに情報を得るにはそちらを参照してください。そこに説明されているデフォルトの
  効果を得るために、\var{module}と\var{registry}引数は\NULL{}に設定することができます。
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_CheckSignals}{}
  この関数はPythonのシグナル処理とやりとりすることができます。
  シグナルがそのプロセスへ送られたかどうかチェックし、そうならば対応する
  シグナルハンドラを呼び出します。
  \module{signal}\refbimodindex{signal}モジュールがサポートされている場合は、
  これはPythonで書かれたシグナルハンドラを呼び出せます。すべての場合で、
  \constant{SIGINT}\ttindex{SIGINT}のデフォルトの効果は
  \withsubitem{(built-in exception)}{\ttindex{KeyboardInterrupt}}
  \exception{KeyboardInterrupt}例外を発生させることです。例外が発生した場合、
  エラーインジケータが設定され、関数は\code{1}を返します。
  そうでなければ、関数は\code{0}を返します。エラーインジケータが以前に
  設定されている場合は、それがクリアされるかどうかわからない。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetInterrupt}{}
  この関数は廃止されています。\constant{SIGINT}\ttindex{SIGINT}シグナルが
  到達した影響をシミュレートします --- 次に
  \cfunction{PyErr_CheckSignals()}が呼ばれるとき、
  \withsubitem{(built-in exception)}{\ttindex{KeyboardInterrupt}}
  \exception{KeyboardInterrupt}は送出されるでしょう。インタプリタロックを
  保持することなく呼び出すことができます。
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyErr_NewException}{char *name,
                                                 PyObject *base,
                                                 PyObject *dict}
  このユーティリティ関数は新しい例外オブジェクトを作成して返します。
  \var{name}引数は新しい例外の名前、\code{module.class}形式の
  C文字列でなければならない。
  \var{base}と\var{dict}引数は通常\NULL です。
  これはすべての例外のためのルート、組み込み名\exception{Exception}
  (Cでは\cdata{PyExc_Exception}としてアクセス可能)を根として
  導出されたクラスオブジェクトを作成します。

  新しいクラスの\member{__module__}属性は\var{name}引数の前半部分(最後のドットまで)に
  設定され、クラス名は後半部分(最後のドットの後)に設定されます。
  \var{base}引数は代わりのベースクラスを指定するために使えます; 一つのクラスでも、
  クラスのタプルでも構いません。
  \var{dict}引数はクラス変数とメソッドの辞書を指定するために使えます。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_WriteUnraisable}{PyObject *obj}
  例外が設定されているがインタプリタが実際に例外を発生させることができないときに、
  このユーティリティ関数は警告メッセージを\code{sys.stderr}へプリントします。
  例えば、例外が\method{__del__()}メソッドで発生したときに使われます。

  発生させられない例外が生じたコンテキストを特定するための一つの引数\var{obj}とともに
  関数が呼び出されます。\var{obj}のreprが警告メッセージにプリントされるでしょう。
\end{cfuncdesc}

\section{標準例外 \label{standardExceptions}}

\samp{PyExc_}の後ろにPythonの例外名が続く名前をもつグローバル変数として、
すべての標準Python例外が利用可能です。これらは型\ctype{PyObject*}を
持ち、すべてクラスオブジェクトです。完璧を期するために、すべての変数を
以下に列挙します:

\begin{tableiii}{l|l|c}{cdata}{C名}{Python名}{注記}
  \lineiii{PyExc_BaseException\ttindex{PyExc_BaseException}}{\exception{BaseException}}{(1), (4)}
  \lineiii{PyExc_Exception\ttindex{PyExc_Exception}}{\exception{Exception}}{(1)}
  \lineiii{PyExc_StandardError\ttindex{PyExc_StandardError}}{\exception{StandardError}}{(1)}
  \lineiii{PyExc_ArithmeticError\ttindex{PyExc_ArithmeticError}}{\exception{ArithmeticError}}{(1)}
  \lineiii{PyExc_LookupError\ttindex{PyExc_LookupError}}{\exception{LookupError}}{(1)}
  \lineiii{PyExc_AssertionError\ttindex{PyExc_AssertionError}}{\exception{AssertionError}}{}
  \lineiii{PyExc_AttributeError\ttindex{PyExc_AttributeError}}{\exception{AttributeError}}{}
  \lineiii{PyExc_EOFError\ttindex{PyExc_EOFError}}{\exception{EOFError}}{}
  \lineiii{PyExc_EnvironmentError\ttindex{PyExc_EnvironmentError}}{\exception{EnvironmentError}}{(1)}
  \lineiii{PyExc_FloatingPointError\ttindex{PyExc_FloatingPointError}}{\exception{FloatingPointError}}{}
  \lineiii{PyExc_IOError\ttindex{PyExc_IOError}}{\exception{IOError}}{}
  \lineiii{PyExc_ImportError\ttindex{PyExc_ImportError}}{\exception{ImportError}}{}
  \lineiii{PyExc_IndexError\ttindex{PyExc_IndexError}}{\exception{IndexError}}{}
  \lineiii{PyExc_KeyError\ttindex{PyExc_KeyError}}{\exception{KeyError}}{}
  \lineiii{PyExc_KeyboardInterrupt\ttindex{PyExc_KeyboardInterrupt}}{\exception{KeyboardInterrupt}}{}
  \lineiii{PyExc_MemoryError\ttindex{PyExc_MemoryError}}{\exception{MemoryError}}{}
  \lineiii{PyExc_NameError\ttindex{PyExc_NameError}}{\exception{NameError}}{}
  \lineiii{PyExc_NotImplementedError\ttindex{PyExc_NotImplementedError}}{\exception{NotImplementedError}}{}
  \lineiii{PyExc_OSError\ttindex{PyExc_OSError}}{\exception{OSError}}{}
  \lineiii{PyExc_OverflowError\ttindex{PyExc_OverflowError}}{\exception{OverflowError}}{}
  \lineiii{PyExc_ReferenceError\ttindex{PyExc_ReferenceError}}{\exception{ReferenceError}}{(2)}
  \lineiii{PyExc_RuntimeError\ttindex{PyExc_RuntimeError}}{\exception{RuntimeError}}{}
  \lineiii{PyExc_SyntaxError\ttindex{PyExc_SyntaxError}}{\exception{SyntaxError}}{}
  \lineiii{PyExc_SystemError\ttindex{PyExc_SystemError}}{\exception{SystemError}}{}
  \lineiii{PyExc_SystemExit\ttindex{PyExc_SystemExit}}{\exception{SystemExit}}{}
  \lineiii{PyExc_TypeError\ttindex{PyExc_TypeError}}{\exception{TypeError}}{}
  \lineiii{PyExc_ValueError\ttindex{PyExc_ValueError}}{\exception{ValueError}}{}
  \lineiii{PyExc_WindowsError\ttindex{PyExc_WindowsError}}{\exception{WindowsError}}{(3)}
  \lineiii{PyExc_ZeroDivisionError\ttindex{PyExc_ZeroDivisionError}}{\exception{ZeroDivisionError}}{}
\end{tableiii}

\noindent
注記:
\begin{description}
\item[(1)]
  これは別の標準例外のためのベースクラスです。

\item[(2)]
  これは\exception{weakref.ReferenceError}と同じです。

\item[(3)]
  Windowsでのみ定義されています。
  プリプロセッサマクロ\code{MS_WINDOWS}が定義されているかテストすることで、
  これを使うコードを保護してください。

\item[(4)]
  \versionadded{2.5}
\end{description}


\section{文字列例外の廃止}

Pythonへ組み込まれるすべての例外あるいは標準ライブラリに提供されている例外は、
\exception{BaseException}から導出されています。
\withsubitem{(built-in exception)}{\ttindex{BaseException}}

インタプリタで既存のコードが変更なしで動作するように、文字列例外は今でも
サポートされています。しかし、これも将来のリリースで変更されるでしょう。

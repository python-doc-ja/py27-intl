\section{\module{readline} ---
         GNU readline のインタフェース}

\declaremodule{builtin}{readline}
  \platform{Unix}
\sectionauthor{Skip Montanaro}{skip@mojam.com}
\modulesynopsis{Python のための GNU readline サポート。}


\module{readline} モジュールでは、補完をしやすくしたり、
ヒストリファイルを Python インタプリタから読み書きできるように
するためのいくつかの関数を定義しています。
このモジュールは直接使うことも \refmodule{rlcompleter} モジュールを介して使うこともできます。
このモジュールで利用される設定はインタプリタの対話プロンプトの振舞い、
組み込みの\function{raw_input()}と\function{input()}関数の振舞いに影響します。

\module{readline} モジュールでは以下の関数を定義しています:


\begin{funcdesc}{parse_and_bind}{string}
readline 初期化ファイルの行を一行解釈して実行します。
\end{funcdesc}

\begin{funcdesc}{get_line_buffer}{}
行編集バッファの現在の内容を返します。
\end{funcdesc}

\begin{funcdesc}{insert_text}{string}
コマンドラインにテキストを挿入します。
\end{funcdesc}

\begin{funcdesc}{read_init_file}{\optional{filename}}
readline 初期化ファイルを解釈します。
標準のファイル名設定は最後に使われたファイル名です。
\end{funcdesc}

\begin{funcdesc}{read_history_file}{\optional{filename}}
readline ヒストリファイルを読み出します。
標準のファイル名設定は \file{\~{}/.history} です。
\end{funcdesc}

\begin{funcdesc}{write_history_file}{\optional{filename}}
readline ヒストリファイルを保存します。
標準のファイル名設定は \file{\~{}/.history} です。
\end{funcdesc}

\begin{funcdesc}{clear_history}{}
現在のヒストリをクリアします。 (注意:インストールされている GNU readline
がサポートしていない場合、この関数は利用できません)
\versionadded{2.4}
\end{funcdesc}

\begin{funcdesc}{get_history_length}{}
ヒストリファイルに必要な長さを返します。負の値はヒストリファイル
のサイズに制限がないことを示します。
\end{funcdesc}

\begin{funcdesc}{set_history_length}{length}
ヒストリファイルに必要な長さを設定します。この値は
\function{write_history_file()} がヒストリを保存する際にファイルを
切り詰めるために使います。負の値はヒストリファイルのサイズを制限
しないことを示します。
\end{funcdesc}

\begin{funcdesc}{get_current_history_length}{}
現在のヒストリ行数を返します(この値は\function{get_history_length()}で取
得する異なります。\function{get_history_length()}はヒストリファイルに書
き出される最大行数を返します)。\versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{get_history_item}{index}
現在のヒストリから、\var{index} 番目の項目を返します。
\versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{remove_history_item}{pos}
ヒストリから指定した位置にあるヒストリを削除します。
\versionadded{2.4}
\end{funcdesc}

\begin{funcdesc}{replace_history_item}{pos, line}
指定した位置にあるヒストリを、指定した line で置き換えます。
\versionadded{2.4}
\end{funcdesc}

\begin{funcdesc}{redisplay}{}
画面の表示を、現在のヒストリ内容によって更新します。
\versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{set_startup_hook}{\optional{function}}
startup_hook 関数を設定または除去します。\var{function} が指定されて
いれば、新たな startup_hook 関数として用いられます; 
省略されるか \code{None} になっていれば、現在インストール
されているフック関数は除去されます。
startup_hook 関数は readline が最初のプロンプトを出力する
直前に引数なしで呼び出されます。
\end{funcdesc}

\begin{funcdesc}{set_pre_input_hook}{\optional{function}}
pre_input_hook 関数を設定または除去します。\var{function} が指定されて
いれば、新たな pre_input_hook 関数として用いられます; 
省略されるか \code{None} になっていれば、現在インストール
されているフック関数は除去されます。
pre_input_hook 関数は readline が最初のプロンプトを出力した
後で、かつ readline が入力された文字を読み込み始める直前に
引数なしで呼び出されます。
\end{funcdesc}

\begin{funcdesc}{set_completer}{\optional{function}}
completer 関数を設定または除去します。\var{function} が指定されて
いれば、新たな completer 関数として用いられます; 
省略されるか \code{None} になっていれば、現在インストール
されている completer 関数は除去されます。
completer 関数は \code{\var{function}(\var{text}, \var{state})}
の形式で、関数が文字列でない値を返すまで \var{state} を
\code{0}, \code{1}, \code{2}, ..., にして呼び出します。
この関数は \var{text} から始まる文字列の補完結果として可能性の
あるものを返さなくてはなりません。
\end{funcdesc}

\begin{funcdesc}{get_completer}{}
completer 関数を取得します。completer 関数が設定されていなければ
\code{None}を返します。\versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{get_begidx}{}
readline タブ補完スコープの先頭のインデクスを取得します。
\end{funcdesc}

\begin{funcdesc}{get_endidx}{}
readline タブ補完スコープの末尾のインデクスを取得します。
\end{funcdesc}

\begin{funcdesc}{set_completer_delims}{string}
タブ補完のための readline 単語区切り文字を設定します。
\end{funcdesc}

\begin{funcdesc}{get_completer_delims}{}
タブ補完のための readline 単語区切り文字を取得します。
\end{funcdesc}

\begin{funcdesc}{add_history}{line}
1 行をヒストリバッファに追加し、最後に打ち込まれた行のようにします。
\end{funcdesc}


\begin{seealso}
  \seemodule{rlcompleter}{対話的プロンプトで Python 識別子を補完する機能。}
\end{seealso}


\subsection{例 \label{readline-example}}

以下の例では、ユーザのホームディレクトリにある \file{.pyhist} という
名前のヒストリファイルを自動的に読み書きするために、\module{readline}
モジュールによるヒストリの読み書き関数をどのように使うかを例示しています。
以下のソースコードは通常、対話セッションの中で \envvar{PYTHONSTARTUP}
ファイルから読み込まれ自動的に実行されることになります。

\begin{verbatim}
import os
histfile = os.path.join(os.environ["HOME"], ".pyhist")
try:
    readline.read_history_file(histfile)
except IOError:
    pass
import atexit
atexit.register(readline.write_history_file, histfile)
del os, histfile
\end{verbatim}

次の例では \class{code.InteractiveConsole} クラスを拡張し、ヒストリの保
存・復旧をサポートします。

\begin{verbatim}
import code
import readline
import atexit
import os

class HistoryConsole(code.InteractiveConsole):
    def __init__(self, locals=None, filename="<console>",
                 histfile=os.path.expanduser("~/.console-history")):
        code.InteractiveConsole.__init__(self)
        self.init_history(histfile)

    def init_history(self, histfile):
        readline.parse_and_bind("tab: complete")
        if hasattr(readline, "read_history_file"):
            try:
                readline.read_history_file(histfile)
            except IOError:
                pass
            atexit.register(self.save_history, histfile)

    def save_history(self, histfile):
        readline.write_history_file(histfile)
\end{verbatim}

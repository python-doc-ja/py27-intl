\section{\module{subprocess} --- サブプロセス管理}

\declaremodule{standard}{subprocess}
\modulesynopsis{サブプロセス管理}
\moduleauthor{Peter \AA strand}{astrand@lysator.liu.se}
\sectionauthor{Peter \AA strand}{astrand@lysator.liu.se}

\versionadded{2.4}

\module{subprocess} モジュールは、新しくプロセスを開始したり、
それらの標準入出力/エラー出力に対してパイプで接続したり、
それらの終了ステータスを取得したりします。このモジュールは以下のような
古いいくつかのモジュールを置き換えることを目的としています:

% XXX このモジュールに popen2 とそのコマンド・セクションの
% ポインタを追加すること。

\begin{verbatim}
os.system
os.spawn*
os.popen*
popen2.*
commands.*
\end{verbatim}

これらのモジュールや関数の代わりに、\module{subprocess} モジュールを
どのように使うかについては以下の節で説明します。

\subsection{subprocess モジュールを使う}

このモジュールでは \class{Popen} と呼ばれるクラスを定義しています:

\begin{classdesc}{Popen}{args, bufsize=0, executable=None,
            stdin=None, stdout=None, stderr=None,
            preexec_fn=None, close_fds=False, shell=False,
            cwd=None, env=None, universal_newlines=False,
            startupinfo=None, creationflags=0}

各引数の説明は以下のとおりです:

\var{args} は文字列か、あるいはプログラムへの引数のシーケンスである
必要があります。実行するプログラムは通常 args シーケンスあるいは文字列の
最初の要素ですが、executable 引数を使うことにより明示的に指定することもできます。

\UNIX{} で \var{shell=False} の場合 (デフォルト): この場合、
Popen クラスは子プログラムを実行するのに \method{os.execvp()} を使います。
\var{args} は通常シーケンスでなければなりません。文字列の場合は
ひとつだけの文字列要素 (= 実行するプログラム名) をもったシーケンスとして
扱われます。

\UNIX{} で \var{shell=True} の場合: args が文字列の場合、これは
シェルを介して実行されるコマンドライン文字列を指定します。\var{args} が
シーケンスの場合、その最初の要素はコマンドライン文字列となり、
それ以降の要素はすべてシェルへの追加の引数として扱われます。

Windows の場合: \class{Popen} クラスは子プログラムを実行するのに
文字列の扱える CreateProcess() を使います。\var{args} が
シーケンスの場合、これは \method{list2cmdline} メソッドをつかって
コマンドライン文字列に変換されます。注意: すべての MS Windows
アプリケーションがコマンドライン引数を同じやりかたで
解釈するとは限りません。\method{list2cmdline} は MS C ランタイムと
同じやりかたで文字列を解釈するアプリケーション用に設計されています。

\var{bufsize} は、もしこれが与えられた場合、ビルトインの
open() 関数の該当する引数と同じ意味をもちます: \constant{0} はバッファされないことを意味し、
\constant{1} は行ごとにバッファされることを、それ以外の正の値は
(ほぼ) その大きさのバッファが使われることを意味します。
負の \var{bufsize} はシステムのデフォルト値が使われることを意味し、
通常これはバッファがすべて有効となります。\var{bufsize} のデフォルト値は
\constant{0} (バッファされない) です。

\var{executable} 引数には実行するプログラムを指定します。
これはほとんど必要ありません: ふつう、実行するプログラムは
\var{args} 引数で指定されるからです。\code{shell=True} の場合、 \var{executable}
引数は使用するシェルを指定します。 \UNIX{} では、デフォルトのシェルは
\file{/bin/sh} です。Windows では、デフォルトのシェルは
\envvar{COMSPEC} 環境変数で指定されます。

\var{stdin}、 \var{stdout} および \var{stderr} には、
実行するプログラムの標準入力、標準出力、および標準エラー出力の
ファイルハンドルをそれぞれ指定します。とりうる値は
\code{PIPE} 、既存のファイル記述子 (正の整数) 、
既存のファイルオブジェクト、そして \code{None} です。
\code{PIPE} を指定すると新しいパイプが子プロセスに向けて作られます。
\code{None} を指定するとリダイレクトは起こりません。子プロセスの
ファイルハンドルはすべて親から受け継がれます。
加えて、\var{stderr} を \code{STDOUT} にすると、アプリケーションの
stderr からの出力は stdout と同じファイルハンドルに出力されます。

\var{preexec_fn} に callable オブジェクトが指定されている場合、
このオブジェクトは子プロセスが起動されてから、プログラムが
exec される直前に呼ばれます。(\UNIX のみ)

\var{close_fds} が真の場合、子プロセスが実行される前に
\constant{0}、 \constant{1} および \constant{2} をのぞくすべてのファイル記述子が
閉じられます。(\UNIX のみ)

\var{shell} が \constant{True} の場合、
指定されたコマンドはシェルを介して実行されます。

\var{cwd} が \code{None} 以外の場合、子プロセスの
カレントディレクトリが実行される前に \var{cwd} に変更されます。
このディレクトリは実行ファイルを探す段階では考慮されませんので、
プログラムのパスを \var{cwd} に対する相対パスで指定することはできない、
ということに注意してください。

\var{env} が \code{None} 以外の場合、これは新しいプロセスでの
環境変数を定義します。

\var{universal_newlines} が \constant{True} の場合、
stdout および stderr のファイルオブジェクトはテキストファイルとして
open されますが、行の終端は \UNIX 形式の行末 \code{'\e n'} か、
Macintosh 形式の行末 \code{'\e r'} か、あるいは Windows 形式の行末
\code{'\e r\e n'} のいずれも許されます。これらすべての外部表現は
Python プログラムには \code{'\e n'} として認識されます。
\note{この機能は Python に universal newline がサポートされている場合 (デフォルト) にのみ
有効です。また、 \member{stdout}, \member{stdin} および \member{stderr} の
ファイルオブジェクトの newlines 属性は communicate() メソッドでは
更新されません。}

\var{startupinfo} および \var{creationflags} が与えられた場合、
これらは内部で呼びだされる CreateProcess() 関数に渡されます。
これらはメインウインドウの形状や新しいプロセスの優先度などを
指定することができます。  (Windows のみ)
\end{classdesc}

\subsubsection{便利な関数}

このモジュールは二つのショートカット関数も定義しています:

\begin{funcdesc}{call}{*popenargs, **kwargs}
コマンドを指定された引数で実行し、そのコマンドが完了するのを待って、
\member{returncode} 属性を返します。

この引数は Popen コンストラクタの引数と同じです。
使用例:

\begin{verbatim}
    retcode = call(["ls", "-l"])
\end{verbatim}
\end{funcdesc}

\begin{funcdesc}{check_call}{*popenargs, **kwargs}
コマンドを引数付きで実行します。コマンドが完了するのを待ちます。終了コードがゼロ
ならば終わりますが、そうでなければ \exception{CalledProcessError} 例外を送出します。
\exception{CalledProcessError} オブジェクトにはリターンコードが
\member{returncode} 属性として収められています。

引数は Popen のコンストラクタと一緒です。使用例:

\begin{verbatim}
    check_call(["ls", "-l"])
\end{verbatim}
\end{funcdesc}

\subsubsection{例外}

子プロセス内で raise した例外は、新しいプログラムが実行される前であれば、
親プロセスでも raise されます。さらに、この例外オブジェクトには
\member{child_traceback} という属性が追加されており、これには
子プロセスの視点からの traceback 情報が格納されています。

もっとも一般的に起こる例外は \exception{OSError} です。
これは、たとえば存在しないファイルを実行しようとしたときなどに
発生します。アプリケーションは \exception{OSError} 例外には
あらかじめ準備しておく必要があります。

不適当な引数で \class{Popen} が呼ばれた場合は、
\exception{ValueError} が発生します。

\function{check_call()} は
もし呼び出されたプロセスがゼロでないリターンコードを返したならば
\exception{CalledProcessError} を送出します。

\subsubsection{セキュリティ}

ほかの popen 関数とは異なり、この実装は決して暗黙のうちに /bin/sh を
実行しません。これはシェルのメタ文字をふくむすべての文字が
安全に子プロセスに渡されるということを意味しています。


\subsection{Popen オブジェクト}

\class{Popen} クラスのインスタンスには、以下のようなメソッドがあります:

\begin{methoddesc}[Popen]{poll}{}
子プロセスが終了しているかどうかを検査します。
returncode 属性を返します。
\end{methoddesc}

\begin{methoddesc}[Popen]{wait}{}
子プロセスが終了するまで待ちます。
returncode 属性を返します。
\end{methoddesc}

\begin{methoddesc}[Popen]{communicate}{input=None}
プロセスと通信します: end-of-file に到達するまで
データを stdin に送信し、stdout および stderr からデータを受信します。
プロセスが終了するまで待ちます。オプション引数 \var{input} には
子プロセスに送られる文字列か、あるいはデータを送らない場合は \code{None} を指定します。

communicate() はタプル (stdout, stderr) を返します。

\note{受信したデータはメモリ中にバッファされます。
そのため、返されるデータが大きいかあるいは制限がないような場合は
このメソッドを使うべきではありません。}
\end{methoddesc}

以下の属性も利用できます:

\begin{memberdesc}[Popen]{stdin}
\var{stdin} 引数が \code{PIPE} の場合、この属性には
子プロセスの入力に使われるファイルオブジェクトになります。
そうでない場合は \code{None} です。
\end{memberdesc}

\begin{memberdesc}[Popen]{stdout}
\var{stdout} 引数が \code{PIPE} の場合、この属性には
子プロセスの出力に使われるファイルオブジェクトになります。
そうでない場合は \code{None} です。
\end{memberdesc}

\begin{memberdesc}[Popen]{stderr}
\var{stderr} 引数が \code{PIPE} の場合、この属性には
子プロセスのエラー出力に使われるファイルオブジェクトになります。
そうでない場合は \code{None} です。
\end{memberdesc}

\begin{memberdesc}[Popen]{pid}
子プロセスのプロセス ID が入ります。
\end{memberdesc}

\begin{memberdesc}[Popen]{returncode}
子プロセスの終了ステータスが入ります。
\code{None} はまだその子プロセスが終了していないことを示し、
負の値 -N は子プロセスがシグナル N により中止させられたことを示します (\UNIX{} のみ)。
\end{memberdesc}


\subsection{古い関数を subprocess モジュールで置き換える}

以下、この節では、"a ==> b" と書かれているものは
a の代替として b が使えるということを表します。

\note{この節で紹介されている関数はすべて、実行するプログラムが
見つからないときは (いくぶん) 静かに終了します。このモジュールは
\exception{OSError} 例外を発生させます。}

以下の例では、 subprocess モジュールは "from subprocess import *" で
インポートされたと仮定しています。

\subsubsection{/bin/sh シェルのバッククォートを置き換える}

\begin{verbatim}
output=`mycmd myarg`
==>
output = Popen(["mycmd", "myarg"], stdout=PIPE).communicate()[0]
\end{verbatim}

\subsubsection{シェルのパイプラインを置き換える}

\begin{verbatim}
output=`dmesg | grep hda`
==>
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
output = p2.communicate()[0]
\end{verbatim}

\subsubsection{os.system() を置き換える}

\begin{verbatim}
sts = os.system("mycmd" + " myarg")
==>
p = Popen("mycmd" + " myarg", shell=True)
sts = os.waitpid(p.pid, 0)
\end{verbatim}

注意:

\begin{itemize}
\item このプログラムは普通シェル経由で呼び出す必要はありません。
\item 終了状態を見るよりも \member{returncode} 属性を見るほうが簡単です。
\end{itemize}

より現実的な例ではこうなるでしょう:

\begin{verbatim}
try:
    retcode = call("mycmd" + " myarg", shell=True)
    if retcode < 0:
        print >>sys.stderr, "子プロセスがシグナルによって中止されました", -retcode
    else:
        print >>sys.stderr, "子プロセスが終了コードを返しました", retcode
except OSError, e:
    print >>sys.stderr, "実行に失敗しました:", e
\end{verbatim}

\subsubsection{os.spawn* を置き換える}

P_NOWAIT の例:

\begin{verbatim}
pid = os.spawnlp(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg")
==>
pid = Popen(["/bin/mycmd", "myarg"]).pid
\end{verbatim}

P_WAIT の例:

\begin{verbatim}
retcode = os.spawnlp(os.P_WAIT, "/bin/mycmd", "mycmd", "myarg")
==>
retcode = call(["/bin/mycmd", "myarg"])
\end{verbatim}

シーケンスを使った例:

\begin{verbatim}
os.spawnvp(os.P_NOWAIT, path, args)
==>
Popen([path] + args[1:])
\end{verbatim}

環境変数を使った例:

\begin{verbatim}
os.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)
==>
Popen(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})
\end{verbatim}

\subsubsection{os.popen* を置き換える}

\begin{verbatim}
pipe = os.popen(cmd, mode='r', bufsize)
==>
pipe = Popen(cmd, shell=True, bufsize=bufsize, stdout=PIPE).stdout
\end{verbatim}

\begin{verbatim}
pipe = os.popen(cmd, mode='w', bufsize)
==>
pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin
\end{verbatim}

\begin{verbatim}
(child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)
==>
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdin, child_stdout) = (p.stdin, p.stdout)
\end{verbatim}

\begin{verbatim}
(child_stdin,
 child_stdout,
 child_stderr) = os.popen3(cmd, mode, bufsize)
==>
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
(child_stdin,
 child_stdout,
 child_stderr) = (p.stdin, p.stdout, p.stderr)
\end{verbatim}

\begin{verbatim}
(child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)
==>
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)
\end{verbatim}

\subsubsection{popen2.* を置き換える}

\note{popen2 に対するコマンド引数が文字列の場合、
そのコマンドは /bin/sh 経由で実行されます。いっぽうこれが
リストの場合、そのコマンドは直接実行されます。}

\begin{verbatim}
(child_stdout, child_stdin) = popen2.popen2("somestring", bufsize, mode)
==>
p = Popen(["somestring"], shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdout, child_stdin) = (p.stdout, p.stdin)
\end{verbatim}

\begin{verbatim}
(child_stdout, child_stdin) = popen2.popen2(["mycmd", "myarg"], bufsize, mode)
==>
p = Popen(["mycmd", "myarg"], bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdout, child_stdin) = (p.stdout, p.stdin)
\end{verbatim}

popen2.Popen3 および popen2.Popen4 は基本的には subprocess.Popen と同様です。
ただし、違う点は:

\begin{itemize}
\item subprocess.Popen は実行できなかった場合に例外を発生させます。

\item \var{capturestderr} 引数は \var{stderr} 引数に代わりました。

\item stdin=PIPE および stdout=PIPE を指定する必要があります。

\item popen2 はデフォルトですべてのファイル記述子を閉じますが、subprocess.Popen では
       明示的に close_fds=True を指定する必要があります。
\end{itemize}

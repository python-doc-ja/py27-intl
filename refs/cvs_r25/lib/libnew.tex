\section{\module{new} ---
         ランタイム内部オブジェクトの作成}

\declaremodule{builtin}{new}
\sectionauthor{Moshe Zadka}{moshez@zadka.site.co.il}
\modulesynopsis{ランタイム実装オブジェクトの作成のインターフェイス。}


\module{new}モジュールはインタプリタオブジェクト作成関数へのインターフェイスを与えます。新しいオブジェクトを``魔法を使ったように''作り出す必要がある、通常の作成関数が使えないときに、これは主にマーシャル型関数で使われます。このモジュールはインタプリタへの低レベルインターフェイスを提供します。したがって、このモジュールを使うときには注意しなければなりません。
オブジェクトが利用される時にインタプリタをクラッシュさせるような引数を
与えることもできてしまいます。

\module{new}モジュールは次の関数を定義しています:

\begin{funcdesc}{instance}{class\optional{, dict}}
この関数は\method{__init__()}コンストラクタを呼び出さずに辞書\var{dict}をもつ\var{class}のインスタンスを作り出します。\var{dict}が省略されるか、\code{None}である場合は、新しいインスタンスのために新しい空の辞書が作られます。オブジェクトがいつもと同じ状態であるという保証はないことに注意してください。
\end{funcdesc}

\begin{funcdesc}{instancemethod}{function, instance, class}
この関数は\var{instance}に束縛されたメソッドオブジェクトか、あるいは\var{instance}が\code{None}の場合に束縛されていないメソッドオブジェクトを返します。\var{function}は呼び出し可能でなければなりません。
\end{funcdesc}

\begin{funcdesc}{function}{code, globals\optional{, name\optional{,
                           argdefs\optional{, closure}}}}
与えられたコードとグローバル変数をもつ(Python)関数を返します。\var{name}を与えるならば、文字列か\code{None}でなければならない。文字列の場合は、関数は与えられた名前をもつ。そうでなければ、関数名は\code{\var{code}.co_name}から取られる。\var{argdefs}を与える場合はタプルでなければならず、パラメータのデフォルト値を決めるために使われます。
\var{closure} を与える場合は\code{None}または名前を\code{\var{code}.co_freevars}に束縛するセルオブジェクトのタプルである必要があります。

)が与えられていると、
\end{funcdesc}

\begin{funcdesc}{code}{argcount, nlocals, stacksize, flags, codestring,
                       constants, names, varnames, filename, name, firstlineno,
                       lnotab}
この関数は\cfunction{PyCode_New()}というC関数へのインターフェイスです。
%XXX This is still undocumented!!!!!!!!!!!
\end{funcdesc}

\begin{funcdesc}{module}{name\optional{, doc}}
この関数は\var{name}という名前の新しいモジュールオブジェクトを返します。\var{name}は文字列でなければならない。
省略可能な \var{doc} 引数はどんな型でもよい。
\end{funcdesc}

\begin{funcdesc}{classobj}{name, baseclasses, dict}
この関数は新しいクラスオブジェクトを返します。そのクラスオブジェクトは(クラスのタプルであるべき)\var{baseclasses}から派生し、名前空間\var{dict}を持ち、\var{name}という名前です。
\end{funcdesc}

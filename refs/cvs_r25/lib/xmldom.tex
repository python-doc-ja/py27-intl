\section{\module{xml.dom} ---
         文書オブジェクトモデル (DOM) API}

\declaremodule{standard}{xml.dom}
\modulesynopsis{Python のための文書オブジェクトモデル API。}
\sectionauthor{Paul Prescod}{paul@prescod.net}
\sectionauthor{Martin v. L\"owis}{loewis@informatik.hu-berlin.de}

\versionadded{2.0}

文書オブジェクトモデル、または ``DOM'' は、ワールドワイドウェブ
コンソーシアム (World Wide Web Consortium, W3C) による、XML 
ドキュメントにアクセスしたり変更を加えたりするための、プログラミング
言語間共通の API です。DOM 実装によって、XML ドキュメントは
ツリー構造として表現されます。また、クライアントコード側で
ツリー構造をゼロから構築できるようになります。さらに、
前述の構造に対して、よく知られたインタフェースをもつ一連の
オブジェクトを通したアクセス手段も提供します。

DOM はランダムアクセスを行うアプリケーションで非常に有用です。
SAX では、一度に閲覧することができるのはドキュメントのほんの
一部分です。ある SAX 要素に注目している際には、別の要素をアクセス
することはできません。またテキストノードに注目しているときには、
その中に入っている要素をアクセスすることができません。
SAX によるアプリケーションを書くときには、プログラムがドキュメント内の
どこを処理しているのかを追跡するよう、コードのどこかに記述する
必要があります。SAX 自体がその作業を行ってくれることはありません。
さらに、XML ドキュメントに対する先読み (look ahead) が必要だと
すると不運なことになります。

アプリケーションによっては、ツリーにアクセスできなければ
イベント駆動モデルを実現できません。もちろん、何らかのツリーを
SAX イベントに応じて自分で構築することもできるでしょうが、
DOM ではそのようなコードを書かなくてもよくなります。
DOM は XML データに対する標準的なツリー表現なのです。

%What if your needs are somewhere between SAX and the DOM?  Perhaps
%you cannot afford to load the entire tree in memory but you find the
%SAX model somewhat cumbersome and low-level.  There is also a module
%called xml.dom.pulldom that allows you to build trees of only the
%parts of a document that you need structured access to.  It also has
%features that allow you to find your way around the DOM.
% See http://www.prescod.net/python/pulldom

文書オブジェクトモデルは、W3C によっていくつかの段階、W3C の用語で
言えば ``レベル (level)'' で定義されています。 Python においては、
DOM API への対応付け は実質的には DOM レベル~2 勧告に基づいています。
現在はドラフト形式でのみ入手できる レベル~3 仕様への対応付けは、
\ulink{Python XML 分科会 (Special Interest Group)}
{http://www.python.org/sigs/xml-sig/} により、
\ulink{PyXML パッケージ}{http://pyxml.sourceforge.net/} の一部として
開発中です。 DOM レベル~3 サポートの現在の状態についての情報は、
PyXML パッケージに同梱されているドキュメントを参照してください。

DOM アプリケーションは、普通は XML を DOM に解析するところから始まり
ます。どのようにして解析を行うかについては DOM レベル~1 では全く
カバーしておらず、レベル~2 では限定的な改良だけが行われました:
レベル~2 では\class{Document} を生成するメソッドを提供する
\class{DOMImplementation} オブジェクトクラスがありますが、
実装に依存しない方法で XML リーダ(reader)/パーザ(parser)/文書ビルダ
(Document builder) にアクセスする方法はありません。また、既存の 
\class{Document} オブジェクトなしにこれらのメソッドにアクセスする
ような、よく定義された方法もありません。
Python では、各々の DOM 実装で \function{getDOMImplementation()} 
が定義されているはずです。
DOM レベル~3 ではロード(Load)/ストア(Store) 仕様が追加され、リーダの
インタフェースにを定義していますが、Python 標準ライブラリではまだ
利用することができません。

DOM 文書オブジェクトを生成したら、そのプロパティとメソッドを使って
XML 文書の一部にアクセスできます。これらのプロパティは
DOM 仕様で定義されています; 本リファレンスマニュアルでは、
Python において DOM 仕様がどのように解釈されているかを記述しています。

W3C から提供されている仕様は、 DOM API を Java、ECMAScript、および
OMG IDL で定義しています。ここで定義されている Python での対応づけは、
大部分がこの仕様の IDL 版に基づいていますが、厳密な準拠は必要と
されていません (実装で IDL の厳密な対応付けをサポートするのは自由
ですが)。API への対応付けに関する詳細な議論は \ref{dom-conformance} 、
``適合性'' を参照してください。


\begin{seealso}
  \seetitle[http://www.w3.org/TR/DOM-Level-2-Core/]{Document Object
            Model (DOM) Level~2 Specification}
           {Python DOM API が準拠している W3C 勧告。}
  \seetitle[http://www.w3.org/TR/REC-DOM-Level-1/]{Document Object
            Model (DOM) Level~1 Specification}
           {\module{xml.dom.minidom} でサポートされている W3C の DOM
に関する勧告。}
  \seetitle[http://pyxml.sourceforge.net]{PyXML}{完全な機能をもった
DOM 実装を必要とするユーザは PyXML パッケージを利用すべきです。}
  \seetitle[http://www.omg.org/docs/formal/02-11-05.pdf]{Python
            Language Mapping Specification}
           {このドキュメントでは OMG IDL から Python への対応付けを
記述しています。}
\end{seealso}

\subsection{モジュールの内容}

\module{xml.dom} には、以下の関数が収められています:

\begin{funcdesc}{registerDOMImplementation}{name, factory}
ファクトリ関数 (factory function) \var{factory} を名前 \var{name} で
登録します。ファクトリ関数は \class{DOMImplementation} インタフェース
を実装するオブジェクトを返さなければなりません。ファクトリ関数は
毎回同じオブジェクトを返すこともでき、呼び出されるたびに、特定の実装
(例えば実装が何らかのカスタマイズをサポートしている場合) における、
適切な新たなオブジェクトを返すこともできます。
\end{funcdesc}

\begin{funcdesc}{getDOMImplementation}{\optional{name\optional{, features}}}
適切な DOM 実装を返します \var{name} は、よく知られた DOM 実装の
モジュール名か、\code{None} になります。\code{None} でない場合、
対応するモジュールを import して、import が成功した場合
\class{DOMImplementation} オブジェクトを返します。\var{name} が与えられ
ておらず、環境変数 \envvar{PYTHON_DOM} が設定されていた場合、
DOM 実装を見つけるのに環境変数が使われます。

\var{name} が与えられない場合、 利用可能な実装を調べて、
指定された機能 (feature) セットを持つものを探します。
実装が見つからなければ \exception{ImportError} を送出します。
\var{features} のリストは \code{(\var{feature}, \var{version})} の
ペアからなるシーケンスで、利用可能な \class{DOMImplementation} オブジェクト
の \method{hasFeature()} メソッドに渡されます。
\end{funcdesc}


いくつかの便利な定数も提供されています:

\begin{datadesc}{EMPTY_NAMESPACE}
DOM 内のノードに名前空間が何も関連づけられていないことを示すために
使われる値です。この値は通常、ノードの \member{namespaceURI} の値
として見つかったり、名前空間特有のメソッドに対する \var{namespaceURI}
パラメタとして使われます。
  \versionadded{2.2}
\end{datadesc}

\begin{datadesc}{XML_NAMESPACE}
  \citetitle[http://www.w3.org/TR/REC-xml-names/]{Namespaces in XML}
  (4 節) で定義されている、予約済みプレフィクス (reserved prefix)
\code{xml} に関連付けられた名前空間 URI です。
  \versionadded{2.2}
\end{datadesc}

\begin{datadesc}{XMLNS_NAMESPACE}
  \citetitle[http://www.w3.org/TR/DOM-Level-2-Core/core.html]{Document
  Object Model (DOM) Level~2 Core Specification} (1.1.8 節)
で定義されている、名前空間宣言への名前空間 URI です。
  \versionadded{2.2}
\end{datadesc}

\begin{datadesc}{XHTML_NAMESPACE}
\citetitle[http://www.w3.org/TR/xhtml1/]{XHTML 1.0: The Extensible
HyperText Markup Language} (3.1.1 節)
で定義されている、XHTML 名前空間 URI です。
  \versionadded{2.2}
\end{datadesc}


% Should the Node documentation go here?

加えて、 \module{xml.dom} には基底となる \class{Node} クラスと
DOM 例外クラスが収められています。このモジュールで提供されている
\class{Node} クラスは DOM 仕様で定義されているメソッドや属性は
何ら実装していません; これらは具体的な DOM 実装において提供
しなければなりません。このモジュールの一部として提供されている
\class{Node} クラスでは、具体的な \class{Node} オブジェクトの
\member{nodeType} 属性として使う定数を提供しています; これらの
定数は、DOM 仕様に適合するため、クラスではなくモジュールのレベルに
配置されています。


\subsection{DOM 内のオブジェクト\label{dom-objects}}

DOM について最も明確に限定しているドキュメントは W3C による
DOM 仕様です。

DOM 属性は単純な文字列としてだけではなく、ノードとして操作される
かもしれないので注意してください。とはいえ、そうしなければならない
場合はかなり稀なので、今のところ記述されていません。


\begin{tableiii}{l|l|l}{class}{インタフェース}{節}{目的}
  \lineiii{DOMImplementation}{\ref{dom-implementation-objects}}
          {根底にある実装へのインタフェース。}
  \lineiii{Node}{\ref{dom-node-objects}}
          {ドキュメント内の大部分のオブジェクトのに対する基底インタフェース。}
  \lineiii{NodeList}{\ref{dom-nodelist-objects}}
          {ノードの列に対するインタフェース。}
  \lineiii{DocumentType}{\ref{dom-documenttype-objects}}
          {ドキュメントを処理するために必要な宣言についての情報。}
  \lineiii{Document}{\ref{dom-document-objects}}
          {ドキュメント全体を表現するオブジェクト。}
  \lineiii{Element}{\ref{dom-element-objects}}
          {ドキュメント階層内の要素ノード。}
  \lineiii{Attr}{\ref{dom-attr-objects}}
          {階層ノード上の属性値。}
  \lineiii{Comment}{\ref{dom-comment-objects}}
          {ソースドキュメント内のコメント表現。}
  \lineiii{Text}{\ref{dom-text-objects}}
          {ドキュメント内のテキスト記述を含むノード。}
  \lineiii{ProcessingInstruction}{\ref{dom-pi-objects}}
          {処理命令 (processing instruction) 表現。}
\end{tableiii}

さらに追加の節として、 Python で DOM を利用するために定義されている
例外について記述しています。


\subsubsection{DOMImplementation オブジェクト
               \label{dom-implementation-objects}}

\class{DOMImplementation} インタフェースは、利用している DOM 実装
において特定の機能が利用可能かどうかを決定するための方法を
アプリケーションに提供します。DOM レベル~2 では、
\class{DOMImplementation} を使って新たな\class{Document} オブジェクト
や \class{DocumentType} オブジェクトを生成する機能も追加しています。

\begin{methoddesc}[DOMImplementation]{hasFeature}{feature, version}
機能名\var{feature}とバージョン番号\var{version}で
識別される機能（feature）が実装されていればtrueを返します。
\end{methoddesc}

\begin{methoddesc}[DOMImplementation]{createDocument}{namespaceUri, qualifiedName, doctype}
新たな(DOMのスーパークラスである)\class{Document}クラスのオブジェクトを返します。
このクラスは\var{namespaceUri}と\var{qualifiedName}が設定された子クラス\class{Element}の
オブジェクトを所有しています。
\var{doctype}は
\method{createDocumentType()}によって生成された
\class{DocumentType}クラスのオブジェクト、
または\code{None}である必要があります。
Python DOM APIでは、子クラスである\class{Element}を作成しないことを
示すために、はじめの２つの引数を\code{None}に設定することができます。
\end{methoddesc}

\begin{methoddesc}[DOMImplementation]{createDocumentType}{qualifiedName, publicId, systemId}
新たな\class{DocumentType}クラスのオブジェクトを返します。
このオブジェクトは\var{qualifiedName}、\var{publicId}、そして
\var{systemId}文字列をふくんでおり、XML文書の形式情報を表現しています。
\end{methoddesc}


\subsubsection{Node オブジェクト \label{dom-node-objects}}

XML 文書の全ての構成要素は \class{Node} のサブクラスです。

\begin{memberdesc}[Node]{nodeType}
ノード (node) の型を表現する整数値です。型に対応する以下の
シンボル定数: 
\constant{ELEMENT_NODE} 、 \constant{ATTRIBUTE_NODE} 、
\constant{TEXT_NODE} 、 \constant{CDATA_SECTION_NODE} 、
\constant{ENTITY_NODE} 、 \constant{PROCESSING_INSTRUCTION_NODE} 、
\constant{COMMENT_NODE} 、 \constant{DOCUMENT_NODE} 、
\constant{DOCUMENT_TYPE_NODE} 、 \constant{NOTATION_NODE} 、
が \class{Node} オブジェクトで定義されています。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{parentNode}
現在のノードの親ノードか、文書ノードの場合には \code{None}
になります。この値は常に \class{Node} オブジェクトか \code{None}
になります。\class{Element} ノードの場合、この値はルート要素 
(root element) の場合を除き親要素 (parent element) となり、
ルート要素の場合には \class{Document} オブジェクトとなります。
\class{Attr} ノードの場合、この値は常に \code{None} となります。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{attributes}
属性オブジェクトの \class{NamedNodeMap} です。要素だけがこの属性に
実際の値を持ちます; その他のオブジェクトでは、この属性を \code{None} 
にします。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{previousSibling}
このノードと同じ親ノードを持ち、直前にくるノードです。例えば、
\var{self} 要素のの開始タグの直前にくる終了タグを持つ要素です。
もちろん、XML 文書は要素だけで構成されているだけではないので、
直前にくる兄弟関係にある要素 (sibling) はテキストやコメント、
その他になる可能性があります。このノードが親ノードにおける
先頭の子ノードである場合、属性値は \code{None} になります。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{nextSibling}
このノードと同じ親ノードを持ち、直後にくるノードです。例えば、
\member{previousSibling} も参照してください。
このノードが親ノードにおける末尾頭の子ノードである場合、
属性値は \code{None} になります。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{childNodes}
このノード内に収められているノードからなるリストです。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{firstChild}
このノードに子ノードがある場合、その先頭のノードです。
そうでない場合 \code{None} になります。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{lastChild}
このノードに子ノードがある場合、その末尾のノードです。
そうでない場合 \code{None} になります。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{localName}
\member{tagName} にコロンがあれば、コロン以降の部分に、なければ
\member{tagName} 全体になります。値は文字列です。
\end{memberdesc}

\begin{memberdesc}[Node]{prefix}
\member{tagName} のコロンがあれば、コロン以前の部分に、なければ
空文字列になります。値は文字列か、\code{None} になります。
\end{memberdesc}

\begin{memberdesc}[Node]{namespaceURI}
要素名に関連付けられた名前空間です。文字列か \code{None} に
なります。読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{nodeName}
この属性はノード型ごとに異なる意味を持ちます; 詳しくは DOM 仕様を
参照してください。この属性で得られることになる情報は、全てのノード
型では \member{tagName} 、属性では \member{name} プロパティといった
ように、常に他のプロパティで得ることができます。全てのノード型で、
この属性の値は文字列か \code{None} になります。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[Node]{nodeValue}
この属性はノード型ごとに異なる意味を持ちます; 詳しくは DOM 仕様を
参照してください。その序今日は \member{nodeName} と似ています。
この属性の値は文字列か \code{None} になります。
\end{memberdesc}

\begin{methoddesc}[Node]{hasAttributes}{}
ノードが何らかの属性を持っている場合に真を返します。
\end{methoddesc}

\begin{methoddesc}[Node]{hasChildNodes}{}
ノードが何らかの子ノードを持っている場合に真を返します。
\end{methoddesc}

\begin{methoddesc}[Node]{isSameNode}{other}
\var{other} がこのノードと同じノードを参照している場合に真を返します。
このメソッドは、何らかのプロキシ (proxy) 機構を利用するような DOM 
実装で特に便利です (一つ以上のオブジェクトが同じノードを参照
するかもしれないからです)。

\begin{notice}
このメソッドは DOM レベル~3 API で提案されており、まだ 
``ワーキングドラフト(working draft)'' の段階です。しかし、
このインタフェースだけは議論にはならないと考えられます。
W3C による変更は必ずしも Python DOM インタフェースにおける
このメソッドに影響するとは限りません (ただしこのメソッドに
対する何らかの新たな W3C API もサポートされるかもしれません)。
\end{notice}
\end{methoddesc}

\begin{methoddesc}[Node]{appendChild}{newChild}
現在のノードの子ノードリストの末尾に新たな子ノードを追加し、
\var{newChild} を返します。
\end{methoddesc}

\begin{methoddesc}[Node]{insertBefore}{newChild, refChild}
新たな子ノードを既存の子ノードの前に挿入します。\var{refChild}
は現在のノードの子ノードである場合に限られます; そうでない場合、
\exception{ValueError} が送出されます。
\var{newChild} が返されます。
もし\var{refChild}が\code{None}なら、\var{newChild}を子ノードリストの
最後に挿入します。
\end{methoddesc}

\begin{methoddesc}[Node]{removeChild}{oldChild}
子ノードを削除します。\var{oldChild} はこのノードの子ノードでなければ
なりません。そうでない場合、\exception{ValueError} が送出されます。
成功した場合 \var{oldChild} が返されます。
\var{oldChild} をそれ以降使わない場合、\method{unlink()} メソッドを
呼び出さなければなりません。
\end{methoddesc}

\begin{methoddesc}[Node]{replaceChild}{newChild, oldChild}
既存のノードと新たなノードを置き換えます。この操作は \var{oldChild}
が現在のノードの子ノードである場合に限られます; そうでない場合、
\exception{ValueError} が送出されます。
\end{methoddesc}

\begin{methoddesc}[Node]{normalize}{}
一続きのテキスト全体を一個の \class{Text} インスタンスとして保存する
ために隣接するテキストノードを結合します。これにより、多くの
アプリケーションで DOM ツリーからのテキスト処理が簡単になります。
\versionadded{2.1}
\end{methoddesc}

\begin{methoddesc}[Node]{cloneNode}{deep}
このノードを複製 (clone) します。\var{deep} を設定すると、子ノードも
同様に複製することを意味します。複製されたノードを返します。
\end{methoddesc}


\subsubsection{NodeList オブジェクト \label{dom-nodelist-objects}}

\class{NodeList} は、ノードからなるシーケンスを表現します。これらのオブジェクト
は DOM コア勧告 (DOM Core recommendation) において、二通りに使われて
います: \class{Element} オブジェクトでは、子ノードのリストを提供するのに
\class{NodeList} を利用します。また、このインタフェースにおける 
\class{Node} の \method{getElementsByTagName()} および
\method{getElementsByTagNameNS()} メソッドは、クエリに対する結果
を表現するのに\class{NodeList} を利用します。

DOM レベル~2 勧告では、これらのオブジェクトに対し、メソッドと属性を
一つづつ定義しています:

\begin{methoddesc}[NodeList]{item}{i}
シーケンスに \var{i} 番目の要素がある場合にはその要素を、そうでない場合には
\code{None} を返します。\var{i} はゼロよりも小さくてはならず、
シーケンスの長さ以上であってはなりません。
\end{methoddesc}

\begin{memberdesc}[NodeList]{length}
シーケンス中のノードの数です。
\end{memberdesc}

この他に、Python の DOM インタフェースでは、\class{NodeList} 
オブジェクトを Python のシーケンスとして使えるようにするサポートが
追加されていることが必要です。\class{NodeList} の実装では、全て
\method{__len__()} と \method{__getitem__()} をサポートしなければ
なりません; このサポートにより、\keyword{for} 文内で 
\class{NodeList} にわたる繰り返しと、組み込み関数 \function{len()} 
の適切なサポートができるようになります。

DOM 実装が文書の変更をサポートしている場合、\class{NodeList} の
実装でも \method{__setitem__()} および \method{__delitem__()} メソッドを
サポートしなければなりません。


\subsubsection{DocumentType オブジェクト \label{dom-documenttype-objects}}

文書で宣言されている記法 (notation) やエンティティ (entity) 
に関する (外部サブセット(external subset) がパーザから利用でき、情報
を提供できる場合にはそれも含めた) 情報は、 \class{DocumentType} 
オブジェクトから手に入れることができます。文書の \class{DocumentType} 
は、\class{Document} オブジェクトの \member{doctype} 属性で入手することが
できます; 文書の \code{DOCTYPE} 宣言がない場合、文書の \member{doctype} 
属性は、このインタフェースを持つインスタンスの代わりに \code{None} 
に設定されます。

\class{DocumentType} は \class{Node} を特殊化したもので、以下の
属性を加えています:

\begin{memberdesc}[DocumentType]{publicId}
文書型定義 (document type definition) の外部サブセットに対する
公開識別子 (public identifier) です。文字列または \code{None}
になります。
\end{memberdesc}

\begin{memberdesc}[DocumentType]{systemId}
文書型定義 (document type definition) の外部サブセットに対する
システム識別子 (system identifier) です。文字列の URI または
\code{None} になります。
\end{memberdesc}

\begin{memberdesc}[DocumentType]{internalSubset}
ドキュメントの完全な内部サブセットを与える文字列です。
サブセットを囲むブラケットは含みません。ドキュメントが内部サブセット
を持たない場合、この値は \code{None} です。
\end{memberdesc}

\begin{memberdesc}[DocumentType]{name}
\code{DOCTYPE} 宣言でルート要素の名前が与えられている場合、その
値になります。
\end{memberdesc}

\begin{memberdesc}[DocumentType]{entities}
外部エンティティの定義を与える \class{NamedNodeMap} です。
複数回定義されているエンティティに対しては、最初の定義だけが
提供されます (その他は XML 勧告での要求仕様によって無視されます)。
パーザによって情報が提供されないか、エンティティが定義されていない
場合には、この値は \code{None} になることがあります。
\end{memberdesc}

\begin{memberdesc}[DocumentType]{notations}
記法の定義を与える \class{NamedNodeMap} です。
複数回定義されている記法名に対しては、最初の定義だけが
提供されます (その他は XML 勧告での要求仕様によって無視されます)。
パーザによって情報が提供されないか、エンティティが定義されていない
場合には、この値は \code{None} になることがあります。
\end{memberdesc}


\subsubsection{Document オブジェクト \label{dom-document-objects}}

\class{Document} は XML ドキュメント全体を表現し、その構成要素
である要素、属性、処理命令、コメント等が入っています。
\class{Document} は \class{Node} からプロパティを継承していることを
思い出してください。

\begin{memberdesc}[Document]{documentElement}
ドキュメントの唯一無二のルート要素です。
\end{memberdesc}

\begin{methoddesc}[Document]{createElement}{tagName}
新たな要素ノードを生成して返します。要素は、生成された時点では
ドキュメント内に挿入されません。\method{insertBefore()} や
\method{appendChild()} のような他のメソッドの一つを使って
明示的に挿入を行う必要があります。
\end{methoddesc}

\begin{methoddesc}[Document]{createElementNS}{namespaceURI, tagName}
名前空間を伴う新たな要素ノードを生成して返します。\var{tagName}
にはプレフィクス (prefix) があってもかまいません。要素は、生成された
時点では文書内に挿入されません。\method{insertBefore()} や
\method{appendChild()} のような他のメソッドの一つを使って
明示的に挿入を行う必要があります。
\method{appendChild()}.
\end{methoddesc}

\begin{methoddesc}[Document]{createTextNode}{data}
パラメタで渡されたデータの入ったテキストノードを生成して返します。
他の生成 (create) メソッドと同じく、このメソッドは生成された
ノードをツリーに挿入しません。
\end{methoddesc}

\begin{methoddesc}[Document]{createComment}{data}
パラメタで渡されたデータの入ったコメントノードを生成して返します。
他の生成 (create) メソッドと同じく、このメソッドは生成された
ノードをツリーに挿入しません。
\end{methoddesc}

\begin{methoddesc}[Document]{createProcessingInstruction}{target, data}
パラメタで渡された \var{target} および \var{data} の入った処理命令
ノードを生成して返します。他の生成 (create) メソッドと同じく、
このメソッドは生成されたノードをツリーに挿入しません。
\end{methoddesc}

\begin{methoddesc}[Document]{createAttribute}{name}
属性ノードを生成して返します。このメソッドは属性ノードを特定の
要素に関連づけることはしません。新たに生成された属性インスタンス
を使うには、適切な \class{Element} オブジェクトの 
\method{setAttributeNode()} を使わなければなりません。
\end{methoddesc}

\begin{methoddesc}[Document]{createAttributeNS}{namespaceURI, qualifiedName}
名前空間を伴う新たな属性ノードを生成して返します。\var{tagName}
にはプレフィクス (prefix) があってもかまいません。
このメソッドは属性ノードを特定の要素に関連づけることはしません。
新たに生成された属性インスタンスを使うには、適切な \class{Element} 
オブジェクトの \method{setAttributeNode()} を使わなければなりません。
\end{methoddesc}

\begin{methoddesc}[Document]{getElementsByTagName}{tagName}
全ての下位要素 (直接の子要素、子要素の子要素、等) から、特定の
要素型名を持つものを検索します。
\end{methoddesc}

\begin{methoddesc}[Document]{getElementsByTagNameNS}{namespaceURI, localName}
全ての下位要素 (直接の子要素、子要素の子要素、等) から、特定の
名前空間 URI とローカル名 (local name) を持つものを検索します。
ローカル名は名前空間におけるプレフィクス以降の部分です。
\end{methoddesc}


\subsubsection{Element オブジェクト \label{dom-element-objects}}

\class{Element} は \class{Node} のサブクラスです。このため
\class{Node} クラスの全ての属性を継承します。

\begin{memberdesc}[Element]{tagName}
要素型名です。名前空間使用の文書では、要素型名中にコロンが
あるかもしれません。値は文字列です。
\end{memberdesc}

\begin{methoddesc}[Element]{getElementsByTagName}{tagName}
\class{Document} クラス内における同名のメソッドと同じです。
\end{methoddesc}

\begin{methoddesc}[Element]{getElementsByTagNameNS}{tagName}
\class{Document} クラス内における同名のメソッドと同じです。
\end{methoddesc}

\begin{methoddesc}[Element]{hasAttribute}{name}
指定要素に\var{name}で渡した名前の属性が存在していれば true を返します。
\end{methoddesc}

\begin{methoddesc}[Element]{hasAttributeNS}{namespaceURI, localName}
指定要素に\var{namespaceURI}と\var{localName}で指定した名前の属性が
存在していれば true を返します。
\end{methoddesc}

\begin{methoddesc}[Element]{getAttribute}{name}
\var{name}で指定した属性の値を文字列として返します。
もし、属性が存在しない、もしくは属性に値が設定されていない場合、
空の文字列が返されます。
\end{methoddesc}

\begin{methoddesc}[Element]{getAttributeNode}{attrname}
\var{attrname} で指定された属性の \class{Attr} ノードを返します。
\end{methoddesc}

\begin{methoddesc}[Element]{getAttributeNS}{namespaceURI, localName}
\var{namespaceURI}と\var{localName}によって指定した属性の値を
文字列として返します。
もし、属性が存在しない、もしくは属性に値が設定されていない場合、
空の文字列が返されます。
\end{methoddesc}

\begin{methoddesc}[Element]{getAttributeNodeNS}{namespaceURI, localName}
指定した \var{namespaceURI} および \var{localName} を持つ属性値を
ノードとして返します。
\end{methoddesc}

\begin{methoddesc}[Element]{removeAttribute}{name}
名前で指定された属性を削除します。該当する属性がなくても例外は送出
されません。
\end{methoddesc}

\begin{methoddesc}[Element]{removeAttributeNode}{oldAttr}
\var{oldAttr} が属性リストにある場合、削除して返します。
\var{oldAttr} が存在しない場合、\exception{NotFoundErr} が送出されます。
\end{methoddesc}

\begin{methoddesc}[Element]{removeAttributeNS}{namespaceURI, localName}
名前で指定された属性を削除します。このメソッドは \var{qname} では
なく \var{localName} を使うので注意してください。該当する
属性がなくても例外は送出されません。
\end{methoddesc}

\begin{methoddesc}[Element]{setAttribute}{name, value}
文字列を使って属性値を設定します。
\end{methoddesc}

\begin{methoddesc}[Element]{setAttributeNode}{newAttr}
新たな属性ノードを要素に追加します。\member{name} 属性が
既存の属性に一致した場合、必要に応じて属性を置き換えます。
置換が生じると、古い属性ノードが返されます。
\var{newAttr} がすでに使われていれば、
\exception{InuseAttributeErr} が送出されます。
\end{methoddesc}

\begin{methoddesc}[Element]{setAttributeNodeNS}{newAttr}
新たな属性ノードを要素に追加します。\member{namespaceURI} および
\member{localName} 属性が既存の属性に一致した場合、必要に応じて
属性を置き換えます。置換が生じると、古い属性ノードが返されます。
\var{newAttr} がすでに使われていれば、
\exception{InuseAttributeErr} が送出されます。
\end{methoddesc}

\begin{methoddesc}[Element]{setAttributeNS}{namespaceURI, qname, value}
指定された \var{namespaceURI} および \var{qname} で与えられた属性
の値を文字列で設定します。qname は属性の完全な名前であり、この点が
上記のメソッドと違うので注意してください。
\end{methoddesc}


\subsubsection{Attr オブジェクト \label{dom-attr-objects}}

\class{Attr} は \class{Node} を継承しており、全ての属性を受け継いで
います。

\begin{memberdesc}[Attr]{name}
要素型名です。名前空間使用の文書では、要素型名中にコロンが
あるかもしれません。
\end{memberdesc}

\begin{memberdesc}[Attr]{localName}
名前にコロンがあればコロン以降の部分に、なければ名前全体になります。
\end{memberdesc}

\begin{memberdesc}[Attr]{prefix}
名前にコロンがあればコロン以前の部分に、なければ空文字列になります。
\end{memberdesc}


\subsubsection{NamedNodeMap Objects \label{dom-attributelist-objects}}

\class{NamedNodeMap} は \class{Node} を継承して \emph{いません} 。

\begin{memberdesc}[NamedNodeMap]{length}
属性リストの長さです。
\end{memberdesc}

\begin{methoddesc}[NamedNodeMap]{item}{index}
特定のインデクスを持つ属性を返します。属性の並び方は任意ですが、
DOM 文書が生成されている間は一定になります。各要素は属性
ノードです。属性値はノードの \member{value} 属性で取得してください。
\end{methoddesc}

このクラスをよりマップ型的な動作ができるようにする実験的なメソッド
もあります。そうしたメソッドを使うこともできますし、
\class{Element} オブジェクトに対して、標準化された
\method{getAttribute*()} ファミリのメソッドを使うこともできます。


\subsubsection{Comment オブジェクト \label{dom-comment-objects}}
\class{Comment} は XML 文書中のコメントを表現します。
\class{Comment} は \class{Node} のサブクラスですが、
子ノードを持つことはありません。

\begin{memberdesc}[Comment]{data}
文字列によるコメントの内容です。この属性には、コメントの先頭にある
\code{<!-}\code{-} と末尾にある \code{-}\code{->} 間の全ての文字
が入っていますが、\code{<!-}\code{-} と\code{-}\code{->} 自体は
含みません。
\end{memberdesc}


\subsubsection{Text オブジェクトおよび CDATASection オブジェクト \label{dom-text-objects}}

\class{Text} インタフェースは XML 文書内のテキストを表現します。
パーザおよび DOM 実装が DOM の XML 拡張をサポートしている場合、
CDATA でマークされた区域 (section) に入れられている部分テキスト
は \class{CDATASection} オブジェクトに記憶されます。
これら二つのインタフェースは同一のものですが、\member{nodeType}
属性が異なります。

これらのインタフェースは \class{Node} インタフェースを拡張したもの
です。しかし子ノードを持つことはできません。

\begin{memberdesc}[Text]{data}
文字列によるテキストノードの内容です。
\end{memberdesc}

\begin{notice}
\class{CDATASection} ノードの利用は、ノードが完全な CDATA マーク区域
を表現するという意味ではなく、ノードの内容が CDATA 区域の一部である
ということを意味するだけです。
単一の CDATA セクションは文書ツリー内で複数のノードとして表現
されることがあります。二つの隣接する \class{CDATASection}
ノードが、異なる CDATA マーク区域かどうかを決定する方法はありません。
\end{notice}


\subsubsection{ProcessingInstruction オブジェクト \label{dom-pi-objects}}

XML 文書内の処理命令を表現します; \class{Node} インタフェース
を継承していますが、子ノードを持つことはできません。

\begin{memberdesc}[ProcessingInstruction]{target}
最初の空白文字までの処理命令の内容です。
読み出し専用の属性です。
\end{memberdesc}

\begin{memberdesc}[ProcessingInstruction]{data}
最初の空白文字以降の処理命令の内容です。
\end{memberdesc}


\subsubsection{例外 \label{dom-exceptions}}

\versionadded{2.1}

DOM レベル~2 勧告では、単一の例外 \exception{DOMException} と、
どの種のエラーが発生したかをアプリケーションが決定できるようにする
多くの定数を定義しています。
\exception{DOMException} インスタンスは、特定の例外に関する
適切な値を提供する \member{code} 属性を伴っています。

Python DOM インタフェースでは、上記の定数を提供していますが、
同時に一連の例外を拡張して、DOM で定義されている各例外コードに対して
特定の例外が存在するようにしています。
DOM の実装では、適切な特定の例外を送出しなければならず、
各例外は \member{code} 属性に対応する適切な値を伴わなければ
なりません。

\begin{excdesc}{DOMException}
全ての特定の DOM 例外で使われている基底例外クラスです。この例外
クラスは直接インスタンス化することができません。
\end{excdesc}

\begin{excdesc}{DomstringSizeErr}
指定された範囲のテキストが文字列に収まらない場合に送出されます。
この例外は Python の DOM 実装で使われるかどうかは判っていませんが、
Python で書かれていない DOM 実装から送出される場合があります。
\end{excdesc}

\begin{excdesc}{HierarchyRequestErr}
挿入できない型のノードを挿入しようと試みたときに送出されます。
\end{excdesc}

\begin{excdesc}{IndexSizeErr}
メソッドに与えたインデクスやサイズパラメタが負の値や許容範囲の
値を超えた際に送出されます。
\end{excdesc}

\begin{excdesc}{InuseAttributeErr}
文書中にすでに存在する \class{Attr} ノードを挿入しようと試みた
際に送出されます。
\end{excdesc}

\begin{excdesc}{InvalidAccessErr}
パラメタまたは操作が根底にあるオブジェクトでサポートされていない
場合に送出されます。
\end{excdesc}

\begin{excdesc}{InvalidCharacterErr}
この例外は、文字列パラメタが、現在使われているコンテキストで
XML 1.0 勧告によって許可されていない場合に送出されます。
例えば、要素型に空白の入った \class{Element} ノードを生成
しようとすると、このエラーが送出されます。
\end{excdesc}

\begin{excdesc}{InvalidModificationErr}
ノードの型を変更しようと試みた際に送出されます。
\end{excdesc}

\begin{excdesc}{InvalidStateErr}
定義されていないオブジェクトや、もはや利用できなくなったオブジェクトを
使おうと試みた際に送出されます。
\end{excdesc}

\begin{excdesc}{NamespaceErr}
\citetitle[http://www.w3.org/TR/REC-xml-names/]{Namespaces in XML}
に照らして許可されていない方法でオブジェクトを変更しようと
試みた場合、この例外が送出されます。
\end{excdesc}

\begin{excdesc}{NotFoundErr}
参照しているコンテキスト中に目的のノードが存在しない場合に送出される
例外です。例えば、\method{NamedNodeMap.removeNamedItem()} は
渡されたノードがノードマップ中に存在しない場合にこの例外を送出
します。
\end{excdesc}

\begin{excdesc}{NotSupportedErr}
要求された方のオブジェクトや操作が実装でサポートされていない場合に
送出されます。
\end{excdesc}

\begin{excdesc}{NoDataAllowedErr}
データ属性をサポートしないノードにデータを指定した際に送出されます。
  % XXX  a better explanation is needed!
\end{excdesc}

\begin{excdesc}{NoModificationAllowedErr}
オブジェクトに対して (読み出し専用ノードに対する修正のように) 
許可されていない修正を行おうと試みた際に送出されます。
\end{excdesc}

\begin{excdesc}{SyntaxErr}
無効または不正な文字列が指定された際に送出されます。
  % XXX  how is this different from InvalidCharacterErr ???
\end{excdesc}

\begin{excdesc}{WrongDocumentErr}
ノードが現在属している文書と異なる文書に挿入され、
かつある文書から別の文書へのノードの移行が実装でサポート
されていない場合に送出されます。
\end{excdesc}

DOM 勧告で定義されている例外コードは、以下のテーブルに従って
上記の例外と対応付けられます:

\begin{tableii}{l|l}{constant}{定数}{例外}
  \lineii{DOMSTRING_SIZE_ERR}{\exception{DomstringSizeErr}}
  \lineii{HIERARCHY_REQUEST_ERR}{\exception{HierarchyRequestErr}}
  \lineii{INDEX_SIZE_ERR}{\exception{IndexSizeErr}}
  \lineii{INUSE_ATTRIBUTE_ERR}{\exception{InuseAttributeErr}}
  \lineii{INVALID_ACCESS_ERR}{\exception{InvalidAccessErr}}
  \lineii{INVALID_CHARACTER_ERR}{\exception{InvalidCharacterErr}}
  \lineii{INVALID_MODIFICATION_ERR}{\exception{InvalidModificationErr}}
  \lineii{INVALID_STATE_ERR}{\exception{InvalidStateErr}}
  \lineii{NAMESPACE_ERR}{\exception{NamespaceErr}}
  \lineii{NOT_FOUND_ERR}{\exception{NotFoundErr}}
  \lineii{NOT_SUPPORTED_ERR}{\exception{NotSupportedErr}}
  \lineii{NO_DATA_ALLOWED_ERR}{\exception{NoDataAllowedErr}}
  \lineii{NO_MODIFICATION_ALLOWED_ERR}{\exception{NoModificationAllowedErr}}
  \lineii{SYNTAX_ERR}{\exception{SyntaxErr}}
  \lineii{WRONG_DOCUMENT_ERR}{\exception{WrongDocumentErr}}
\end{tableii}


\subsection{適合性 \label{dom-conformance}}
この節では適合性に関する要求と、Python DOM API、W3C DOM 勧告、
および OMG IDL の Python API への対応付けとの間の関係について
述べます。

\subsubsection{型の対応付け\label{dom-type-mapping}}

DOM 仕様で使われている基本的な IDL 型は、以下のテーブルに従って
Python の型に対応付けられています。

\begin{tableii}{l|l}{code}{IDL 型}{Python 型}
  \lineii{boolean}{\code{IntegerType} (値 \code{0} または \code{1}) による}
  \lineii{int}{\code{IntegerType}}
  \lineii{long int}{\code{IntegerType}}
  \lineii{unsigned int}{\code{IntegerType}}
\end{tableii}

さらに、勧告で定義されている \class{DOMString} は、Python 文字列
または Unicode 文字列に対応付けられます。アプリケーションでは、
DOM から文字列が返される際には常に Unicode を扱えなければ
なりません。

IDL の \keyword{null} 値は \code{None} に対応付けられており、
API で \keyword{null} の使用が許されている場所では常に受理されるか、
あるいは実装によって提供されるはずです。


\subsubsection{アクセサメソッド \label{dom-accessor-methods}}

OMG IDL から Python への対応付けは、 IDL \keyword{attribute} 
宣言へのアクセサ関数の定義を、Java による対応付けが行うのと
ほとんど同じように行います。

IDL 宣言の対応付け

\begin{verbatim}
readonly attribute string someValue;
         attribute string anotherValue;
\end{verbatim}

は、三つのアクセサ関数: \member{someValue} に対する ``get'' メソッド
(\method{_get_someValue()})、そして\member{anotherValue} に対する
``get'' および ``set'' メソッド (\method{_get_anotherValue()} および
\method{_set_anotherValue()}) を生み出します。
とりわけ、対応付けでは、IDL 属性が通常の Python 属性としてアクセス
可能であることは必須ではありません: \code{\var{object}.someValue} が
動作することは必須 \emph{ではなく} 、\exception{AttributeError}
を送出してもかまいません。

しかしながら、Python DOM API では、通常の属性アクセスが動作することが
必須です。これは、Python IDL コンパイラによって生成された典型的な
サロゲーションはまず動作することはなく、DOM オブジェクトが
CORBA を解してアクセスされる場合には、クライアント上で
ラッパオブジェクトが必要であることを意味します。
CORBA DOM クライアントでは他にもいくつか考慮すべきことがある一方で、
CORBA を介して DOM を使った経験を持つ実装者はこのことを問題視して
いません。\keyword{readonly} であると宣言された属性は、全ての
DOM 実装で書き込みアクセスを制限しているとは限りません。

Python DOM API では、アクセサ関数は必須ではありません。アクセサ関数が提供された場合、
Python IDL 対応付けによって定義された形式をとらなければなりませんが、
属性は Python から直接アクセスすることができるので、それらのメソッドは
必須ではないと考えられます。\keyword{readonly} であると宣言された
属性に対しては、 ``set'' アクセサを提供してはなりません。

このIDLでの定義はW3C DOM APIの全ての要件を実装しているわけではありません。
例えば、一部のオブジェクトの概念や
\method{getElementsByTagName()}が``live''であることなどです。
Python DOM API はこれらの要件を実装することを強制しません。

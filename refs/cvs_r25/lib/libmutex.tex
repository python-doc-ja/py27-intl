\section{\module{mutex} ---
         排他制御}

\declaremodule{standard}{mutex}
\sectionauthor{Moshe Zadka}{moshez@zadka.site.co.il}
\modulesynopsis{排他制御のためのロックとキュー}

\module{mutex} モジュールでは、ロック (lock) の獲得と解除によって
排他制御を可能にするクラスを定義しています。
排他制御はスレッドやマルチタスクを使う上で便利かもしれませんが、
このクラスがそうした機能を必要として (いたり、想定して) いるわけでは
ありません。

\module{mutex}モジュールでは以下のクラスを定義しています:

\begin{classdesc}{mutex}{}
新しい (ロックされてない) mutex を作ります。

mutex には 2 つの状態変数 --- ``ロック'' ビット (locked bit) と
キュー (queue) があります。
mutex がロックされていなければ、キューは空です。
それ以外の場合、キューは空になっているか、
\code{(\var{function}, \var{argument})} のペアが一つ以上入っています。
このペアはロックを獲得しようと待機している関数 (またはメソッド)
を表しています。
キューが空でないときに mutex をロック解除すると、キューの先頭の
エントリをキューから除去し、そのエントリのペアに基づいて
\code{\var{function}(\var{argument})} を呼び出します。
これによって、先頭にあったエントリが新たなロックを獲得します。

当然のことながらマルチスレッドの制御には利用できません -- というのも、
\method{lock()} が、ロックを獲得したら関数を呼び出すという
変なインタフェースだからです。
\end{classdesc}


\subsection{mutex オブジェクト \label{mutex-objects}}

\class{mutex} には以下のメソッドがあります:

\begin{methoddesc}[mutex]{test}{}
mutex がロックされているかどうか調べます。
\end{methoddesc}

\begin{methoddesc}[mutex]{testandset}{}
「原子的 (Atomic)」な Test-and-Set 操作です。
ロックがセットされていなければ獲得して \code{True} を返します。
それ以外の場合には\code{False}を返します。
\end{methoddesc}

\begin{methoddesc}[mutex]{lock}{function, argument}
mutex がロックされていなければ
\code{\var{function}(\var{argument})} を実行します。
mutex がロックされている場合、関数とその引数をキューに置きます。
キューに置かれた \code{\var{function}(\var{argument})} がいつ実行
されるかについては\method{unlock}を参照してください。
\end{methoddesc}

\begin{methoddesc}[mutex]{unlock}{}
キューが空ならば mutex をロック解除します。
そうでなければ、キューの最初の要素を実行します。
\end{methoddesc}

\section{\module{doctest} ---
         対話モードを使った使用例の内容をテストする}

\declaremodule{standard}{doctest}
\moduleauthor{Tim Peters}{tim@python.org}
\sectionauthor{Tim Peters}{tim@python.org}
\sectionauthor{Moshe Zadka}{moshez@debian.org}
\sectionauthor{Edward Loper}{edloper@users.sourceforge.net}

\modulesynopsis{対話モードを使った使用例の内容を検証するためのフレームワーク。}

\refmodule{doctest} モジュールは、対話的 Python セッションのように
見えるテキストを探し出し、セッションの内容を実行して、そこに書かれている
通りに振舞うかを調べます。 \refmodule{doctest} は以下のような用途に
よく使われています:

\begin{itemize}
\item モジュールの docstring (ドキュメンテーション文字列) 中にある対話
  モードでの使用例全てが書かれている通りに動作するかを検証することで、
  docstring の内容が最新のものになるよう保ちます。
\item テストファイルやテストオブジェクト中の対話モードにおける使用例が
  期待通りに動作するかを検証することで、回帰テストを実現します。
\item 入出力例をふんだんに使ったパッケージのチュートリアルドキュメントを
  書けます。入出力例と解説文のどちらに注目するかによって、ドキュメントは
  「読めるテスト」にも「実行できるドキュメント」にもなります。
\end{itemize}

以下にちょっとした、それでいて完全な例を示します:

\module{doctest} モジュールは、モジュールの docstring から、
これらのセッションを実際に実行して、そこに書かれている通りに動作するか
検証します。

\begin{verbatim}
"""
This is the "example" module.

The example module supplies one function, factorial().  For example,

>>> factorial(5)
120
"""

def factorial(n):
    """Return the factorial of n, an exact integer >= 0.

    If the result is small enough to fit in an int, return an int.
    Else return a long.

    >>> [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> [factorial(long(n)) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> factorial(30)
    265252859812191058636308480000000L
    >>> factorial(30L)
    265252859812191058636308480000000L
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be >= 0

    Factorials of floats are OK, but the float must be an exact integer:
    >>> factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    >>> factorial(30.0)
    265252859812191058636308480000000L

    It must also not be ridiculously large:
    >>> factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """

\end{verbatim}
% allow LaTeX to break here.
\begin{verbatim}

    import math
    if not n >= 0:
        raise ValueError("n must be >= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n+1 == n:  # catch a value like 1e300
        raise OverflowError("n too large")
    result = 1
    factor = 2
    while factor <= n:
        result *= factor  
        factor += 1
    return result

def _test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    _test()
\end{verbatim}

\file{example.py} をコマンドラインから直接実行すると、
\refmodule{doctest} はその魔法を働かせます:

\begin{verbatim}
$ python example.py
$
\end{verbatim}

出力は何もありません！ しかしこれが正常で、全ての例が正しく動作する
ことを意味しています。
スクリプトに \programopt{-v} を与えると、\refmodule{doctest} 
は何を行おうとしているのかを記録した詳細なログを出力し、
最後にまとめを出力します:

\begin{verbatim}
$ python example.py -v
Trying:
    factorial(5)
Expecting:
    120
ok
Trying:
    [factorial(n) for n in range(6)]
Expecting:
    [1, 1, 2, 6, 24, 120]
ok
Trying:
    [factorial(long(n)) for n in range(6)]
Expecting:
    [1, 1, 2, 6, 24, 120]
ok
\end{verbatim}

といった具合で、最後には:

\begin{verbatim}
Trying:
    factorial(1e100)
Expecting:
    Traceback (most recent call last):
        ...
    OverflowError: n too large
ok
1 items had no tests:
    __main__._test
2 items passed all tests:
   1 tests in __main__
   8 tests in __main__.factorial
9 tests in 3 items.
9 passed and 0 failed.
Test passed.
$
\end{verbatim}

これが、\module{doctest} を使って生産性の向上を目指す上で知っておく
必要があることの全てです！
さあやってみましょう。詳細な事柄は後続の各節で全て説明しています。
doctest の例は、標準の Python テストスイートやライブラリ中に
沢山あります。標準のテストファイル \file{Lib/test/test_doctest.py} 
には、特に便利な例題があります。

\file{doctest.py} 内の docstring には \module{doctest} の全ての側面に
ついての詳細な情報が入っており、ここではより重要な点をカバーするだけに
します。

\subsection{簡単な利用法: docstring 中の例題をチェックする
\label{doctest-simple-testmod}}

doctest を試す簡単な方法、(とはいえ、いつもそうする必要はないのですが) 
は、各モジュール \module{M} の最後を、以下:

\begin{verbatim}
def _test():
    import doctest, M
    doctest.testmod()

if __name__ == "__main__":
    _test()
\end{verbatim}

のようにして締めくくるやりかたです。

こうすると、\refmodule{doctest} は\module{M} 中の docstring を検査します。
モジュールをスクリプトとして実行すると、 docstring 中の例題が実行
され、検証されます:

\begin{verbatim}
python M.py
\end{verbatim}

ドキュメンテーション文字列に書かれた例の実行が失敗しない限り、何も
表示されません。失敗すると、失敗した例と、その原因が (場合によっては複数)
標準出力に印字され、最後に\samp{***Test Failed*** \var{N} failures.}
という行を出力します。ここで、\var{N} は失敗した例題の数です。

一方、\programopt{-v} スイッチをつけて走らせると:

\begin{verbatim}
python M.py -v
\end{verbatim}

実行を試みた全ての例について詳細に報告し、最後に各種まとめをおこなった
内容が標準出力に印字されます。

\code{verbose=True} を \function{testmod()} に渡せば、
詳細報告 (verbose) モードを強制できます。また、
\code{verbose=False} にすれば禁止できます。どちらの場合にも、
\function{testmod()} は \code{sys.argv} 上のスイッチ
を調べません。(従って、\programopt{-v} をつけても効果はありません)。

\function{testmod()} の詳しい情報は\ref{doctest-basic-api} 節を
参照してください。

\subsection{簡単な利用法: テキストファイル中の例題をチェックする
  \label{doctest-simple-testfile}}

doctest のもう一つの簡単な用途は、テキストファイル中にある対話操作の
例に対するテストです。これには \function{testfile()} 関数を使います:
 
\begin{verbatim}
import doctest
doctest.testfile("example.txt")
\end{verbatim}

この短いスクリプトは、\file{example.txt} というファイルの中に入っている
対話モードの Python 操作例全てを実行して、その内容を検証します。
ファイルの内容は一つの巨大な docstring であるかのように扱われます;
ファイルが Python プログラムでなくてもよいのです！ 例えば、
\file{example.txt} には以下のような内容が入っているかもしれません:

\begin{verbatim}
The ``example`` module
======================

Using ``factorial``
-------------------
This is an example text file in reStructuredText format.  First import
``factorial`` from the ``example`` module:
 
    >>> from example import factorial
 
Now use it:
 
    >>> factorial(6)
    120
\end{verbatim}

\code{doctest.testfile("example.txt")} を実行すると、
このドキュメント内のエラーを見つけ出します:

\begin{verbatim}
File "./example.txt", line 14, in example.txt
Failed example:
    factorial(6)
Expected:
    120
Got:
    720
\end{verbatim}

\function{testmod()} と同じく、\function{testfile()} は例題が失敗しない
限り何も表示しません。例題が失敗すると、失敗した例題とその原因が
(場合によっては複数) \function{testmod()} と同じ書式で標準出力に
書き出されます。

デフォルトでは、\function{testfile()} は自分自身を呼び出した
モジュールのあるディレクトリを探します。その他の場所にあるファイルを
見に行くように\function{testfile()} に指示するためのオプション引数に
ついての説明は \ref{doctest-basic-api} 節を参照してください。

\function{testmod()} と同様、コマンドラインオプション\programopt{-v} 
またはオプションのキーワード引数 \var{verbose} を使うと、
\function{testfile()} の冗長度を設定できます。

\function{testfile()} の詳細は\ref{doctest-basic-api}
節を参照してください。

\subsection{doctest のからくり\label{doctest-how-it-works}}

この節では、doctest のからくり: どの docstring を見に行くのか、
どうやって対話操作例を見つけ出すのか、どんな実行コンテキストを使うのか、
例外をどう扱うか、上記の振る舞いを制御するためにどのような
オプションフラグを使うか、について詳しく吟味します。こうした情報は、
doctest に対応した例題を書くために必要な知識です; 書いた例題に対して
実際に doctest を実行する上で必要な情報については後続の節を参照して
ください。

\subsubsection{どのドキュメンテーション文字列が検証されるのか?
\label{doctest-which-docstrings}}

モジュールのドキュメンテーション文字列、
全ての関数、クラスおよびメソッドのドキュメンテーション文字列が
検索されます。モジュールに import されたオブジェクトは
検索されません。

加えて、 \code{M.__test__} が存在し、 "真の値を持つ" 場合、
この値は辞書で、辞書の各エントリは (文字列の) 名前を
関数オブジェクト、クラスオブジェクト、または文字列に対応付けて
いなくてはなりません。\code{M.__test__} から得られた関数および
クラスオブジェクトのドキュメンテーション文字列は、その名前が
プライベートなものでも検索され、文字列の場合にはそれが
ドキュメンテーション文字列であるかのように直接検索を行います。
出力においては、\code{M.__test__} におけるキー \code{K}
は、

\begin{verbatim}
<name of M>.__test__.K
\end{verbatim}

のように表示されます。

検索中に見つかったクラスも同様に再帰的に検索が行われ、
クラスに含まれているメソッドおよびネストされたクラスについて
ドキュメンテーション文字列のテストが行われます。

\versionchanged["プライベート名" の概念は撤廃されたため、今後は
  ドキュメントにしません]{2.4}
 
\subsection{ドキュメンテーション文字列内の例をどうやって認識するのか?
  \label{doctest-finding-examples}}

ほとんどの場合、対話コンソールセッション上でのコピー／ペーストはうまく
動作します。とはいえ、 \module{doctest} は特定の Python シェルの振る舞い
を正確にエミュレーションしようとするわけではありません。ハードタブは
全て 8 カラムのタブストップを使ってスペースに展開されます。従って、
タブがそのように表現されると考えておかないととまずいことになります:
その場合は、ハードタブを使わないか、自前で \class{DocTestParser}
クラスを書いてください。

\versionchanged[新たにタブをスペースに展開するようになりました; 以前の
  バージョンはハードタブを保存しようとしていたので、混乱させるような
  テスト結果になってしまっていました]{2.4}
 
\begin{verbatim}
>>> # comments are ignored
>>> x = 12
>>> x
12
>>> if x == 13:
...     print "yes"
... else:
...     print "no"
...     print "NO"
...     print "NO!!!"
...
no
NO
NO!!!
>>>
\end{verbatim}

出力結果例  (expected output) は、コードを含む最後の
\code{'>>>~'} or \code{'...~'} 行の直下に続きます。
また、出力結果例 (がある場合) は、次の \code{'>>>~'}
行か、全て空白文字の行まで続きます。

細かな注意:

\begin{itemize}

\item 出力結果例には、全て空白の行が入っていてはなりません。そのような行は
  出力結果例の終了を表すと見なされるからです。もし予想出力結果の内容
  に空白行が入っている場合には、空白行が入るべき場所全てに
  \code{<BLANKLINE>} を入れてください。
  \versionchanged[\code{<BLANKLINE>} を追加しました; 以前のバージョンでは、
  空白行の入った予想出力結果を扱う方法がありませんでした]{2.4}

\item stdout への出力は取り込まれますが、stderr は取り込まれません (例外
  発生時のトレースバックは別の方法で取り込まれます)。

\item 対話セッションにおいて、バックスラッシュを用いて次の行に続ける場合や、
  その他の理由でバックスラッシュを用いる場合、raw docstring を使って
  バックスラッシュを入力どおりに扱わせるようにせねばなりません:

\begin{verbatim}
>>> def f(x):
...     r'''Backslashes in a raw docstring: m\n'''
>>> print f.__doc__
Backslashes in a raw docstring: m\n
\end{verbatim}

こうしなければ、バックスラッシュは文字列の一部として解釈されてしまいますう。
例えば、上の例の "{\textbackslash}" は改行文字として認識されてしまうでしょう。
こうする代わりに、(raw docstring を使わずに) doctest 版の中では
バックスラッシュを全て二重にしてもかまいません:

\begin{verbatim}
>>> def f(x):
...     '''Backslashes in a raw docstring: m\\n'''
>>> print f.__doc__
Backslashes in a raw docstring: m\n
\end{verbatim}

\item 開始カラムはどこでもかまいません:

\begin{verbatim}
  >>> assert "Easy!"
        >>> import math
            >>> math.floor(1.9)
            1.0
\end{verbatim}
出力結果例の先頭部にある空白文字列は、例題の開始部分にあたる
\code{'>>>~'} 行の先頭にある空白文字列と同じだけはぎとられます。
\end{itemize}

\subsection{実行コンテキストとは何か?}

デフォルトでは、\refmodule{doctest} はテストを行うべき docstring
を見つけるたびに \module{M} のグローバル名前空間の\emph{浅いコピー} 
を使い、テストの実行によってモジュール
の実際のグローバル名前空間を変更しないようにし、かつ\module{M} 内で
行ったテストが痕跡を残して偶発的に別のテストを誤って動作させないように
しています。従って、例題中では \module{M} 内のトップレベルで定義された
すべての名前と、docstring ドキュメンテーション文字列が動作する以前に
定義された名前を自由に使えます。個々の例題は他の docstring 中で
定義された名前を参照できません。

\function{testmod()} や \function{testfile()}に \code{globs=your_dict} を
渡し、自前の辞書を実行コンテキストとして使うこともできます。

\subsection{例外はどう扱えばよいのですか?}

例で生成される出力がトレースバックのみである限り問題ありません:
単にトレースバックを貼り付けてください。\footnote{予想出力結果
と例外の両方を含んだ例はサポートされていません。一方の終わりと
他方の始まりを見分けようとするのはエラーの元になりがちですし、
解りにくいテストになってしまいます。}
トレースバックには、
頻繁に変更されがちな情報が入っている (例えばファイルパスや行番号など)
ものなので、受け入れるべきテスト結果に柔軟性を持たせようと doctest が
苦労している部分の一つです。

簡単な例を示しましょう:

\begin{verbatim}
>>> [1, 2, 3].remove(42)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: list.remove(x): x not in list
>>>
\end{verbatim}

この doctest は \exception{ValueError} が送出され、かつ詳細情報に
\samp{list.remove(x): x not in list} が入っている場合にのみ成功します。

例外が発生したときの予想出力はトレースバックヘッダから始まっていなければ
なりません。トレースバックの形式は以下の二通りの行のいずれかでよく、
例題の最初の行と同じインデントでなければりません:

\begin{verbatim}
Traceback (most recent call last):
Traceback (innermost last):
\end{verbatim}

トレースバックヘッダの後ろにトレースバックスタックを続けてもかまいませんが、
doctest はその内容を無視します。普通はトレースバックスタックを無視するか、
対話セッションからそのままコピーしてきます。

トレースバックスタックの後ろにはもっとも有意義な部分、例外の型と
詳細情報の入った行があります。通常、この行はトレースバックの末尾
にあるのですが、例外が複数行の詳細情報を持っている場合、複数の行
にわたることもあります:

\begin{verbatim}
>>> raise ValueError('multi\n    line\ndetail')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: multi
    line
detail
\end{verbatim}

上の例では、最後の 3 行 (\exception{ValueError} から始まる行) 
における例外の型と詳細情報だけが比較され、それ以外の部分は無視
されます。

例外を扱うコツは、例題をドキュメントとして読む上で明らかに価値の
ある情報でない限り、トレースバックスタックは無視する、ということ
です。従って、先ほどの例は以下のように書くべきでしょう:

\begin{verbatim}
>>> raise ValueError('multi\n    line\ndetail')
Traceback (most recent call last):
    ...
ValueError: multi
    line
detail
\end{verbatim}

トレースバックの扱いは非常に特殊なので注意してください。特に、
上の書き直した例題では、\samp{...} の扱いが doctest の 
\constant{ELLIPSIS} オプションによって変わります。この例での省略記号
は何かの省略を表しているかもしれませんし、コンマや数字が 3 個 (または
300 個かもしれませんし、Monty Python のスキットをインデントして
書き写したものかもしれません。

以下の詳細はずっと覚えておく必要はないのですが、一度目を通しておいて
ください:

\begin{itemize}

\item doctest は予想出力の出所が print 文なのか例外なのかを推測
  できません。従って、例えば予想出力が \samp{ValueError: 42 is prime} 
  であるような例題は、\exception{ValueError} が実際に送出された
  場合と、万が一予想出力と同じ文字列を print した場合の両方で
  パスしてしまいます。現実的には、通常の出力がトレースバックヘッダ
  から始まることはないので、さしたる問題にはなりません。

\item トレースバックスタック (がある場合) の各行は、例題の最初の行
  よりも深くインデントされているか、\emph{または} 英数文字以外で
  始まっていなければなりません。トレースバックヘッダ以後に現れる行の
  うち、インデントが等しく英数文字で始まる最初の行は例外の詳細情報
  が書かれた行とみなされるからです。もちろん、通常のトレースバックでは
  全く正しく動作します。

\item doctest のオプション\constant{IGNORE_EXCEPTION_DETAIL} を指定
  した場合、最も左端のコロン以後の内容が無視されます。

\item 対話シェルでは、\exception{SyntaxError} の場合にトレースバック
  ヘッダを無視することがあります。しかし doctest にとっては、例外を例外で
  ないものと区別するためにトレースバックヘッダが必要です。
  そこで、トレースバックヘッダを省略するような\exception{SyntaxError} 
  をテストする必要があるというごく稀なケースでは、例題に自分で作った
  トレースバックヘッダを追加する必要があるでしょう。

\item \exception{SyntaxError} の場合、 Python は構文エラーの起きた
  場所を\code{\^} マーカで表示します:

\begin{verbatim}
>>> 1 1
  File "<stdin>", line 1
    1 1
      ^
SyntaxError: invalid syntax
\end{verbatim}

例外の型と詳細情報の前にエラー位置を示す行がくるため、 doctest は
この行を調べません。例えば、以下の例では、間違った場所に\code{\^} 
マーカを入れてもパスしてしまいます:

\begin{verbatim}
>>> 1 1
Traceback (most recent call last):
  File "<stdin>", line 1
    1 1
    ^
SyntaxError: invalid syntax
\end{verbatim}

\end{itemize}

\versionchanged[複数行からなる例外の詳細情報を扱えるようにし、
  doctest オプション\constant{IGNORE_EXCEPTION_DETAIL} を追加しました]{2.4}

\subsubsection{オプションフラグとディレクティブ\label{doctest-options}}

doctest では、その挙動の様々な側面をたくさんのオプションフラグで制御
しています。各フラグのシンボル名はモジュールの定数として提供されて
おり、論理和で組み合わせて様々な関数に渡せるようになっています。
シンボル名は doctest のディレクティブ (directive, 下記参照) としても
使えます。

最初に説明するオプション群は、 テストのセマンティクスを決めます。
すなわち、実際にテストを実行したときの出力と例題中の予想出力とが
一致しているかどうかを doctest がどうやって判断するかを制御します:

\begin{datadesc}{DONT_ACCEPT_TRUE_FOR_1}
  デフォルトでは、予想出力ブロックに単に\code{1} だけが入っており、
  実際の出力ブロックに \code{1} または \code{True} だけが入って
  いた場合、これらの出力は一致しているとみなされます。
  \code{0} と \code{False} の場合も同様です。
  \constant{DONT_ACCEPT_TRUE_FOR_1} を指定すると、こうした値の読み替え
  を行いません。デフォルトの挙動で読み替えを行うのは、最近の Python で
  多くの関数の戻り値型が整数型からブール型に変更されたことに対応する
  ためです; 読み替えを行う場合、"通常の整数" の出力を予想出力とする
  ような doctest も動作します。このオプションはそのうち無くなるでしょうが、
  ここ数年はそのままでしょう。
\end{datadesc}

\begin{datadesc}{DONT_ACCEPT_BLANKLINE}
  デフォルトでは、予想出力ブロックに \code{<BLANKLINE>} だけの
  入った行がある場合、その行は実際の出力における空行に一致する
  ようになります。完全な空行を入れてしまうと予想出力がそこで
  終わっているとみなされてしまうため、空行を予想出力に入れたい
  場合にはこの方法を使わねばなりません。
  \constant{DONT_ACCEPT_BLANKLINE} を指定すると、
  \code{<BLANKLINE>} の読み替えを行わなくなります。
\end{datadesc}

\begin{datadesc}{NORMALIZE_WHITESPACE}
  このフラグを指定すると、空白 (空白と改行文字) の列は互いに等価であると
  みなします。予想出力における任意の空白列は実際の出力における任意の
  空白と一致します。デフォルトでは、空白は厳密に一致せねばなりません。
  \constant{NORMALIZE_WHITESPACE} は、予想出力の内容が非常に長いために、
  ソースコード中でその内容を複数行に折り返して書きたい場合に特に便利です。
\end{datadesc}

\begin{datadesc}{ELLIPSIS}
  このフラグを指定すると、予想出力中の省略記号マーカ (\code{...}) 
  を実際の出力中の任意の部分文字列に一致させられます。部分文字列は
  行境界にわたるものや空文字列を含みます。従って、このフラグを使うのは
  単純な内容を対象にする場合にとどめましょう。複雑な使い方をすると、
  正規表現に \regexp{.*} を使ったときのように
  "あらら、省略部分をマッチがえてる (match too much) ！" 
  と驚くことになりかねません。
\end{datadesc}

\begin{datadesc}{IGNORE_EXCEPTION_DETAIL}
  このフラグを指定すると、予想される実行結果に例外が入るような例題で、
  予想通りの型の例外が送出された場合に、例外の詳細情報が一致していなくても
  テストをパスさせます。例えば、予想出力が\samp{ValueError: 42} 
  であるような例題は、実際に送出された例外が\samp{ValueError: 3*14} でも
  パスしますが、\exception{TypeError} が送出されるといった場合には
  パスしません。

  \constant{ELLIPSIS} を使っても同様のことができ、
  \constant{IGNORE_EXCEPTION_DETAIL} は リリース 2.4 以前の Python
  を使う人がほとんどいなくなった時期を見計らって撤廃するかもしれないので
  気をつけてください。それまでは、\constant{IGNORE_EXCEPTION_DETAIL} は
  2.4 以前の Python で例外の詳細については気にせずテストをパスさせるように
  doctest を書くための唯一の明確な方法です。例えば、

\begin{verbatim}
>>> (1, 2)[3] = 'moo' #doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: object doesn't support item assignment
\end{verbatim}

にすると、 Python 2.4 と Python 2.3 の両方でテストをパスさせられます。
というのは、例外の詳細情報は 2.4 で変更され、 "doesn't" から "does not" 
と書くようになったからです。

\end{datadesc}

\begin{datadesc}{SKIP}

  このフラグを指定すると、例題は一切実行されません。こうした機能
  は doctest の実行例がドキュメントとテストを兼ねていて、ドキュメントの
  ためには含めておかなければならないけれどチェックされなくても良い、と
  いうような文脈で役に立ちます。例えば、実行例の出力がランダムであると
  か、テスト機構には手が届かない資源に依存している場合などです。

  SKIP フラグは一時的に例題を"コメントアウト"するのにも使えます。

\end{datadesc}

\begin{datadesc}{COMPARISON_FLAGS}
  上記の比較フラグ全ての論理和をとったビットマスクです。
\end{datadesc}

二つ目のオプション群は、テストの失敗を報告する方法を制御します:

\begin{datadesc}{REPORT_UDIFF}
  このオプションを指定すると、複数行にわたる予想出力や実際の出力
  を、一元化 (unified) diff を使って表示します。
\end{datadesc}

\begin{datadesc}{REPORT_CDIFF}
  このオプションを指定すると、複数行にわたる予想出力や実際の出力
  を、コンテキスト diff を使って表示します。
\end{datadesc}

\begin{datadesc}{REPORT_NDIFF}
  このオプションを指定すると、予想出力と実際の出力との間の差分を
  よく知られている\file{ndiff.py} ユーティリティと同じアルゴリズムを
  使っている \code{difflib.Differ} で分析します。これは、行単位の差分
  と同じように行内の差分にマーカをつけられるようにする唯一の手段です。
  例えば、予想出力のある行に数字の \code{1} が入っていて、実際の出力
  には \code{l} が入っている場合、不一致のおきているカラム位置を
  示すキャレットの入った行が一行挿入されます。
\end{datadesc}

\begin{datadesc}{REPORT_ONLY_FIRST_FAILURE}
  このオプションを指定すると、各 doctest で最初にエラーの起きた例題
  だけを表示し、それ以後の例題の出力を抑制します。これにより、正しく
  書かれた例題が、それ以前の例題の失敗によっておかしくなってしまった
  場合に、doctest がそれを報告しないようになります。とはいえ、
  最初に失敗を引き起こした例題とは関係なく誤って書かれた例題の
  報告も抑制してしまいます。\constant{REPORT_ONLY_FIRST_FAILURE} を
  指定した場合、例題がどこかで失敗しても、それ以後の例題を続けて実行し、
  失敗したテストの総数を報告します; 出力が抑制されるだけです。
\end{datadesc}

\begin{datadesc}{REPORTING_FLAGS}
  上記のエラー報告に関するフラグ全ての論理和をとったビットマスクです。
\end{datadesc}

「doctest ディレクティブ」を使うと、個々の例題に対してオプションフラグ
の設定を変更できます。 doctest ディレクティブは特殊な Python コメント文
として表現され、例題のソースコードの後に続けます:

\begin{productionlist}[doctest]
    \production{directive}
               {"\#" "doctest:" \token{directive_options}}
    \production{directive_options}
               {\token{directive_option} ("," \token{directive_option})*}
    \production{directive_option}
               {\token{on_or_off} \token{directive_option_name}}
    \production{on_or_off}
               {"+" | "-"}
    \production{directive_option_name}
               {"DONT_ACCEPT_BLANKLINE" | "NORMALIZE_WHITESPACE" | ...}
\end{productionlist}

\code{+} や\code{-} とディレクティブオプション名の間に空白を入れては
なりません。ディレクティブオプション名は上で説明したオプションフラグ名
のいずれかです。

ある例題の doctest ディレクティブは、その例題だけの doctest の
振る舞いを変えます。ある特定の挙動を有効にしたければ \code{+} を、
無効にしたければ \code{-} を使います。

例えば、以下のテストはパスします:

\begin{verbatim}
>>> print range(20) #doctest: +NORMALIZE_WHITESPACE
[0,   1,  2,  3,  4,  5,  6,  7,  8,  9,
10,  11, 12, 13, 14, 15, 16, 17, 18, 19]
\end{verbatim}

ディレクティブがない場合、実際の出力には一桁の数字の間に二つスペースが
入っていないこと、実際の出力は 1 行になることから、テストはパスしない
はずです。別のディレクティブを使って、このテストをパスさせることも
できます:

\begin{verbatim}
>>> print range(20) # doctest:+ELLIPSIS
[0, 1, ..., 18, 19]
\end{verbatim}

複数のディレクティブは、一つの物理行の中にコンマで区切って指定できます:

\begin{verbatim}
>>> print range(20) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
[0,    1, ...,   18,    19]
\end{verbatim}

一つの例題中で複数のディレクティブコメントを使った場合、それらは
組み合わされます:

\begin{verbatim}
>>> print range(20) # doctest: +ELLIPSIS
...                 # doctest: +NORMALIZE_WHITESPACE
[0,    1, ...,   18,    19]
\end{verbatim}

前の例題で示したように、\samp{...} の後ろにディレクティブだけの
入った行を例題のうしろに追加して書けます。この書きかたは、
例題が長すぎるためにディレクティブを同じ行に入れると収まりが悪い
場合に便利です:

\begin{verbatim}
>>> print range(5) + range(10,20) + range(30,40) + range(50,60)
... # doctest: +ELLIPSIS
[0, ..., 4, 10, ..., 19, 30, ..., 39, 50, ..., 59]
\end{verbatim}

デフォルトでは全てのオプションが無効になっており、ディレクティブは
特定の例題だけに影響を及ぼすので、通常意味があるのは有効にするための
オプション(\code{+} のついたディレクティブ) だけです。とはいえ、
doctest を実行する関数はオプションフラグを指定してデフォルトとは
異なった挙動を実現できるので、そのような場合には \code{-} を使った
無効化オプションも意味を持ちます。

\versionchanged[定数 \constant{DONT_ACCEPT_BLANKLINE},
    \constant{NORMALIZE_WHITESPACE}, \constant{ELLIPSIS},
    \constant{IGNORE_EXCEPTION_DETAIL},
    \constant{REPORT_UDIFF}, \constant{REPORT_CDIFF},
    \constant{REPORT_NDIFF}, \constant{REPORT_ONLY_FIRST_FAILURE},
    \constant{COMPARISON_FLAGS}, \constant{REPORTING_FLAGS}
    を追加しました。予想出力中の \code{<BLANKLINE>} がデフォルトで
    実際の出力中の空行にマッチするようになりました。また、
    doctest ディレクティブが追加されました]{2.4}
\versionchanged[定数 \constant{SKIP} が追加されました]{2.5}

新たなオプションフラグ名を登録する方法もありますが、\refmodule{doctest}
の内部をサブクラスで拡張しない限り、意味はないでしょう:

\begin{funcdesc}{register_optionflag}{name}
  名前\var{name} の新たなオプションフラグを作成し、作成されたフラグの
  整数値を返します。\function{register_optionflag()} は
  \class{OutputChecker} や  \class{DocTestRunner} をサブクラス化して、
  その中で新たに作成したオプションをサポートさせる際に使います。
  \function{register_optionflag} は以下のような定形文で呼び出さねば
  なりません:

\begin{verbatim}
  MY_FLAG = register_optionflag('MY_FLAG')
\end{verbatim}

  \versionadded{2.4}
\end{funcdesc}

\subsubsection{注意\label{doctest-warnings}}

\module{doctest} では、予想出力に対する厳密な一致を厳しく求めて
います。一致しない文字が一文字でもあると、テストは失敗してしまいます。
このため、Python が出力に関して何を保証していて、何を保証していないかを
正確に知っていないと幾度か混乱させられることでしょう。
例えば、辞書を出力する際、Python はキーと値のペアが常に特定の順番で
並ぶよう保証してはいません。従って、以下のようなテスト

% Hey! What happened to Monty Python examples?
% Tim: ask Guido -- it's his example!
\begin{verbatim}
>>> foo()
{"Hermione": "hippogryph", "Harry": "broomstick"}
\end{verbatim}

は失敗するかもしれないのです! 回避するには

\begin{verbatim}
>>> foo() == {"Hermione": "hippogryph", "Harry": "broomstick"}
True
\end{verbatim}

とするのが一つのやり方です。別のやり方は、

\begin{verbatim}
>>> d = foo().items()
>>> d.sort()
>>> d
[('Harry', 'broomstick'), ('Hermione', 'hippogryph')]
\end{verbatim}

です。

他にもありますが、自分で考えてみてください。

以下のように、オブジェクトアドレスを埋め込むような結果を
print するのもよくありません:

\begin{verbatim}
>>> id(1.0) # certain to fail some of the time
7948648
>>> class C: pass
>>> C()   # the default repr() for instances embeds an address
<__main__.C instance at 0x00AC18F0>
\end{verbatim}

\constant{ELLIPSIS} ディレクティブを使うと、上のような例をうまく解決
できます:

\begin{verbatim}
>>> C() #doctest: +ELLIPSIS
<__main__.C instance at 0x...>
\end{verbatim}

浮動小数点数もまた、プラットフォーム間での微妙な出力の違いの原因となり
ます。というのも、Python は浮動小数点の書式化をプラットフォームの 
C ライブラリにゆだねており、この点では、C ライブラリはプラットフォーム間で
非常に大きく異なっているからです。

\begin{verbatim}
>>> 1./7  # risky
0.14285714285714285
>>> print 1./7 # safer
0.142857142857
>>> print round(1./7, 6) # much safer
0.142857
\end{verbatim}

\code{I/2.**J} の形式になる数値はどのプラットフォームでもうまく
動作するので、私はこの形式の数値を生成するように doctest の例題を
工夫しています:

\begin{verbatim}
>>> 3./4  # utterly safe
0.75
\end{verbatim}

このように、単分数 (simple fraction) を使えば、人間にとっても
理解しやすくよいドキュメントになります。

\subsection{基本 API\label{doctest-basic-api}}

関数 \function{testmod()} および \function{testfile()} は、
基本的なほとんどの用途に十分な doctest インタフェースを提供しています。
これら二つの関数についてもっとくだけた説明を読みたければ、
\ref{doctest-simple-testmod} 節および \ref{doctest-simple-testfile} 節
を参照してください。

\begin{funcdesc}{testfile}{filename\optional{, module_relative}\optional{,
                          name}\optional{, package}\optional{,
                          globs}\optional{, verbose}\optional{,
                          report}\optional{, optionflags}\optional{,
                          extraglobs}\optional{, raise_on_error}\optional{,
                          parser}\optional{, encoding}}

\var{filename} 以外の引数は全てオプションで、キーワード引数形式で
指定せねばなりません。

\var{filename} に指定したファイル内にある例題をテストします。
\samp{(\var{failure_count}, \var{test_count})} を返します。

オプション引数の \var{module_relative} は、ファイル名をどのように
解釈するかを指定します:

  \begin{itemize}
  \item \var{module_relative} が \code{True} (デフォルト) の場合、
    \var{filename} は OS に依存しないモジュールの相対パスになります。
    デフォルトでは、このパスは関数 \function{testfile} を呼び出して
    いるモジュールからの相対パスになります; ただし、\var{package}
    引数を指定した場合には、パッケージからの相対になります。
    OS への依存性を除くため、\var{filename} ではパスを分割する
    文字に\code{/} を使わねばならず、絶対パスにしてはなりません
    (パス文字列を\code{/} で始めてはなりません)。
  \item \var{module_relative} が \code{False} の場合、\var{filename}
    は OS 依存のパスを示します。パスは絶対パスでも相対パスでも
    かまいません; 相対パスにした場合、現在の作業ディレクトリを
    基準に解決します。
  \end{itemize}

オプション引数 \var{name} には、テストの名前を指定します; デフォルトの
場合や \code{None} を指定した場合、 
\code{os.path.basename(\var{filename})} になります。

オプション引数 \var{package} には、 Python パッケージを指定するか、
モジュール相対のファイル名の場合には相対の基準ディレクトリとなる
Python パッケージの名前を指定します。パッケージを指定しない倍、
関数を呼び出しているモジュールのディレクトリを相対の基準
ディレクトリとして使います。\var{module_relative} を\code{False}
に指定している場合、\var{package} を指定するとエラーになります。

オプション引数\var{globs} には辞書を指定します。この辞書は、
例題を実行する際のグローバル変数として用いられます。
doctest はこの辞書の浅いコピーを生成するので、例題は白紙の
状態からスタートします。デフォルトの場合や\code{None} を指定
した場合、新たな空の辞書になります。

オプション引数 \var{extraglobs} には辞書を指定します。この辞書は、
例題を実行する際にグローバル変数にマージされます。マージは
\method{dict.update()} のように振舞います: \var{globs} と
\var{extraglobs} との間に同じキー値がある場合、両者を合わせた
辞書中には\var{extraglobs} の方の値が入ります。この仕様は、
パラメタ付きで doctest を実行するという、やや進んだ機能です。
例えば、一般的な名前を使って基底クラス向けに doctest を書いておき、
その後で辞書で一般的な名前からテストしたいサブクラスへの対応付けを
行う辞書を\var{extraglobs} に渡して、様々なサブクラスをテスト
できます。

オプション引数 \var{verbose} が真の場合、様々な情報を出力します。
偽の場合にはテストの失敗だけを報告します。デフォルトの場合や \code{None}
を指定した場合、\code{sys.argv} に \code{-v} を指定しない限り
この値は真になりません。

オプション引数\var{report} が真の場合、テストの最後にサマリを
出力します。それ以外の場合には何も出力しません。verbose モードの
場合、サマリには詳細な情報を出力しますが、そうでない場合には
サマリはとても簡潔になります (実際には、全てのテストが成功した場合には
何も出力しません)。

オプション引数 \var{optionflags} は、各オプションフラグの論理和を
とった値を指定します。\ref{doctest-options} 節を参照してください。

オプション引数 \var{raise_on_error} の値はデフォルトでは偽です。
真にすると、最初のテスト失敗や予期しない例外が起きたときに例外を
送出します。このオプションを使うと、失敗の原因を検死デバッグ
(post-mortem debug) できます。デフォルトの動作では、例題の実行を
継続します。

オプション引数 \var{parser} には、\class{DocTestParser} (または
そのサブクラス) を指定します。このクラスはファイルから例題を抽出
するために使われます。デフォルトでは通常のパーザ 
(\code{\class{DocTestParser}()}) です。

オプション引数 \var{encoding} にはファイルをユニコードに変換する際に使われる
エンコーディングを指定します。

  \versionadded{2.4}

  \versionchanged[\var{encoding} パラメタが追加されました]{2.5}

\end{funcdesc}

\begin{funcdesc}{testmod}{\optional{m}\optional{, name}\optional{,
                          globs}\optional{, verbose}\optional{,
                          report}\optional{,
                          optionflags}\optional{, extraglobs}\optional{,
                          raise_on_error}\optional{, exclude_empty}}

引数は全てオプションで、\var{m}以外の引数はキーワード引数として
指定せねばなりません。

モジュール \var{m} (\var{m} を指定しないか\code{None} にした場合には
\module{__main__}) から到達可能な関数およびクラスの docstring 内に
ある例題をテストします。\code{\var{m}.__doc__} 内の例題からテストを
開始します。

また、辞書 \code{\var{m}.__test__} が存在し、\code{None} で
ない場合、この辞書から到達できる例題もテストします。
\code{\var{m}.__test__} は、(文字列の) 名前から関数、クラスおよび
文字列への対応付けを行っています。関数およびクラスの場合には、
その docstring 内から例題を検索します。文字列の場合には、docstring
と同じようにして例題の検索を直接実行します。

モジュール\var{m} に属するオブジェクトにつけられた docstrings のみを
検索します。

\samp{(\var{failure_count}, \var{test_count})} を返します。

オプション引数 \var{name} には、モジュールの名前を指定します。
デフォルトの場合や\code{None} を指定した場合には、 
\code{\var{m}.__name__} を使います。

オプション引数 \var{exclude_empty} はデフォルトでは偽になっています。
この値を真にすると、doctest を持たないオブジェクトを考慮から
外します。デフォルトの設定は依存のバージョンとの互換性を考えたハック
であり、\method{doctest.master.summarize()} と \function{testmod()} を
合わせて利用しているようなコードでも、テスト例題を持たないオブジェクト
から出力を得るようにしています。
新たに追加された\class{DocTestFinder} のコンストラクタの
\var{exclude_empty} はデフォルトで真になります。

オプション引数 \var{extraglobs}, \var{verbose}, \var{report},
  \var{optionflags}, \var{raise_on_error}, および \var{globs} は
上で説明した \function{testfile()} の引数と同じです。ただし、
\var{globs} のデフォルト値は\code{\var{m}.__dict__} になります。

  \versionchanged[\var{optionflags} パラメタを追加しました]{2.3}

  \versionchanged[\var{extraglobs}, \var{raise_on_error}
                  および\var{exclude_empty} パラメタを追加しました]{2.4}

  \versionchanged[オプション引数 \var{isprivate} は、2.4 では非推奨でしたが、
                  廃止されました]{2.5}
\end{funcdesc}

単一のオブジェクトに関連付けられた doctest を実行するための関数も
あります。この関数は以前のバージョンとの互換性のために提供されて
います。この関数を撤廃する予定はありませんが、役に立つことは
ほとんどありません:

\begin{funcdesc}{run_docstring_examples}{f, globs\optional{,
                            verbose}\optional{, name}\optional{,
                            compileflags}\optional{, optionflags}}

オブジェクト \var{f} に関連付けられた例題をテストします。
\var{f} はモジュール、関数、またはクラスオブジェクトです。

引数\var{globs} に辞書を指定すると、その浅いコピーを実行コンテキスト
に使います。

オプション引数\var{name} はテスト失敗時のメッセージに使われます。
デフォルトの値は \code{NoName} です。

オプション引数 \var{verbose} の値を真にすると、テストが失敗しなくても
出力を生成します。デフォルトでは、例題のテストに失敗したときのみ
出力を生成します。

オプション引数\var{compileflags} には、例題を実行するときに Python 
バイトコードコンパイラが使うフラグを指定します。デフォルトの場合や
\code{None} を指定した場合、フラグは\var{globs} 内にある future
機能セットに対応したものになります。

オプション引数 \var{optionflags} は、上で述べた\function{testfile()}
と同様の働きをします。
\end{funcdesc}

\subsection{単位テスト API\label{doctest-unittest-api}}

doctest 化したモジュールのコレクションが増えるにつれ、全ての doctest を
システマティックに実行したいと思うようになるはずです。 Python 2.4 
以前の \refmodule{doctest} には \class{Tester} という
ほとんどドキュメント化されていないクラスがあり、複数のモジュールの
doctest を統合する初歩的な手段を提供していました。
\class{Tester} は非力であり、実際のところ、もっときちんとした Python の
テストフレームワークが \refmodule{unittest} モジュールで構築されており、
複数のソースコードからのテストを統合する柔軟な方法を提供しています。
そこで Python 2.4 では \refmodule{doctest} の \class{Tester} クラスを
撤廃し、モジュールや doctest の入ったテキストファイルから
\refmodule{unittest} テストスイートを作成できるような二つの関数を
\refmodule{doctest} 側で提供するようにしました。
こうしたテストスイートは、\refmodule{unittest} のテストランナを
使って実行できます:

\begin{verbatim}
import unittest
import doctest
import my_module_with_doctests, and_another

suite = unittest.TestSuite()
for mod in my_module_with_doctests, and_another:
    suite.addTest(doctest.DocTestSuite(mod))
runner = unittest.TextTestRunner()
runner.run(suite)
\end{verbatim}

doctest の入ったテキストファイルやモジュールから
\class{\refmodule{unittest}.TestSuite} インスタンスを生成するための
主な関数は二つあります:

\begin{funcdesc}{DocFileSuite}{\optional{module_relative}\optional{,
                              package}\optional{, setUp}\optional{,
                              tearDown}\optional{, globs}\optional{,
                              optionflags}\optional{, parser}\optional{,
                              encoding}}

単一または複数のテキストファイルに入っている doctest 形式のテストを、
\class{\refmodule{unittest}.TestSuite} インスタンスに変換します。

この関数の返す\class{\refmodule{unittest}.TestSuite} インスタンスは、
unittest フレームワークで動作させ、各ファイルの例題を対話的に実行する
ためのものです。ファイル内の何らかの例題の実行に失敗すると、この関数で
生成した単位テストは失敗し、該当するテストの入っているファイルの名前と、
(場合によりだいたいの) 行番号の入った\exception{failureException} 例外を
送出します。

関数には、テストを行いたい一つまたは複数のファイルへのパスを
(文字列で) 渡します。

\function{DocFileSuite} には、キーワード引数でオプションを指定できます:

オプション引数\var{module_relative} は\var{paths} に指定したファイル名を
どのように解釈するかを指定します:

\begin{itemize}
\item \var{module_relative} が \code{True} (デフォルト) の場合、
\var{filename} は OS に依存しないモジュールの相対パスになります。
デフォルトでは、このパスは関数 \function{testfile} を呼び出して
いるモジュールからの相対パスになります; ただし、\var{package}
引数を指定した場合には、パッケージからの相対になります。
OS への依存性を除くため、\var{filename} ではパスを分割する
文字に\code{/} を使わねばならず、絶対パスにしてはなりません
(パス文字列を\code{/} で始めてはなりません)。
\item \var{module_relative} が \code{False} の場合、\var{filename}
は OS 依存のパスを示します。パスは絶対パスでも相対パスでも
かまいません; 相対パスにした場合、現在の作業ディレクトリを
基準に解決します。
\end{itemize}

オプション引数 \var{package} には、 Python パッケージを指定するか、
モジュール相対のファイル名の場合には相対の基準ディレクトリとなる
Python パッケージの名前を指定します。パッケージを指定しない倍、
関数を呼び出しているモジュールのディレクトリを相対の基準
ディレクトリとして使います。\var{module_relative} を\code{False}
に指定している場合、\var{package} を指定するとエラーになります。

オプション引数 \var{setUp} には、テストスイートのセットアップに使う
関数を指定します。この関数は、各ファイルのテストを実行する前に
呼び出されます。 \var{setUp} 関数は \class{DocTest} オブジェクトに
引き渡されます。\var{setUp} は\var{globs} 属性を介してテストの
グローバル変数にアクセスできます。

オプション引数 \var{tearDown} には、テストを解体 (tear-down) する
ための関数を指定します。この関数は、各ファイルのテストの実行を
終了するたびに呼び出されます。\var{tearDown}関数は \class{DocTest} 
オブジェクトに引き渡されます。\var{tearDown} はは\var{globs} 属性を
介してテストのグローバル変数にアクセスできます。

オプション引数 \var{globs} は辞書で、テストのグローバル変数
の初期値が入ります。この辞書は各テストごとに新たにコピーして使われ
ます。デフォルトでは \var{globs} は空の新たな辞書です。

オプション引数 \var{optionflags} には、テストを実行する際に
デフォルトで適用される doctest オプションを OR で結合して
指定します。
\ref{doctest-options} 節を参照してください。
結果レポートに関するオプションの指定する上手いやり方は
下記の\function{set_unittest_reportflags()} の説明を参照してください。

オプション引数 \var{parser} には、ファイルからテストを抽出するために
使う\class{DocTestParser} (またはサブクラス) を指定します。
デフォルトは通常のパーザ (\code{\class{DocTestParser}()}) です。

オプション引数 \var{encoding} にはファイルをユニコードに変換する際に使われる
エンコーディングを指定します。

  \versionadded{2.4}

  \versionchanged[グローバル変数 \code{__file__} が追加され
  \function{DocFileSuite()} を使ってテキストファイルから読み込まれた
  doctest に提供されます]{2.5}

  \versionchanged[\var{encoding} パラメタが追加されました]{2.5}

\end{funcdesc}

\begin{funcdesc}{DocTestSuite}{\optional{module}\optional{,
                              globs}\optional{, extraglobs}\optional{,
                              test_finder}\optional{, setUp}\optional{,
                              tearDown}\optional{, checker}}
doctest のテストを \class{\refmodule{unittest}.TestSuite} に変換します。

この関数の返す\class{\refmodule{unittest}.TestSuite} インスタンスは、
unittest フレームワークで動作させ、モジュール内の各 doctest を実行する
ためのものです。何らかの doctest の実行に失敗すると、この関数で
生成した単位テストは失敗し、該当するテストの入っているファイルの名前と、
(場合によりだいたいの) 行番号の入った\exception{failureException} 例外を
送出します。

オプション引数 \var{module} には、テストしたいモジュールの名前を
指定します。\var{module} にはモジュールオブジェクトまたは (ドット表記の) 
モジュール名を指定できます。\var{module} を指定しない場合、この関数を
呼び出しているモジュールになります。

オプション引数 \var{globs} は辞書で、テストのグローバル変数
の初期値が入ります。この辞書は各テストごとに新たにコピーして使われ
ます。デフォルトでは\var{glob} は空の新たな辞書です。

オプション引数 \var{extraglobs} には追加のグローバル変数セットを
指定します。この変数セットは \var{globs} に統合されます。
デフォルトでは、追加のグローバル変数はありません。

オプション引数 \var{test_finder} は、モジュールから doctest を抽出
するための \class{DocTestFinder} オブジェクト (またはその代用となる
オブジェクト) です。

オプション引数 \var{setUp}、\var{tearDown}、および \var{optionflags}
は上の \function{DocFileSuite()} と同じです。

  \versionadded{2.3}

  \versionchanged[\var{globs}, \var{extraglobs},
    \var{test_finder}, \var{setUp}, \var{tearDown}, および
    \var{optionflags} パラメタを追加しました。また、この関数は
    doctest の検索に\function{testmod()} と同じテクニックを使うように
    なりました]{2.4}
\end{funcdesc}

\function{DocTestSuite()} は水面下では\class{doctest.DocTestCase}
インスタンスから\class{\refmodule{unittest}.TestSuite} を作成しており、
\class{DocTestCase} は\class{\refmodule{unittest}.TestCase} のサブクラス
になっています。\class{DocTestCase} についてはここでは説明しません
(これは内部実装上の詳細だからです) が、そのコードを調べてみれば、
\refmodule{unittest} の組み込みの詳細に関する疑問を解決できるはずです。

同様に、\function{DocFileSuite()} は\class{doctest.DocFileCase}
インスタンスから\class{\refmodule{unittest}.TestSuite} を
作成し、 \class{DocFileCase} は \class{DocTestCase} のサブクラス
になっています。これにははっきりとした訳があります:
\refmodule{doctest} 関数を自分で実行する場合、オプションフラグを
\refmodule{doctest} 関数に渡すことで、\refmodule{doctest} 
のオプションを直接操作できます。しかしながら、\refmodule{unittest}
フレームワークを書いている場合には、いつどのようにテストを動作させるかを
\refmodule{unittest} が完全に制御してしまいます。フレームワークの作者は
たいてい、\refmodule{doctest} のレポートオプションを (コマンドライン
オプションで指定するなどして) 操作したいと考えますが、\refmodule{unittest}
を介して \refmodule{doctest} のテストランナにオプションを渡す方法は
存在しないのです。

このため、\refmodule{doctest} では、以下の関数を使って、
 \refmodule{unittest} サポート
に特化したレポートフラグ表記方法もサポートしています:

\begin{funcdesc}{set_unittest_reportflags}{flags}
\refmodule{doctest} のレポートフラグをセットします。

引数\var{flags} にはオプションフラグを OR で結合して渡します。
\ref{doctest-options} 節を参照してください。「レポートフラグ」
しか使えません。

この関数で設定した内容はモジュール全体にわたる物であり、関数呼び出し
以後に \refmodule{unittest} モジュールから実行される全ての doctest
に影響します: \class{DocTestCase} の\method{runTest()} メソッド
は、\class{DocTestCase} インスタンスが作成された際に、現在の
テストケースに指定されたオプションフラグを見に行きます。
レポートフラグが指定されていない場合 (通常の場合で、望ましいケースです)、
\refmodule{doctest} の \refmodule{unittest} レポートフラグが OR で
結合され、doctest を実行するために作成される\class{DocTestRunner} 
インスタンスに渡されます。
\class{DocTestCase} インスタンスを構築する際に何らかのレポートフラグが
指定されていた場合、\refmodule{doctest} の\refmodule{unittest} 
レポートフラグは無視されます。

この関数は、関数を呼び出す前に有効になっていた\refmodule{unittest} 
レポートフラグの値を返します。

  \versionadded{2.4}
\end{funcdesc}


\subsection{拡張 API\label{doctest-advanced-api}}

基本 API は、 doctest を使いやすくするための簡単なラッパであり、
柔軟性があってほとんどのユーザの必要を満たしています; とはいえ、
もっとテストをきめ細かに制御したい場合や、 doctest の機能を
拡張したい場合、拡張 API (advanced API) を使わねばなりません。

拡張 API は、doctest ケースから抽出した対話モードでの例題を
記憶するための二つのコンテナクラスを中心に構成されています:

\begin{itemize}
\item \class{Example}: 一つの Python 実行文と、その予想出力をペアに
  したもの。
\item \class{DocTest}: \class{Example} の集まり。通常一つの docstring や
  テキストファイルから抽出されます。
\end{itemize}

その他に、 doctest の例題を検索、パーズ、実行、チェックするための
処理クラスが以下のように定義されています:

\begin{itemize}
\item \class{DocTestFinder}: 与えられたモジュールから全ての
  docstring を検索し、対話モードでの例題が入った各 docstring から
  \class{DocTestParser} を使って\class{DocTest} を生成します。
\item \class{DocTestParser}: (オブジェクトにつけられた docstring のような)
  文字列から\class{DocTest} オブジェクトを生成します。
\item \class{DocTestRunner}: \class{DocTest} 内の例題を実行し、
  \class{OutputChecker} を使って出力を検証します。
\item \class{OutputChecker}: doctest 例題から実際に出力された結果を
  予想出力と比較し、両者が一致するか判別します。
\end{itemize}

これらの処理クラスの関係を図にまとめると、以下のようになります:

\begin{verbatim}
                            list of:
+------+                   +---------+
|module| --DocTestFinder-> | DocTest | --DocTestRunner-> results
+------+    |        ^     +---------+     |       ^    (printed)
            |        |     | Example |     |       |
            v        |     |   ...   |     v       |
           DocTestParser   | Example |   OutputChecker
                           +---------+
\end{verbatim}

\subsubsection{DocTest オブジェクト\label{doctest-DocTest}}
\begin{classdesc}{DocTest}{examples, globs, name, filename, lineno,
                           docstring}
単一の名前空間内で実行される doctest 例題の集まりです。  
コンストラクタの引数は \class{DocTest} インスタンス中の同名の
メンバ変数の初期化に使われます。
    \versionadded{2.4}
\end{classdesc}

\class{DocTest} では、以下のメンバ変数を定義しています。
これらの変数はコンストラクタで初期化されます。直接変更してはなりません。

\begin{memberdesc}{examples}
対話モードにおける例題それぞれをエンコードしていて、テストで実行
される、\class{Example} オブジェクトからなるリストです。
\end{memberdesc}

\begin{memberdesc}{globs}
例題を実行する名前空間 (いわゆるグローバル変数) です。
このメンバは、名前から値への対応付けを行っている辞書です。
例題が名前空間に対して (新たな変数をバインドするなど)
何らかの変更を行った場合、\member{globs} への反映はテストの実行後に
起こります。
\end{memberdesc}

\begin{memberdesc}{name}
\class{DocTest} を識別する名前の文字列です。通常、この値は
テストを取り出したオブジェクトかファイルの名前になります。
\end{memberdesc}

\begin{memberdesc}{filename}
\class{DocTest} を取り出したファイルの名前です;
ファイル名が未知の場合や \class{DocTest} をファイルから取り出したので
ない場合には\code{None} になります。
\end{memberdesc}

\begin{memberdesc}{lineno}
\member{filename} 中で\class{DocTest} のテスト例題が始まっている行の
行番号です。行番号は、ファイルの先頭をゼロとして数えます。
\end{memberdesc}

\begin{memberdesc}{docstring}
テストを取り出した docstring 自体を現す文字列です。
docstring 文字列を得られない場合や、文字列からテスト例題を
取り出したのでない場合には \code{None} になります。
\end{memberdesc}

\subsubsection{Example オブジェクト\label{doctest-Example}}
\begin{classdesc}{Example}{source, want\optional{,
                           exc_msg}\optional{, lineno}\optional{,
                           indent}\optional{, options}}
ひとつの Python 文と、それに対する予想出力からなる、単一の対話的モードの
例題です。コンストラクタの引数は \class{Example} インスタンス中の同名の
メンバ変数の初期化に使われます。
    \versionadded{2.4}
\end{classdesc}

\class{Example} では、以下のメンバ変数を定義しています。 
これらの変数はコンストラクタで初期化されます。直接変更してはなりません。

\begin{memberdesc}{source}
例題のソースコードが入った文字列です。ソースコードは単一の
Python で、末尾は常に改行です。コンストラクタは必要に応じて
改行を追加します。
\end{memberdesc}

\begin{memberdesc}{want}
例題のソースコードを実行した際の予想出力 (標準出力と、例外が生じた
場合にはトレースバック) です。\member{want} の末尾は、予想出力が全く
ない場合を除いて常に改行になります。予想出力がない場合には
空文字列になります。コンストラクタは必要に応じて
改行を追加します。
\end{memberdesc}

\begin{memberdesc}{exc_msg}
例題が例外を生成すると予想される場合の例外メッセージです。
例外を送出しない場合には \code{None} です。
この例外メッセージは、\function{traceback.format_exception_only()}
の戻り値と比較されます。 値が \code{None} でない限り、\member{exc_msg}
は改行で終わっていなければなりません; コンストラクタは必要に応じて
改行を追加します。
\end{memberdesc}

\begin{memberdesc}{lineno}
この例題の入っている文字列中における、例題の実行文のある行のの行番号です。
行番号は文字列の先頭をゼロとして数えます。
\end{memberdesc}

\begin{memberdesc}{indent}
例題の入っている文字列のインデント、すなわち例題の最初のプロンプト
より前にある空白文字の数です。
\end{memberdesc}

\begin{memberdesc}{options}
オプションフラグを \code{True} または \code{False} に対応付けて
いる辞書です。例題に対するデフォルトオプションを上書きするために
用いられます。この辞書に入っていないオプションフラグはデフォルトの
状態 (\class{DocTestrunner} の \member{optionflags} の内容) の
ままになります。
\end{memberdesc}

\subsubsection{DocTestFinder オブジェクト\label{doctest-DocTestFinder}}
\begin{classdesc}{DocTestFinder}{\optional{verbose}\optional{,
                                parser}\optional{, recurse}\optional{,
                                exclude_empty}}
与えられたオブジェクトについて、その docstring か、そのオブジェクトに
入っているオブジェクトの docstring から\class{DocTest} を抽出する処理
クラスです。
現在のところ、モジュール、関数、クラス、メソッド、静的メソッド、
クラスメソッド、プロパティから\class{DocTest} を抽出できます。

オプション引数 \var{verbose} を使うと、抽出処理の対象となるオブジェクト
を表示できます。デフォルトは \code{False} (出力をおこなわない) です。

オプション引数 \var{parser} には、 docstring から \class{DocTest} を
抽出するのに使う\class{DocTestParser} オブジェクト
(またはその代替となるオブジェクト) を指定します。

オプション引数 \var{recurse} が偽の場合、\method{DocTestFinder.find()}
は与えられたオブジェクトだけを調べ、そのオブジェクトに入っている他の
オブジェクトを調べません。

オプション引数 \var{exclude_empty} が偽の場合、\method{DocTestFinder.find()}
は空の docstring を持つオブジェクトもテスト対象に含めます。

    \versionadded{2.4}
\end{classdesc}

\class{DocTestFinder} では以下のメソッドを定義しています:

\begin{methoddesc}{find}{obj\optional{, name}\optional{,
                   module}\optional{, globs}\optional{, extraglobs}}
\var{obj} または \var{obj} 内に入っているオブジェクトの docstring 中で
定義されている\class{DocTest} のリストを返します。

オプション引数 \var{name} には、オブジェクトの名前を指定します。
この名前は、関数が返す \class{DocTest} の名前になります。
\var{name} を指定しない場合、\code{\var{obj}.__name__} を使います。

オプションのパラメタ \var{module} は、指定したオブジェクトを
収めているモジュールを指定します。\var{module} を指定しないか、
\constant{None} を指定した場合には、正しいモジュールを自動的に
決定しようと試みます。オブジェクトのモジュールは以下のような役割を
果たします:

    \begin{itemize}
    \item \var{globs} を指定していない場合、オブジェクトのモジュールは
      デフォルトの名前空間になります。
    \item 他のモジュールから import されたオブジェクトに対して
      \class{DocTestFinder} が\class{DocTest} を抽出するのを避ける
      ために使います (\var{module} 由来でないオブジェクトを無視します)。
    \item オブジェクトの入っているファイル名を調べるために使います。
    \item オブジェクトがファイル内の何行目にあるかを調べる手助けにします。
    \end{itemize}

\var{module} が \code{False} の場合には、モジュールの検索を試みません。
これは正確さを欠くような使い方で、通常 doctest 自体のテストにしか
つかいません。
\var{module} が\code{False} の場合、 または\var{module} が\code{None} 
で自動的に的確なモジュールを見つけ出せない場合には、全てのオブジェクトは
\code{(non-existent)} モジュールに属するとみなされ、そのオブジェクト内の
全てのオブジェクトに対して (再帰的に) doctest の検索をおこないます。

各\class{DocTest} のグローバル変数は、\var{globs} と\var{extraglobs}
を合わせたもの (\var{extraglobs} 内のバインドが\var{globs} 内の
バインドを上書きする) になります。各々の \class{DocTest} に対して、
グローバル変数を表す辞書の新たな浅いコピーを生成します。
\var{globs} を指定しない場合に使われるのデフォルト値は、
モジュールを指定していればそのモジュールの \var{__dict__} になり、
指定していなければ\code{\{\}} になります。\var{extraglobs} を指定しない場合、
デフォルトの値は\code{\{\}} になります。
\end{methoddesc}

\subsubsection{DocTestParser オブジェクト\label{doctest-DocTestParser}}
\begin{classdesc}{DocTestParser}{}
対話モードの例題を文字列から抽出し、それを使って\class{DocTest} 
オブジェクトを生成するために使われる処理クラスです。
    \versionadded{2.4}
\end{classdesc}

\class{DocTestParser} では以下のメソッドを定義しています:

\begin{methoddesc}{get_doctest}{string, globs, name, filename, lineno}
指定した文字列から全ての doctest 例題を抽出し、\class{DocTest}
オブジェクト内に集めます。

\var{globs}, \var{name}, \var{filename}, および \var{lineno} は
新たに作成される \class{DocTest} オブジェクトの属性になります。
詳しくは\class{DocTest} のドキュメントを参照してください。
\end{methoddesc}

\begin{methoddesc}{get_examples}{string\optional{, name}}
指定した文字列から全ての doctest 例題を抽出し、\class{Example} 
オブジェクトからなるリストにして返します。
各\class{Example} の行番号はゼロから数えます。オプション引数
\var{name} はこの文字列につける名前で、エラーメッセージにしか
使われません。
\end{methoddesc}

\begin{methoddesc}{parse}{string\optional{, name}}
指定した文字列を、例題とその間のテキストに分割し、
例題を\class{Example} オブジェクトに変換し、\class{Example} と
文字列からなるリストにして返します。
各\class{Example} の行番号はゼロから数えます。オプション引数
\var{name} はこの文字列につける名前で、エラーメッセージにしか
使われません。
\end{methoddesc}

\subsubsection{DocTestRunner オブジェクト\label{doctest-DocTestRunner}}
\begin{classdesc}{DocTestRunner}{\optional{checker}\optional{,
                                 verbose}\optional{, optionflags}}
\class{DocTest} 内の対話モード例題を実行し、検証する際に用いられる
処理クラスです。

予想出力と実際の出力との比較は \class{OutputChecker} で行います。
比較は様々なオプションフラグを使ってカスタマイズできます;
詳しくは\ref{doctest-options} を参照してください。
オプションフラグでは不十分な場合、コンストラクタに
\class{OutputChecker} のサブクラスを渡して比較方法をカスタマイズ
できます。

テストランナの表示出力の制御には二つの方法があります。
一つ目は、\method{TestRunner.run()} に出力用の関数を渡すというものです。
この関数は、表示すべき文字列を引数にして呼び出されます。デフォルトは
\code{sys.stdout.write} です。出力を取り込んで処理するだけでは
不十分な場合、\class{DocTestRunner} をサブクラス化し、
\method{report_start}, \method{report_success},
\method{report_unexpected_exception}, および \method{report_failure}
をオーバライドすればカスタマイズできます。

オプションのキーワード引数\var{checker} には、\class{OutputChecker}
オブジェクト (またはその代用品) を指定します。このオブジェクトは
doctest 例題の予想出力と実際の出力との比較を行う際に使われます。

オプションのキーワード引数\var{verbose} は、\class{DocTestRunner}
の出すメッセージの冗長性を制御します。\var{verbose} が\code{True}
の場合、各例題を実行するつど、その例題についての情報を出力します。
\var{verbose} が\code{False} の場合、テストの失敗だけを出力します。
\var{verbose} を指定しない場合や\code{None} を指定した場合、
コマンドラインスイッチ \programopt{-v} を使った場合にのみ
\var{verbose} 出力を適用します。

オプションのキーワード引数\var{optionflags} を使うと、テストランナが
予想出力と実際の出力を比較する方法や、テストの失敗を表示する方法を
制御できます。詳しくは\ref{doctest-options} 節を参照してください。

    \versionadded{2.4}
\end{classdesc}

\class{DocTestRunner} では、以下のメソッドを定義しています:

\begin{methoddesc}{report_start}{out, test, example}
テストランナが例題を処理しようとしているときにレポートを出力します。
\class{DocTestRunner} の出力をサブクラスでカスタマイズできるように
するためのメソッドです。直接呼び出してはなりません。

\var{example} は処理する例題です。\var{test} は \var{example} の
入っているテストです。\var{out} は出力用の関数で、
\method{DocTestRunner.run()} に渡されます。
\end{methoddesc}

\begin{methoddesc}{report_success}{out, test, example, got}
与えられた例題が正しく動作したことを報告します。
このメソッドは \class{DocTestRunner} のサブクラスで
出力をカスタマイズできるようにするために提供されています;
直接呼び出してはなりません。

\var{example} は処理する例題です。\var{got} は例題から実際に得られた
出力です。\var{test} は \var{example} の入っているテストです。
\var{out} は出力用の関数で、\method{DocTestRunner.run()} に渡されます。
\end{methoddesc}

\begin{methoddesc}{report_failure}{out, test, example, got}
与えられた例題が正しく動作しなかったことを報告します。
このメソッドは \class{DocTestRunner} のサブクラスで
出力をカスタマイズできるようにするために提供されています;
直接呼び出してはなりません。

\var{example} は処理する例題です。\var{got} は例題から実際に得られた
出力です。\var{test} は \var{example} の入っているテストです。
\var{out} は出力用の関数で、\method{DocTestRunner.run()} に渡されます。
\end{methoddesc}

\begin{methoddesc}{report_unexpected_exception}{out, test, example, exc_info}
与えられた例題が予想とは違う例外を送出したことを報告します。
このメソッドは \class{DocTestRunner} のサブクラスで
出力をカスタマイズできるようにするために提供されています;
直接呼び出してはなりません。

\var{example} は処理する例題です。\var{exc_info} には予期せず送出
された例外の情報を入れたタプル (\function{sys.exc_info()} の返す内容) 
になります。\var{test} は \var{example} の入っているテストです。
\var{out} は出力用の関数で、\method{DocTestRunner.run()} に渡されます。
\end{methoddesc}

\begin{methoddesc}{run}{test\optional{, compileflags}\optional{,
                        out}\optional{, clear_globs}}
\var{test} 内の例題 (\class{DocTest} オブジェクト) を実行し、
その結果を出力用の関数\var{out} を使って表示します。

例題は名前空間 \code{test.globs} の下で実行されます。
\var{clear_globs} が真 (デフォルト) の場合、名前空間はテストの実行後に
消去され、ガベージコレクションをうながします。テストの実行完了後に
その内容を調べたければ、\var{clear_globs} を \constant{False} に
してください。

\var{compileflags} には、例題を実行する際に Python コンパイラに
適用するフラグセットを指定します。\var{compileflags} を指定しない
場合、デフォルト値は\var{globs} で適用されている future-import フラグ
セットになります。

各例題の出力は \class{DocTestRunner} の出力チェッカで検査され、
その結果は \method{DocTestRunner.report_*}. メソッドで書式化
されます。
\end{methoddesc}

\begin{methoddesc}{summarize}{\optional{verbose}}
この DocTestRunner が実行した全てのテストケースのサマリを出力し、
タプル\samp{(\var{failure_count}, \var{test_count})} を返します。

オプションの\var{verbose} 引数を使うと、どのくらいサマリを詳しくするかを
制御できます。冗長度を指定しない場合、\class{DocTestRunner}
自体の冗長度を使います。
\end{methoddesc}

\subsubsection{OutputChecker オブジェクト\label{doctest-OutputChecker}}

\begin{classdesc}{OutputChecker}{}
doctest 例題を実際に実行したときの出力が予想出力と一致するかどうか
をチェックするために使われるクラスです。 \class{OutputChecker} では、
与えられた二つの出力を比較して、一致する場合には真を返す
\method{check_output} と、二つの出力間の違いを説明する文字列を
返す\method{output_difference} の、二つのメソッドがあります。
    \versionadded{2.4}
\end{classdesc}

\class{OutputChecker} では以下のメソッドを定義しています:

\begin{methoddesc}{check_output}{want, got, optionflags}
例題から実際に得られた出力 (\var{got}) と、予想出力 (\var{want})
が一致する場合にのみ\constant{True} を返します。
二つの文字列が全く同一の場合には常に一致するとみなしますが、
テストランナの使っているオプションフラグにより、厳密には同じ内容
になっていなくても一致するとみなす場合もあります。オプションフラグに
ついての詳しい情報は\ref{doctest-options} 節を参照してください。
\end{methoddesc}

\begin{methoddesc}{output_difference}{want, got, optionflags}
与えられた例題の予想出力 (\var{want})と、実際に得られた出力
(\var{got}) の間の差異を解説している文字列を返します。
\var{optionflags} は\var{want} と\var{got} を比較する際に使われる
オプションフラグのセットです。
\end{methoddesc}

\subsection{デバッグ\label{doctest-debugging}}

\module{doctest} では、doctest 例題をデバッグするメカニズムをいくつか
提供しています:

\begin{itemize}
\item doctest を実行可能な Python プログラムに変換し、 Python デバッガ
  \refmodule{pdb} で実行できるようにするための関数がいくつかあります。
\item \class{DocTestRunner} のサブクラス\class{DebugRunner} クラスが
  あります。このクラスは、最初に失敗した例題に対して例外を送出します。
  例外には例題に関する情報が入っています。この情報は例題の検視デバッグ
  に利用できます。
\item \function{DocTestSuite()} の生成する\refmodule{unittest} テストケース
  は、\method{debug()} メソッドをサポートしています。\method{debug()} は
  \class{\refmodule{unittest}.TestCase} で定義されています。
\item \function{\refmodule{pdb}.set_trace()} を doctest 例題の中で呼び
  出しておけば、その行が実行されたときに Python デバッガが組み込まれます。
  デバッガを組み込んだあとは、変数の現在の値などを調べられます。
  たとえば、以下のようなモジュールレベルの docstring の入ったファイル
  \file{a.py} があるとします:

\begin{verbatim}
"""
>>> def f(x):
...     g(x*2)
>>> def g(x):
...     print x+3
...     import pdb; pdb.set_trace()
>>> f(3)
9
"""
\end{verbatim}

対話セッションは以下のようになるでしょう:

\begin{verbatim}
>>> import a, doctest
>>> doctest.testmod(a)
--Return--
> <doctest a[1]>(3)g()->None
-> import pdb; pdb.set_trace()
(Pdb) list
  1     def g(x):
  2         print x+3
  3  ->     import pdb; pdb.set_trace()
[EOF]
(Pdb) print x
6
(Pdb) step
--Return--
> <doctest a[0]>(2)f()->None
-> g(x*2)
(Pdb) list
  1     def f(x):
  2  ->     g(x*2)
[EOF]
(Pdb) print x
3
(Pdb) step
--Return--
> <doctest a[2]>(1)?()->None
-> f(3)
(Pdb) cont
(0, 3)
>>>
\end{verbatim}

\versionchanged[\code{\refmodule{pdb}.set_trace()} を doctest の
  中で有効に使えるようになりました]{2.4}
\end{itemize}

以下は、doctest を Python コードに変換して、できたコードをデバッガ下で
実行できるようにするための関数です:

\begin{funcdesc}{script_from_examples}{s}
例題の入ったテキストをスクリプトに変換します。

引数\var{s} は doctest 例題の入った文字列です。この文字列は Python 
スクリプトに変換され、その中では \var{s} の doctest 例題が
通常のコードに、それ以外は Python のコメント文になります。
生成したスクリプトを文字列で返します。例えば、

    \begin{verbatim}
    import doctest
    print doctest.script_from_examples(r"""
        Set x and y to 1 and 2.
        >>> x, y = 1, 2

        Print their sum:
        >>> print x+y
        3
    """)
    \end{verbatim}

は、

    \begin{verbatim}
    # Set x and y to 1 and 2.
    x, y = 1, 2
    #
    # Print their sum:
    print x+y
    # Expected:
    ## 3
    \end{verbatim}

になります。

この関数は他の関数 (下記参照) から使われていまるが、対話セッションを
Python スクリプトに変換したいような場合にも便利でしょう。

  \versionadded{2.4}
\end{funcdesc}

\begin{funcdesc}{testsource}{module, name}
あるオブジェクトの doctest をスクリプトに変換します。

引数\var{module} はモジュールオブジェクトか、対象の doctest を持つ
オブジェクトの入ったモジュールのドット表記名です。
引数\var{name} は対象の doctest を持つオブジェクトの (モジュール内の)
名前です。対象オブジェクトの docstring を上の
\function{script_from_examples()} で説明した方法で Python スクリプトに
変換してできた文字列を返しますます。例えば、\file{a.py} モジュールの
トップレベルに関数 \function{f()} がある場合、以下のコード

\begin{verbatim}
import a, doctest
print doctest.testsource(a, "a.f")
\end{verbatim}

を実行すると、\function{f()} の docstring から doctest をコードに
変換し、それ以外をコメントにしたスクリプトを出力します。

  \versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{debug}{module, name\optional{, pm}}
オブジェクトの持つ doctest をデバッグします。

\var{module} および \var{name} 引数は上の \function{testsource()}
と同じです。指定したオブジェクトの docstring から合成された Python 
スクリプトは一時ファイルに書き出され、その後 Python デバッガ
\refmodule{pdb} の制御下で実行されます。

ローカルおよびグローバルの実行コンテキストには、
\code{\var{module}.__dict__} の浅いコピーが使われます。

オプション引数\var{pm} は、検死デバッグを行うかどうかを指定します。
\var{pm} が真の場合、スクリプトファイルは直接実行され、
スクリプトが送出した例外が処理されないまま終了した場合にのみデバッガ
が立ち入ります。その場合、\code{\refmodule{pdb}.post_mortem()} によって
検死デバッグを起動し、処理されなかった例外から得られたトレースバック
オブジェクトを渡します。\var{pm} を指定しないか値を偽にした場合、
\code{\refmodule{pdb}.run()} に適切な \function{execfile()} 呼び出しを
渡して、最初からデバッガの下でスクリプトを実行します。

  \versionadded{2.3}

  \versionchanged[引数\var{pm} を追加しました]{2.4}
\end{funcdesc}

\begin{funcdesc}{debug_src}{src\optional{, pm}\optional{, globs}}
文字列中の doctest をデバッグします。

上の\function{debug()} に似ていますが、doctest の入った文字列は
\var{src} 引数で直接指定します。

オプション引数 \var{pm} は上の \function{debug()} と同じ意味です。

オプション引数\var{globs} には、ローカルおよびグローバルな
実行コンテキストの両方に使われる辞書を指定します。\var{globs} を
指定しない場合や\code{None} にした場合、空の辞書を使います。
辞書を指定した場合、実際の実行コンテキストには浅いコピーが使われます。

  \versionadded{2.4}
\end{funcdesc}

\class{DebugRunner} クラス自体や\class{DebugRunner} クラスが送出
する特殊な例外は、テストフレームワークの作者にとって非常に興味のある
ところで
The \class{DebugRunner} class, and the special exceptions it may raise,
are of most interest to testing framework authors, and will only be
sketched here.  

詳しくはソースコード、とりわけ\class{DebugRunner} の docstring
(それ自体 doctest ですよ!) を参照してください。

\begin{classdesc}{DebugRunner}{\optional{checker}\optional{,
                                 verbose}\optional{, optionflags}}
テストの失敗に遭遇するとすぐに例外を送出するようになっている
\class{DocTestRunner} のサブクラスです。予期しない例外が生じると、
\exception{UnexpectedException} 例外を送出します。この例外には、
テスト、例題、もともと送出された例外が入っています。
予想出力と実際出力が一致しないために失敗した場合には、
\exception{DocTestFailure} 例外を送出します。この例外には、
テスト、例題、実際の出力が入っています。

コンストラクタのパラメタやメソッドについては、\ref{doctest-advanced-api}
節の \class{DocTestRunner} のドキュメントを参照してください。
\end{classdesc}

\class{DebugRunner} インスタンスの送出する例外には以下の二つがあります:

\begin{excclassdesc}{DocTestFailure}{test, example, got}
doctest 例題の実際の出力が予想出力と一致しなかったことを示すために
\class{DocTestRunner} が送出する例外です。
コンストラクタの引数は、インスタンスの同名のメンバ変数を
初期化するために使われます。
\end{excclassdesc}
\exception{DocTestFailure} では以下のメンバ変数を定義しています:
\begin{memberdesc}{test}
例題が失敗した時に実行されていた\class{DocTest} オブジェクトです。
\end{memberdesc}
\begin{memberdesc}{example}
失敗した \class{Example} オブジェクトです。
\end{memberdesc}
\begin{memberdesc}{got}
例題の実際の出力です。
\end{memberdesc}

\begin{excclassdesc}{UnexpectedException}{test, example, exc_info}
doctest 例題が予期しない例外を送出したことを示すために
\class{DocTestRunner} が送出する例外です。
コンストラクタの引数は、インスタンスの同名のメンバ変数を
初期化するために使われます。
\end{excclassdesc}
\exception{UnexpectedException} では以下のメンバ変数を定義しています:
\begin{memberdesc}{test}
例題が失敗した時に実行されていた\class{DocTest} オブジェクトです。
\end{memberdesc}
\begin{memberdesc}{example}
失敗した \class{Example} オブジェクトです。
\end{memberdesc}
\begin{memberdesc}{exc_info}
予期しない例外についての情報の入ったタプルで、\function{sys.exc_info()} 
が返すのと同じものです。
\end{memberdesc}

\subsection{提言\label{doctest-soapbox}}

冒頭でも触れたように、\refmodule{doctest} は、

\begin{enumerate}
\item docstring 内の例題をチェックする、
\item 回帰テストを行う、
\item 実行可能なドキュメント/読めるテストの実現、
\end{enumerate}

という三つの主な用途を持つようになりました。これらの用途にはそれぞれ
違った要求があるので、区別して考えるのが重要です。特に、 docstring を
曖昧なテストケースに埋もれさせてしまうとドキュメントとしては最悪です。

docstring の例は注意深く作成してください。 doctest の作成にはコツがあり、
きちんと学ぶ必要があります --- 最初はすんなりできないでしょう。
例題は、ドキュメントに紛れ無しの価値を与えます。
よい例がたくさんの言葉に値することは多々あります。
注意深くやれば、例はユーザにとってはあまり意味のないものになるかも
しれませんが、歳を経るにつれて、あるいは "状況が変わった" 際に何度も
何度も正しく動作させるためにかかることになる時間を節約するという形で、
きっと見返りを得るでしょう。
私は今でも、自分の \refmodule{doctest} で処理した例が "たいした事のない" 
変更を行った際にうまく動作しなくなることに驚いています。

説明テキストの作成をけちらなければ、\refmodule{doctest} は回帰テストの
優れたツールにもなり得ます。説明文と例題を交互に記述していけば、
実際に何をどうしてテストしているのかもっと簡単に把握できるように
なるでしょう。もちろん、コードベースのテストに詳しくコメントを入れるのも
手ですが、そんなことをするプログラマはほとんどいません。
多くの人々が、\refmodule{doctest} のアプローチをとった方がきれいに
テストを書けると気づいています。おそらく、これは単にコード中にコメント
を書くのが少し面倒だからという理由でしょう。私はもう少しうがった見方も
しています: doctest ベースのテストを書くときの自然な態度は、
自分のソフトウェアのよい点を説明しようとして、例題を使って説明
しようとするときの態度そのものだからだ、という理由です。
それゆえに、テストファイルは自然と単純な機能の解説から始め、論理的により
複雑で境界条件的なケースに進むような形になります。結果的に、
一見ランダムに見えるような個別の機能をテストしている個別の関数の集まり
ではなく、首尾一貫した説明ができるようになるのです。
\refmodule{doctest} によるテストの作成は全く別の取り組み方であり、
テストと説明の区別をなくして、全く違う結果を生み出すのです。

回帰テストは特定のオブジェクトやファイルにまとめておくのがよいでしょう。
回帰テストの組み方にはいくつか選択肢があります:

\begin{itemize}
\item テストケースを対話モードの例題にして入れたテキストファイルを書き、
  \function{testifle()} や \function{DocFileSuite()} を使ってそのファイル
  をテストします。この方法をお勧めします。最初から doctest を使うように
  している新たなプロジェクトでは、この方法が一番簡単です。
\item \code{_regrtest_\textit{topic}} という名前の関数を定義します。
  この関数には、あるトピックに対応するテストケースの入った docstring
  が一つだけ入っています。この関数はモジュールと同じファイルの中にも
  置けますし、別のテストファイルに分けてもかまいません。
\item 回帰テストのトピックをテストケースの入った docstring に
  対応付けた辞書\code{__test__} 辞書を定義します。
\end{itemize}



\subsection{進んだ使い方}

doctest をどのように動作させるかを制御する、いくつかのモジュール
レベルの関数が利用できます。

\begin{funcdesc}{debug}{module, name}
doctest を含む単一のドキュメンテーション文字列をデバッグします。

デバッグしたいドキュメンテーション文字列の入った \var{module} 
(またはドットで区切ったモジュール名) と、(モジュール内の) 
デバッグしたいドキュメンテーション文字列を持つオブジェクトの 
\var{name} を指定してください。

doctest の例が展開され (\function{testsource()} 関数を参照してください)、
一次ファイルに書き込まれます。次に Python デバッガ \refmodule{pdb}
がこのファイルに対して起動されます。
  \versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{testmod}{}
この関数は doctest への基本的なインタフェース提供します。
この関数は  \class{Tester} のローカルなインスタンスを生成し、
このクラスの適切なメソッドを動作させ、結果をグローバルな \class{Tester}
インスタンスである \code{master} に統合します。

\function{testmod()} が提供するよりも細かい制御を行うには、
\class{Tester} のインスタンスを自作のポリシで作成するか、
\code{master} のメソッドを直接呼び出します。詳細は
\code{Tester.__doc__} を参照してください。
\end{funcdesc}

\begin{funcdesc}{testsource}{module, name}
doctest の例をドキュメンテーション文字列から展開します。

展開したいテストの入った \var{module}  (またはドットで区切られた
モジュールの名前) と、展開したいテストの入った docstring を
持つオブジェクトの (モジュール内の) \var{name} を与えます。

doctest 内の例は Python コードの入った文字列として返されます。
例中での予想される出力のブロックは Python のコメントに変換
されます。
  \versionadded{2.3}
\end{funcdesc}

\begin{funcdesc}{DocTestSuite}{\optional{module}}
モジュールにおける doctest のテストプログラムを
\class{\refmodule{unittest}.TestSuite} に変換します。

返される \class{TestSuite} は unittest フレームワークで動作する
ためのもので、モジュール内の各 doctest を走らせます。
doctest のいずれかが失敗すると、生成された unittest が失敗し、
該当するテストを含むファイルと (時に近似の) 行番号を表示する
\exception{DocTestTestFailure} 例外が送出されます。

オプションの \var{module} 引数はテストするモジュールを与えます。
この値はモジュールオブジェクトか (場合によってはドットで区切られた)
モジュール名となります。指定されていなければ、この関数を呼び出している
モジュールが使われます。

\refmodule{unittest} モジュールが \class{TestSuite} を
利用する数多くの方法のうちの一つを使った例を以下に示します:

  \begin{verbatim}
    import unittest
    import doctest
    import my_module_with_doctests

    suite = doctest.DocTestSuite(my_module_with_doctests)
    runner = unittest.TextTestRunner()
    runner.run(suite)
  \end{verbatim}

  \versionadded{2.3}
  \warning{この関数は現在のところ \code{M.__test__} を検索せず、
その検索テクニックはあらゆる点で \function{testmod()} と合致しません。
将来のバージョンではこれら二つを収斂させる予定です。}
\end{funcdesc}


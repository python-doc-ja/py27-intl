\section{\module{gl} ---
         \emph{Graphics Library} インターフェース}

\declaremodule{builtin}{gl}
  \platform{IRIX}
\modulesynopsis{Silicon Graphics の\emph{Graphics Library} の関数。}


このモジュールはSilicon Graphicsの\emph{Graphics Library}へのアクセスを
提供します。
Silicon Graphicsマシン上だけで利用可能です。

\warning{
GLライブラリの不適切な呼び出しによっては、Pythonインタープリタがコアを吐
き出すことがあります。
特に、GLのほとんどの関数では最初のウィンドウを開く前に呼び出すのは安全で
はありません。
}

このモジュールはとても大きいので、ここに全てを記述することはできません
が、以下の説明で出発点としては十分でしょう。
Cの関数のパラメータは、以下のような決まりに従ってPythonに翻訳されます：

\begin{itemize}
\item
全て（short、long、unsigned）の整数値（int）はPythonの整数に相当します。
\item
全ての浮動小数点数と倍精度浮動小数点数はPythonの浮動小数点数に相当しま
す。
たいていの場合、Pythonの整数も使えます。
\item
全ての配列はPythonの一次元のリストに相当します。
たいていの場合、タプルも使えます。
\item
\begin{sloppypar}
全ての文字列と文字の引数は、Pythonの文字列に相当します。例えば、
\code{winopen('Hi There!')}
と
\code{rotate(900, 'z')}。
\end{sloppypar}
\item
配列である引数の長さを特定するためだけに使われる全て
（short、long、unsigned）の整数値の引数あるいは返り値は、無視されます。
例えば、Cの呼び出しで、

\begin{verbatim}
lmdef(deftype, index, np, props)
\end{verbatim}

これはPythonでは、こうなります。

\begin{verbatim}
lmdef(deftype, index, props)
\end{verbatim}

\item
出力のための引数は、引数のリストから省略されています；
代わりにこれらは関数の返り値として渡されます。
もし１つ以上の値が返されるのなら、返り値はタプルです。
もしCの関数が通常の返り値（先のルールによって省略されません）と、出力の
ための引数の両方を取るなら、返り値はタプルの最初に来ます。
例：Cの呼び出しで、

\begin{verbatim}
getmcolor(i, &red, &green, &blue)
\end{verbatim}

これはPythonではこうなります。

\begin{verbatim}
red, green, blue = getmcolor(i)
\end{verbatim}

\end{itemize}

以下の関数は一般的でないか、引数に特別な決まりを持っています：

\begin{funcdesc}{varray}{argument}
%JHXXX the argument-argument added
\code{v3d()}の呼び出しに相当しますが、それよりも速いです。
\var{argument}は座標のリスト（あるいはタプル）です。
各座標は\code{(\var{x}, \var{y}, \var{z})}あるいは
\code{(\var{x}, \var{y})}のタプルでなければなりません。
座標は２次元あるいは３次元が可能ですが、全て同次元でなければなりません。
ですが、浮動小数点数と整数を混合して使えます。
座標は（マニュアルページにあるように）必要であれば\code{\var{z} = 0.0}と
仮定して、常に３次元の精密な座標に変換され、各座標について\code{v3d()}が
呼び出されます。
\end{funcdesc}

\begin{funcdesc}{nvarray}{}
\code{n3f}と\code{v3f}の呼び出しに相当しますが、それらよりも速いです。
引数は法線と座標とのペアからなるシーケンス（リストあるいはタプル）です。
各ペアは座標と、その座標からの法線とのタプルです。
各座標と各法線は\code{(\var{x}, \var{y}, \var{z})}からなるタプルでなけれ
ばなりません。
３つの座標が渡されなければなりません。
浮動小数点数と整数を混合して使えます。
各ペアについて、法線に対して\code{n3f()}が呼び出され、座標に対して
\code{v3f()}が呼び出されます。
\end{funcdesc}

\begin{funcdesc}{vnarray}{}
\code{nvarray()}と似ていますが、各ペアは始めに座標を、２番目に法線を持っ
ています。
\end{funcdesc}

\begin{funcdesc}{nurbssurface}{s_k, t_k, ctl, s_ord, t_ord, type}
% XXX s_k[], t_k[], ctl[][]
nurbs（非均一有理Bスプライン）曲面を定義します。
\code{\var{ctl}[][]}の次元は以下のように計算されます：
\code{[len(\var{s_k}) - \var{s_ord}]}、
\code{[len(\var{t_k}) - \var{t_ord}]}。
\end{funcdesc}

\begin{funcdesc}{nurbscurve}{knots, ctlpoints, order, type}
nurbs（非均一有理Bスプライン）曲線を定義します。
ctlpointsの長さは、\code{len(\var{knots}) - \var{order}}です。
\end{funcdesc}

\begin{funcdesc}{pwlcurve}{points, type}
区分線形曲線（piecewise-linear curve）を定義します。
\var{points}は座標のリストです。
\var{type}は\code{N_ST}でなければなりません。
\end{funcdesc}

\begin{funcdesc}{pick}{n}
\funcline{select}{n}
これらの関数はただ一つの引数を取り、pick/selectに使うバッファのサイズを
設定します。
\end{funcdesc}

\begin{funcdesc}{endpick}{}
\funcline{endselect}{}
これらの関数は引数を取りません。
pick/selectに使われているバッファの大きさを示す整数のリストを返します。
バッファがあふれているのを検出するメソッドはありません。
\end{funcdesc}

小さいですが完全なPythonのGLプログラムの例をここに挙げます：

\begin{verbatim}
import gl, GL, time

def main():
    gl.foreground()
    gl.prefposition(500, 900, 500, 900)
    w = gl.winopen('CrissCross')
    gl.ortho2(0.0, 400.0, 0.0, 400.0)
    gl.color(GL.WHITE)
    gl.clear()
    gl.color(GL.RED)
    gl.bgnline()
    gl.v2f(0.0, 0.0)
    gl.v2f(400.0, 400.0)
    gl.endline()
    gl.bgnline()
    gl.v2f(400.0, 0.0)
    gl.v2f(0.0, 400.0)
    gl.endline()
    time.sleep(5)

main()
\end{verbatim}


\begin{seealso}
  \seetitle[http://pyopengl.sourceforge.net/]
           {PyOpenGL: PythonのOpenGLとの結合}
            {OpenGL\index{OpenGL}へのインターフェースが利用できます；
           詳しくは\strong{PyOpenGL}\index{PyOpenGL}プロジェクト
           \url{http://pyopengl.sourceforge.net/}から情報を入手できま
           す。
これは、SGIのハードウェアが1996年頃より前である必要がないので、OpenGLの
方が良い選択かもしれません。}
\end{seealso}


\section{\module{DEVICE} ---
\module{gl}モジュールで使われる定数}

\declaremodule{standard}{DEVICE}
  \platform{IRIX}
\modulesynopsis{
\module{gl}モジュールで使われる定数。}

このモジュールには、Silicon Graphicsの\emph{Graphics Library}で使われる
定数が定義されています。これらはCのプログラマーがヘッダーファイル
\code{<gl/device.h>}の中から使っているものです。
詳しくはモジュールのソースファイルをご覧ください。

\section{\module{GL} ---
\module{gl}モジュールで使われる定数}

\declaremodule[gl-constants]{standard}{GL}
  \platform{IRIX}
\modulesynopsis{
\module{gl}モジュールで使われる定数。}

このモジュールにはSilicon Graphicsの\emph{Graphics Library}で使われる
Cのヘッダーファイル\code{<gl/gl.h>}の定数が定義されています。
詳しくはモジュールのソースファイルをご覧ください。

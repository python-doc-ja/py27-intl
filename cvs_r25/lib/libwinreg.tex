\section{\module{_winreg} --
         Windows レジストリへのアクセス}

\declaremodule[-winreg]{extension}{_winreg}
  \platform{Windows}
\modulesynopsis{Windows レジストリを操作するためのルーチンおよびオブジェクト。}
\sectionauthor{Mark Hammond}{MarkH@ActiveState.com}

\versionadded{2.0}

これらの関数は Windows レジストリ API を Python で使えるようにします。
プログラマがレジストリハンドルのクローズを失念した場合でも、確実に
ハンドルがクローズされるようにするために、整数値をレジストリハンドル
として使う代わりにハンドルオブジェクトが使われます。

このモジュールは Windows レジストリ操作のための非常に低レベルの
インタフェースを使えるようにします; 将来、より高レベルの
レジストリ API インタフェースを提供するような、新たな \code{winreg}
モジュールが作られるよう期待します。

このモジュールでは以下の関数を提供します:


\begin{funcdesc}{CloseKey}{hkey}
以前開かれたレジストリキーを閉じます。
\var{hkey} 引数には以前開かれたレジストリキーを特定します。

このメソッドを使って (または \method{handle.Close()} によって) \var{hkey}
が閉じられなかった場合、Python が \var{hkey} オブジェクトを破壊
する際に閉じられるので注意してください。
\end{funcdesc}


\begin{funcdesc}{ConnectRegistry}{computer_name, key}
他の計算機上にある既定のレジストリハンドル接続を確立し、
\dfn{ハンドルオブジェクト (handle object)} を返します。

\var{computer_name} はリモートコンピュータの名前で、
\code{r"\e\e computername"} の形式をとります。\code{None}
の場合、ローカルの計算機が使われます。

\var{key} は接続したい既定のハンドルです。

戻り値は開かれたキーのハンドルです。
関数が失敗した場合、\exception{EnvironmentError} 例外が
送出されます。
\end{funcdesc}


\begin{funcdesc}{CreateKey}{key, sub_key}
特定のキーを生成するか開き、\dfn{ハンドルオブジェクト}
を返します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数の
うちの一つです。

\var{sub_key} はこのメソッドが開く、または新規作成するキーの
名前です。

\var{key} が既定のキーの一つなら、\var{sub_key} は \code{None} 
でかまいません。この場合、返されるハンドルは関数に渡されたのと
同じキーハンドルです。

キーがすでに存在する場合、この関数は既に存在するキーを開きます。

戻り値は開かれたキーのハンドルです。この関数が失敗した場合、
\exception{EnvironmentError} 例外が送出されます。
\end{funcdesc}

\begin{funcdesc}{DeleteKey}{key, sub_key}
特定のキーを削除します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{sub_key}  は文字列で、\var{key} パラメタによって特定された
キーのサブキーでなければなりません。この値は \code{None} で
あってはならず、キーはサブキーを持っていてはなりません。

\emph{このメソッドはサブキーをもつキーを削除することはできません。}

このメソッドの実行が成功すると、キー全体が、その値すべてを含めて
削除されます。このメソッドが失敗した場合、
\exception{EnvironmentError} 例外が送出されます。
\end{funcdesc}


\begin{funcdesc}{DeleteValue}{key, value}
レジストリキーから指定された名前つきの値を削除します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つでなければなりません。

\var{value} は削除したい値を指定するための文字列です。
\end{funcdesc}


\begin{funcdesc}{EnumKey}{key, index}
開かれているレジストリキーのサブキーを列挙し、文字列で返します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つでなければなりません。

\var{index} は整数値で、取得するキーのインデクスを特定します。

この関数は呼び出されるたびに一つのサブキーの名前を取得します。
この関数は通常、これ以上サブキーがないことを示す
\exception{EnvironmentError} 例外が送出されるまで繰り返し呼び
出されます。
\end{funcdesc}


\begin{funcdesc}{EnumValue}{key, index}
開かれているレジストリキーの値を列挙し、タプルで返します。
  
\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つでなければなりません。

\var{index} は整数値で、取得する値のインデクスを特定します。

この関数は呼び出されるたびに一つの値の名前を取得します。
この関数は通常、これ以上値がないことを示す
\exception{EnvironmentError} 例外が送出されるまで繰り返し呼び
出されます。

結果は 3 要素のタプルになります:

 \begin{tableii}{c|p{3in}}{code}{Index}{Meaning}
   \lineii{0}{値の名前を特定する文字列}
   \lineii{1}{値のデータを保持するためのオブジェクトで、その型は背後の
レジストリ型に依存します}
   \lineii{2}{値のデータ型を特定する整数です}
 \end{tableii}

\end{funcdesc}


\begin{funcdesc}{FlushKey}{key}

キーのすべての属性をレジストリに書き込みます。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つでなければなりません。

キーを変更するために RegFlushKey を呼ぶ必要はありません。
レジストリの変更は怠惰なフラッシュ機構 (lazy flusher) を使って
フラッシュされます。また、システムの遮断時にもディスクにフラッシュ
されます。\function{CloseKey()} と違って、\function{FlushKey()} 
メソッドはレジストリに全てのデータを書き終えたときにのみ返ります。
アプリケーションは、レジストリへの変更を絶対に確実にディスク上に
反映させる必要がある場合にのみ、\function{FlushKey()} を呼ぶべきです。
 
\note{
\function{FlushKey()} を呼び出す必要があるかどうか分からない場合、
おそらくその必要はありません。
}
 
\end{funcdesc}


\begin{funcdesc}{RegLoadKey}{key, sub_key, file_name}
指定されたキーの下にサブキーを生成し、サブキーに指定されたファイル
のレジストリ情報を記録します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{sub_key} は記録先のサブキーを指定する文字列です。

\var{file_name} はレジストリデータを読み出すためのファイル名です。
このファイルは \function{SaveKey()} 関数で生成されたファイルでなくては
なりません。ファイル割り当てテーブル (FAT) ファイルシステム下では、
ファイル名は拡張子を持っていてはなりません。

この関数を呼び出しているプロセスが \constant{SE_RESTORE_PRIVILEGE}
特権を持たない場合には LoadKey() は失敗します。
この特権はファイル許可とは違うので注意してください - 詳細は Win32
ドキュメンテーションを参照してください。

\var{key} が \function{ConnectRegistry()} によって返されたハンドル
の場合、\var{fileName} に指定されたパスは遠隔計算機に対する相対パス
名になります。

Win32 ドキュメンテーションでは、\var{key} は \constant{HKEY_USER} 
または \constant{HKEY_LOCAL_MACHINE} ツリー内になければならない
とされています。これは正しいかもしれないし、そうでないかもしれません。
\end{funcdesc}


\begin{funcdesc}{OpenKey}{key, sub_key\optional{, res\code{ = 0}}\optional{, sam\code{ = \constant{KEY_READ}}}}
指定されたキーを開き、\dfn{ハンドルオブジェクト} を返します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{sub_key} は開きたいサブキーを特定する文字列です。

\var{res} 予約されている整数値で、ゼロでなくてはなりません。
標準の値はゼロです。
 
\var{sam} は必要なキーへのセキュリティアクセスを記述する、
アクセスマスクを指定する整数です。標準の値は \constant{KEY_READ} です。
 
指定されたキーへの新しいハンドルが返されます。

この関数が失敗すると 、\exception{EnvironmentError} が送出されます。
\end{funcdesc}


\begin{funcdesc}{OpenKeyEx}{}
\function{OpenKeyEx()} の機能は \function{OpenKey()}
を標準の引数で使うことで提供されています。
\end{funcdesc}


\begin{funcdesc}{QueryInfoKey}{key}
キーに関数情報をタプルとして返します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

結果は以下の 3 要素からなるタプルです:

 \begin{tableii}{c|p{3in}}{code}{インデクス}{意味}
   \lineii{0}{このキーが持つサブキーの数を表す整数。}
   \lineii{1}{このキーが持つ値の数を表す整数。}
   \lineii{2}{最後のキーの変更が (あれば) いつだったかを表す長整数で、
1600 年 1 月 1 日からの 100 ナノ秒単位で数えたもの。}
 \end{tableii}
\end{funcdesc}


\begin{funcdesc}{QueryValue}{key, sub_key}
キーに対する、名前付けられていない値を文字列で取得します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{sub_key} は値が関連付けられているサブキーの名前を保持する文字列
です。この引数が \code{None} または空文字列の場合、この関数は
\var{key} で特定されるキーに対して \function{SetValue()} メソッドで
設定された値を取得します。

レジストリ中の値は名前、型、およびデータから構成されています。
このメソッドはあるキーのデータ中で、名前 NULL をもつ最初の値を取得します。
しかし背後の API 呼び出しは型情報を返しません。非常に、非常に、非常に
不完全な実装です。この関数を使うべきではありません！！！
\end{funcdesc}


\begin{funcdesc}{QueryValueEx}{key, value_name}
開かれたレジストリキーに関連付けられている、指定した名前の値に対して、
型およびデータを取得します。
  
\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{value_name} は要求する値を指定する文字列です。

結果は 2 つの要素からなるタプルです:

 \begin{tableii}{c|p{3in}}{code}{インデクス}{意味}
   \lineii{0}{レジストリ要素の名前。}
   \lineii{1}{この値のレジストリ型を表す整数。}
 \end{tableii}
\end{funcdesc}


\begin{funcdesc}{SaveKey}{key, file_name}
指定されたキーと、そのサブキー全てを指定したファイルに保存します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{file_name} はレジストリデータを保存するファイルの名前です、
このファイルはすでに存在していてはいけません。このファイル名が
拡張子を含んでいる場合、\method{LoadKey()}、 \method{ReplaceKey()} 
または \method{RestoreKey()} メソッドは、ファイル割り当てテーブル
(FAT) 型ファイルシステムを使うことができません。

\var{key} が遠隔の計算機上にあるキーを表す場合、\var{file_name}
で記述されているパスは遠隔の計算機に対して相対的なパスになります。
このメソッドの呼び出し側は \constant{SeBackupPrivilege} 
セキュリティ特権を保有していなければなりません。この特権は
ファイルパーミッションとは異なります - 詳細は Win32 
ドキュメンテーションを参照してください。

この関数は \var{security_attributes} を NULL にして API に渡します。
\end{funcdesc}


\begin{funcdesc}{SetValue}{key, sub_key, type, value}
値を指定したキーに関連付けます。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{sub_key} は値が関連付けられているサブキーの名前を表す文字列です。
 
\var{type} はデータの型を指定する整数です。現状では、この値は
\constant{REG_SZ} でなければならず、これは文字列だけが
サポートされていることを示します。他のデータ型をサポートするには
\function{SetValueEx()} を使ってください。
 
\var{value} は新たな値を指定する文字列です。

\var{sub_key} 引数で指定されたキーが存在しなければ、
SetValue 関数で生成されます。

値の長さは利用可能なメモリによって制限されます。(2048 バイト以上の)
長い値はファイルに保存して、そのファイル名を設定レジストリに保存
するべきです。そうすればレジストリを効率的に動作させる役に立ちます。

\var{key} 引数に指定されたキーは \constant{KEY_SET_VALUE}
アクセスで開かれていなければなりません。
\end{funcdesc}


\begin{funcdesc}{SetValueEx}{key, value_name, reserved, type, value}
開かれたレジストリキーの値フィールドにデータを記録します。

\var{key} はすでに開かれたキーか、既定の \constant{HKEY_*} 定数
のうちの一つです。

\var{sub_key} は値が関連付けられているサブキーの名前を表す文字列です。

\var{type} はデータの型を指定する整数です。
値はこのモジュールで定義されている以下の定数のうちの一つでなければ
なりません:

 \begin{tableii}{l|p{3in}}{constant}{定数}{意味}
   \lineii{REG_BINARY}{何らかの形式のバイナリデータ。}
   \lineii{REG_DWORD}{32 ビットの数。}
   \lineii{REG_DWORD_LITTLE_ENDIAN}{32 ビットのリトルエンディアン形式の数。}
   \lineii{REG_DWORD_BIG_ENDIAN}{32 ビットのビッグエンディアン形式の数。}
   \lineii{REG_EXPAND_SZ}{環境変数を参照している、ヌル文字で終端された文字列。 (\samp{\%PATH\%})。}
   \lineii{REG_LINK}{Unicode のシンボリックリンク。}
   \lineii{REG_MULTI_SZ}{ヌル文字で終端された文字列からなり、二つのヌル文字で終端されている配列 (Python はこの終端の処理を自動的に行います)。}
   \lineii{REG_NONE}{定義されていない値の形式。}
   \lineii{REG_RESOURCE_LIST}{デバイスドライバリソースのリスト。}
   \lineii{REG_SZ}{ヌルで終端された文字列。}
 \end{tableii}

\var{reserved} は何もしません - API には常にゼロが渡されます。

\var{value} は新たな値を指定する文字列です。

このメソッドではまた、指定されたキーに対して、さらに別の値や型情報を
設定することができます。\var{key} 引数で指定されたキーは
\constant{KEY_SET_VALUE} アクセスで開かれていなければなりません。

キーを開くには、 \function{CreateKeyEx()} または \function{OpenKey()} 
メソッドを使ってください。

値の長さは利用可能なメモリによって制限されます。(2048 バイト以上の)
長い値はファイルに保存して、そのファイル名を設定レジストリに保存
するべきです。そうすればレジストリを効率的に動作させる役に立ちます。

\end{funcdesc}



\subsection{レジストリハンドルオブジェクト \label{handle-object}}

このオブジェクトは Windows の HKEY オブジェクトをラップし、
オブジェクトが破壊されたときに自動的にハンドルを閉じます。
オブジェクトの \method{Close()} メソッドと \function{CloseKey()} 関数
のどちらも、後始末がきちんと行われることを保証するために呼び出す
ことができます。

このモジュールのレジストリ関数は全て、これらのハンドル
オブジェクトの一つを返します。

このモジュールのレジストリ関数でハンドルオブジェクトを受理する
ものは全て整数も受理しますが、ハンドルオブジェクトを利用する
ことを推奨します。
 
ハンドルオブジェクトは \method{__nonzero__()} の意味構成を持ちます -
すなわち、
\begin{verbatim}
    if handle:
        print "Yes"
\end{verbatim}
は、ハンドルが現在有効な (閉じられたり切り離されたりしていない) 場合
には \code{Yes} となります。

ハンドルオブジェクトはまた、比較の意味構成もサポートしています。
このため、背後の Windows ハンドル値が同じものを複数のハンドルオブジェクト
が参照している場合、それらの比較は真になります。

ハンドルオブジェクトは (例えば組み込みの \function{int()} 関数を
使って) 整数に変換することができます。この場合、背後の
Windows ハンドル値が返されます、また、 \method{Detach()} メソッド
を使って整数のハンドル値を返させると同時に、ハンドルオブジェクト
から Windows ハンドルを切り離すこともできます。

\begin{methoddesc}[PyHKEY]{Close}{}
背後の Windows ハンドルを閉じます。

ハンドルがすでに閉じられていてもエラーは送出されません。
\end{methoddesc}


\begin{methoddesc}[PyHKEY]{Detach}{}
ハンドルオブジェクトから Windows ハンドルを切り離します。

切り離される以前にそのハンドルを保持していた整数 (または 64 ビット 
Windows の場合には長整数) オブジェクトが返されます。
ハンドルがすでに切り離されていたり閉じられていたりした場合、
ゼロが返されます。

この関数を呼び出した後、ハンドルは確実に無効化されますが、
閉じられるわけではありません。背後の Win32 ハンドルがハンドル
オブジェクトよりも長く維持される必要がある場合にはこの
関数を呼び出すとよいでしょう。
\end{methoddesc}


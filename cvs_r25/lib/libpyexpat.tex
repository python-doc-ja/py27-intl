\section{\module{xml.parsers.expat} ---
         Expat を使った高速な XML 解析}

% Markup notes:
%
% Many of the attributes of the XMLParser objects are callbacks.
% Since signature information must be presented, these are described
% using the methoddesc environment.  Since they are attributes which
% are set by client code, in-text references to these attributes
% should be marked using the \member macro and should not include the
% parentheses used when marking functions and methods.

\declaremodule{standard}{xml.parsers.expat}
\modulesynopsis{Expat による、検証を行わない XML パーザへのインタフェース}
\moduleauthor{Paul Prescod}{paul@prescod.net}

\versionadded{2.0}

\module{xml.parsers.expat} モジュールは、検証 (validation) を
行わない XML パーザ (parser, 解析器)、Expat\index{Expat} への
Python インタフェースです。
モジュールは一つの拡張型 \class{xmlparser} を提供します。これは
XMLパーザの現在の状況を表します。一旦 \class{xmlparser} オブジェクトを
生成すると、オブジェクトの様々な属性をハンドラ関数 (handler function)
に設定できます。
その後、XML 文書をパーザに入力すると、 XML文書の文字列とマークアップ
に応じてハンドラ関数が呼び出されます。

このモジュールでは、Expatパーザへのアクセスを提供するために
\module{pyexpat}\refbimodindex{pyexpat}モジュールを使用します。
\module{pyexpat}モジュールの直接使用は撤廃されています。

このモジュールは、例外を一つと型オブジェクトを一つ提供しています。

\begin{excdesc}{ExpatError}
  Expat がエラーを報告したときに例外を送出します。Expatのエラーを
  解釈する上での詳細な情報は、 \ref{expaterror-objects} の
``ExpatError Exceptions,''
  を参照してください。
\end{excdesc}

\begin{excdesc}{error}
  \exception{ExpatError}への別名です。
\end{excdesc}

\begin{datadesc}{XMLParserType}
  \function{ParserCreate()} 関数から返された戻り値の型を示します。
\end{datadesc}


\module{xml.parsers.expat} モジュールには以下の 2 つの関数が収められて
います:

\begin{funcdesc}{ErrorString}{errno}
与えられたエラー番号 \var{errno} を解説する文字列を返します。
\end{funcdesc}

\begin{funcdesc}{ParserCreate}{\optional{encoding\optional{,
                               namespace_separator}}}
新しい \class{xmlparser} オブジェクトを作成し、返します。
\var{encoding} が指定されていた場合、XMLデータで使われている
文字列のエンコード名でなければなりません。Expatは、Pythonのように多くの
エンコードをサポートしておらず、またエンコーディングのレパートリを
拡張することはできません; サポートするエンコードは、UTF-8, 
UTF-16, ISO-8859-1 (Latin1), ASCII です。\var{encoding}が
指定されると、文書に対する明示的、非明示的なエンコード指定を
上書き (override) します。

Expat はオプションで XML 名前空間の処理を行うことができます。
これは引数  \var{namespace_separator} に値を指定することで
有効になります。
この値は、1文字の文字列でなければなりません; 文字列が誤った長さ
を持つ場合には \exception{ValueError} が送出されます (\code{None} は
値の省略と見なされます) 名前空間の処理が可能なとき、名前空間に属する
要素と属性が展開されます。要素のハンドラである 
\member{StartElementHandler} と \member{EndElementHandler} に渡された
要素名は、名前空間のURI、名前空間の区切り文字、要素名のローカル部を
連結したものになります。名前空間の区切り文字が 0 バイト 
(\code{chr(0)}) の場合、名前空間の URI とローカル部は区切り文字なしで
連結されます。

たとえば、 \var{namespace_separator} に空白文字(\character{ })がセットされ、
次のような文書が解析されるとします。

\begin{verbatim}
<?xml version="1.0"?>
<root xmlns    = "http://default-namespace.org/"
      xmlns:py = "http://www.python.org/ns/">
  <py:elem1 />
  <elem2 xmlns="" />
</root>
\end{verbatim}

\member{StartElementHandler} は各要素ごとに次のような文字列を受け取ります。

\begin{verbatim}
http://default-namespace.org/ root
http://www.python.org/ns/ elem1
elem2
\end{verbatim}
\end{funcdesc}


\begin{seealso}
  \seetitle[http://www.libexpat.org/]{The Expat XML Parser}
           {Expatプロジェクトのホームページ}
\end{seealso}


\subsection{XMLParser Objects \label{xmlparser-objects}}

\class{xmlparser} オブジェクトは以下のようなメソッドを持ちます。

\begin{methoddesc}[xmlparser]{Parse}{data\optional{, isfinal}}
文字列 \var{data} の内容を解析し、解析されたデータを処理するための
適切な関数を呼び出します。このメソッドを最後に呼び出す時は
\var{isfinal} を真にしなければなりません。 
\var{data} は空の文字列を取ることもできます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{ParseFile}{file}
\var{file} オブジェクトから読み込んだXMLデータを解析します。 
\var{file} には \method{read(\var{nbytes})} メソッドのみが必要です。
このメソッドはデータがなくなった場合に空文字列を返さねばなりません。。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{SetBase}{base}
(XML) 宣言中のシステム識別子中の相対 URI を解決するための、
基底 URI を設定します。相対識別子の解決はアプリケーションに
任されます: この値は関数 \function{ExternalEntityRefHandler} や
\function{NotationDeclHandler}、\function{UnparsedEntityDeclHandler}
に引数 \var{base} としてそのまま渡されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{GetBase}{}
以前の \method{SetBase()} によって設定された基底 URI を文字列の形で
返します。\method{SetBase()}が呼ばれていないときには \code{None} を
返します。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{GetInputContext}{}
現在のイベントを発生させた入力データを文字列として返します。
データはテキストの入っているエンティティが持っているエンコードに
なります。
イベントハンドラがアクティブでないときに呼ばれると、戻り値は
\code{None}となります。
\versionadded{2.1}
\end{methoddesc}

\begin{methoddesc}[xmlparser]{ExternalEntityParserCreate}{context\optional{,
                                                          encoding}}
親となるパーザで解析された内容が参照している、外部で解析される
エンティティを解析するために使える ``子の'' パーザを作成します。
\var{context} パラメータは、以下に記すように
\method{ExternalEntityRefHandler()} 
ハンドラ関数に渡される文字列でなければなりません。子のパーザは
\member{ordered_attributes}、\member{returns_unicode}、
\member{specified_attributes} が現在のパーザの値に設定されて
生成されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{UseForeignDTD}{\optional{flag}}
\var{flag}の値をデフォルトのtrueにすると、Expatは代わりのDTDを
ロードするため、すべての引数に\constant{None} を設定して
\member{ExternalEntityRefHandler} を呼び出します。XML文書が
文書型定義を持っていなければ、 \member{ExternalEntityRefHandler} 
が呼び出しますが、\member{StartDoctypeDeclHandler} と
\member{EndDoctypeDeclHandler}は呼び出されません。

\var{flag} にfalseを与えると、メソッドが前回呼ばれた時のtrueの
設定が解除されますが、他には何も起こりません。

このメソッドは \method{Parse()} または \method{ParseFile()}
メソッドが呼び出される前にだけ呼び出されます;これら2つのメソッドの
どちらかが呼び出されたあとにメソッドが呼ばれると、 \member{code} に
定数 \constant{errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING} が
設定されて例外 \exception{ExpatError} が送出されます。

\versionadded{2.3}
\end{methoddesc}


\class{xmlparser} オブジェクトは次のような属性を持ちます:

\begin{memberdesc}[xmlparser]{buffer_size}
\member{buffer_text} が真の時に使われるバッファのサイズです。
この値は変更できません。
\versionadded{2.3}
\end{memberdesc}

\begin{memberdesc}[xmlparser]{buffer_text}
この値を真にすると、\class{xmlparser} オブジェクトが Expatから返された
もとの内容をバッファに保持するようになります。これにより可能なときに
何度も \method{CharacterDataHandler()} を呼び出してしまうようなことを
避けることができます。Expatは通常、文字列のデータを行末ごと大量に破棄
するため、かなりパフォーマンスを改善できるはずです。この属性はデフォルト
では偽で、いつでも変更可能です。
\versionadded{2.3}
\end{memberdesc}

\begin{memberdesc}[xmlparser]{buffer_used}
\member{buffer_text} が利用可能なとき、バッファに保持されたバイト数です。
これらのバイトはUTF-8でエンコードされたテキストを表します。この属性は
 \member{buffer_text} が偽の時には意味がありません。
\versionadded{2.3}
\end{memberdesc}

\begin{memberdesc}[xmlparser]{ordered_attributes}
この属性をゼロ以外の整数にすると、報告される(XMLノードの) 属性を
辞書型ではなくリスト型にします。属性は文書のテキスト中の出現順で示されます。
それぞれの属性は、2つのリストのエントリ: 属性名とその値、が与えられます。
(このモジュールの古いバージョンでも、同じフォーマットが使われています。)
デフォルトでは、この属性はデフォルトでは偽となりますが、
いつでも変更可能です。
\versionadded{2.1}
\end{memberdesc}

\begin{memberdesc}[xmlparser]{returns_unicode} 
この属性をゼロ以外の整数にすると、ハンドラ関数に Unicode 文字列が
渡されます。 \member{returns_unicode} が \constant{False} の時には、UTF-8でエンコード
されたデータを含む 8 ビット文字列がハンドラに渡されます。Pythonがユニコード
サポートつきでビルドされている場合、この値はデフォルトで\constant{True}です。
\versionchanged[戻り値の型がいつでも変更できるように変更されたはずです]{1.6}
\end{memberdesc}

\begin{memberdesc}[xmlparser]{specified_attributes}
ゼロ以外の整数にすると、パーザは文書のインスタンスで特定される
属性だけを報告し、属性宣言から導出された属性は報告しないようになります。
この属性が指定されたアプリケーションでは、XMLプロセッサの振る舞いに
関する標準に従うために必要とされる (文書型) 宣言によって、どのような
付加情報が利用できるのかということについて特に注意を払わなければなりません。
デフォルトで、この属性は偽となりますが、いつでも変更可能です。
\versionadded{2.1}
\end{memberdesc}

以下の属性には、 \class{xmlparser} オブジェクトで最も最近に起きた
エラーに関する値が入っており、また \method{Parse()} または 
\method{ParseFile()}メソッドが \exception{xml.parsers.expat.ExpatError} 
例外を送出した際にのみ正しい値となります。

\begin{memberdesc}[xmlparser]{ErrorByteIndex} 
エラーが発生したバイトのインデクスです。
\end{memberdesc} 

\begin{memberdesc}[xmlparser]{ErrorCode} 
エラーを特定する数値によるコードです。この値は\function{ErrorString()} に
渡したり、 \code{errors} オブジェクトで定義された内容と比較できます。
\end{memberdesc}

\begin{memberdesc}[xmlparser]{ErrorColumnNumber} 
エラーの発生したカラム番号です。
\end{memberdesc}

\begin{memberdesc}[xmlparser]{ErrorLineNumber}
エラーの発生した行番号です。
\end{memberdesc}

以下の属性は \class{xmlparser} オブジェクトがその時パースしている位置に
関する値を保持しています。コールバックがパースイベントを報告している間、
これらの値はイベントの生成した文字列の先頭の位置を指し示します。
コールバックの外から参照された時には、（対応するコールバックであるかに
かかわらず）直前のパースイベントの位置を示します。
\versionadded{2.4}

\begin{memberdesc}[xmlparser]{CurrentByteIndex} 
パーサへの入力の、現在のバイトインデックス。
\end{memberdesc} 

\begin{memberdesc}[xmlparser]{CurrentColumnNumber} 
パーサへの入力の、現在のカラム番号。
\end{memberdesc}

\begin{memberdesc}[xmlparser]{CurrentLineNumber}
パーサへの入力の、現在の行番号。
\end{memberdesc}

以下に指定可能なハンドラのリストを示します。
\class{xmlparser} オブジェクト \var{o} に
ハンドラを指定するには、\code{\var{o}.\var{handlername} = \var{func}}
を使用します。 \var{handlername} は、以下のリストに挙げた値をとらねば
ならず、また \var{func} は正しい数の引数を受理する呼び出し可能な
オブジェクトでなければなりません。引数は特に明記しない限り、すべて
文字列となります。
\begin{methoddesc}[xmlparser]{XmlDeclHandler}{version, encoding, standalone}
XML 宣言が解析された時に呼ばれます。XML宣言とは、XML勧告の適用
バージョン (オプション)、文書テキストのエンコード、そしてオプションの
``スタンドアロン'' の宣言です。 \var{version} と \var{encoding} は
\member{returns_unicode} 属性によって指示された型を示す文字列となり、
 \var{standalone} は、文書がスタンドアロンであると宣言される場合には
\code{1}に、文書がスタンドアロンでない場合には \code{0} に、
スタンドアロン宣言を省略する場合には \code{-1} になります。
このハンドラは Expat のバージョン1.95.0以降のみ使用できます。
\versionadded{2.1}
\end{methoddesc}

\begin{methoddesc}[xmlparser]{StartDoctypeDeclHandler}{doctypeName,
                                                       systemId, publicId,
                                                       has_internal_subset}
Expatが文書型宣言\code{<!DOCTYPE \ldots})を解析し始めたときに
呼び出されます。\var{doctypeName} は、与えられた値がそのまま
Expat に提供されます。\var{systemId} と \var{publicId} パラメタが
指定されている場合、それぞれシステムと公開識別子を与えます。
省略する時には\code{None} にします。文書が内部的な文書宣言のサブセット
(internal document declaration subset) を持つか、サブセット自体の
場合、\var{has_internal_subset} は true になります。
このハンドラには、Expat version 1.2以上が必要です。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{EndDoctypeDeclHandler}{}
Expatが文書型宣言の解析を終えたときに呼び出されます。
このハンドラには、Expat version 1.2以上が必要です。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{ElementDeclHandler}{name, model}
それぞれの要素型宣言ごとに呼び出されます。\var{name}は要素型の名前であり、
\var{model} は内容モデル (content model) の表現です。
\end{methoddesc}
%-------------

\begin{methoddesc}[xmlparser]{AttlistDeclHandler}{elname, attname,
                                                  type, default, required}
ひとつの要素型で宣言される属性ごとに呼び出されます。属性リストの宣言が
3つの属性を宣言したとすると、このハンドラはひとつの属性に1度づつ、
3度呼び出されます。
\var{elname} は要素名であり、これに対して宣言が適用され、\var{attname}が
宣言された属性名となります。 属性型は文字列で、\var{type} として渡され
ます; 取りえる値は、\code{'CDATA'}, \code{'ID'},\code{'IDREF'}, ...
です。
\var{default}は、属性が文書のインスタンスによって指定されていないときに
使用されるデフォルト値を与えます。デフォルト値(\code{\#IMPLIED} values)が
存在しないときには\code{None}を与えます。文書のインスタンスによって属性値が
与えられる必要のあるときには\var{required}がtrueになります。
このメソッドはExpat version 1.95.0 以上が必要です。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{StartElementHandler}{name, attributes}
要素の開始を処理するごとに呼び出されます。\var{name} は要素名を格納した
文字列で、\var{attributes} はその値に属性名を対応付ける辞書型です。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{EndElementHandler}{name}
要素の終端を処理するごとに呼び出されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{ProcessingInstructionHandler}{target, data}
Called for every processing instruction.
処理命令を処理するごとに呼び出されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{CharacterDataHandler}{data}
文字データを処理するときに呼びだされます。このハンドラは通常の文字データ、
CDATAセクション、無視できる空白文字列のために呼び出されます。
これらを識別しなければならないアプリケーションは、要求された情報を
収集するために \member{StartCdataSectionHandler}, \member{EndCdataSectionHandler},
and \member{ElementDeclHandler}コールバックメソッドを使用できます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{UnparsedEntityDeclHandler}{entityName, base,
                                                         systemId, publicId,
                                                         notationName}
解析されていない (NDATA) エンティティ宣言を処理するために呼び出されます。
このハンドラは Expat ライブラリのバージョン1.2のためだけに存在します;
より最近のバージョンでは、
代わりに\member{EntityDeclHandler}を使用してください (根底にある
Expat ライブラリ内の関数は、撤廃されたものであると宣言されています)。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{EntityDeclHandler}{entityName,
                                                 is_parameter_entity, value,
                                                 base, systemId,
                                                 publicId,
                                                 notationName}
エンティティ宣言ごとに呼び出されます。パラメタと内部エンティティに
ついて、\var{value} はエンティティ宣言の宣言済みの内容を与える文字列
となります; 外部エンティティの時には\code{None} となります。解析済み
エンティティの場合、\var{notationName} パラメタは \code{None} となり、
解析されていないエンティティの時には記法 (notation) 名となります。
\var{is_parameter_entity} は、エンティティがパラメタエンティティの
場合真に、一般エンティティ (general entitiy) の場合には偽になります
(ほとんどのアプリケーションでは、一般エンティティのことしか気に
する必要がありません)。
このハンドラは Expat ライブラリのバージョン1.95.0 以降でのみ使用できます。
\versionadded{2.1}
\end{methoddesc}

\begin{methoddesc}[xmlparser]{NotationDeclHandler}{notationName, base,
                                                   systemId, publicId}
記法の宣言 (notation declaration) で呼び出されます。
\var{notationName}, \var{base}, \var{systemId}, および \var{publicId} 
を与える場合、文字列にします。public な識別子が省略された場合、
\var{publicId} は \code{None} になります。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{StartNamespaceDeclHandler}{prefix, uri}
要素が名前空間宣言を含んでいる場合に呼び出されます。名前空間宣言は、
宣言が配置されている要素に対して \member{StartElementHandler} が
呼び出される前に処理されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{EndNamespaceDeclHandler}{prefix}
名前空間宣言を含んでいたエレメントの終了タグに到達したときに
呼び出されます。このハンドラは、要素に関する名前空間宣言ごとに、
\member{StartNamespaceDeclHandler} とは逆の順番で一度だけ呼び
出され、各名前空間宣言のスコープが開始されたことを示します。
このハンドラは、要素が終了する際、対応する
 \member{EndElementHandler} が呼ばれた後に呼び出されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{CommentHandler}{data}
コメントで呼び出されます。\var{data} はコメントのテキストで、
先頭の `\code{<!-}\code{-}' と末尾の `\code{-}\code{->}'
を除きます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{StartCdataSectionHandler}{}
CDATA セクションの開始時に呼び出されます。CDATA セクションの
構文的な開始と終了位置を識別できるようにするには、このハンドラと
\member{EndCdataSectionHandler} が必要です。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{EndCdataSectionHandler}{}
CDATA セクションの終了時に呼び出されます。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{DefaultHandler}{data}
XML 文書中で、適用可能なハンドラが指定されていない
文字すべてに対して呼び出されます。この文字とは、検出されたことが
報告されるが、ハンドラは指定されていないような
コンストラクト (construct) の一部である文字を意味します。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{DefaultHandlerExpand}{data}
\function{DefaultHandler} と同じですが、内部エンティティの
展開を禁止しません。エンティティ参照はデフォルトハンドラに
渡されません。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{NotStandaloneHandler}{} 
XML 文書がスタンドアロンの文書として宣言されていない場合に呼び出されます。
外部サブセットやパラメタエンティティへの参照が存在するが、XML 宣言が
XML 宣言中で standalone 変数を \code{yes} に設定していない場合に
起きます。このハンドラが \code{0} を返すと、パーザは 
\constant{XML_ERROR_NOT_STANDALONE} を送出します。
このハンドラが設定されていなければ、パーザは前述の事態で
例外を送出しません。
\end{methoddesc}

\begin{methoddesc}[xmlparser]{ExternalEntityRefHandler}{context, base,
                                                        systemId, publicId}
外部エンティティの参照時に呼び出されます。\var{base} は現在の基底
(base) で、以前の \method{SetBase()} で設定された値になっています。
public、および system の識別子である、\var{systemId} と\var{publicId}
が指定されている場合、値は文字列です; public 識別子が指定されていない
場合、 \var{publicId} は \code{None} になります。
\var{context} の値は不明瞭なものであり、以下に記述するようにしか
使ってはなりません。

外部エンティティが解析されるようにするには、このハンドラを実装
しなければなりません。このハンドラは、
\code{ExternalEntityParserCreate(\var{context})} を使って
適切なコールバックを指定し、子パーザを生成して、
エンティティを解析する役割を担います。このハンドラは整数を
返さねばなりません;  \code{0} を返した場合、パーザは
\constant{XML_ERROR_EXTERNAL_ENTITY_HANDLING} エラーを送出します。
そうでないばあい、解析を継続します。

このハンドラが与えられておらず、
\member{DefaultHandler} コールバックが指定されていれば、
外部エンティティは\member{DefaultHandler} で報告されます。
\end{methoddesc}


\subsection{ExpatError 例外 \label{expaterror-objects}}
\sectionauthor{Fred L. Drake, Jr.}{fdrake@acm.org}

\exception{ExpatError} 例外はいくつかの興味深い属性を備えています:

\begin{memberdesc}[ExpatError]{code}
特定のエラーにおける Expat の内部エラー番号です。この値は
このモジュールの\code{errors} オブジェクトで定義されている
定数のいずれかに一致します。
  \versionadded{2.1}
\end{memberdesc}

\begin{memberdesc}[ExpatError]{lineno}
エラーが検出された場所の行番号です。最初の行の番号は \code{1} です。
  \versionadded{2.1}
\end{memberdesc}

\begin{memberdesc}[ExpatError]{offset}
エラーが発生した場所の行内でのオフセットです。最初のカラムの番号は
\code{0} です。
  \versionadded{2.1}
\end{memberdesc}


\subsection{例 \label{expat-example}}

以下のプログラムでは、与えられた引数を出力するだけの三つのハンドラを
定義しています。

\begin{verbatim}
import xml.parsers.expat

# 3 handler functions
def start_element(name, attrs):
    print 'Start element:', name, attrs
def end_element(name):
    print 'End element:', name
def char_data(data):
    print 'Character data:', repr(data)

p = xml.parsers.expat.ParserCreate()

p.StartElementHandler = start_element
p.EndElementHandler = end_element
p.CharacterDataHandler = char_data

p.Parse("""<?xml version="1.0"?>
<parent id="top"><child1 name="paul">Text goes here</child1>
<child2 name="fred">More text</child2>
</parent>""")
\end{verbatim}

このプログラムの出力は以下のようになります:

\begin{verbatim}
Start element: parent {'id': 'top'}
Start element: child1 {'name': 'paul'}
Character data: 'Text goes here'
End element: child1
Character data: '\n'
Start element: child2 {'name': 'fred'}
Character data: 'More text'
End element: child2
Character data: '\n'
End element: parent
\end{verbatim}


\subsection{内容モデルの記述 \label{expat-content-models}}
\sectionauthor{Fred L. Drake, Jr.}{fdrake@acm.org}

内容モデルは入れ子になったタプルを使って記述されています。
各タプルには 4 つの値: 型、限定詞 (quantifier)、名前、そして子の
タプル、が収められています。子のタプルは単に内容モデルを
記述したものです。

最初の二つのフィールドの値は \module{xml.parsers.expat} モジュールの
\code{model} オブジェクトで定義されている定数です。これらの定数は
二つのグループ: モデル型 (model type) グループと限定子 (quantifier)
グループ、に取りまとめられます。

以下にモデル型グループにおける定数を示します:

\begin{datadescni}{XML_CTYPE_ANY}
モデル名で指定された要素は \code{ANY} の内容モデルを持つと
宣言されます。
\end{datadescni}

\begin{datadescni}{XML_CTYPE_CHOICE}
指定されたエレメントはいくつかのオプションから選択できるようになって
います; \code{(A | B | C)} のような内容モデルで用いられます。
\end{datadescni}

\begin{datadescni}{XML_CTYPE_EMPTY}
\code{EMPTY} であると宣言されている要素はこのモデル型を持ちます。
\end{datadescni}

\begin{datadescni}{XML_CTYPE_MIXED}
\end{datadescni}

\begin{datadescni}{XML_CTYPE_NAME}
\end{datadescni}

\begin{datadescni}{XML_CTYPE_SEQ}
順々に続くようなモデルの系列を表すモデルがこのモデル型で表されます。
\code{(A, B, C)} のようなモデルで用いられます。
\end{datadescni}


限定子グループにおける定数を以下に示します:

\begin{datadescni}{XML_CQUANT_NONE}
修飾子 (modifier) が指定されていません。従って \code{A} のように、
厳密に一つだけです。
\end{datadescni}

\begin{datadescni}{XML_CQUANT_OPT}
このモデルはオプションです: \code{A?} のように、一つか全くないかです。
\end{datadescni}

\begin{datadescni}{XML_CQUANT_PLUS}
このモデルは (\code{A+} のように) 一つかそれ以上あります。
\end{datadescni}

\begin{datadescni}{XML_CQUANT_REP}
このモデルは \code{A*} のようにゼロ回以上あります。
\end{datadescni}


\subsection{Expat エラー定数 \label{expat-errors}}

以下の定数は \refmodule{xml.parsers.expat} モジュールにおける
\code{errors} オブジェクトで提供されています。これらの定数は、
エラーが発生した際に送出される \exception{ExpatError}
例外オブジェクトのいくつかの属性を解釈する上で便利です。

\code{errors} オブジェクトは以下の属性を持ちます:

\begin{datadescni}{XML_ERROR_ASYNC_ENTITY}
\end{datadescni}

\begin{datadescni}{XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF}
属性値中のエンティティ参照が、内部エンティティではなく外部エンティティ
を参照しました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_BAD_CHAR_REF}
文字参照が、XML では正しくない (illegal) 文字を参照しました
(例えば \code{0} や `\code{\&\#0;}')。
\end{datadescni}

\begin{datadescni}{XML_ERROR_BINARY_ENTITY_REF}
エンティティ参照が、記法 (notation) つきで宣言されている
エンティティを参照したため、解析できません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_DUPLICATE_ATTRIBUTE}
一つの属性が一つの開始タグ内に一度より多く使われています。
\end{datadescni}

\begin{datadescni}{XML_ERROR_INCORRECT_ENCODING}
\end{datadescni}

\begin{datadescni}{XML_ERROR_INVALID_TOKEN}
入力されたバイトが文字に適切に関連付けできない際に送出されます;
例えば、UTF-8 入力ストリームにおける NUL バイト (値 \code{0}) 
などです。
\end{datadescni}

\begin{datadescni}{XML_ERROR_JUNK_AFTER_DOC_ELEMENT}
空白以外の何かがドキュメント要素の後にあります。
\end{datadescni}

\begin{datadescni}{XML_ERROR_MISPLACED_XML_PI}
入力データの先頭以外の場所に XML 定義が見つかりました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_NO_ELEMENTS}
このドキュメントには要素が入っていません (XML では全てのドキュメントは
確実にトップレベルの要素を一つ持つよう要求しています)。
\end{datadescni}

\begin{datadescni}{XML_ERROR_NO_MEMORY}
Expat が内部メモリを確保できませんでした。
\end{datadescni}

\begin{datadescni}{XML_ERROR_PARAM_ENTITY_REF}
パラメタエンティティが許可されていない場所で見つかりました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_PARTIAL_CHAR}
入力に不完全な文字が見つかりました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_RECURSIVE_ENTITY_REF}
エンティティ参照中に、同じエンティティへの別の参照が入っていました;
おそらく違う名前で参照しているか、間接的に参照しています。
\end{datadescni}

\begin{datadescni}{XML_ERROR_SYNTAX}
何らかの仕様化されていない構文エラーに遭遇しました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_TAG_MISMATCH}
終了タグが最も内側で開かれている開始タグに一致しません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNCLOSED_TOKEN}
何らかの (開始タグのような) トークン が閉じられないまま、
ストリームの終端や次のトークンに遭遇しました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNDEFINED_ENTITY}
定義されていないエンティティへの参照が行われました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNKNOWN_ENCODING}
ドキュメントのエンコードが Expat でサポートされていません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNCLOSED_CDATA_SECTION}
CDATAセクションが閉じられていません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_EXTERNAL_ENTITY_HANDLING}
\end{datadescni}

\begin{datadescni}{XML_ERROR_NOT_STANDALONE}
XML文書が``standalone''だと宣言されており
 \member{NotStandaloneHandler} が設定され \code{0}が
返されているにもかかわらず、パーサは``standalone''では
ないと判別しました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNEXPECTED_STATE}
\end{datadescni}

\begin{datadescni}{XML_ERROR_ENTITY_DECLARED_IN_PE}
\end{datadescni}

\begin{datadescni}{XML_ERROR_FEATURE_REQUIRES_XML_DTD}
その操作を完了するにはDTDのサポートが必要ですが、ExpatがDTDの
サポートをしない設定になっています。これは \module{xml.parsers.expat}
モジュールの標準的なビルドでは報告されません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING}
パースが始まったあとで動作の変更が要求されました。これはパースが
開始される前にのみ変更可能です。（現在のところ） \method{UseForeignDTD()}
によってのみ送出されます。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNBOUND_PREFIX}
名前空間の処理を有効すると宣言されていないプレフィックスが見つかります。
\end{datadescni}

\begin{datadescni}{XML_ERROR_UNDECLARING_PREFIX}
XML文書はプレフィックスに対応した名前空間宣言を削除しようとしました。
\end{datadescni}

\begin{datadescni}{XML_ERROR_INCOMPLETE_PE}
パラメータエンティティは不完全なマークアップを含んでいます。
\end{datadescni}

\begin{datadescni}{XML_ERROR_XML_DECL}
XML文書中に要素がありません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_TEXT_DECL}
外部エンティティ中のテキスト宣言にエラーがあります。
\end{datadescni}

\begin{datadescni}{XML_ERROR_PUBLICID}
パブリックID中に許可されていない文字があります。
\end{datadescni}

\begin{datadescni}{XML_ERROR_SUSPENDED}
要求された操作は一時停止されたパーサで行われていますが、
許可されていない操作です。このエラーは追加の入力を
行なおうとしている場合、もしくはパーサが停止しようと
している場合にも送出されます。
\end{datadescni}

\begin{datadescni}{XML_ERROR_NOT_SUSPENDED}
パーサを一時停止しようとしましたが、停止されませんでした。
\end{datadescni}

\begin{datadescni}{XML_ERROR_ABORTED}
Pythonアプリケーションには通知されません。
\end{datadescni}

\begin{datadescni}{XML_ERROR_FINISHED}
要求された操作で、パース対象となる入力が完了したと判断
しましたが、入力は受理されませんでした。このエラーは
追加の入力を行なおうとしている場合、もしくはパーサが
停止しようとしている場合に送出されます。
\end{datadescni}

\begin{datadescni}{XML_ERROR_SUSPEND_PE}
\end{datadescni}

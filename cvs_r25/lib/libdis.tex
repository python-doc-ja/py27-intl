\section{\module{dis} ---
         Pythonバイトコードの逆アセンブラ}

\declaremodule{standard}{dis}
\modulesynopsis{Pythonバイトコードの逆アセンブラ。}


\module{dis}モジュールはPythonバイトコードを逆アセンブルしてバイトコードの解析を助けます。Pythonアセンブラがないため、このモジュールがPythonアセンブリ言語を定義しています。このモジュールが入力として受け取るPythonバイトコードはファイル\file{Include/opcode.h}に定義されており、コンパイラとインタプリタが使用しています。

例: 関数\function{myfunc}を考えると:

\begin{verbatim}
def myfunc(alist):
    return len(alist)
\end{verbatim}

次のコマンドを\function{myfunc()}の逆アセンブリを得るために使うことができます:

\begin{verbatim}
>>> dis.dis(myfunc)
  2           0 LOAD_GLOBAL              0 (len)
              3 LOAD_FAST                0 (alist)
              6 CALL_FUNCTION            1
              9 RETURN_VALUE        
\end{verbatim}

(``2''は行番号です)。

\module{dis}モジュールは次の関数と定数を定義します:

\begin{funcdesc}{dis}{\optional{bytesource}}
\var{bytesource}オブジェクトを逆アセンブルします。\var{bytesource}はモジュール、クラス、関数、あるいはコードオブジェクトのいずれかを示します。モジュールに対しては、すべての関数を逆アセンブルします。クラスに対しては、すべてのメソッドを逆アセンブルします。単一のコードシーケンスに対しては、バイトコード命令ごとに一行をプリントします。オブジェクトが与えられない場合は、最後のトレースバックを逆アセンブルします。
\end{funcdesc}

\begin{funcdesc}{distb}{\optional{tb}}
トレースバックのスタックの先頭の関数を逆アセンブルします。Noneが渡された場合は最後のトレースバックを使います。例外を引き起こした命令が表示されます。
\end{funcdesc}

\begin{funcdesc}{disassemble}{code\optional{, lasti}}
コードオブジェクトを逆アセンブルします。\var{lasti}が与えられた場合は、最後の命令を示します。出力は次のようなカラムに分割されます:

\begin{enumerate}
\item 各行の最初の命令に対する行番号。
\item 現在の命令。\samp{-->}として示されます。
\item ラベル付けされた命令。\samp{>>}とともに表示されます。
\item the address of the instruction,
\item 命令のアドレス。
\item 演算コード名。
\item 演算パラメータ。
\item 括弧の中のパラメータのインタプリテーション。
\end{enumerate}

パラメータインタープリテーションはローカルおよびグルーバル変数名、定数値、分岐目標、そして比較演算子を認識します。
\end{funcdesc}

\begin{funcdesc}{disco}{code\optional{, lasti}}
disassembleの別名。よりタイプしやすく、以前のPythonリリースと互換性があります。
\end{funcdesc}

\begin{datadesc}{opname}
演算名。一連のバイトコードを使ってインデキシングできます。
\end{datadesc}

\begin{datadesc}{opmap}
バイトコードからオペレーション名へのマッピング辞書。
\end{datadesc}

\begin{datadesc}{cmp_op}
すべての比較演算名。
\end{datadesc}

\begin{datadesc}{hasconst}
定数パラメータを持つ一連のバイトコード。
\end{datadesc}

\begin{datadesc}{hasfree}
自由変数にアクセスする一連のバイトコード。
\end{datadesc}

\begin{datadesc}{hasname}
名前によって属性にアクセスする一連のバイトコード。
\end{datadesc}

\begin{datadesc}{hasjrel}
相対ジャンプターゲットをもつ一連のバイトコード。
\end{datadesc}

\begin{datadesc}{hasjabs}
絶対ジャンプターゲットをもつ一連のバイトコード。
\end{datadesc}

\begin{datadesc}{haslocal}
ローカル変数にアクセスする一連のバイトコード。
\end{datadesc}

\begin{datadesc}{hascompare}
ブール演算の一連のバイトコード。
\end{datadesc}

\subsection{Pythonバイトコード命令}
\label{bytecodes}

現在Pythonコンパイラは次のバイトコード命令を生成します。

\setindexsubitem{(byte code insns)}

\begin{opcodedesc}{STOP_CODE}{}
コンパイラにend-of-code(コードの終わり)を知らせます。インタプリタでは使われません。
\end{opcodedesc}

\begin{opcodedesc}{NOP}{}
なにもしないコード。バイトコードオプティマイザでプレースホルダとして使われます。
Do nothing code.  Used as a placeholder by the bytecode optimizer.
\end{opcodedesc}

\begin{opcodedesc}{POP_TOP}{}
top-of-stack (TOS)(スタックの先頭)の項目を取り除きます。
\end{opcodedesc}

\begin{opcodedesc}{ROT_TWO}{}
スタックの先頭から二つの項目を入れ替えます。
\end{opcodedesc}

\begin{opcodedesc}{ROT_THREE}{}
スタックの二番目と三番目の項目の位置を一つ上げ、先頭を三番目へ下げます。
\end{opcodedesc}

\begin{opcodedesc}{ROT_FOUR}{}
スタックの二番目、三番目および四番目の位置を一つ上げ、先頭を四番目に下げます。
\end{opcodedesc}

\begin{opcodedesc}{DUP_TOP}{}
スタックの先頭に参照の複製を作ります。
\end{opcodedesc}

一項演算はスタックの先頭を取り出して演算を適用し、結果をスタックへプッシュし戻します。

\begin{opcodedesc}{UNARY_POSITIVE}{}
\code{TOS = +TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{UNARY_NEGATIVE}{}
\code{TOS = -TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{UNARY_NOT}{}
\code{TOS = not TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{UNARY_CONVERT}{}
\code{TOS = `TOS`}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{UNARY_INVERT}{}
\code{TOS = \~{}TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{GET_ITER}{}
\code{TOS = iter(TOS)}を実行します。
\end{opcodedesc}

二項演算はスタックからスタックの先頭(TOS)と先頭から二番目のスタック項目を取り除きます。演算を実行し、スタックへ結果をプッシュし戻します。

\begin{opcodedesc}{BINARY_POWER}{}
\code{TOS = TOS1 ** TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_MULTIPLY}{}
\code{TOS = TOS1 * TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_DIVIDE}{}
\code{from __future__ import division}が有効でないとき、\code{TOS = TOS1 / TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_FLOOR_DIVIDE}{}
\code{TOS = TOS1 // TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_TRUE_DIVIDE}{}
\code{from __future__ import division}が有効でないとき、\code{TOS = TOS1 / TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_MODULO}{}
\code{TOS = TOS1 \%{} TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_ADD}{}
\code{TOS = TOS1 + TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_SUBTRACT}{}
\code{TOS = TOS1 - TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_SUBSCR}{}
\code{TOS = TOS1[TOS]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_LSHIFT}{}
\code{TOS = TOS1 <\code{}< TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_RSHIFT}{}
\code{TOS = TOS1 >\code{}> TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_AND}{}
\code{TOS = TOS1 \&\ TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_XOR}{}
\code{TOS = TOS1 \^\ TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{BINARY_OR}{}
\code{TOS = TOS1 | TOS}を実行します。
\end{opcodedesc}

インプレース演算はTOSとTOS1を取り除いて結果をスタックへプッシュするという点で二項演算と似ています。しかし、TOS1がインプレース演算をサポートしている場合には演算が直接TOS1に行われます。また、演算結果のTOSは元のTOS1と同じオブジェクトになることが多いですが、常に同じというわけではありません。

\begin{opcodedesc}{INPLACE_POWER}{}
インプレースに\code{TOS = TOS1 ** TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_MULTIPLY}{}
インプレースに\code{TOS = TOS1 * TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_DIVIDE}{}
\code{from __future__ import division}が有効でないとき、インプレースに\code{TOS = TOS1 / TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_FLOOR_DIVIDE}{}
インプレースに\code{TOS = TOS1 // TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_TRUE_DIVIDE}{}
\code{from __future__ import division}が有効でないとき、インプレースに\code{TOS = TOS1 / TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_MODULO}{}
インプレースに\code{TOS = TOS1 \%{} TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_ADD}{}
インプレースに\code{TOS = TOS1 + TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_SUBTRACT}{}
インプレースに\code{TOS = TOS1 - TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_LSHIFT}{}
インプレースに\code{TOS = TOS1 <\code{}< TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_RSHIFT}{}
インプレースに\code{TOS = TOS1 >\code{}> TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_AND}{}
インプレースに\code{TOS = TOS1 \&\ TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_XOR}{}
インプレースに\code{TOS = TOS1 \^\ TOS}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{INPLACE_OR}{}
インプレースに\code{TOS = TOS1 | TOS}を実行します。
\end{opcodedesc}

スライス演算は三つまでのパラメータを取ります。

\begin{opcodedesc}{SLICE+0}{}
\code{TOS = TOS[:]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{SLICE+1}{}
\code{TOS = TOS1[TOS:]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{SLICE+2}{}
\code{TOS = TOS1[:TOS]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{SLICE+3}{}
\code{TOS = TOS2[TOS1:TOS]}を実行します。
\end{opcodedesc}

スライス代入はさらに別のパラメータを必要とします。どんな文もそうであるように、スタックに何もプッシュしません。

\begin{opcodedesc}{STORE_SLICE+0}{}
\code{TOS[:] = TOS1}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{STORE_SLICE+1}{}
\code{TOS1[TOS:] = TOS2}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{STORE_SLICE+2}{}
\code{TOS1[:TOS] = TOS2}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{STORE_SLICE+3}{}
\code{TOS2[TOS1:TOS] = TOS3}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_SLICE+0}{}
\code{del TOS[:]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_SLICE+1}{}
\code{del TOS1[TOS:]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_SLICE+2}{}
\code{del TOS1[:TOS]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_SLICE+3}{}
\code{del TOS2[TOS1:TOS]}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{STORE_SUBSCR}{}
\code{TOS1[TOS] = TOS2}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_SUBSCR}{}
\code{del TOS1[TOS]}を実行します。
\end{opcodedesc}

その他の演算。

\begin{opcodedesc}{PRINT_EXPR}{}
対話モードのための式文を実行します。TOSはスタックから取り除かれプリントされます。非対話モードにおいては、式文は\code{POP_STACK}で終了しています。
\end{opcodedesc}

\begin{opcodedesc}{PRINT_ITEM}{}
\code{sys.stdout}に束縛されたファイル互換のオブジェクトへTOSをプリントします。\keyword{print}文に、各項目に対するこのような命令が一つあります。
\end{opcodedesc}

\begin{opcodedesc}{PRINT_ITEM_TO}{}
\code{PRINT_ITEM}と似ていますが、TOSから二番目の項目をTOSにあるファイル互換オブジェクトへプリントします。これは拡張print文で使われます。
\end{opcodedesc}

\begin{opcodedesc}{PRINT_NEWLINE}{}
\code{sys.stdout}へ改行をプリントします。これは\keyword{print}文がコンマで終わっていない場合に\keyword{print}文の最後の演算として生成されます。
\end{opcodedesc}

\begin{opcodedesc}{PRINT_NEWLINE_TO}{}
\code{PRINT_NEWLINE}と似ていますが、TOSのファイル互換オブジェクトに改行をプリントします。これは拡張print文で使われます。
\end{opcodedesc}

\begin{opcodedesc}{BREAK_LOOP}{}
\keyword{break}文があるためループを終了します。
\end{opcodedesc}

\begin{opcodedesc}{CONTINUE_LOOP}{target}
\keyword{continue}文があるためループを継続します。\var{target}はジャンプするアドレスです(アドレスは\code{FOR_ITER}命令であるべきです)。
\end{opcodedesc}

\begin{opcodedesc}{LIST_APPEND}{}
\code{list.append(TOS1, TOS)}を呼びます。 リスト内包表記を実装するために使われます。
\end{opcodedesc}

\begin{opcodedesc}{LOAD_LOCALS}{}
現在のスコープのローカルな名前空間(locals)への参照をスタックにプッシュします。これはクラス定義のためのコードで使われます: クラス本体が評価された後、localsはクラス定義へ渡されます。
\end{opcodedesc}

\begin{opcodedesc}{RETURN_VALUE}{}
関数の呼び出し元へTOSを返します。
\end{opcodedesc}

\begin{opcodedesc}{YIELD_VALUE}{}
\code{TOS}をポップし、それをジェネレータからyieldします。
\end{opcodedesc}

\begin{opcodedesc}{IMPORT_STAR}{}
\character{_}で始まっていないすべてのシンボルをモジュールTOSから直接ローカル名前空間へロードします。モジュールはすべての名前をロードした後にポップされます。この演算コードは\code{from module import *}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{EXEC_STMT}{}
\code{exec TOS2,TOS1,TOS}を実行します。コンパイラは見つからないオプションのパラメータを\code{None}で埋めます。
\end{opcodedesc}

\begin{opcodedesc}{POP_BLOCK}{}
ブロックスタックからブロックを一つ取り除きます。フレームごとにブロックのスタックがあり、ネストしたループ、try文などを意味しています。
\end{opcodedesc}

\begin{opcodedesc}{END_FINALLY}{}
\keyword{finally}節を終わらせます。インタプリタは例外を再び発生させなければならないかどうか、あるいは、関数が返り外側の次のブロックに続くかどうかを思い出します。
\end{opcodedesc}

\begin{opcodedesc}{BUILD_CLASS}{}
新しいクラスオブジェクトを作成します。TOSはメソッド辞書、TOS1は基底クラスの名前のタプル、TOS2はクラス名です。
\end{opcodedesc}

次の演算コードはすべて引数を要求します。引数はより重要なバイトを下位にもつ2バイトです。

\begin{opcodedesc}{STORE_NAME}{namei}
\code{name = TOS}を実行します。\var{namei}はコードオブジェクトの属性\member{co_names}における\var{name}のインデックスです。コンパイラは可能ならば\code{STORE_LOCAL}または\code{STORE_GLOBAL}を使おうとします。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_NAME}{namei}
\code{del name}を実行します。ここで、\var{namei}はコードオブジェクトの\member{co_names}属性へのインデックスです。
\end{opcodedesc}

\begin{opcodedesc}{UNPACK_SEQUENCE}{count}
TOSを\var{count}個のへ個別の値に分け、右から左にスタックに置かれます。
\end{opcodedesc}

%\begin{opcodedesc}{UNPACK_LIST}{count}
%This opcode is obsolete.
%\end{opcodedesc}

%\begin{opcodedesc}{UNPACK_ARG}{count}
%This opcode is obsolete.
%\end{opcodedesc}

\begin{opcodedesc}{DUP_TOPX}{count}
\var{count}個の項目を同じ順番を保ちながら複製します。実装上の制限から、\var{count}は1から5の間(5を含む)でなければいけません。
\end{opcodedesc}

\begin{opcodedesc}{STORE_ATTR}{namei}
\code{TOS.name = TOS1}を実行します。ここで、\var{namei}は\member{co_names}における名前のインデックスです。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_ATTR}{namei}
\member{co_names}へのインデックスとして\var{namei}を使い、\code{del TOS.name}を実行します。
\end{opcodedesc}

\begin{opcodedesc}{STORE_GLOBAL}{namei}
\code{STORE_NAME}として機能しますが、グローバルとして名前を記憶します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_GLOBAL}{namei}
\code{DELETE_NAME}として機能しますが、グルーバル名を削除します。
\end{opcodedesc}

%\begin{opcodedesc}{UNPACK_VARARG}{argc}
%This opcode is obsolete.
%\end{opcodedesc}

\begin{opcodedesc}{LOAD_CONST}{consti}
\samp{co_consts[\var{consti}]}をスタックにプッシュします。
\end{opcodedesc}

\begin{opcodedesc}{LOAD_NAME}{namei}
\samp{co_names[\var{namei}]}に関連付けられた値をスタックにプッシュします。
\end{opcodedesc}

\begin{opcodedesc}{BUILD_TUPLE}{count}
スタックから\var{count}個の項目を消費するタプルを作り出し、できたタプルをスタックにプッシュします。
\end{opcodedesc}

\begin{opcodedesc}{BUILD_LIST}{count}
\code{BUILD_TUPLE}として機能しますが、リストを作り出します。
\end{opcodedesc}

\begin{opcodedesc}{BUILD_MAP}{zero}
スタックに新しい空の辞書オブジェクトをプッシュします。引数は無視され、コンパイラによってゼロに設定されます。
\end{opcodedesc}

\begin{opcodedesc}{LOAD_ATTR}{namei}
TOSを\code{getattr(TOS, co_names[\var{namei}])}と入れ替えます。
\end{opcodedesc}

\begin{opcodedesc}{COMPARE_OP}{opname}
ブール演算を実行します。演算名は\code{cmp_op[\var{opname}]}にあります。
\end{opcodedesc}

\begin{opcodedesc}{IMPORT_NAME}{namei}
モジュール\code{co_names[\var{namei}]}をインポートします。モジュールオブジェクトはスタックへプッシュされます。現在の名前空間は影響されません: 適切なimport文に対して、それに続く\code{STORE_FAST}命令が名前空間を変更します。
\end{opcodedesc}

\begin{opcodedesc}{IMPORT_FROM}{namei}
属性\code{co_names[\var{namei}]}をTOSに見つかるモジュールからロードします。作成されたオブジェクトはスタックにプッシュされ、その後\code{STORE_FAST}命令によって記憶されます。
\end{opcodedesc}

\begin{opcodedesc}{JUMP_FORWARD}{delta}
バイトコードカウンタを\var{delta}だけ増加させます。
\end{opcodedesc}

\begin{opcodedesc}{JUMP_IF_TRUE}{delta}
TOSが真ならば、\var{delta}だけバイトコードカウンタを増加させます。TOSはスタックに残されます。
\end{opcodedesc}

\begin{opcodedesc}{JUMP_IF_FALSE}{delta}
TOSが偽ならば、\var{delta}だけバイトコードカウンタを増加させます。TOSは変更されません。
\end{opcodedesc}

\begin{opcodedesc}{JUMP_ABSOLUTE}{target}
バイトコードカウンタを\var{target}に設定します。
\end{opcodedesc}

\begin{opcodedesc}{FOR_ITER}{delta}
\code{TOS}はイテレータです。その\method{next()}メソッドを呼び出します。これが新しい値を作り出すならば、それを(その下にイテレータを残したまま)スタックにプッシュします。イテレータが尽きたことを示した場合は、\code{TOS}がポップされます。そして、バイトコードカウンタが\var{delta}だけ増やされます。
\end{opcodedesc}

%\begin{opcodedesc}{FOR_LOOP}{delta}
%This opcode is obsolete.
%\end{opcodedesc}

%\begin{opcodedesc}{LOAD_LOCAL}{namei}
%This opcode is obsolete.
%\end{opcodedesc}

\begin{opcodedesc}{LOAD_GLOBAL}{namei}
グルーバル名\code{co_names[\var{namei}]}をスタック上にロードします。
\end{opcodedesc}

%\begin{opcodedesc}{SET_FUNC_ARGS}{argc}
%This opcode is obsolete.
%\end{opcodedesc}

\begin{opcodedesc}{SETUP_LOOP}{delta}
ブロックスタックにループのためのブロックをプッシュします。ブロックは現在の命令から\var{delta}バイトの大きさを占めます。
\end{opcodedesc}

\begin{opcodedesc}{SETUP_EXCEPT}{delta}
try-except節からtryブロックをブロックスタックにプッシュします。\var{delta}は最初のexceptブロックを指します。
\end{opcodedesc}

\begin{opcodedesc}{SETUP_FINALLY}{delta}
try-except節からtryブロックをブロックスタックにプッシュします。\var{delta}はfinallyブロックを指します。
\end{opcodedesc}

\begin{opcodedesc}{LOAD_FAST}{var_num}
ローカルな\code{co_varnames[\var{var_num}]}への参照をスタックにプッシュします。
\end{opcodedesc}

\begin{opcodedesc}{STORE_FAST}{var_num}
TOSをローカルな\code{co_varnames[\var{var_num}]}の中に保存します。
\end{opcodedesc}

\begin{opcodedesc}{DELETE_FAST}{var_num}
ローカルな\code{co_varnames[\var{var_num}]}を削除します。
\end{opcodedesc}

\begin{opcodedesc}{LOAD_CLOSURE}{i}
セルと自由変数記憶領域のスロット\var{i}に含まれるセルへの参照をプッシュします。\var{i}が\var{co_cellvars}の長さより小さければ、変数の名前は\code{co_cellvars[\var{i}]}です。そうでなければ、それは\code{co_freevars[\var{i} - len(co_cellvars)]}です。

\end{opcodedesc}

\begin{opcodedesc}{LOAD_DEREF}{i}
セルと自由変数記憶領域のスロット\var{i}に含まれるセルをロードします。セルが持つオブジェクトへの参照をスタックにプッシュします。
\end{opcodedesc}

\begin{opcodedesc}{STORE_DEREF}{i}
セルと自由変数記憶領域のスロット\var{i}に含まれるセルへTOSを保存します。
\end{opcodedesc}

\begin{opcodedesc}{SET_LINENO}{lineno}
このペコードは廃止されました。
\end{opcodedesc}

\begin{opcodedesc}{RAISE_VARARGS}{argc}
例外を発生させます。\var{argc}はraise文へ与えるパラメータの数を0から3の範囲で示します。ハンドラはTOS2としてトレースバック、TOS1としてパラメータ、そしてTOSとして例外を見つけられます。
\end{opcodedesc}

\begin{opcodedesc}{CALL_FUNCTION}{argc}
関数を呼び出します。\var{argc}の低位バイトは位置パラメータを示し、高位バイトはキーワードパラメータの数を示します。オペコードは最初にキーワードパラメータをスタック上に見つけます。それぞれのキーワード引数に対して、その値はキーの上にあります。スタック上のキーワードパラメータの下に位置パラメータはあり、先頭に最も右のパラメータがあります。スタック上のパラメータの下には、呼び出す関数オブジェクトがあります。

\end{opcodedesc}

\begin{opcodedesc}{MAKE_FUNCTION}{argc}
新しい関数オブジェクトをスタックにプッシュします。TOSは関数に関連付けられたコードです。関数オブジェクトはTOSの下にある\var{argc}デフォルトパラメータをもつように定義されます。
\end{opcodedesc}

\begin{opcodedesc}{MAKE_CLOSURE}{argc}
新しい関数オブジェクトを作り出し、その\var{func_closure}スロットを設定し、それをスタックにプッシュします。TOSは関数に関連付けられたコードです。コードオブジェクトがN個の自由変数を持っているならば、スタック上の次のN個の項目はこれらの変数に対するセルです。関数はセルの前にある\var{argc}デフォルトパラメータも持っています。
\end{opcodedesc}

\begin{opcodedesc}{BUILD_SLICE}{argc}
スライスオブジェクトをスタックにプッシュします。\var{argc}は2あるいは3でなければなりません。2ならば\code{slice(TOS1, TOS)}がプッシュされます。3ならば\code{slice(TOS2, TOS1, TOS)}がプッシュされます。これ以上の情報については、\code{slice()}\bifuncindex{slice}組み込み関数を参照してください。
\end{opcodedesc}

\begin{opcodedesc}{EXTENDED_ARG}{ext}
大きすぎてデフォルトの二バイトに当てはめることができない引数をもつあらゆるオペコードの前に置かれます。\var{ext}は二つの追加バイトを保持し、その後ろのオペコードの引数と一緒になって取られます。それらは四バイト引数を構成し、\var{ext}はその最上位バイトです。
\end{opcodedesc}

\begin{opcodedesc}{CALL_FUNCTION_VAR}{argc}
関数を呼び出します。\var{argc}は\code{CALL_FUNCTION}のように解釈実行されます。スタックの先頭の要素は変数引数リストを含んでおり、その後にキーワードと位置引数が続きます。
\end{opcodedesc}

\begin{opcodedesc}{CALL_FUNCTION_KW}{argc}
関数を呼び出します。\var{argc}は\code{CALL_FUNCTION}のように解釈実行されます。スタックの先頭の要素はキーワード引数辞書を含んでおり、その後に明示的なキーワードと位置引数が続きます。
\end{opcodedesc}

\begin{opcodedesc}{CALL_FUNCTION_VAR_KW}{argc}
関数を呼び出します。\var{argc}は\code{CALL_FUNCTION}のように解釈実行されます。スタックの先頭の要素はキーワード引数辞書を含んでおり、その後に変数引数のタプルが続き、さらに明示的なキーワードと位置引数が続きます。
\end{opcodedesc}

\begin{opcodedesc}{HAVE_ARGUMENT}{}
これはオペコードではありません。引数をとらないオペコード\code{< HAVE_ARGUMENT} と、
とるオペコード \code{>= HAVE_ARGUMENT} を分割する行です。
\end{opcodedesc}


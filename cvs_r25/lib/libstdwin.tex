\chapter{スタンダードウィンドウインターフェース}

この章のモジュールは、STDWINライブラリが利用可能なシステム上でのみ利用可能です。STDWINは\UNIX{}のX11上とMacintoshで動作します。CWIリポートCS-R8817を参照してください。

\warning{
新しいアプリケーションにSTDWINを使うのはお勧めしません。
Microsoft WindowsやWindows NTにはポートされていませんし、X11やMacintoshでは重要な機能 --- 特にダイアログを作るためのツールがありません。
その代わり、ほとんどのプラットフォームにはネイティブで動作するツールがあります
（しかし、現在このマニュアルの中で文書化されているものはありません）：
\UNIX{}のX11上でのTkinter、\UNIX{}のX11上でのMotifあるいはAthenaウィジェットを使ったナイティブなXt、WindowsとWindows NTのWin32、Macintosh上のネイティブなツールキットインターフェースのセット。}


\section{\module{stdwin} ---
プラットフォーム非依存のグラフィカルユーザーインターフェースシステム}

\declaremodule{builtin}{stdwin}
\modulesynopsis{
X11とMacintoshの古いグラフィカルユーザーインターフェースシステム。}


このモジュールでは、STDWINの機能へのアクセスを提供するための新しいオブジェクトや関数がいくつか定義されています。

X11が動作している\UNIX{}では、\envvar{DISPLAY}の環境変数が設定されているか、引数\programopt{-display} \var{displayname}を明示的にPythonインタープリタに渡したときだけ使用できます。

関数名は、対応するCのSTDWINの関数の始めの`w'を除いたものに似ています。
座標は整数のペアで表現されます；矩形は座標のペアで表わします。
STDWINの完全な説明については、CプログラマーのためのSTDWINの文書（前述のCWIリポート）を参照してください。

\subsection{
\module{stdwin}モジュールで定義された関数}
\nodename{STDWIN Functions}

以下の関数が\module{stdwin}モジュールで定義されています：

\begin{funcdesc}{open}{title}
タイトルの初期値を文字列の引数で与えて新しいウィンドウを開きます。
ウィンドウオブジェクトを返します；ウィンドウオブジェクトのメソッドは後述します。
\footnote{
	STDWINのPythonバージョンは描画操作をサポートしていません；
	描画に関する命令は全て描画イベントで伝えます。}
\end{funcdesc}

\begin{funcdesc}{getevent}{}
次のイベントまで待って、そのイベントを返します。
イベントはタプルとして返されます：
タプルの最初の要素はイベントのタイプで小さな整数；
2番目の要素はイベントが起こったウィンドウオブジェクト、あるいはどのウィンドウか特定しないなら\code{None}；
3番目の要素はタイプに依存したもの。
イベントタイプの名前とコマンドのコードは、標準モジュール
\refmodule{stdwinevents}に定義されています。
\end{funcdesc}

\begin{funcdesc}{pollevent}{}
次のイベントがすぐに利用可能なら、そのイベントを返します。
もしどのイベントも利用可能でないなら、\code{()}を返します。
\end{funcdesc}

\begin{funcdesc}{getactive}{}
現在アクティブなウィンドウを返します。もし現在アクティブなのがなければ
\code{()}を返します。
（これはWE_ACTIVATEとWE_DEACTIVATEイベントをモニターすることでエミュレートできます。）
\end{funcdesc}

\begin{funcdesc}{listfontnames}{pattern}
パターン（文字列）に適合するシステムのフォント名のリストを返します。
パターンは通常、\code{'*'}が使われます；そうすると全ての利用可能なフォントを返します。
X11上で動作しているなら、標準のX11フォント選択構文（例えばリソース定義で使われるような）がパターンに使えます。
つまり、ワイルドカード文字\code{'*'}は（空文字列を含む）文字列全てに適合し、\code{'?'}は1文字全てに適合します。
Macintoshでは今のところ、この関数は空のリストを返します。
\end{funcdesc}

\begin{funcdesc}{setdefscrollbars}{hflag, vflag}
これ以降に開くウィンドウが水平と垂直のスクロールバーを持つかどうかを決めるフラグを設定します。
\end{funcdesc}

\begin{funcdesc}{setdefwinpos}{h, v}
これ以降に開くウィンドウのデフォルトの位置を決定します。
\end{funcdesc}

\begin{funcdesc}{setdefwinsize}{width, height}
これ以降に開くウィンドウのデフォルトのサイズを決定します。
\end{funcdesc}

\begin{funcdesc}{getdefscrollbars}{}
これ以降に開くウィンドウが水平と垂直のスクロールバーを持つかどうかを決めるフラグを返します。
\end{funcdesc}

\begin{funcdesc}{getdefwinpos}{}
これ以降に開くウィンドウのデフォルトの位置を返します。
\end{funcdesc}

\begin{funcdesc}{getdefwinsize}{}
これ以降に開くウィンドウのデフォルトのサイズを返します。
\end{funcdesc}

\begin{funcdesc}{getscrsize}{}
スクリーンサイズをピクセル数で返します。
\end{funcdesc}

\begin{funcdesc}{getscrmm}{}
スクリーンサイズをミリメーターで返します。
\end{funcdesc}

\begin{funcdesc}{fetchcolor}{colorname}
与えられたカラー名に一致するピクセル値を返します。
不明のカラー名についてはデフォルトのフォアグラウンドカラーを返します。
ヒント：以下のコードはあなたのマシンが2色以上をサポートするかどうかをテストします。
\begin{verbatim}
if stdwin.fetchcolor('black') <> \
          stdwin.fetchcolor('red') <> \
          stdwin.fetchcolor('white'):
    print 'color machine'
else:
    print 'monochrome machine'
\end{verbatim}
\end{funcdesc}

\begin{funcdesc}{setfgcolor}{pixel}
デフォルトのフォアグラウンドカラーを設定します。
これ以降に開くウィンドウとダイアログのデフォルトのフォアグラウンドカラーになります。
\end{funcdesc}

\begin{funcdesc}{setbgcolor}{pixel}
デフォルトのバックグラウンドカラーを設定します。
これ以降に開くウィンドウとダイアログのデフォルトのバックグラウンドカラーになります。
\end{funcdesc}

\begin{funcdesc}{getfgcolor}{}
現在のデフォルトのフォアグラウンドカラーのピクセル値を返します。
\end{funcdesc}

\begin{funcdesc}{getbgcolor}{}
現在のデフォルトのバックグラウンドカラーのピクセル値を返します。
\end{funcdesc}

\begin{funcdesc}{setfont}{fontname}
現在のデフォルトのフォントを設定します。
このフォントはこれ以降に開くウィンドウのデフォルトフォントになり、後述するテキストを計算する関数
\function{textwidth()}、\function{textbreak()}、\function{lineheight()} 
、\function{baseline()}でも使われます。
さらに2つの省略可能なパラメータ、サイズとスタイルが指定できます：
サイズはフォントサイズ（`ポイント'）です。
スタイルはスタイルを示す以下のような1文字です：
\code{'b'} = bold、
\code{'i'} = italic、
\code{'o'} = bold + italic、
\code{'u'} = underline；
デフォルトのスタイルはromanです。
サイズとスタイルはX11では無視されますが、Macintoshで使用されます。
（この複雑な点は申し訳ありません --- もっと統一のとれたインターフェースが計画されています。）
\end{funcdesc}

\begin{funcdesc}{menucreate}{title}
グローバルメニュー（全てのウィンドウに表示されるメニュー）を参照するメニューオブジェクトを作ります。
メニューのメソッドについては後述します。
注意：通常、メニューはローカルに作られます；後述のウィンドウメソッド
\method{menucreate()}を参照してください。

\warning{
メニューはこの呼び出しで返されるオブジェクトが存在する限り、ウィンドウに表示されます。}
\end{funcdesc}

\begin{funcdesc}{newbitmap}{width, height}
与えられた大きさの新しいビットマップオブジェクトを作ります。
ビットマップオブジェクトのメソッドについては後述します。
Macintoshでは利用できません。
\end{funcdesc}

\begin{funcdesc}{fleep}{}
ビープ音や警告音（あるいは`視覚的な警告'やフラッシュと呼ばれるもの）を鳴らします。
\end{funcdesc}

\begin{funcdesc}{message}{string}
引数の文字列を表示するダイアログボックスを表示します。
ユーザがOKをクリックしないと、関数は値を返しません。
\end{funcdesc}

\begin{funcdesc}{askync}{prompt, default}
ユーザにYes、Noで答えさせる質問を表示するダイアログを表示します。
Noなら0、Yesなら1を返します。
ユーザがReturnキーを押したら、デフォルト値（0か1でなければなりません）が返ります。
もしユーザがダイアログをキャンセルしたら、例外
\exception{KeyboardInterrupt}が発生します。
\end{funcdesc}

\begin{funcdesc}{askstr}{prompt, default}
ユーザに文字列を尋ねるダイアログを表示します。
もしユーザがReturnキーを押したら、デフォルトの文字列が返されます。
もしユーザがダイアログをキャンセルしたら、例外
\exception{KeyboardInterrupt}が発生します。
\end{funcdesc}

\begin{funcdesc}{askfile}{prompt, default, new}
ユーザにファイル名を尋ねます。
もし\var{new}がゼロなら存在するファイルでなければなりません；そうでないなら新しいファイルになります。
ユーザがダイアログをキャンセルしたら、例外\exception{KeyboardInterrupt}
が発生します。
\end{funcdesc}

\begin{funcdesc}{setcutbuffer}{i, string}
システムのカットバッファのナンバー\var{i}に文字列を保存し、他のアプリケーションで（ペーストのために）使えるようにします。
X11では8つのカットバッファ（ナンバー0から7）があります。
カットバッファナンバー0はMacintoshの`クリップボード'です。
\end{funcdesc}

\begin{funcdesc}{getcutbuffer}{i}
システムのカットバッファのナンバー\var{i}の内容を返します。
\end{funcdesc}

\begin{funcdesc}{rotatecutbuffers}{n}
X11で8つのカットバッファを\var{n}回循環させます。
Macintoshでは無視されます。
\end{funcdesc}

\begin{funcdesc}{getselection}{i}
X11のセレクションナンバー\var{i}を返します。
セレクションはカットバッファではありません。
セレクションナンバーはモジュール\refmodule{stdwinevents}で定義されています。
例えば、セレクション\constant{WS_PRIMARY}は\dfn{primary}セレクション
（\program{xterm}で使われます）です；
セレクション\constant{WS_SECONDARY}は\dfn{secondary}セレクションです。
セレクション\constant{WS_CLIPBOARD}は\dfn{clipboard}セレクション
（\program{xclipboard}で使われます）です。
Macintoshでは常に空文字列が返されます。
\end{funcdesc}

\begin{funcdesc}{resetselection}{i}
もしセレクションナンバー\var{i}を保持していたら、リセットします。
（ウィンドウメソッド\method{setselection()}を参照してください。）
\end{funcdesc}

\begin{funcdesc}{baseline}{}
現在のフォントのベースラインを返します
（STDWINで定義される、ベースラインから文字のてっぺんまでの縦の距離です）。
\end{funcdesc}

\begin{funcdesc}{lineheight}{}
現在のフォントの全ラインの高さを返します。
\end{funcdesc}

\begin{funcdesc}{textbreak}{str, width}
現在のフォントで文字列を描こうとしたとき、\var{width}ビットの幅に入る文字数を返します。
\end{funcdesc}

\begin{funcdesc}{textwidth}{str}
現在のフォントで描画したときの文字列の幅をビット数で返します。
\end{funcdesc}

\begin{funcdesc}{connectionnumber}{}
\funcline{fileno}{}
（\UNIX{}上のX11のみ）X11の実装の内部で使われる``connection number''を返します。
（これは普通、ソケットのファイル名です。）
以下の二つの関数はどちらも同じ値を返します；
\method{connectionnumber()}はX11とSTDWINの対応する関数にちなんで名づけられ、一方、\method{fileno()}は\module{stdwin}モジュールを\function{select.select()}の``ファイル''オブジェクトのパラメータとして使用可能にします。
もし\constant{select()}が\module{stdwin}での入力を可能にしているなら、イベントが待機状態にあることを保証しません  --- Xサーバーとクライアントのライブラリの間で内部の応答があるかもしれません。
そのため、もしプログラムをブロックしたくないなら、イベントをチェックして\code{None}が返るまで\function{stdwin.pollevent()}を呼び出すべきです。
X11の内部のバッファリングのため、\function{select()}で\module{stdwin}が準備できているかどうかわからない間も\function{stdwin.pollevent()}でイベントを返すことが可能です。そのため、\function{select()}を呼び出してブロックする前に\code{None}が返されるまで、\function{stdwin.pollevent()}を呼び出して保留中のイベントを読み込むべきです。
\withsubitem{(in module select)}{\ttindex{select()}}
\end{funcdesc}

\subsection{
ウィンドウオブジェクト}
\nodename{STDWIN Window Objects}

ウィンドウオブジェクトは\function{stdwin.open()}で作られます。
\method{close()}メソッドあるいはガベージコレクションで閉じられます。
ウィンドウオブジェクトには以下のメソッドがあります：

\begin{methoddesc}[window]{begindrawing}{}
描画オブジェクトを返します。この描画オブジェクトのメソッド（後述します）でウィンドウに描画できます。
\end{methoddesc}

\begin{methoddesc}[window]{change}{rect}
与えられた矩形を無効にします；これは描画イベントを発生させます。
\end{methoddesc}

\begin{methoddesc}[window]{gettitle}{}
ウィンドウのタイトル文字列を返します。
\end{methoddesc}

\begin{methoddesc}[window]{getdocsize}{}
\begin{sloppypar}
\method{setdocsize()}で設定されたドキュメントサイズを整数のペアで返します。
\end{sloppypar}
\end{methoddesc}

\begin{methoddesc}[window]{getorigin}{}
ドキュメントに関するウィンドウの位置を整数のペアで返します。
\end{methoddesc}

%
\begin{methoddesc}[window]{getwinsize}{}
ウィンドウのサイズを整数のペアで返します。
\end{methoddesc}

\begin{methoddesc}[window]{getwinpos}{}
ウィンドウの左上隅の位置を（画面の左上隅からの座標で）整数のペアで返します。
\end{methoddesc}

\begin{methoddesc}[window]{menucreate}{title}
ローカルメニューを参照するメニューオブジェクトを作ります（このメニューはこのウィンドウだけに表示されます）。
メニューオブジェクトのメソッドは後述します。

\warning{
メニューはこの呼び出しで返されるオブジェクトが存在する限り、表示されます。}
\end{methoddesc}

\begin{methoddesc}[window]{scroll}{rect, point}
与えられた矩形を座標で示すベクタだけスクロールします。
\end{methoddesc}

\begin{methoddesc}[window]{setdocsize}{point}
描画するドキュメントのサイズを設定します。
\end{methoddesc}

\begin{methoddesc}[window]{setorigin}{point}
ウィンドウを元の位置（左上隅）からドキュメント内の与えられた座標へ移動します。
\end{methoddesc}

\begin{methoddesc}[window]{setselection}{i, str}
X11のセレクションナンバー\var{i}に文字列\var{str}を設定しようとします。
（\var{i}の意味については\module{stdwin}の関数\function{getselection()}を参照してください。）
設定に成功したらTrueを返します。
成功したら、(a)他のアプリケーションがセレクションの保有権を持つまで；(b)ウィンドウが削除されるまで；あるいは(c)\function{stdwin.resetselection(\var{i})}を呼び出してアプリケーションが保有権を消去するまで、ウィンドウはセレクションを``保持''します。
他のアプリケーションがセレクションの保有権を持ったら、\constant{WE_LOST_SEL}イベントが他のウィンドウに送られ、セレクションナンバーが詳しく送られます。
Macintoshでは無視されます。
\end{methoddesc}

\begin{methoddesc}[window]{settimer}{dsecs}
\code{\var{dsecs}/10}秒でウィンドウにタイマーイベントを設定します。
\end{methoddesc}

\begin{methoddesc}[window]{settitle}{title}
ウィンドウのタイトル文字列を設定します。
\end{methoddesc}

\begin{methoddesc}[window]{setwincursor}{name}
\begin{sloppypar}
ウィンドウのカーソルを名前で指定したカーソルに設定します。
もし指定し名前のカーソルが存在しないなら、例外\exception{RuntimeError}が
発生します。
適切な名前として、
\code{'ibeam'}、
\code{'arrow'}、
\code{'cross'}、
\code{'watch'}、
\code{'plus'}
があります。
X11には他にもたくさんあります（\code{<X11/cursorfont.h>}を参照してください）。
\end{sloppypar}
\end{methoddesc}

\begin{methoddesc}[window]{setwinpos}{h, v}
ウィンドウの左上隅の位置を（画面の左上隅からの座標で）設定します。
\end{methoddesc}

\begin{methoddesc}[window]{setwinsize}{width, height}
ウィンドウのサイズを設定します。
\end{methoddesc}

\begin{methoddesc}[window]{show}{rect}
与えられたドキュメントの矩形がウィンドウ内に表示されるようにします。
\end{methoddesc}

\begin{methoddesc}[window]{textcreate}{rect}
ウィンドウ内に、与えられた矩形のテキストエディットオブジェクトを作ります。
テキストエディットオブジェクトのメソッドについては後述します。
\end{methoddesc}

\begin{methoddesc}[window]{setactive}{}
ウィンドウをアクティブウィンドウにしようとします。
成功したら、WE_ACTIVATEイベントを発生します（そして、このアプリケーションの他のウィンドウがディアクティベートされたら、WE_DEACTIVATEが発生します）。
\end{methoddesc}

\begin{methoddesc}[window]{close}{}
ウィンドウオブジェクトを捨てます。
そのウィンドウは使えなくなります。
\end{methoddesc}

\subsection{
描画オブジェクト}

描画オブジェクトはウィンドウのメソッド\method{begindrawing()}だけで作られます。
同時に1つの描画オブジェクトだけが存在できます；描画を終了させるためには描画オブジェクトを消去しなければなりません。
\function{stdwin.getevent()}が呼び出されるときには、描画オブジェクトは存在できません。
描画オブジェクトには以下のメソッドがあります：

\begin{methoddesc}[drawing]{box}{rect}
矩形の中にボックスを描画します。
\end{methoddesc}

\begin{methoddesc}[drawing]{circle}{center, radius}
与えられた中心座標と半径で円を描画します。
\end{methoddesc}

\begin{methoddesc}[drawing]{elarc}{center, (rh, rv), (a1, a2)}
与えられた中心座標で楕円を描画します。
\code{(\var{rh}, \var{rv})}は水平と垂直の半径の半分のサイズを指定します。
\code{(\var{a1}, \var{a2})}は開始点と終了点の角度（度数）を指定します。
0度は3時の位置で、90度は12時の位置です。
\end{methoddesc}

\begin{methoddesc}[drawing]{erase}{rect}
矩形を消去します。
\end{methoddesc}

\begin{methoddesc}[drawing]{fillcircle}{center, radius}
与えられた中心座標と半径で円を描画し塗りつぶします。
\end{methoddesc}

\begin{methoddesc}[drawing]{fillelarc}{center, (rh, rv), (a1, a2)}
楕円を描画し塗りつぶします；引数は\method{elarc()}と同じです。
\end{methoddesc}

\begin{methoddesc}[drawing]{fillpoly}{points}
座標のリスト（あるいはタプル）で与えられるポリゴンを描画し塗りつぶします。
\end{methoddesc}

\begin{methoddesc}[drawing]{invert}{rect}
矩形を反転します。
\end{methoddesc}

\begin{methoddesc}[drawing]{line}{p1, p2}
\var{p1}から\var{p2}まで線を描きます。
\end{methoddesc}

\begin{methoddesc}[drawing]{paint}{rect}
矩形を塗りつぶします。
\end{methoddesc}

\begin{methoddesc}[drawing]{poly}{points}
座標のリスト（あるいはタプル）で与えられる点を線でつなぎます。
\end{methoddesc}

\begin{methoddesc}[drawing]{shade}{rect, percent}
\var{percent}のパーセントの濃淡で矩形を描画し塗りつぶします。
\end{methoddesc}

\begin{methoddesc}[drawing]{text}{p, str}
文字列を座標p（文字列の左上を示す座標）の地点から描画します。
\end{methoddesc}

\begin{methoddesc}[drawing]{xorcircle}{center, radius}
\funcline{xorelarc}{center, (rh, rv), (a1, a2)}
\funcline{xorline}{p1, p2}
\funcline{xorpoly}{points}
それぞれ円、楕円、弧、直線、ポリゴンをXORモードで描画します。
\end{methoddesc}

\begin{methoddesc}[drawing]{setfgcolor}{}
\funcline{setbgcolor}{}
\funcline{getfgcolor}{}
\funcline{getbgcolor}{}
これらの関数は、前述の\module{stdwin}モジュールに対応するものと似ていますが、グローバルなデフォルトカラーではなく、現在描画に使われているカラーを設定、または返します。
描画オブジェクトが作られると、そのオブジェクトのカラーはウィンドウのデフォルトカラーに設定されます。ウィンドウのデフォルトカラーはウィンドウが作られると、グローバルなデフォルトカラーで初期化されます。
\end{methoddesc}

\begin{methoddesc}[drawing]{setfont}{}
\funcline{baseline}{}
\funcline{lineheight}{}
\funcline{textbreak}{}
\funcline{textwidth}{}
これらの関数は、前述の\module{stdwin}モジュールに対応するものと似ていますが、グローバルなデフォルトフォントではなく、現在描画に使われているフォントを設定、または返します。
描画オブジェクトが作られると、そのオブジェクトのフォントはウィンドウのデフォルトフォントに設定されます。ウィンドウのデフォルトフォントは、ウィンドウが作られるとグローバルなデフォルトフォントで初期化されます。
\end{methoddesc}

\begin{methoddesc}[drawing]{bitmap}{point, bitmap, mask}
\var{point}を左上隅の座標として\var{bitmap}を描画します。
省略可能な引数\var{mask}は\var{bitmap}と同じオブジェクトか\code{None}でなければならず、
同じオブジェクトならフォアグラウンドカラーでビットマップに設定されたビットのみが描かれ、\code{None}なら全てのビットを描きます（1ならフォアグラウンドカラーで、0ならバックグラウンドカラーで描きます）。
Macintoshでは利用できません。
\end{methoddesc}

\begin{methoddesc}[drawing]{cliprect}{rect}
矩形を``クリップ範囲''に設定します。
クリップ範囲は再び変更されるまで、あるいは描画オブジェクトが閉じられるまで全ての描画操作を制限します。
描画オブジェクトが作られると、クリップ範囲はウィンドウ全体に設定されます。
描画されるオブジェクトの一部がクリップ範囲の外に外れるときには、描かれるピクセルはクリップ範囲とクリップ範囲にないところに同じ操作で描かれるピクセルとの交わりです。
\end{methoddesc}

\begin{methoddesc}[drawing]{noclip}{}
クリップ範囲をウィンドウ全体にリセットします。
\end{methoddesc}

\begin{methoddesc}[drawing]{close}{}
\funcline{enddrawing}{}
描画オブジェクトを捨てます。
その描画オブジェクトは使えなくなります。
\end{methoddesc}

\subsection{
メニューオブジェクト}

メニューオブジェクトはメニューを表わします。
メニューオブジェクトが削除されると、メニューはなくなります。
以下のメソッドが定義されています：


\begin{methoddesc}[menu]{additem}{text, shortcut}
指定されたテキストでメニューアイテムを加えます。
ショートカットは長さ1の文字列を指定するか、省略（ショートカットを指定しない）できます。
\end{methoddesc}

\begin{methoddesc}[menu]{setitem}{i, text}
アイテムナンバー\var{i}にテキストを設定します。
\end{methoddesc}

\begin{methoddesc}[menu]{enable}{i, flag}
アイテム\var{i}を使用可能あるいは不可能にします。
\end{methoddesc}

\begin{methoddesc}[menu]{check}{i, flag}
アイテム\var{i}の\dfn{check mark}を設定あるいは消去します。
\end{methoddesc}

\begin{methoddesc}[menu]{close}{}
メニューオブジェクトを消去します。
そのメニューオブジェクトは使えなくなります。
\end{methoddesc}

\subsection{
ビットマップオブジェクト}

ビットマップは矩形のビット値を配列で表わします。
左上の点は(0, 0)の座標を持ちます。
ビットマップは描画オブジェクトの\method{bitmap()}メソッドで描画されます。
ビットマップは今のところ、Macintoshでは利用できません。

以下のメソッドが定義されています：

\begin{methoddesc}[bitmap]{getsize}{}
ビットマップの幅と高さを表わすタプルを返します。
（関数\function{newbitmap()}に渡された値が返されます。）
\end{methoddesc}

\begin{methoddesc}[bitmap]{setbit}{point, bit}
\var{point}で示された座標のビット値を\var{bit}へ設定します。
\end{methoddesc}

\begin{methoddesc}[bitmap]{getbit}{point}
\var{point}で示された座標のビット値を返します。
\end{methoddesc}

\begin{methoddesc}[bitmap]{close}{}
ビットマップオブジェクトを消去します。
そのビットマップオブジェクトは使えなくなります。
\end{methoddesc}

\subsection{
テキストエディットオブジェクト}

テキストエディットオブジェクトはテキストエディットのブロック範囲を示します。
意味については\C{}プログラマーのためのSTDWINドキュメントを参照してください。
以下のメソッドがあります：


\begin{methoddesc}[text-edit]{arrow}{code}
テキストエディットブロックにアローイベントを送ります。
\var{code}は\constant{WC_LEFT}、\constant{WC_RIGHT}、
\constant{WC_UP}、\constant{WC_DOWN}のうちのどれか1つでなければなりません（\refmodule{stdwinevents}モジュールを参照してください）。
\end{methoddesc}

\begin{methoddesc}[text-edit]{draw}{rect}
テキストイベントブロックにドローイベントを送ります。
矩形は再描画の範囲を指定します。
\end{methoddesc}

\begin{methoddesc}[text-edit]{event}{type, window, detail}
\function{stdwin.getevent()}からのイベントをテキストエディットブロックへ送ります。
イベントがハンドルされるとTrueを返します。
\end{methoddesc}

\begin{methoddesc}[text-edit]{getfocus}{}
フォーカスされた開始位置と終了位置を示す2つの整数を返します。この整数は\method{gettext()}で返されるテキストのスライスの添字として使えます。
\end{methoddesc}

\begin{methoddesc}[text-edit]{getfocustext}{}
フォーカスされたテキストを返します。
\end{methoddesc}

\begin{methoddesc}[text-edit]{getrect}{}
テキストエディットブロックの実際の位置を示す矩形を返します。
（テキストエディットのブロックはぴったり合うように自動的に伸びたり縮んだりするので、下の座標は最初の位置と異なっているかもしれません。）
\end{methoddesc}

\begin{methoddesc}[text-edit]{gettext}{}
テキストバッファ全体を返します。
\end{methoddesc}

\begin{methoddesc}[text-edit]{move}{rect}
ドキュメント内のテキストエディットブロックの新しい位置を設定します。
\end{methoddesc}

\begin{methoddesc}[text-edit]{replace}{str}
フォーカスされたテキストを与えられた文字列で入れ替えます。
新しいフォーカスは入れ替えた文字列の終点になります。
\end{methoddesc}

\begin{methoddesc}[text-edit]{setfocus}{i, j}
新しいフォーカスを設定します。
範囲外の値は警告なしに切り取られます。
\end{methoddesc}

\begin{methoddesc}[text-edit]{settext}{str}
テキストバッファ全体を与えられた文字列で入れ替えて、フォーカスを\code{(0, 0)}に設定します。
\end{methoddesc}

\begin{methoddesc}[text-edit]{setview}{rect}
表示する範囲の矩形を\var{rect}に設定します。
もし\var{rect}が\var{None}なら表示モードはリセットされます。
表示モードでは、テキストエディットオブジェクトからの出力は表示範囲に切り取られます。
これは独自のテキストスクロールウィンドウを作るのに便利です。
\end{methoddesc}

\begin{methoddesc}[text-edit]{close}{}
テキストエディットオブジェクトを消去します。
そのテキストエディットは使えなくなります。
\end{methoddesc}

\subsection{
例}
\nodename{STDWIN Example}

ここにPythonでSTDWINを使用した最小の例を挙げます。
ウィンドウを作り、ウィンドウの左上に``Hello world''の文字を描きます。
ウィンドウは背後に隠れて再び前面に来ると、正確に再描画されます。
クローズアイコンあるいはクローズメニューが選ばれると、プログラムは終了します。

\begin{verbatim}
import stdwin
from stdwinevents import *

def main():
    mywin = stdwin.open('Hello')
    #
    while 1:
        (type, win, detail) = stdwin.getevent()
        if type == WE_DRAW:
            draw = win.begindrawing()
            draw.text((0, 0), 'Hello, world')
            del draw
        elif type == WE_CLOSE:
            break

main()
\end{verbatim}


\section{\module{stdwinevents} ---
\module{stdwin}で使われる定数}

\declaremodule{standard}{stdwinevents}
\modulesynopsis{
\module{stdwin}で使われる定数}


このモジュールにはSTDWINで定数として使われるイベントタイプ（\constant{WE_ACTIVATE}など）、コマンドコード（\constant{WC_LEFT}など）、セレクションタイプ（\constant{WS_PRIMARY}など）が定義されています。
詳しくはソースファイルを参照してください。
お勧めの使用法は以下の通りです：

\begin{verbatim}
>>> from stdwinevents import *
>>> 
\end{verbatim}


\section{\module{rect} ---
\module{stdwin}とともに使われる関数}

\declaremodule{standard}{rect}
\modulesynopsis{
\module{stdwin}で使われる座標関連の関数。}


このモジュールには矩形を操作するための便利な関数が含まれています。
矩形は\refmodule{stdwin}モジュールで定義されています：
矩形は座標のペアで、座標は整数のペアです。
例えば、矩形

\begin{verbatim}
(10, 20), (90, 80)
\end{verbatim}

は、左、上、右、下の端がそれぞれ10、20、90、80の矩形です。
縦軸は（\refmodule{stdwin}にあるように）下方向に数値が大きくなることに注意してください。

このモジュールには以下のオブジェクトが定義されています：

\begin{excdesc}{error}
この例外はこのモジュールの関数でエラーが検出されると発生します。
例外の引数は問題点をもう少し詳しく説明する文字列です。
\end{excdesc}

\begin{datadesc}{empty}
何かの操作で空の結果が返されると返される矩形。
これによって、結果が空かどうかをすぐにチェックできます：

\begin{verbatim}
>>> import rect
>>> r1 = (10, 20), (90, 80)
>>> r2 = (0, 0), (10, 20)
>>> r3 = rect.intersect([r1, r2])
>>> if r3 is rect.empty: print 'Empty intersection'
Empty intersection
>>> 
\end{verbatim}
\end{datadesc}

\begin{funcdesc}{is_empty}{r}
与えられた矩形が空ならTrueを返します。
もし、
\begin{math}\var{left} \geq \var{right}\end{math}あるいは
\begin{math}\var{top} \geq \var{bottom}\end{math}なら、
矩形\code{(\var{left}, \var{top}), (\var{right}, \var{bottom})}は
空です。
\end{funcdesc}

\begin{funcdesc}{intersect}{list}
リストの引数で表わされる矩形の交わりを返します。
タプルの引数でも呼び出せます。
リストが空なら、例外\exception{rect.error}を発生します。
矩形の交わりが空なら、例外\constant{rect.empty}を発生します。
\end{funcdesc}

\begin{funcdesc}{union}{list}
リストの引数のなかにある、空でない全ての矩形を含む矩形のうち、最小のものを返します。
タプルの引数あるいは2つかそれ以上の矩形を引数として呼び出せます。
もしリストが空、あるいは矩形が全て空なら、例外\constant{rect.empty}を発生します。
\end{funcdesc}

\begin{funcdesc}{pointinrect}{point, rect}
座標が矩形の中にあればTrueを返します。
定義にしたがえば、もし
\begin{math}\var{left} \leq \var{h} < \var{right}\end{math}で
\begin{math}\var{top} \leq \var{v} < \var{bottom}\end{math}であれば、
座標\code{(\var{h}, \var{v})}が矩形
\code{(\var{left}, \var{top}), (\var{right}, \var{bottom})}
の中にあります。
\end{funcdesc}

\begin{funcdesc}{inset}{rect, (dh, dv)}
引数\var{rect}の中で幅\var{dh}ピクセル、高さ\var{dv}ピクセルの矩形を返します。
もし\var{dh}と\var{dv}のどちらかが負なら、結果は\var{rect}の外側になります。
\end{funcdesc}

\begin{funcdesc}{rect2geom}{rect}
矩形を幾何的な表現：
\code{(\var{left}, \var{top}), (\var{width}, \var{height})}
に変換します。
\end{funcdesc}

\begin{funcdesc}{geom2rect}{geom}
幾何的な表現で与えられた矩形を一般的な矩形の表現
\code{(\var{left}, \var{top}), (\var{right}, \var{bottom})}に
戻します。
\end{funcdesc}

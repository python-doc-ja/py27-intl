\section{\module{rexec} ---
         制限実行のフレームワーク}

\declaremodule{standard}{rexec}
\modulesynopsis{基本的な制限実行フレームワーク。}
\versionchanged[Disabled module]{2.3}
  
\begin{notice}[warning]
  このドキュメントは、\module{rexec}モジュールを使用している古い
コードを読む際の参照用として残されています。
\end{notice}


このモジュールには \class{RExec} クラスが含まれています。このクラスは、
\method{r_eval()}、 \method{r_execfile()}、 \method{r_exec()}および
\method{r_import()} メソッドをサポートし、これらは標準の
Python 関数 \method{eval()}、 \method{execfile()} および
 \keyword{exec} と \keyword{import} 文の制限されたバージョンです。
この制限された環境で実行されるコードは、安全であると見なされた
モジュールや関数だけにアクセスします；\class{RExec} をサブクラス化すれば、
望むように能力を追加および削除できます。

\begin{notice}[warning]
\module{rexec} モジュールは、下記のように動作するべく設計されては
いますが、注意深く書かれたコードなら利用できてしまうかもしれない、
既知の脆弱性がいくつかあります。従って、``製品レベル'' のセキュリティ
を要する状況では、\module{rexec} の動作をあてにするべきではありません。
製品レベルのセキュリティを求めるなら、サブプロセスを介した実行や、
あるいは処理するコードとデータの両方に対する非常に注意深い 
``浄化'' が必要でしょう。上記の代わりに、\module{rexec} の既知の
脆弱性に対するパッチ当ての手伝いも歓迎します。
\end{notice}

\begin{notice}
   \class{RExec} クラスは、プログラムコードによる
ディスクファイルの読み書きや TCP/IP ソケットの利用といった、
安全でない操作の実行を防ぐことができます。しかし、
プログラムコードよる非常に大量のメモリや処理時間の消費に対して
防御することはできません。
\end{notice}

\begin{classdesc}{RExec}{\optional{hooks\optional{, verbose}}}
\class{RExec} クラスのインスタンスを返します。

\var{hooks} は、\class{RHooks} クラスあるいはそのサブクラスの
インスタンスです。\var{hooks} が省略されているか \code{None} であれば、
デフォルトの \class{RHooks} クラスがインスタンス化されます。
\module{rexec} モジュールが (組み込みモジュールを含む) あるモジュールを
探したり、あるモジュールのコードを読んだりする時は常に、
\module{rexec} がじかにファイルシステムに出て行くことはありません。
その代わり、あらかじめ \class{RHooks} クラスに渡しておいたり、
コンストラクタで生成された \class{RHooks} インスタンスのメソッドを
呼び出します。

(実際には、\class{RExec} オブジェクトはこれらを呼び出しません --- 
呼び出しは、\class{RExec} オブジェクトの一部であるモジュールローダ
オブジェクトによって行われます。
これによって別のレベルの柔軟性が実現されます。この柔軟性は、制限された
環境内で\keyword{import} 機構を変更する時に役に立ちます。 )

代替の \class{RHooks} オブジェクトを提供することで、モジュールを
インポートする際に行われるファイルシステムへのアクセスを制御する
ことができます。このとき、各々のアクセスが行われる順番を制御する
実際のアルゴリズムは変更されません。
例えば、\class{RHooks} オブジェクトを置き換えて、ILU のような
ある種の RPC メカニズムを介することで、全てのファイルシステムの要求を
どこかにあるファイルサーバに渡すことができます。
Grail のアプレットローダは、アプレットを URL からディレクトリ上に
import する際にこの機構を使っています。

もし \var{verbose}が true であれば、追加のデバッグ出力が標準出力に
送られます。
\end{classdesc}

制限された環境で実行するコードも、やはり \function{sys.exit()} 関数を
呼ぶことができることを知っておくことは大事なことです。制限された
コードがインタプリタから抜けだすことを許さないためには、いつでも、
制限されたコードが、\exception{SystemExit} 例外をキャッチする
\keyword{try}/\keyword{except} 文とともに実行するように、呼び出しを防御します。
制限された環境から \function{sys.exit()}関数を除去するだけでは不十分です --
制限されたコードは、やはり \code{raise SystemExit} を使うことができてしまいます。
\exception{SystemExit}を取り除くことも、合理的なオプションではありません；
いくつかのライブラリコードはこれを使っていますし、これが利用できなくなると
中断してしまうでしょう。


\begin{seealso}
  \seetitle[http://grail.sourceforge.net/]{Grail のホームページ}{Grail は
             すべて Python で書かれた Web ブラウザです。これは、
            \module{rexec}モジュールを、Python アプレットをサポートするのに
            使っていて、このモジュールの使用例として使うことが
            できます。}
\end{seealso}


\subsection{RExec オブジェクト\label{rexec-objects}}

\class{RExec} インスタンスは以下のメソッドをサポートします：

\begin{methoddesc}{r_eval}{code}
\var{code} は、Python の式を含む文字列か、あるいはコンパイルされた
コードオブジェクトのどちらかでなければなりません。そしてこれらは制限された
環境の \module{__main__} モジュールで評価されます。式あるいはコード
オブジェクトの値が返されます。
\end{methoddesc}

\begin{methoddesc}{r_exec}{code}
\var{code} は、1行以上の Python コードを含む文字列か、コンパイルされた
コードオブジェクトのどちらかでなければなりません。そしてこれらは、
制限された環境の \module{__main__} モジュールで実行されます。
\end{methoddesc}

\begin{methoddesc}{r_execfile}{filename}
ファイル \var{filename} 内の Python コードを、制限された環境の
 \module{__main__} モジュールで実行します。
\end{methoddesc}

名前が \samp{s_} で始まるメソッドは、\samp{r_}で始まる関数と同様ですが、
そのコードは、標準 I/O ストリーム \code{sys.stdin}、
\code{sys.stderr} および  \code{sys.stdout} の制限されたバージョンへの
アクセスが許されています。

\begin{methoddesc}{s_eval}{code}
\var{code} は、Python 式を含む文字列でなければなりません。そして
制限された環境で評価されます。
\end{methoddesc}

\begin{methoddesc}{s_exec}{code}
\var{code} は、1行以上のPython コードを含む文字列でなければなりません。そして
制限された環境で実行されます。
\end{methoddesc}

\begin{methoddesc}{s_execfile}{code}
ファイル \var{filename} に含まれた Python コードを制限された環境で
実行します。
\end{methoddesc}

\class{RExec} オブジェクトは、制限された環境で実行されるコードによって
暗黙のうちに呼ばれる、さまざまなメソッドもサポートしなければなりません。
これらのメソッドをサブクラス内でオーバライドすることによって、制限された環境が
強制するポリシを変更します。

\begin{methoddesc}{r_import}{modulename\optional{, globals\optional{,
                             locals\optional{, fromlist}}}}
モジュール \var{modulename} をインポートし、もしそのモジュールが
安全でないとみなされるなら、\exception{ImportError} 例外を発生します。
\end{methoddesc}

\begin{methoddesc}{r_open}{filename\optional{, mode\optional{, bufsize}}}
\function{open()} が制限された環境で呼ばれるとき、呼ばれるメソッドです。
引数は \function{open()}のものと同じであり、ファイルオブジェクト
(あるいはファイルオブジェクトと互換性のあるクラスインスタンス)が
返されます。 \class{RExec}のデフォルトの動作は、任意のファイルを
読み取り用にオープンすることを許可しますが、ファイルに書き込もうとする
ことは許しません。より制限の少ない \method{r_open()}の実装については、
以下の例を見て下さい。
\end{methoddesc}

\begin{methoddesc}{r_reload}{module}
モジュールオブジェクト \var{module} を再ロードして、それを再解析し再初期化します。
\end{methoddesc}

\begin{methoddesc}{r_unload}{module}
モジュールオブジェクト \var{module}をアンロードします
(それを制限された環境の \code{sys.modules} 辞書から取りのぞきます)。
\end{methoddesc}

および制限された標準 I/O ストリームへのアクセスが可能な同等のもの：

\begin{methoddesc}{s_import}{modulename\optional{, globals\optional{,
                             locals\optional{, fromlist}}}}
モジュール \var{modulename} をインポートし、もしそのモジュールが
安全でないとみなされるなら、\exception{ImportError} 例外を発生します。
\end{methoddesc}

\begin{methoddesc}{s_reload}{module}
モジュールオブジェクト \var{module} を再ロードして、それを再解析し再初期化します。
\end{methoddesc}

\begin{methoddesc}{s_unload}{module}
モジュールオブジェクト \var{module}をアンロードします。
% XXX これのセマンティクスはどうなりますか？
\end{methoddesc}


\subsection{制限された環境を定義する \label{rexec-extension}}

\class{RExec} クラスには以下のクラス属性があります。それらは、
 \method{__init__()} メソッドが使います。それらを既存の
 インスタンス上で変更しても何の効果もありません；そうする代わりに、
\class{RExec} のサブクラスを作成して、そのクラス定義でそれらに
新しい値を割り当てます。そうすると、新しいクラスのインスタンスは、
これらの新しい値を使用します。これらの属性のすべては、文字列のタプルです。

\begin{memberdesc}{nok_builtin_names}
制限された環境で実行するプログラムでは利用でき\emph{ない}であろう、
組み込み関数の名前を格納しています。 \class{RExec}に対する値は、
\code{('open', 'reload', '__import__')} です。
(これは例外です。というのは、組み込み関数のほとんど大多数は
無害だからです。この変数をオーバライドしたいサブクラスは、
基本クラスからの値から始めて、
追加した許されない関数を連結して
いかなければなりません -- 危険な関数が新しく Python に追加された時は、
それらも、このモジュールに追加します。)
\end{memberdesc}

\begin{memberdesc}{ok_builtin_modules}
安全にインポートできる組み込みモジュールの名前を格納しています。
 \class{RExec}に対する値は、 \code{('audioop', 'array', 'binascii',
'cmath', 'errno', 'imageop', 'marshal', 'math', 'md5', 'operator',
'parser', 'regex', 'select', 'sha', '_sre', 'strop',
'struct', 'time')} です。この変数をオーバーライドする場合も、
同様な注意が適用されます -- 基本クラスからの値を使って始めます。
\end{memberdesc}

\begin{memberdesc}{ok_path}
\keyword{import}が制限された環境で実行される時に検索される
ディレクトリーを格納しています。
\class{RExec}に対する値は、(モジュールがロードされた時は)
制限されないコードの \code{sys.path} と同一です。
\end{memberdesc}

\begin{memberdesc}{ok_posix_names}
% これは ok_os_names と呼ばれるべきでしょうか?
制限された環境で実行するプログラムで利用できる、
\refmodule{os} モジュール内の関数の名前を格納しています。
\class{RExec}に対する値は、 \code{('error', 'fstat', 'listdir',
'lstat', 'readlink', 'stat', 'times', 'uname', 'getpid', 'getppid',
'getcwd', 'getuid', 'getgid', 'geteuid', 'getegid')} です。
\end{memberdesc}

\begin{memberdesc}{ok_sys_names}
制限された環境で実行するプログラムで利用できる、
 \refmodule{sys} モジュール内の関数名と変数名を格納しています。
\class{RExec}に対する値は、 \code{('ps1', 'ps2',
'copyright', 'version', 'platform', 'exit', 'maxint')}です。
\end{memberdesc}

\begin{memberdesc}{ok_file_types}
モジュールがロードすることを許されているファイルタイプを格納しています。
各ファイルタイプは、\refmodule{imp}モジュールで定義された整数定数です。
意味のある値は、\constant{PY_SOURCE}、\constant{PY_COMPILED} および
\constant{C_EXTENSION} です。\class{RExec}に対する値は、\code{(C_EXTENSION,
PY_SOURCE)}です。サブクラスで \constant{PY_COMPILED}を追加することは推奨されません；
攻撃者が、バイトコンパイルしたでっちあげのファイル(\file{.pyc})を、
例えば、あなたの公開 FTP サーバの \file{/tmp} に書いたり、
\file{/incoming} にアップロードしたりして、とにかくあなたのファイルシステム内に
置くことで、制限された実行モードから抜け出ることができるかもしれないからです。
\end{memberdesc}


\subsection{例}

標準の \class{RExec} クラスよりも、若干、もっと緩めたポリシを
望んでいるとしましょう。例えば、もし \file{/tmp} 内のファイルへの書き込みを
喜んで許すならば、\class{RExec} クラスを次のように
サブクラス化できます：

\begin{verbatim}
class TmpWriterRExec(rexec.RExec):
    def r_open(self, file, mode='r', buf=-1):
        if mode in ('r', 'rb'):
            pass
        elif mode in ('w', 'wb', 'a', 'ab'):
            # ファイル名をチェックします :  /tmp/ で始まらなければなりません
            if file[:5]!='/tmp/':
                raise IOError, " /tmp 以外へは書き込みできません"
            elif (string.find(file, '/../') >= 0 or
                 file[:3] == '../' or file[-3:] == '/..'):
                raise IOError, "ファイル名の '..' は禁じられています"
        else: raise IOError, "open() モードが正しくありません"
        return open(file, mode, buf)
\end{verbatim}
%
上のコードは、完全に正しいファイル名でも、時には禁止する場合があることに
注意して下さい；例えば、制限された環境でのコードでは、\file{/tmp/foo/../bar}
というファイルはオープンできないかもしれません。これを修正するには、
\method{r_open()} メソッドが、そのファイル名を \file{/tmp/bar}に単純化
しなければなりません。そのためには、ファイル名を分割して、それにさまざまな
操作を行う必要があります。セキュリティが重大な場合には、
より複雑で、微妙なセキュリティホールを抱え込むかもしれない、一般性のある
コードよりも、 制限が余りにあり過ぎるとしても単純なコードを書く方が、
望ましいでしょう。

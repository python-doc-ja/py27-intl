% XXX Label can't be _ast?
% XXX Where should this section/chapter go?
\chapter{抽象構文木\label{ast}}

\sectionauthor{Martin v. L\"owis}{martin@v.loewis.de}

\versionadded{2.5}

\code{_ast} モジュールは、Python アプリケーションで Python
の抽象構文木を処理しやすくするものです。Python コンパイラは、
現在は構文木への読み込みアクセス機能しか提供していません。
つまり、アプリケーションでできるのは Python ソースコードから
構文木を作成することだけであり、(それを修正したりした)
構文木からバイトコードを作成することはできないということです。
抽象構文そのものは、Python のリリースごとに変化する可能性があります。
このモジュールを使用すると、現在の文法をプログラム上で知る助けになるでしょう。

抽象構文木を作成するには、組み込み関数 \function{compile}
のフラグとして \code{_ast.PyCF_ONLY_AST} を渡します。
その結果は、\code{_ast.AST} を継承したクラスのオブジェクトのツリーとなります。

実際のクラスは \code{Parser/Python.asdl} ファイルから派生したものです。
これは後ほど示します。
抽象構文の左辺のシンボルに対してそれぞれクラスが定義されています
(たとえば \code{_ast.stmt} や \code{_ast.expr})。また、右辺の
各コンストラクタに対してもそれぞれクラスが定義されています。
これらのクラスは左辺のツリーのクラスを継承しています。
たとえば \code{_ast.BinOp} は \code{_ast.expr} を継承しています。
production rules with alternatives (aka "sums") の場合、左辺は抽象クラ
スとなります。特定のコンストラクタノードのインスタンスのみが作成されま
す。

各具象クラスは属性 \code{_fields} を持っており、すべての子ノードの名前を
そこに保持しています。

具象クラスのインスタンスは、各子ノードに対してそれぞれひとつの属性を持っ
ています。この属性は、文法で定義された型となります。たとえば
\code{_ast.BinOp} のインスタンスは \code{left} という属性を持っており、
その型は \code{_ast.expr} です。\code{_ast.expr} や \code{_ast.stmt}
のサブクラスのインスタンスにはさらにlinenoやcol_offsetといった属性があ
ります。linenoはソーステキスト上の行番号(1から数え始めるので、最初の
行の行番号は1となります)、そしてcol_offsetはノードが生成した最初のトー
クンのutf8バイトオフセットとなります。utf8オフセットが記録される理由は、
パーサが内部でutf8を使用するからです。

これらの属性が、文法上オプションであると (クエスチョンマークを用いて)
マークされている場合は、その値が \code{None} となることもあります。
属性のが複数の値をとりうる場合 (アスタリスクでマークされている場合)
は、値は Python のリストで表されます。

\section{抽象文法 (Abstract Grammar)}

このモジュールでは文字列定数 \code{__version__} を定義しています。
これは、以下に示すファイルの subversion リビジョン番号です。

抽象文法は、現在次のように定義されています。

\verbatiminput{../../Parser/Python.asdl}

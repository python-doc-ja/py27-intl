\section{\module{wsgiref} --- WSGI ユーティリティとリファレンス実装}
\declaremodule{}{wsgiref}
\moduleauthor{Phillip J. Eby}{pje@telecommunity.com}
\sectionauthor{Phillip J. Eby}{pje@telecommunity.com}
\modulesynopsis{WSGI ユーティリティとリファレンス実装}

\versionadded{2.5}

Web Server Gateway Interface (WSGI) は、Web サーバソフトウェアと
Python で記述された Web アプリケーションとの標準インターフェースです。
標準インターフェースを持つことで、WSGI をサポートするアプリケーションを
幾つもの異なる Web サーバで使うことが容易になります。

Web サーバとプログラミングフレームワークの作者だけが、WSGI デザインの
あらゆる細部や特例などを知る必要があります。WSGI アプリケーションを
インストールしたり、既存のフレームワークを使ったアプリケーションを記述する
だけの皆さんは、全てについて理解する必要はありません。

\module{wsgiref} は WSGI 仕様のリファレンス実装で、これは Web サーバや
フレームワークに WSGI サポートを加えるのに利用できます。
これは WSGI 環境変数やレスポンスヘッダを操作するユーティリティ、
WSGI サーバ実装時のベースクラス、WSGI アプリケーションを提供する 
デモ用 HTTP サーバ、それと WSGI サーバとアプリケーションの
WSGI 仕様 (\pep{333}) 準拠のバリデーションツールを提供します。

% XXX If you're just trying to write a web application...

\url{http://www.wsgi.org}に、WSGIに関するさらなる情報と、チュートリアルや
その他のリソースへのリンクがあります。










\subsection{\module{wsgiref.util} -- WSGI 環境のユーティリティ}
\declaremodule{}{wsgiref.util}

このモジュールは WSGI 環境で使う様々なユーティリティ関数を提供します。
WSGI 環境は \pep{333} で記述されているような HTTP リクエスト変数を含む
辞書です。全ての \var{environ} パラメタを取る関数は WSGI 準拠の
辞書を与えられることを期待しています；細かい仕様については \pep{333} を
参照してください。

\begin{funcdesc}{guess_scheme}{environ}
\code{wsgi.url_scheme} が "http" か "https" かについて、\var{environ} 辞書の
\code{HTTPS} 環境変数を調べることでその推測を返します。 戻り値は文字列(string)です。

この関数は、CGI や FastCGI のような CGI に似たプロトコルをラップする
ゲートウェイを作成する場合に便利です。典型的には、それらのプロトコルを
提供するサーバが SSL 経由でリクエストを受け取った場合には \code{HTTPS} 変数に
値 "1" "yes"、または "on" を持つでしょう。ですので、この関数はそのような値が
見つかった場合には "https" を返し、そうでなければ "http" を返します。
\end{funcdesc}

\begin{funcdesc}{request_uri}{environ \optional{, include_query=1}}
クエリ文字列をオプションで含むリクエスト URI 全体を、
\pep{333} の "URL 再構築(URL Reconstruction)" にあるアルゴリズムを使って返します。
\var{include_query} が false の場合、クエリ文字列は結果となる文字列には
含まれません。
\end{funcdesc}

\begin{funcdesc}{application_uri}{environ}
\function{request_url} に似ていて、\code{PATH_INFO} と \code{QUERY_STRING} 変数は
無視されます。結果はリクエストによって指定されたアプリケーションオブジェクトの
ベース URI です。
\end{funcdesc}

\begin{funcdesc}{shift_path_info}{environ}
\code{PATH_INFO} から\code{SCRIPT_NAME} まで一つの名前をシフトして
その名前を返します。\var{environ} 辞書は\emph{変更されます}；\code{PATH_INFO} や
\code{SCRIPT_NAME} のオリジナルをそのまま残したい場合にはコピーを使ってください。

\code{PATH_INFO} にパスセグメントが何も残っていなければ、\code{None} が返されます。

典型的なこのルーチンの使い方はリクエスト URI のそれぞれの要素の処理で、
例えばパスを一連の辞書のキーとして取り扱う場合です。
このルーチンは、渡された環境を、ターゲット URL で示される別の WSGI アプリケーション
の呼び出しに合うように調整します。
例えば、\code{/foo} に WSGI アプリケーションがあったとして、そして
リクエスト URL パスが \code{/foo/bar/baz} で、\code{/foo} の WSGI アプリケーションが
\function{shift_path_info} を呼んだ場合、これは "bar" 文字列を受け取り、
環境は \code{/foo/bar} の WSGI アプリケーションへの受け渡しに適するように
更新されます。つまり、\code{SCRIPT_NAME} は \code{/foo} から \code{/foo/bar} に変わって、
\code{PATH_INFO} は \code{/bar/baz} から \code{/baz} に変化するのです。

\code{PATH_INFO} が単に "/" の場合、このルーチンは空の文字列を返し、
\code{SCRIPT_NAME} の末尾にスラッシュを加えます、これはたとえ
空のパスセグメントが通常は無視され、そして \code{SCRIPT_NAME} は通常
スラッシュで終わる事が無かったとしてもです。これは意図的な振る舞いで、
このルーチンでオブジェクト巡回(object traversal) をした場合に
\code{/x} で終わる URI と \code{/x/} で終わるものを
アプリケーションが識別できることを保証するためのものです。
\end{funcdesc}

\begin{funcdesc}{setup_testing_defaults}{environ}
テスト目的で、\var{environ} を自明なデフォルト値 (trivial defaults) で更新します。

このルーチンは WSGI に必要な様々なパラメタを追加し、それには
\code{HTTP_HOST}、\code{SERVER_NAME}、\code{SERVER_PORT}、
\code{REQUEST_METHOD}、\code{SCRIPT_NAME}、\code{PATH_INFO}、あとは
\pep{333} で定義されている \code{wsgi.*} 変数群を含みます。これは
デフォルト値のみを追加し、これらの変数の既存設定は一切置きかえません。

このルーチンは、ダミー環境をセットアップすることによって WSGI サーバと
アプリケーションのユニットテストを容易にすることを意図しています。
これは実際の WSGI サーバやアプリケーションで使うべきではありません。
なぜならこのデータは偽物なのです！
\end{funcdesc}


上記の環境用関数に加えて、\module{wsgiref.util} モジュールも
以下のようなその他のユーティリティを提供します：

\begin{funcdesc}{is_hop_by_hop}{header_name}
'header_name' が \rfc{2616} で定義されている HTTP/1.1 の "Hop-by-Hop" ヘッダの
場合に true を返します。
\end{funcdesc}

\begin{classdesc}{FileWrapper}{filelike \optional{, blksize=8192}}
ファイルライクオブジェクトをイテレータに変換するラッパです。
結果のオブジェクトは \method{__getitem__} と \method{__iter__} 両方を
サポートしますが、これは Python 2.1 と Jython の互換性のためです。
オブジェクトがイテレートされる間、オプションの \var{blksize} パラメタが
くり返し \var{filelike} オブジェクトの \method{read()} メソッドに渡されて
受け渡す文字列を取得します。\method{read()} が空文字列を返した場合
イテレーションは終了して、再開されることはありません。

\var{filelike} に \method{close()} メソッドがある場合、返されたオブジェクトも
\method{close()} メソッドを持ち、これが呼ばれた場合には \var{filelike} オブジェクトの
\method{close()} メソッドを呼び出します。
\end{classdesc}



















\subsection{\module{wsgiref.headers} -- WSGI レスポンスヘッダツール群}
\declaremodule{}{wsgiref.headers}
このモジュールは単一のクラス、\class{Headers} を提供し、WSGI レスポンスヘッダの
操作をマップに似たインターフェースで便利にします。

\begin{classdesc}{Headers}{headers}
\var{headers} をラップするマップに似たオブジェクトを生成します。これは
\pep{333} に定義されるようなヘッダの名前／値のタプルのリストです。
新しい \class{Headers} オブジェクトに与えられた変更は、一緒に作成された
\var{headers} リストを直接更新します。

\class{Headers} オブジェクトは典型的なマッピング操作をサポートし、これには
\method{__getitem__}、\method{get}、\method{__setitem__}、
\method{setdefault}、\method{__delitem__}、\method{__contains__} と
\method{has_key} を含みます。これらメソッドのそれぞれにおいて、キーは
ヘッダ名で（大文字小文字は区別しません）、値はそのヘッダ名に関連づけられた
最初の値です。ヘッダを設定すると既存のヘッダ値は削除され、ラップされた
ヘッダのリストの末尾に新しい値が加えられます。既存のヘッダの順番は
一般的に整えられていて、ラップされたリストの最後に新しいヘッダが追加されます。

辞書とは違って、\class{Headers} オブジェクトはラップされたヘッダリストに
存在しないキーを取得または削除しようとした場合にもエラーを発生しません。
単に、存在しないヘッダの取得は \code{None} を返し、存在しないヘッダの削除は
何もしません。

\class{Headers} オブジェクトは \method{keys()}、\method{values()}、
\method{items()} メソッドもサポートします。\method{keys()} と \method{items()} で
返されるリストは、同じキーを一回以上含むことがあり、これは複数の値を持つヘッダの場合です。
\class{Header} オブジェクトの \code{len()} は、その \method{items()} の長さと同じであり、
ラップされたヘッダリストの長さと同じです。事実、\method{items()} メソッドは
単にラップされたヘッダリストのコピーを返しているだけです。

\class{Headers} オブジェクトに対して \code{str()} を呼ぶと、HTTP レスポンスヘッダとして
送信するのに適した形に整形された文字列を返します。それぞれのヘッダはコロンとスペースで
区切られた値と共に一列に並んでいます。
それぞれの行はキャリッジリターンとラインフィードで終了し、文字列は空行で終了しています。

これらのマッピングインターフェースと整形機能に加えて、\class{Headers} オブジェクトは
複数の値を持つヘッダの取得と追加、MIME パラメタでヘッダを追加するための
以下のようなメソッド群も持っています：

\begin{methoddesc}{get_all}{name}
指定されたヘッダの全ての値のリストを返します。

返されるリストは、元々のヘッダリストに現れる順、またはこのインスタンスに
追加された順に並んでいて、複製を含む場合があります。削除されて加えられた
フィールドは全てヘッダリストの末尾に付きます。ある名前のフィールドが何もなければ、
空のリストが返ります。
\end{methoddesc}


\begin{methoddesc}{add_header}{name, value, **_params}
ヘッダ（複数の値かもしれません）を、キーワード引数を通じて指定する
オプションの MIME パラメタと共に追加します。

\var{name} は追加するヘッダフィールドです。このヘッダフィールドに MIME パラメタを
設定するためにキーワード引数を使うことができます。それぞれのパラメタは文字列か \code{None} で
なければいけません。パラメタ中のアンダースコアはダッシュに変換されます、これはダッシュが
Python の識別子としては不正なのですが、多くの MIME パラメタはダッシュを含むためです。
パラメタ値が文字列の場合、これはヘッダ値のパラメタに \code{name="value"} の形で追加されます。
これがもし \code{None} の場合、パラメタ名だけが追加されます。（これは値なしの MIME パラメタの
場合に使われます。）使い方の例は：

\begin{verbatim}
h.add_header('content-disposition', 'attachment', filename='bud.gif')
\end{verbatim}

上記はこのようなヘッダを追加します：

\begin{verbatim}
Content-Disposition: attachment; filename="bud.gif"
\end{verbatim}
\end{methoddesc}
\end{classdesc}

\subsection{\module{wsgiref.simple_server} -- シンプルな WSGI HTTP サーバ}
\declaremodule[wsgiref.simpleserver]{}{wsgiref.simple_server}

このモジュールは WSGI アプリケーションを提供する
シンプルな HTTP サーバです（\module{BaseHTTPServer} がベースです）。
個々のサーバインスタンスは単一の WSGI アプリケーションを、特定のホストとポート上で
提供します。もし一つのホストとポート上で複数のアプリケーションを提供したいならば、
\code{PATH_INFO} をパースして個々のリクエストでどのアプリケーションを呼び出すか
選択するような WSGI アプリケーションを作るべきです。（例えば、 \module{wsgiref.util} から
\function{shift_path_info()} を利用します。）

\begin{funcdesc}{make_server}{host, port, app
\optional{, server_class=\class{WSGIServer} \optional{,
handler_class=\class{WSGIRequestHandler}}}}
\var{host} と \var{port} 上で待機し、 \var{app} へのコネクションを受け付ける 
WSGI サーバを作成します。戻り値は与えられた \var{server_class} のインスタンスで、
指定された \var{handler_class} を使ってリクエストを処理します。\var{app} は \pep{333} で
定義されるところの WSGI アプリケーションでなければいけません。

使用例：
\begin{verbatim}from wsgiref.simple_server import make_server, demo_app

httpd = make_server('', 8000, demo_app)
print "Serving HTTP on port 8000..."

# プロセスが死ぬまでリクエストに答える
httpd.serve_forever()

# 代替：１つのリクエストを受けて終了する
##httpd.handle_request()
\end{verbatim}

\end{funcdesc}






\begin{funcdesc}{demo_app}{environ, start_response}
この関数は小規模ながら完全な WSGI アプリケーションで、
"Hello world!" メッセージと、\var{environ} パラメタに提供されている
キー／値のペアをを含むテキストページを返します。
これは WSGI サーバ（\module{wsgiref.simple_server} のような）が
シンプルな WSGI アプリケーションを正しく実行できるかを確かめるのに便利です。
\end{funcdesc}


\begin{classdesc}{WSGIServer}{server_address, RequestHandlerClass}
\class{WSGIServer} インスタンスを作成します。\var{server_address} は
\code{(host,port)} のタプル、そして \var{RequesthandlerClass} は
リクエストの処理に使われる \class{BaseHTTPServer.BaseHTTPRequestHandler} の
サブクラスでなければいけません。

\function{make_server} が細かい調整をやってくれるので、
通常はこのコンストラクタを呼ぶ必要はありません。

\class{WSGIServer} は \class{BaseHTTPServer.HTTPServer} のサブクラスですので、
この全てのメソッド（\method{serve_forever()} や \method{handle_request()} のような）が
利用できます。
\class{WSGIServer} も以下のような WSGI 固有メソッドを提供します：

\begin{methoddesc}{set_app}{application}
呼び出し可能（callable）な \var{application} を
リクエストを受け取る WSGI アプリケーションとして設定します。
\end{methoddesc}

\begin{methoddesc}{get_app}{}
現在設定されている呼び出し可能（callable）アプリケーションを返します。
\end{methoddesc}

しかしながら、通常はこれらの追加されたメソッドを使う必要はありません。
\method{set_app()} は普通は \function{make_server()} によって呼ばれ、
\method{get_app()} は主にリクエストハンドラインスタンスの便宜上存在する
からです。
\end{classdesc}



\begin{classdesc}{WSGIRequestHandler}{request, client_address, server}
与えられた \var{request}（すなわちソケット）の HTTP ハンドラ、
\var{client_address}（\code{\var{host},\var{port})} のタプル）、
\var{server}（\class{WSGIServer} インスタンス）の HTTP ハンドラを作成します。

このクラスのインスタンスを直接生成する必要はありません；これらは
必要に応じて \class{WSGIServer} オブジェクトによって自動的に生成されます。
しかしながら、このクラスをサブクラス化し、\function{make_server()} 関数に
\var{handler_class} として与えることは可能でしょう。サブクラスにおいて
オーバーライドする意味のありそうなものは：

\begin{methoddesc}{get_environ}{}
リクエストに対する WSGI 環境を含む辞書を返します。デフォルト実装では
\class{WSGIServer} オブジェクトの \member{base_environ} 辞書属性のコンテンツを
コピーし、それから HTTP リクエスト由来の様々なヘッダを追加しています。
このメソッド呼び出し毎に、\pep{333} に指定されている関連する CGI 環境変数を
全て含む新規の辞書を返さなければいけません。
\end{methoddesc}

\begin{methoddesc}{get_stderr}{}
\code{wsgi.errors} ストリームとして使われるオブジェクトを返します。
デフォルト実装では単に \code{sys.stderr} を返します。
\end{methoddesc}

\begin{methoddesc}{handle}{}
HTTP リクエストを処理します。デフォルト実装では実際の WGI アプリケーション
インターフェースを実装するのに \module{wsgiref.handlers} クラスを使って
ハンドラインスタンスを作成します。
\end{methoddesc}









\subsection{\module{wsgiref.validate} -- WSGI 準拠チェッカ}
\declaremodule{}{wsgiref.validate}
WSGI アプリケーションのオブジェクト、フレームワーク、サーバ又はミドルウェアの
作成時には、その新規のコードを \module{wsgiref.validate} を使って準拠の検証をする
と便利です。このモジュールは WSGI サーバやゲートウェイと WSGI アプリケーション
オブジェクト間の通信を検証する WSGI アプリケーションオブジェクトを作成する
関数を提供し、双方のプロトコル準拠をチェックします。

このユーティリティは完全な \pep{333} 準拠を保証するものでないことは注意してください；
このモジュールでエラーが出ないことは必ずしもエラーが存在しないことを意味しません。
しかしこのモジュールがエラーを出したならば、サーバかアプリケーションの
どちらかが 100% 準拠ではないことはほとんど確実です。

このモジュールは lan Bicking の "Python Paste" ライブラリの 
\module{paste.lint} モジュールをベースにしています。

\begin{funcdesc}{validator}{application}
\var{application} をラップし、新しい WSGI アプリケーションオブジェクトを返します。
返されたアプリケーションは全てのリクエストを元々の \var{application} に
フォワードし、\var{application} とそれを呼び出すサーバの両方が WSGI 仕様と
RFC 2616 の両方に準拠しているかをチェックします。

検出された非準拠は、投げられる \exception{AssertionError} の中に入ります；
しかし、このエラーがどう扱われるかはサーバ依存であることに注意してください。
例えば、\module{wsgiref.simple_server} とその他 \module{wsgiref.handlers} ベースの
サーバ（エラー処理メソッドが他のことをするようにオーバライドしていないもの）は
単純にエラーが発生したというメッセージとトラックバックのダンプを \code{sys.stderr} や
その他のエラーストリームに出力します。

このラッパは\module{warnings} モジュールを使って出力を生成し、
疑問の余地はあるが実際には \pep{333} で禁止はされていないかもしれない挙動を
指摘します。これらは Python のコマンドラインオプションや \module{warnings} API で
抑制されなければ、\code{sys.stderr}（たまたま同一のオブジェクトで無い限り 
\code{wsgi.errors} では\emph{ない}）に書き出されます。
\end{funcdesc}

\subsection{\module{wsgiref.handlers} -- サーバ／ゲートウェイのベースクラス}
\declaremodule{}{wsgiref.handlers}
このモジュールは WSGI サーバとゲートウェイ実装のベースハンドラクラスを
提供します。これらのベースクラスは CGI ライクの環境を与えられれば
入力、出力そしてエラーストリームと共に WSGI アプリケーションとの
通信の大部分を処理します。


\begin{classdesc}{CGIHandler}{}
\code{sys.stdin}、\code{sys.stdout}、\code{stderr} そして \code{os.environ} 経由での
CGI ベースの呼び出しです。これは、もしあなたが WSGI アプリケーションを持っていて、
これを CGI スクリプトとして実行したい場合に有用です。単に \code{CGIHandler().run(app)} を
起動してください。\code{app} はあなたが起動したい WSGI アプリケーションオブジェクトです。

このクラスは \class{BaseCGIHandler} のサブクラスで、これは \code{wsgi.run_once} を true、
\code{wsgi.multithread} を false、そして \code{wsgi.multiprocess} を true にセットし、
常に \module{sys} と \module{os} を、必要な CGI ストリームと環境を取得するために使用します。
\end{classdesc}


\begin{classdesc}{BaseCGIHandler}{stdin, stdout, stderr, environ
\optional{, multithread=True \optional{, multiprocess=False}}}

\class{CGIHandler} に似ていますが、\module{sys} と \module{os} モジュールを
使う代わりに CGI 環境と I/O ストリームを明示的に指定します。\var{multithread} と
\var{multiprocess} の値は、ハンドラインスタンスにより実行されるアプリケーションの 
\code{wsgi.multithread} と \code{wsgi.multiprocess} フラグの設定に使われます。

このクラスは \class{SimpleHandler} のサブクラスで、HTTP の "本サーバ" でない
ソフトウェアと使うことを意図しています。もしあなたが \code{Status:} ヘッダを
HTTP ステータスを送信するのに使うような ゲートウェイプロトコルの実装（CGI、FastCGI、SCGIなど）を
書いているとして、おそらく \class{SimpleHandler} でなくこれをサブクラス化したいことでしょう。
\end{classdesc}



\begin{classdesc}{SimpleHandler}{stdin, stdout, stderr, environ
\optional{,multithread=True \optional{, multiprocess=False}}}
\class{BaseCGIHandler} と似ていますが、HTTP の本サーバと使うためにデザインされています。
もしあなたが HTTP サーバ実装を書いている場合、おそらく \class{BaseCGIHandler} でなく
これをサブクラス化したいことでしょう。

このクラスは \class{BaseHandler} のサブクラスです。これは \method{__init__()}、
\method{get_stdin()}、\method{get_stderr()}、\method{add_cgi_vars()}、\method{_write()}、
\method{_flush()} をオーバーライドして、コンストラクタから明示的に環境とストリームを
設定するようにしています。与えられた環境とストリームは \member{stdin}、\member{stdout}、
\member{stderr} それに \member{environ} 属性に保存されています。
\end{classdesc}

\begin{classdesc}{BaseHandler}{}
これは WSGI アプリケーションを実行するための抽象ベースクラスです。
原理上は複数のリクエスト用に再利用可能なサブクラスを作成することが
できますが、それぞれのインスタンスは一つの HTTP リクエストを処理します。

\class{BaseHandler} インスタンスは外部からの利用にたった一つのメソッドを持ちます：

\begin{methoddesc}{run}{app}
指定された WSGI アプリケーション、\var{app} を実行します。
\end{methoddesc}

その他の全ての \class{BaseHandler} のメソッドはアプリケーション実行プロセスで
このメソッドから呼ばれます。ですので、主にそのプロセスのカスタマイズのために
存在しています。

以下のメソッドはサブクラスでオーバーライドされなければいけません：

\begin{methoddesc}{_write}{data}
文字列の \var{data} をクライアントへの転送用にバッファします。
このメソッドが実際にデータを転送しても OK です：
下部システムが実際にそのような区別をしている場合に効率をより良くするために、
\class{BaseHandler} は書き出しとフラッシュ操作を分けているからです。
\end{methoddesc}

\begin{methoddesc}{_flush}{}
バッファされたデータをクライアントに強制的に転送します。このメソッドは
何もしなくても OK です（すなわち、\method{_write()} が実際にデータを送る場合）。
\end{methoddesc}

\begin{methoddesc}{get_stdin}{}
現在処理中のリクエストの \code{wsgi.input} としての利用に適当な
入力ストリームオブジェクトを返します。
\end{methoddesc}

\begin{methoddesc}{get_stderr}{}
現在処理中のリクエストの \code{wsgi.errors} としての利用に適当な
出力ストリームオブジェクトを返します。
\end{methoddesc}

\begin{methoddesc}{add_cgi_vars}{}
現在のリクエストの CGI 変数を \member{environ} 属性に追加します。
\end{methoddesc}

これらがオーバーライドするであろうメソッド及び属性です。
しかしながら、このリストは単にサマリであり、オーバーライド可能な全てのメソッドは
含んでいません。カスタマイズした \class{BaseHandler} サブクラスを作成しようとする前に
ドキュメント文字列 (docstrings) やソースコードでさらなる情報を調べてください。















WSGI 環境のカスタマイズのための属性とメソッド：

\begin{memberdesc}{wsgi_multithread}
\code{wsgi.multithread} 環境変数で使われる値。デフォルトは \class{BaseHandler} では
true ですが、別のサブクラスではデフォルトで（またはコンストラクタによって設定されて）
異なる値を持つことがあります。
\end{memberdesc}

\begin{memberdesc}{wsgi_multiprocess}
\code{wsgi.multiprocess} 環境変数で使われる値。デフォルトは \class{BaseHandler} では
true ですが、別のサブクラスではデフォルトで（またはコンストラクタによって設定されて）
異なる値を持つことがあります。
\end{memberdesc}

\begin{memberdesc}{wsgi_run_once}
\code{wsgi.run_once} 環境変数で使われる値。デフォルトは \class{BaseHandler} では
false ですが、\class{CGIHandler} はデフォルトでこれを true に設定します。
\end{memberdesc}

\begin{memberdesc}{os_environ}
全てのリクエストの WSGI 環境に含まれるデフォルトの環境変数。
デフォルトでは、\module{wsgiref.handlers} がインポートされた時点では
これは \code{os.environ} のコピーですが、サブクラスはクラスまたは
インスタンスレベルでそれら自身のものを作ることができます。
デフォルト値は複数のクラスとインスタンスで共有されるため、
この辞書は読み取り専用と考えるべきだという点に注意してください。
\end{memberdesc}

\begin{memberdesc}{server_software}
\member{origin_server} 属性が設定されている場合、この属性の値がデフォルトの
\code{SERVER_SOFTWARE} WSGI 環境変数の設定や HTTP レスポンス中の
デフォルトの \code{Server:} ヘッダの設定に使われます。これは（\class{BaseCGIHandler} や
\class{CGIHandler} のような）HTTP オリジンサーバでないハンドラでは無視されます。
\end{memberdesc}



\begin{methoddesc}{get_scheme}{}
現在のリクエストで使われている URL スキームを返します。デフォルト実装は
\module{wsgiref.util} の \function{guess_scheme()} を使い、
現在のリクエストの \member{envion} 変数に基づいて
スキームが"http" か "https" かを推測します。
\end{methoddesc}

\begin{methoddesc}{setup_environ}{}
\member{environ} 属性を、全てを導入済みの WSGI 環境に設定します。
デフォルトの実装は、上記全てのメソッドと属性、加えて \method{get_stdin()}、
\method{get_stderr()}、\method{add_cgi_vars()} メソッドと \member{wsgi_file_wrapper} 属性を
利用します。これは、キーが存在せず、\member{origin_server} 属性が true 値で
\member{server_software} 属性も設定されている場合に \code{SERVER_SOFTWARE} を挿入します。
\end{methoddesc}

\end{classdesc}























例外処理のカスタマイズのためのメソッドと属性：

\begin{methoddesc}{log_exception}{exc_info}
\var{exec_info} タプルをサーバログに記録します。\var{exc_info} は
\code{(\var{type}, \var{value}, \var{traceback})} のタプルです。
デフォルトの実装は単純にトレースバックをリクエストの \code{wsgi.errors} ストリームに
書き出してフラッシュします。サブクラスはこのメソッドをオーバーライドして
フォーマットを変更したり出力先の変更、トレースバックを管理者にメールしたり
その他適切と思われるいかなるアクションも取ることができます。
\end{methoddesc}

\begin{memberdesc}{traceback_limit}
デフォルトの \method{log_exception()} メソッドで出力される
トレースバック出力に含まれる最大のフレーム数です。\code{None} ならば、
全てのフレームが含まれます。
\end{memberdesc}

\begin{methoddesc}{error_output}{environ, start_response}
このメソッドは、ユーザに対してエラーページを出力する WSGI アプリケーションです。
これはクライアントにヘッダが送出される前にエラーが発生した場合にのみ
呼び出されます。

このメソッドは \code{sys.exc_info()} を使って現在のエラー情報に
アクセスでき、その情報はこれを呼ぶときに \var{start_response} に
渡すべきです（\pep{333} の "Error Handling" セクションに記述があります）。

デフォルト実装は単に \member{error_status}、\member{error_headers}、そして
\member{error_body} 属性を出力ページの生成に使います。サブクラスでは
これをオーバーライドしてもっと動的なエラー出力をすることが出来ます。

しかし、セキュリティの観点からは診断をあらゆる老練ユーザに吐き出すことは
推奨されないことに気をつけてください；理想的には、診断的な出力を有効に
するには何らかの特別なことをする必要があるようにすべきで、これが
デフォルト実装では何も含まれていない理由です。
\end{methoddesc}




\begin{memberdesc}{error_status}
エラーレスポンスで使われる HTTP ステータスです。これは \pep{333} で
定義されているステータス文字列です；デフォルトは 500 コードとメッセージです。
\end{memberdesc}

\begin{memberdesc}{error_headers}
エラーレスポンスで使われる HTTP ヘッダです。これは \pep{333} で述べられているような、
WSGI レスポンスヘッダ（\code{(\var{name}, \var{value})} タプル）のリストであるべきです。
デフォルトのリストはコンテントタイプを \code{text/plain} にセットしているだけです。
\end{memberdesc}

\begin{memberdesc}{error_body}
エラーレスポンスボディ。これは HTTP レスポンスのボディ文字列であるべきです。
これはデフォルトではプレーンテキストで "A server error occurred.  Please
contact the administrator." です。
\end{memberdesc}























\pep{333} の "オプションのプラットフォーム固有のファイルハンドリング" 機能のための
メソッドと属性：

\begin{memberdesc}{wsgi_file_wrapper}
\code{wsgi.file_wrapper} ファクトリ、または \code{None} です。
この属性のデフォルト値は \module{wsgiref.util} の \class{FileWrapper} クラスです。
\end{memberdesc}

\begin{methoddesc}{sendfile}{}
オーバーライドしてプラットフォーム固有のファイル転送を実装します。
このメソッドはアプリケーションの戻り値が \member{wsgi_file_wrapper} 属性で
指定されたクラスのインスタンスの場合にのみ呼ばれます。これは
ファイルの転送が成功できた場合には true を返して、デフォルトの転送コードが
実行されないようにするべきです。このデフォルトの実装は単に false 値を返します。
\end{methoddesc}


その他のメソッドと属性：

\begin{memberdesc}{origin_server}
この属性はハンドラの \method{_write()} と \method{_flush()} が、
特別に \code{Status:} ヘッダに HTTP ステータスを求めるような
CGI 状のゲートウェイプロトコル経由でなく、クライアントと
直接通信をするような場合には true 値に設定されているべきです。

この属性のデフォルト値は \class{BaseHandler} では true ですが、
\class{BaseCGIHandler} と \class{CGIHandler} では false です。
\end{memberdesc}

\begin{memberdesc}{http_version}
\member{origin_server} が true の場合、この文字列属性はクライアントへの
レスポンスセットの HTTP バージョンの設定に使われます。デフォルトは \code{"1.0"} です。
\end{memberdesc}





\end{classdesc}

\section{\module{timeit} ---
         小さなコード断片の実行時間計測}

\declaremodule{standard}{timeit}
\modulesynopsis{小さなコード断片の実行時間計測。}

\versionadded{2.3}
\index{Benchmarking}
\index{Performance}

このモジュールは Python の小さなコード断片の時間を簡単に計測する手段を
提供します。インターフェースはコマンドラインとメソッドとして呼び出し可
能なものの両方を備えています。また、このモジュールは実行時間の計測にあ
たり陥りがちな落し穴に対する様々な対策が取られています。詳しくは、
O'Reilly の \citetitle{Python Cookbook}、``Algorithms'' の章にある Tim
Peters が書いた解説を参照してください。

このモジュールには次のパブリック・クラスが定義されています。

\begin{classdesc}{Timer}{\optional{stmt=\code{'pass'}
                         \optional{, setup=\code{'pass'}
                         \optional{, timer=<timer function>}}}}

小さなコード断片の実行時間計測をおこなうためのクラスです。

コンストラクタは引数として、時間計測の対象となる文、セットアップに使用
する追加の文、タイマ関数を受け取ります。文のデフォルト値は両方とも 
\code{'pass'} で、タイマ関数はプラットフォーム依存(モジュールの doc
string を参照)です。文には複数行の文字列リテラルを含まない限り、改行を
入れることも可能です。

最初の文の実行時間を計測には \method{timeit()} メソッドを使用します。
また \method{timeit()} を複数回呼び出し、その結果のリストを返す 
\method{repeat()} メソッドも用意されています。
\end{classdesc}

\begin{methoddesc}{print_exc}{\optional{file=\constant{None}}}
計測対象コードのトレースバックを出力するためのヘルパー。

利用例:

\begin{verbatim}
    t = Timer(...)       # try/except の外側で
    try:
        t.timeit(...)    # または t.repeat(...)
    except:
        t.print_exc()
\end{verbatim}

標準のトレースバックより優れた点は、コンパイルしたテンプレートのソース
行が表示されることです。オプションの引数 \var{file} にはトレースバック
の出力先を指定します。デフォルトは \code{sys.stderr} になっています。
\end{methoddesc}

\begin{methoddesc}{repeat}{\optional{repeat\code{=3} \optional{,
                           number\code{=1000000}}}}
\method{timeit()} を複数回呼び出します。

このメソッドは \method{timeit()} を複数回呼び出し、その結果をリストで
返すユーティリティ関数です。最初の引数には \method{timeit()} を呼び出
す回数を指定します。2番目の引数は \function{timeit()} へ引数として渡す
\var{数値}です。

\begin{notice}

結果のベクトルから平均値や標準偏差を計算して出力させたいと思うかもしれ
ませんが、それはあまり意味がありません。多くの場合、最も低い値がそのマ
シンが与えられたコード断片を実行する場合の下限値です。結果のうち高めの
値は、Python のスピードが一定しないために生じたものではなく、時刻取得
の際他のプロセスと衝突がおこったため、正確さが損なわれた結果生じたもの
です。したがって、結果のうち \function{min()} だけが見るべき値となりま
す。この点を押さえた上で、統計的な分析よりも常識的な判断で結果を見るよ
うにしてください。
\end{notice}
\end{methoddesc}

\begin{methoddesc}{timeit}{\optional{number\code{=1000000}}}

メイン文の実行時間を \var{number} 回取得します。このメソッドはセットアッ
プ文を1回だけ実行し、メイン文を指定回数実行するのにかかった秒数を浮動
小数で返します。引数はループを何回実行するかの指定で、デフォルト値は
100万回です。メイン文、セットアップ文、タイマ関数はコンストラクタで指
定されたものを使用します。

\begin{notice}
デフォルトでは、 \method{timeit()} は時間計測中、一時的にガーベッジコレ
クションを切ります。
このアプローチの利点は、個別の測定結果を比較しやすくなることです。
不利な点は、GC が測定している関数のパフォーマンスの重要な一部かもしれな
いということです。
そうした場合、\var{setup} 文字列の最初の文で GC を再度有効にすることがで
きます。
例えば :
\begin{verbatim}
    timeit.Timer('for i in xrange(10): oct(i)', 'gc.enable()').timeit()
\end{verbatim}
\end{notice}
\end{methoddesc}

\subsection{コマンドライン・インターフェース}

コマンドラインからプログラムとして呼び出す場合は、次の書式を使います。

\begin{verbatim}
python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]
\end{verbatim}

以下のオプションが使用できます。

\begin{description}
\item[-n N/\longprogramopt{number}=N] 'statement' を何回実行するか
\item[-r N/\longprogramopt{repeat}=N] タイマを何回リピートするか(デフォルトは 3)
\item[-s S/\longprogramopt{setup}=S] 最初に1回だけ実行する文
(デフォルトは \code{'pass'})
\item[-t/\longprogramopt{time}] \function{time.time()} を使用する
(Windows を除くすべてのプラットフォームのデフォルト)
\item[-c/\longprogramopt{clock}] \function{time.clock()} を使用する(Windows のデフォルト)
\item[-v/\longprogramopt{verbose}] 時間計測の結果をそのまま詳細な数値でくり返し表示する
\item[-h/\longprogramopt{help}] 簡単な使い方を表示して終了する
\end{description}

文は複数行指定することもできます。その場合、各行は独立した文として引数
に指定されたものとして処理します。クォートと行頭のスペースを使って、イ
ンデントした文を使うことも可能です。この複数行のオプションは 
\programopt{-s} においても同じ形式で指定可能です。

オプション \programopt{-n} でループの回数が指定されていない場合、10回
から始めて、所要時間が 0.2 秒になるまで回数を増やすことで適切なループ
回数が自動計算されるようになっています。

デフォルトのタイマ関数はプラットフォーム依存です。Windows の場合、
\function{time.clock()} はマイクロ秒の精度がありますが、
\function{time.time()} は 1/60 秒の精度しかありません。一方 \UNIX の場
合、\function{time.clock()} でも 1/100 秒の精度があり、
\function{time.time()} はもっと正確です。いずれのプラットフォームにお
いても、デフォルトのタイマ関数は CPU 時間ではなく通常の時間を返します。
つまり、同じコンピュータ上で別のプロセスが動いている場合、タイミングの
衝突する可能性があるということです。正確な時間を割り出すために最善の方
法は、時間の取得を数回くり返しその中の最短の時間を採用することです。
\programopt{-r} オプションはこれをおこなうもので、デフォルトのくり返し
回数は3回になっています。多くの場合はデフォルトのままで充分でしょう。
\UNIX の場合 \function{time.clock()} を使って CPU 時間で測定することも
できます。

\begin{notice}
  pass 文の実行による基本的なオーバーヘッドが存在することに注意してく
  ださい。ここにあるコードはこの事実を隠そうとはしておらず、注意を払う
  必要があります。基本的なオーバーヘッドは引数なしでプログラムを起動す
  ることにより計測できます。
\end{notice}

基本的なオーバヘッドは Python のバージョンによって異なります。Python
2.3 とそれ以前の Python の公平な比較をおこなう場合、古い方の Python は 
\programopt{-O} オプションで起動し \code{SET_LINENO} 命令の実行時間が
含まれないようにする必要があります。

\subsection{使用例}

以下に2つの使用例を記載します(ひとつはコマンドライン・インターフェース
によるもの、もうひとつはモジュール・インターフェースによるものです)。
内容はオブジェクトの属性の有無を調べるのに \function{hasattr()} を使っ
た場合と \keyword{try}/\keyword{except} を使った場合の比較です。

\begin{verbatim}
% timeit.py 'try:' '  str.__nonzero__' 'except AttributeError:' '  pass'
100000 loops, best of 3: 15.7 usec per loop
% timeit.py 'if hasattr(str, "__nonzero__"): pass'
100000 loops, best of 3: 4.26 usec per loop
% timeit.py 'try:' '  int.__nonzero__' 'except AttributeError:' '  pass'
1000000 loops, best of 3: 1.43 usec per loop
% timeit.py 'if hasattr(int, "__nonzero__"): pass'
100000 loops, best of 3: 2.23 usec per loop
\end{verbatim}

\begin{verbatim}
>>> import timeit
>>> s = """\
... try:
...     str.__nonzero__
... except AttributeError:
...     pass
... """
>>> t = timeit.Timer(stmt=s)
>>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
17.09 usec/pass
>>> s = """\
... if hasattr(str, '__nonzero__'): pass
... """
>>> t = timeit.Timer(stmt=s)
>>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
4.85 usec/pass
>>> s = """\
... try:
...     int.__nonzero__
... except AttributeError:
...     pass
... """
>>> t = timeit.Timer(stmt=s)
>>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
1.97 usec/pass
>>> s = """\
... if hasattr(int, '__nonzero__'): pass
... """
>>> t = timeit.Timer(stmt=s)
>>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
3.15 usec/pass
\end{verbatim}

定義した関数に \module{timeit} モジュールがアクセスできるように
するために、import 文の入った \code{setup} 引数を渡すことができます:

\begin{verbatim}
def test():
    "Stupid test function"
    L = []
    for i in range(100):
        L.append(i)

if __name__=='__main__':
    from timeit import Timer
    t = Timer("test()", "from __main__ import test")
    print t.timeit()
\end{verbatim}

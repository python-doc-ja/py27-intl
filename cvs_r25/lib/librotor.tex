\section{\module{rotor} ---
         エニグマ暗号機のような暗号化と復号化}

\declaremodule{builtin}{rotor}
\modulesynopsis{エニグマ暗号機のような暗号化と復号化。}

\deprecated{2.3}{この暗号化アルゴリズムは安全ではありません。}

このモジュールは Lance Ellinghouse\index{Ellinghouse, Lance} に
よって寄与されたロータによる暗号化アルゴリズムを実装しています。
この設計は第二次世界大戦中メッセージを暗号化するために用いられた
エニグマ暗号機からきたものです。ロータは単純に文字の入れ替えです。
例えば `A' をロータの起点とすると、このロータは `A' を `L' に、
`B' を `Z' に、`C' を `G' に、等に関連付けるでしょう。暗号化
を行うためには、複数の異なるロータを選び、ロータの起点を既知の
位置に設定します; それらの初期位置が暗号化の鍵となります。
文字を暗号化するには、原文の文字を最初のロータによって入れ替え、
次にその結果を二つ目のロータで入れ替えます。そして全てのロータ
で入れ替え終わるまでこれを続けます。結果として得られた文字が
暗号文になります。次に最終段ロータの起点位置を一つだけずらし、
`A' を `B' にします; 最終段ロータの起点位置が完全に一周したら、
最終段から 2 段目のロータを一つだけずらし、同じ手続きを再帰的に
繰り返します。別の言い方をすれば、一つの文字を暗号化した後は、
ロータを車の距離計と同じ要領で一つ進めるということです。
復号化の作業も同様です。ただし、置き換えを反転し、操作を逆に
行います。
\indexii{Enigma}{cipher}

個のモジュールで利用可能な関数は以下のとおりです:

\begin{funcdesc}{newrotor}{key\optional{, numrotors}}
ロータオブジェクトを返します \var{key} はロータオブジェクトの
暗号化キー文字列です; ヌル文字以外の任意のバイナリデータを含む
ことができます。暗号化キーはロータの置き換え順列をランダムに
生成し、初期位置を決めるために使われます。\var{numrotors} は
返されるロータオブジェクト中におけるロータ置き換えの数です。
省略される場合、標準の値として 6 が使われます。
\end{funcdesc}

ロータオブジェクトは以下のメソッドを持っています:

\begin{methoddesc}[rotor]{setkey}{key}
ロータの暗号化キーを \var{key} にします、暗号化キーにヌル文字を入れては
いけません。
\end{methoddesc}

\begin{methoddesc}[rotor]{encrypt}{plaintext}
ロータオブジェクトを初期状態に再初期化し、\var{plaintext} 
を暗号化して、暗号文を含む文字列を返します。暗号文は常に
もとの平文と同じ長さになります。
\end{methoddesc}

\begin{methoddesc}[rotor]{encryptmore}{plaintext}
ロータオブジェクトを再初期化せずに \var{plaintext} を暗号化し、
暗号文を含む文字列を返します。
\end{methoddesc}

\begin{methoddesc}[rotor]{decrypt}{ciphertext}
ロータオブジェクトを初期状態に再初期化し、\var{ciphertext} 
を復号化して、平文を含む文字列を返します。平文は常に
暗号文と同じ長さになります。
\end{methoddesc}

\begin{methoddesc}[rotor]{decryptmore}{ciphertext}
ロータオブジェクトを再初期化せずに \var{ciphertext} を復号化し、
平文を含む文字列を返します。
\end{methoddesc}

利用法の例:
\begin{verbatim}
>>> import rotor
>>> rt = rotor.newrotor('key', 12)
>>> rt.encrypt('bar')
'\xab4\xf3'
>>> rt.encryptmore('bar')
'\xef\xfd$'
>>> rt.encrypt('bar')
'\xab4\xf3'
>>> rt.decrypt('\xab4\xf3')
'bar'
>>> rt.decryptmore('\xef\xfd$')
'bar'
>>> rt.decrypt('\xef\xfd$')
'l(\xcd'
>>> del rt
\end{verbatim}

このモジュールのコードはオリジナルのエニグマ暗号機の厳密な
シミュレーションではありません; これはオリジナルのロータ暗号化
手続きを異なる方法で実装しています。
オリジナルのエニグマとの最も重要な違いは、エニグマでは異なる
ロータは実際には 5 から 6 個しか存在せず、一文字あたり 2 回づつ
ロータを適用していたことです; 暗号化キーはロータを暗号機に
配置する順番でした。Python の \module{rotor} モジュールでは、
与えられたキーはまず乱数生成器を初期化するために使います;
次にロータの順列およびその初期位置がランダムに決定されます。
オリジナルの暗号機ではアルファベット文字だけを暗号化していたのに
対し、このモジュールは 8 ビットの任意のバイナリデータを扱う
ことができ、またバイナリ出力を生成します。このモジュールは
また、任意の数のロータを扱うことができます。

オリジナルのエニグマ暗号は 1944 年に解読されました。 % XXX: Is this right?
ここで実装されているバージョンを解読するのは、おそらくそれよりかなり
困難ですが、非常に高い技術を持ち、確信犯の攻撃者が暗号を解読するのは
不可能ではありません。従って、NSA からあなたのファイルを守りたいと
思うなら、このロータ暗号は全く安全とはいえませんが、行きずりの来訪者
にあなたのファイルを覗き見する気力を無くさせるためにはおそらくちょうど
よいでしょう。そして \UNIX{} の \program{crypt} コマンドを使うよりも
やや安全かもしれません。
\index{NSA}
\index{National Security Agency}








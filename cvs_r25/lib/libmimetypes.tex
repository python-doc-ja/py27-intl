\section{\module{mimetypes} ---
         ファイル名を MIME 型へマップする}

\declaremodule{standard}{mimetypes}
\modulesynopsis{Mapping of filename extensions to MIME types.}
\modulesynopsis{ファイル名拡張子の MIME 型へのマッピング。}
\sectionauthor{Fred L. Drake, Jr.}{fdrake@acm.org}


\indexii{MIME}{content type}

 \module{mimetypes} モジュールは、ファイル名あるいは URL と、ファイル名拡張子に
 関連付けられた MIME 型とを変換します。ファイル名から MIME 型へと、
 MIME 型からファイル名拡張子への変換が提供されます；
 後者の変換では符号化方式はサポートされていません。

このモジュールは、一つのクラスと多くの便利な関数を提供します。
これらの関数がこのモジュールへの標準のインターフェースですが、
アプリケーションによっては、そのクラスにも関係するかもしれません。

以下で説明されている関数は、このモジュールへの主要なインターフェースを
提供します。たとえモジュールが初期化されていなくても、もしこれらの関数が、
\function{init()} がセットアップする情報に依存していれば、これらの関数は、
\function{init()} を呼びます。

\begin{funcdesc}{guess_type}{filename\optional{, strict}}
\var{filename} で与えられるファイル名あるいは URL に基づいて、
ファイルの型を推定します。戻り値は、タプル \code{(\var{type},
\var{encoding})} です、ここで  \var{type}は、
もし型が(拡張子がないあるいは未定義のため)推定できない場合は、
 \code{None} を、あるいは、
MIME \mailheader{content-type} ヘッダ \indexii{MIME}{headers}
に利用できる、\code{'\var{type}/\var{subtype}'}の形の文字列です。

\var{encoding} は、符合化方式がない場合は \code{None} を、あるいは、
符号化に使われるプログラムの名前
(たとえば、\program{compress} あるいは \program{gzip})です。
符号化方式は  \mailheader{Content-Encoding}ヘッダとして
使うのに適しており、
 \mailheader{Content-Transfer-Encoding} ヘッダには適して\emph{いません}。
 マッピングはテーブルドリブンです。符号化方式のサフィックスは大/小文字を区別します;
 データ型サフィックスは、最初大/小文字を区別して試し、
 それから大/小文字を区別せずに試します。

省略可能な \var{strict}は、既知の MIME 型のリストとして認識されるものが、
 \ulink{IANAとして登録された}{http://www.isi.edu/in-notes/iana/assignments/media-types}
正式な型のみに限定されるかどうかを指定するフラグです。
 \var{strict} が true (デフォール)の時は、IANA 型のみがサポートされます;
\var{strict} が false のときは、いくつかの追加の、非標準ではあるが、一般的に
使用される MIME 型も認識されます。
\end{funcdesc}

\begin{funcdesc}{guess_all_extensions}{type\optional{, strict}}
\var{type} で与えられる MIME 型に基づいてファイルの拡張子を推定します。
戻り値は、先頭のドット (\character{.})を含む、可能なファイル拡張子すべてを
与える文字列のリストです。拡張子と特別なデータストリームとの関連付けは
保証されませんが、
 \function{guess_type()}によって MIME型 \var{type} とマップされます。

省略可能な \var{strict} は \function{guess_type()} 関数のものと同じ意味を持ちます。
\end{funcdesc}

\begin{funcdesc}{guess_extension}{type\optional{, strict}}
\var{type} で与えられる MIME 型に基づいてファイルの拡張子を推定します。
戻り値は、先頭のドット (\character{.})を含む、ファイル拡張子を
与える文字列のリストです。拡張子と特別なデータストリームとの関連付けは
保証されませんが、
 \function{guess_type()}によって MIME型 \var{type} とマップされます。
 もし \var{type}に対して拡張子が推定できない場合は、 \code{None}が返されます。

省略可能な \var{strict} は \function{guess_type()} 関数のものと同じ意味を持ちます。
\end{funcdesc}


モジュールの動作を制御するために、いくつかの追加の関数とデータ項目が
利用できます。

\begin{funcdesc}{init}{\optional{files}}
内部のデータ構造を初期化します。
もし  \var{files} が与えられていれば、これはデフォールトの型のマップを
増やすために使われる、一連のファイル名でなければなりません。
もし省略されていれば、使われるファイル名は \constant{knownfiles}から
取られます。\var{file} あるいは \constant{knownfiles} 内の各ファイル名は、
それ以前に現れる名前より優先されます。
繰り返し \function{init()} を呼び出すことは許されています。
\end{funcdesc}

\begin{funcdesc}{read_mime_types}{filename}
ファル \var{filename} で与えられた型のマップが、もしあればロードします。
型のマップは、先頭の dot (\character{.}) を含むファイル名拡張子を、
\code{'\var{type}/\var{subtype}'}の形の文字列にマッピングする辞書として返されます。
もしファイル \var{filename} が存在しないか、読み込めなければ、
\code{None} が返されます。
\end{funcdesc}


\begin{funcdesc}{add_type}{type, ext\optional{, strict}}
mime型 \var{type} からのマッピングを拡張子 \var{ext} に追加します。
拡張子がすでに既知であれば、新しい型が古いものに置き替わります。
その型がすでに既知であれば、その拡張子が、既知の拡張子のリストに追加されます。

\var{strict}がある時は、そのマッピングは正式なMIME型に、
そうでなければ、非標準のMIME型に追加されます。
\end{funcdesc}


\begin{datadesc}{inited}
グローバルなデータ構造が初期化されているかどうかを示すフラグ。
これは \function{init()} により true に設定されます。
\end{datadesc}

\begin{datadesc}{knownfiles}
共通にインストールされた型マップファイル名のリスト。これらの
ファイルは、普通 \file{mime.types}という名前であり、パッケージごとに
異なる場所にインストールされます。\index{file!mime.types}
\end{datadesc}

\begin{datadesc}{suffix_map}
サフィックスをサフィックスにマップする辞書。これは、符号化方式と
型が同一拡張子で示される符号化ファイルが認識できるように
使用されます。例えば、\file{.tgz} 拡張子は、符号化と型が別個に
認識できるように \file{.tar.gz}にマップされます。
\end{datadesc}

\begin{datadesc}{encodings_map}
ファイル名拡張子を符号化方式型にマッピングする辞書
\end{datadesc}

\begin{datadesc}{types_map}
ファイル名拡張子をMIME型にマップする辞書
\end{datadesc}

\begin{datadesc}{common_types}
ファイル名拡張子を非標準ではあるが、一般に使われているMIME型に
マップする辞書
\end{datadesc}


 \class{MimeTypes} クラスは、1つ以上のMIME-型 データベースを
 必要とするアプリケーションに役に立つでしょう。

\begin{classdesc}{MimeTypes}{\optional{filenames}}
このクラスは、MIME-型データベースを表現します。デフォールトでは、
このモジュールの他のものと同じデータベースへのアクセスを提供します。
初期データベースは、このモジュールによって提供されるもののコピーで、
追加の \file{mime.types}-形式のファイルを、\method{read()} あるいは \method{readfp()}
メソッドを使って、データベースにロードすることで拡張されます。
マッピング辞書も、もしデフォールトのデータが望むものでなければ、
追加のデータをロードする前にクリアされます。

省略可能な \var{filenames}パラメータは、追加のファイルを、デフォールト
データベースの"トップに"ロードさせるのに使うことができます。

  \versionadded{2.2}
\end{classdesc}

モジュールの使用例:

\begin{verbatim}
>>> import mimetypes
>>> mimetypes.init()
>>> mimetypes.knownfiles
['/etc/mime.types', '/etc/httpd/mime.types', ... ]
>>> mimetypes.suffix_map['.tgz']
'.tar.gz'
>>> mimetypes.encodings_map['.gz']
'gzip'
>>> mimetypes.types_map['.tgz']
'application/x-tar-gz'
\end{verbatim}


\subsection{Mime型 オブジェクト \label{mimetypes-objects}}

\class{MimeTypes} インスタンスは、\refmodule{mimetypes} モジュールの
それと非常によく似たインターフェースを提供します。

\begin{datadesc}{suffix_map}
サフィックスをサフィックスにマップする辞書。これは、符号化方式と
型が同一拡張子で示されるような符号化ファイルが認識できるように
使用されます。例えば、\file{.tgz} 拡張子は、符号化方式と型が別個に
認識できるように \file{.tar.gz}に対応づけられます。
これは、最初はモジュールで定義されたグローバルな \code{suffix_map} の
コピーです。
\end{datadesc}

\begin{datadesc}{encodings_map}
ファイル名拡張子を符号化型にマッピングする辞書。
これは、最初はモジュールで定義されたグローバルな \code{encodings_map} の
コピーです。
\end{datadesc}

\begin{datadesc}{types_map}
ファイル名拡張子をMIME型にマッピングするる辞書。
これは、最初はモジュールで定義されたグローバルな \code{types_map} の
コピーです。
\end{datadesc}

\begin{datadesc}{common_types}
ファイル名拡張子を非標準ではあるが、一般に使われているMIME型にマップする辞書。 これは、最初はモジュールで定義されたグローバルな \code{common_types} の
コピーです。
\end{datadesc}

\begin{methoddesc}{guess_extension}{type\optional{, strict}}
   \function{guess_extension()} 関数と同様に、オブジェクトの
   一部として保存されたテーブルを使用します。
\end{methoddesc}

\begin{methoddesc}{guess_type}{url\optional{, strict}}
   \function{guess_type()} 関数と同様に、オブジェクトの
 一部として保存されたテーブルを使用します。
\end{methoddesc}

\begin{methoddesc}{read}{path}
 MIME情報を、\var{path}という名のファイルからロードします。
 これはファイルを解析するのに \method{readfp()} を使用します。
\end{methoddesc}

\begin{methoddesc}{readfp}{file}
 MIME型情報を、オープンしたファイルからロードします。
 ファイルは、標準の \file{mime.types} ファイルの形式でなければなりません。
\end{methoddesc}

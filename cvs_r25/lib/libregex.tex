\section{\module{regex} ---
         正規表現操作}
\declaremodule{builtin}{regex}

\modulesynopsis{正規表現検索とマッチ操作。
                \strong{廃止!}}


このモジュールは、Emacs でのものと同様な正規表現マッチング操作を
提供します。

\strong{廃止 注:}
このモジュールは Python バージョン 1.5 のものとして廃止されています；
多くの既存のコードがこれをまだ使っているので保守されています。正規表現を
必要とする新しいコードは、すべて新しい \code{re}\refstmodindex{re} モジュールを
使うべきです。それはより強力で、正式な Perl スタイルの正規表現をサポートしています。
既存のコードは変換すべきです。標準ライブラリモジュール
\code{reconvert}\refstmodindex{reconvert} を使うと、
\code{regex} スタイル の正規表現を \code{re}\refstmodindex{re} スタイルの正規表現に変換するのに
役立ちます。(変換に関するこれ以上のヘルプについては、
 Andrew Kuchling の\index{Kuchling, Andrew}
\url{http://www.python.org/doc/howto/regex-to-re/}での
 ``\module{regex-to-re} HOWTO'' を見て下さい )。

デフォールトでは、パターンは(一つ例外がありますが) Emacs スタイルの正規表現
です。そのシンタックスを、幾つかのよく知られた \UNIX{}ユーティリティの
ものとマッチするように変更することもできます。その例外は、Emacs の \samp{\e s}
パターンがサポートされていないことです、というのは、
本来の実装では、これが Emacs のシンタックス表を
参照しているからです。

このモジュールは 8-ビット対応です：パターンも文字列も、ともにヌルバイトや
その高位ビットがセットされている文字を含むことができます。

\strong{注意して下さい：} Python の文字列リテラルには、
たとえバックスラッシュが文字列リテラル内や
正規表現内の特殊文字をエスケープするために
使われていたとしても、バックスラッシュを
2重化することを心配する必要がないという
ほとんど知られていない事実があります。
\emph{しかし}、もしリテラルの \dfn{バックスラッシュ}を、
文字列リテラルとして表現された正規表現に含めたいのであれば、それを
\emph{4重}にするか、それをシングルトン文字クラスに閉じ込めなければなりません。
例えば\  \LaTeX\ \samp{\e section\{\textrm{\ldots}\}} ヘッダを
文書から抽出するには、このパターン：
\code{'[\e ]section\{\e (.*\e )\}'} を使うことができます。\emph{別の例外：}
エスケープシーケンス \samp{\e b} は、文字列リテラル
(その場合は ASCII のベル文字を意味します )でも、
Emacs 正規表現(その場合は 単語境界を表します)でも重要ですが、単語境界を
探すには、 パターン \code{'\e \e b'} を使わなければなりません。
同様に、数字の 0-7 が後に続くバックスラッシュは、8進エスケープとして解釈するのを
防ぐために、2重にしなければなりません。

\subsection{正規表現}

正規表現(すなわち RE) は、それとマッチする文字列の集合を指定します；
このモジュールの関数によって、特別な文字列が与えられた正規表現と
マッチするかどうか(あるいは、与えられた正規表現が特別な文字列と
マッチするかどうか、これらは同じことになりますが)を検査することができます。

正規表現は、新しい正規表現を作るために連結することができます；
もし \emph{A} と \emph{B}が、ともに正規表現であれば、
\emph{AB} もまた正規表現です。もし文字列 \emph{p} が A とマッチし、
文字列 \emph{q} が B とマッチすれば、文字列 \emph{pq} は、AB と
マッチするでしょう。こうして、複雑な表現は、ここで述べたようなプリミティブな、
より簡単なものから容易に構築することができます。正規表現の
理論と実装の詳細については、コンパイラー構造に関する、ほとんどの教科書に
当たって下さい。

% XXX 参照はもっと明確にすることもできるかも知れません、たとえば
% Alfred V. Aho、Ravi Sethi および Jeffrey D. Ullman による
%"Compilers: Principles, Techniques and Tools"(和訳  コンパイラ)、あるいは FA テキスト。

以下に正規表現のフォーマットの簡単な説明を行います。

正規表現は、特殊文字と通常文字の両方を含むことができます。
'\code{A}'、 '\code{a}' あるいは '\code{0}'のような通常文字は、
もっとも簡単な正規表現です；それらは単純にそれら自身とマッチします。
通常文字は連結することができるので、 '\code{last}'は文字 'last'と
マッチします。(このセクションの残りでは、REを
\code{この特別なフォント}のように、普通は引用符なしで、
マッチされる文字列は'単一引用符'内に書きます)。

特殊文字は、通常文字のクラスを表すか、あるいは正規表現が、
どのように解釈されるかを制御します。

特殊文字は：
\begin{itemize}
\item[\code{.}] (ドット。)  改行以外の任意の文字とマッチします。
\item[\code{\^}] (キャレット。)  文字列の先頭とマッチします。
\item[\code{\$}] 文字列の末尾とマッチします。
\code{foo} は、'foo' と'foobar'のどちらにもマッチしますが、一方
正規表現 '\code{foo\$}' は、'foo' だけとマッチします。
\item[\code{*}] 結果の RE を、前にある RE の 0 回以上の繰り返しと
マッチするようにします。 \code{ab*} は、
'a'、'ab' あるいは 任意個数の 'b' が続いた 'a' とマッチするようにします。
\item[\code{+}] 結果の RE を、前にある RE の1回以上の繰り返しと
マッチするようにします。
\code{ab+} は、非ゼロ個以上の 'b' が続く'a' とマッチします；これは
単なる'a'とはマッチしません。
\item[\code{?}] 結果の RE を、前にある RE の0 あるいは 1回の繰り返しと
マッチするようにします。 \code{ab?} は、
'a' あるいは 'ab' とマッチします。

\item[\code{\e}] ('*?+\&\$'のような文字とのマッチを許しながら)、
特殊文字をエスケープするか、あるいは特殊シーケンスを知らせます；
特殊シーケンスは後で議論します。Python はバックスラッシュを文字列リテラルの
エスケープシーケンスとしても使用していることを忘れないで下さい；もし
エスケープシーケンスが、Pyhon のパーザに認識されなければ、そのバックスラッシュと
それに続く文字は、結果の文字列にそのまま含まれます。しかし、
もし Python が結果のシーケンスを認識するのであれば、バックスラッシュは
2回繰り返されなければなりません。

\item[\code{[]}] 文字の集合を示すのに使われます。文字は
個別にリストするか、2つの文字とそれらを分離する '-' を与えて、
範囲で指定できます。特殊文字は、集合内では
有効ではありません。例えば、\code{[akm\$]} は、
文字 'a', 'k', 'm' あるいは '\$'のどれかとマッチします。;
\code{[a-z]} は、任意の小文字とマッチします。

もし集合内に \code{]} を含めたいなら、それはその集合の最初の文字で
なければなりません； \code{-}を含めたいのなら、それを最初あるいは最後の
文字とします。

範囲内に\emph{ない}文字は、その集合の最初の文字として \code{\^}を
含めることでマッチさせることができます；それ以外の場所にある \code{\^} は、
単純に '\code{\^}' 文字とマッチします。
\end{itemize}

特殊シーケンスは、 '\code{\e}' と、以下のリストにある文字から
構成されます。もしそのリストにない通常文字であれば、
結果の RE は、2番目の文字とマッチします。例えば、
\code{\e\$} は、文字 '\$' とマッチします。文字列リテラルで、
バックスラッシュを2重にしなければならないものについては 指示しています。

 \begin{itemize}
\item[\code{\e|}] \code{A\e|B}、ここでA とB は、任意のRE ですが、
A または B とマッチする正規表現を作成します。これは、
グループ(以下を見て下さい)内でも使うことができます。
%
\item[\code{\e( \e)}] グループの先頭と末尾を示します；
グループの中身は、次で説明する \code{\e [1-9]} 特殊シーケンスを
使った文字列で、後でマッチすることができます。
\end{itemize}

\begin{fulllineitems}
\item[\code{\e \e 1, ... \e \e 7, \e 8, \e 9}]
同じ番号のグループの中身とマッチします。例えば、
\code{\e (.+\e ) \e \e 1}は 'the the' あるいは '55 55' とマッチしますが、
'the end'とはマッチしません(グループの後ろの空白に注意して下さい)。この特殊
シーケンスを使うと、最初の 9グループの一つだけとマッチすることができます；
それ以上の番号を持つグループは、\code{\e v}シーケンスを使って
マッチすることができます(\code{\e 8} と \code{\e 9} は、8進数字ではないので、
バックスラッシュを2重にする必要はありません)。
\end{fulllineitems}

\begin{itemize}
\item[\code{\e \e b}] 空文字列とマッチしますが、単語の
先頭と末尾でだけです。単語は、一連の英数文字として
定義されていますので、単語の末尾は、空白あるいは非英数文字
で示されます。
%
\item[\code{\e B}] 空白文字とマッチしますが、それが単語の先頭あるいは
末尾に\emph{ない}時です。
%
\item[\code{\e v}] 2桁の数字が続かなければなりません。そして、同じ
番号のグループの中身とマッチします。グループ番号は、 1 と 99 を含んで、
その間でなければなりません。
%
\item[\code{\e w}] 任意の英数文字とマッチします；これは
集合 \code{[a-zA-Z0-9]}と同じ意味です。
%
\item[\code{\e W}] 任意の非英数文字とマッチします；これは
集合 \code{[\^a-zA-Z0-9]} と同じ意味です。
\item[\code{\e <}] 空文字列とマッチしますが、単語の先頭だけ
です。単語は一連の英数文字として定義されていますので、
単語の末尾は空白あるいは
非英数文字で示されます。
\item[\code{\e >}] 空文字列とマッチしますが、単語の末尾だけ
です。

\item[\code{\e \e \e \e}] リテラルのバックスラッシュとマッチします。

% Emacs では、以下の2つはバッファの開始/バッファの終了です。
% Python では、これらは ^$ の同意語とみなされます。
\item[\code{\e `}] \code{\^}と同じですが、これは文字列の先頭でだけ
マッチします。
\item[\code{\e \e '}] {\$} と同じですが、これは文字列の末尾でだけ
マッチします。
% バッファの終了
\end{itemize}

\subsection{モジュール 内容}
\nodename{モジュール regex の内容}

このモジュールは、以下の関数と例外を定義します：


\begin{funcdesc}{match}{pattern, string}
   \var{string}の先頭から、どれだけの文字が正規表現 \var{pattern}と
   マッチするかを返します。もし文字列がパターンとマッチしなければ、
   \code{-1}を返します(これは
   ゼロ長さマッチとは違います!)。
\end{funcdesc}

\begin{funcdesc}{search}{pattern, string}
  正規表現 \var{pattern}とマッチする、\var{string}内の最初の位置を
  返します。もし文字列に、パターンとマッチする位置がなければ、
  \code{-1}を返します(これは、どこかでの
  ゼロ長さマッチとは違います!)。
\end{funcdesc}

\begin{funcdesc}{compile}{pattern\optional{, translate}}
  正規表現のパターンを正規表現オブジェクトにコンパイルします。正規表現
  オブジェクトは、以下で説明する  \code{match()} や \code{search()}
  メソッドを使って、マッチングに使うことができます。
   省略可能な引数 \var{translate}は、もしあれば、(パターンとマッチされる
   文字列の両方の)文字が、それらを比較する前にどのように変換されるかを
   示す 256文字の文字列でなければなりません；文字列の
  \var{i}-番目の要素は、\ASCII{} code \var{i}を持つ文字に対する変換を
  与えます。これは、大文字・小文字を区別するマッチングを実装するのに
  使うことができます；以下の \code{casefold} データ項目を見て下さい。

  シーケンス

\begin{verbatim}
prog = regex.compile(pat)
result = prog.match(str)
\end{verbatim}
%
は、

\begin{verbatim}
result = regex.match(pat, str)
\end{verbatim}

と同じ意味ですが、\code{compile()}を使うバージョンの方が、複数の
正規表現が、一つのプログラム内で同時に使われている時には、より
効率的です(\code{regex.match()} あるいは \code{regex.search()}へ渡す最後の
 パターンをコンパイルするバージョンはキャッシュされますので、一度に
 単一の正規表現しか使用しないプログラムでは、正規表現をコンパイルする
 ことについて心配する必要はありません)。
\end{funcdesc}

\begin{funcdesc}{set_syntax}{flags}
  \code{compile()}、\code{match()} および \code{search()}へのこれ以降の呼び出しで
  使用されるシンタックスを設定します(既にコンパイルされた正規表現オブジェクト
  には影響しません)。引数は、いくつかのフラグビットを
  OR したる整数です。戻り値は、シンタックスフラグの
  以前の値です。フラグの名前は、標準モジュール
  \code{regex_syntax}\refstmodindex{regex_syntax}で定義されています；
  これ以上の説明については、ファイル \file{regex_syntax.py} を読んで下さい。
\end{funcdesc}

\begin{funcdesc}{get_syntax}{}
  シンタックスフラグの現在の値を整数として返します。
\end{funcdesc}

\begin{funcdesc}{symcomp}{pattern\optional{, translate}}
これは \code{compile()}と似ていますが、記号グループ名をサポートします：もし
丸括弧で囲まれたグループが、かぎ括弧で囲まれたグループ名で始まっていれば、
たとえば、\code{'\e(<id>[a-z][a-z0-9]*\e)'}のグループは、結果のコンパイル
された正規表現オブジェクトの \code{group()} メソッドへの引数として、その名前を:
\code{p.group('id')}のように参照することができます。
グループ名には英数文字と \code{'_'} だけを
含むことができます。
\end{funcdesc}

\begin{excdesc}{error}
  ここでの関数のどれかへ渡された文字列が、有効な正規表現でない時
  (たとえば、対応が取れていない括弧)、あるいは、
  コンパイル中やマッチング中に、他のエラーが起こった時、発生する例外です
  (文字列にパターンへのマッチが含まれていないというのは、 決してエラーではありません)。
\end{excdesc}

\begin{datadesc}{casefold}
すべての大文字をそれらの小文字と対応づけるために、
\code{compile()}への \var{translate} 引数として渡すのに
適した文字列です。
 \end{datadesc}

\noindent
コンパイルされた正規表現オブジェクトは以下のメソッドをサポートします：

\setindexsubitem{(regex method)}
\begin{funcdesc}{match}{string\optional{, pos}}
   \var{string} の先頭から、どれだけの文字がコンパイルした正規表現と
   マッチするかを返します。もし文字列がパターンとマッチしなければ
  \code{-1}を返します(これはゼロ長さマッチとは
  異なります!)。

  省略可能な2番目のパラメータ \var{pos} は、文字列内で、
  検索を始める位置を与えます；それはデフォールトでは \code{0}です。これは、
  文字列のスライシングと完全に同じ意味というわけではありません；
  \code{'\^'} パターン文字は、文字列の実際の先頭と改行の直後で
  マッチしますが、検索が開始するインデックス位置とは、必ずしも
  マッチしません。
\end{funcdesc}

\begin{funcdesc}{search}{string\optional{, pos}}
  \var{string} 内で、正規表現 \code{pattern} とマッチする最初の位置を
  返します。もしどの文字列もパターンとマッチしなければ、\code{-1}を
  返します(これは、どこかでゼロ長さマッチすることとは
  違います!)。

  省略可能な2番目のパラメータは、\code{match()} メソッドのものと
  同じ意味を持ちます。
\end{funcdesc}

\begin{funcdesc}{group}{index, index, ...}
このメソッドは、\code{match()}あるいは \code{search()} メソッドへの
最後の呼び出しでマッチが見つかった時だけ有効です。これはマッチ
した1個以上のグループを返します。もし  \var{index} 引数が1つだけなら、
その結果は単一の文字列です；もし引数が複数であれば、
その結果は引数ごとに1項目を持つタプルです。もし \var{index} がゼロであれば、
対応する戻り値はマッチした文字列全体です；もしそれが範囲 [1..99] 内にあれば、
それは対応する括弧で囲まれたグループ(デフォールトのシンタックスを使うと、グループは、
\code{{\e}(} と \code{{\e})}を使って括弧で囲まれます)とマッチする
文字列です。もしそのようなグループが存在しなければ、対応する結果は
\code{None}です。

もし正規表現が \code{compile()} の代わりに、\code{symcomp()} でコンパイルされたら、
\var{index} 引数は、それらのグループ名でグループを識別するような
文字列でも構いません。
\end{funcdesc}

\noindent
コンパイルされた正規表現は以下のデータ属性をサポートします：

\setindexsubitem{(regex 属性)}

\begin{datadesc}{regs}
これは、 \code{match()} あるいは \code{search()} メソッドへの最後の呼び出しが
マッチを見つけた時、パターン内の括弧に囲まれたすべてのグループの
開始と終了に対応するインデックスのペアのタプルとなります。インデックスは、
\code{match()} あるいは \code{search()}へ渡された文字列引数の
ものです。 0 番目のタプルは、パターン全体の開始と終了を与えます。
最後のマッチあるいは検索が失敗した時は、
これは \code{Node} です。
\end{datadesc}

\begin{datadesc}{last}
これは、 \code{match()} あるいは \code{search()} メソッドへの最後の呼び出しが
マッチを見つけた時、そのメソッドに渡された文字列引数です。
最後のマッチあるいは検索が失敗した時は、これは \code{Node} です。
\end{datadesc}

\begin{datadesc}{translate}
これは、この正規表現オブジェクトを生成した\code{regex.compile()}への
\var{translate} 引数の値です。もし\var{translate} 引数が
\code{regex.compile()}呼び出しで省略されていたら、
これは \code{None}です。
\end{datadesc}

\begin{datadesc}{givenpat}
\code{compile()} あるいは \code{symcomp()}へ渡された正規表現パターン
です。
\end{datadesc}

\begin{datadesc}{realpat}
\code{symcomp()}を使ってコンパイルされた正規表現のグループ名を
はがした後の正規表現です。その他は \code{givenpart}と
同じです。
\end{datadesc}

\begin{datadesc}{groupindex}
\code{symcomp()}を使ってコンパイルされた正規表現への、
記号グループ名から数値グループインデックスへの対応付けを与える辞書です。
そうでなければ \code{None} です。
\end{datadesc}

\section{\module{multifile} ---
         個別の部分を含んだファイル群のサポート}

\declaremodule{standard}{multifile}
\modulesynopsis{MIME データのような、個別の部分を含んだファイル群に対する
読み出しのサポート。}
\sectionauthor{Eric S. Raymond}{esr@snark.thyrsus.com}

\deprecated{2.5}{\module{multifile}モジュールよりも 
                \refmodule{email} パッケージを使うべきです。
                 このモジュールは後方互換性のためだけに存在しています。}


\class{MultiFile} オブジェクトはテキストファイルを区分したものを
ファイル類似の入力オブジェクトとして扱えるようにし、指定した区切り文字
(delimiter) パタンに遭遇した際に \code{''} が返されるようにします。
このクラスの標準設定は MIME マルチパートメッセージを解釈する上で
便利となるように設計されていますが、サブクラス化を行って幾つかの
メソッドを上書きすることで、簡単に汎用目的に対応させることができます。
ます。

\begin{classdesc}{MultiFile}{fp\optional{, seekable}}
マルチファイル (multi-file) を生成します。このクラスは
\function{open()} が返すファイルオブジェクトのような、
\class{MultiFile} インスタンスが行データを取得するための
入力となるオブジェクトを引数としてインスタンス化を
行わなければなりません。

\class{MultiFile} は入力オブジェクトの \method{readline()} 、
\method{seek()}、および \method{tell()} メソッドしか参照せず、
後者の二つのメソッドは個々の MIME パートにランダムアクセスしたい
場合にのみ必要です。\class{MultiFile} を seek できないストリーム
オブジェクトで使うには、オプションの \var{seekable} 引数の値を
偽にしてください; これにより、入力オブジェクトの \method{seek()}
および \method{tail()} メソッドを使わないようになります。
\end{classdesc}

\class{MultiFile} の視点から見ると、テキストは三種類の行データ:
データ、セクション分割子、終了マーカ、からなることを知っていると
約に立つでしょう。MultiFile は、多重入れ子構造になっている可能性
のある、それぞれが独自のセクション分割子および終了マーカのパターン
を持つメッセージパートをサポートするように設計されています。

\begin{seealso}
  \seemodule{email}{網羅的な電子メイル操作パッケージ; 
\module{multifile} モジュールに取って代わります。}
\end{seealso}


\subsection{MultiFile オブジェクト \label{MultiFile-objects}}

\class{MultiFile} インスタンスには以下のメソッドがあります:

\begin{methoddesc}{readline}{str}
一行データを読みます。その行が (セクション分割子や終了マーカや本物の
EOF でない) データの場合、行データを返します。その行がもっとも最近
スタックにプッシュされた境界パターンにマッチした場合、\code{''} を返し、
マッチした内容が終了マーカかそうでないかによって \code{self.last} を
1 か 0 に設定します。行がその他のスタックされている境界パターンにマッチ
した場合、エラーが送出されます。背後のストリームオブジェクトにおける
ファイルの終端に到達した場合、全ての境界がスタックから除去されていない
限りこのメソッドは \exception{Error} を送出します。
\end{methoddesc}

\begin{methoddesc}{readlines}{str}
このパートの残りの全ての行を文字列のリストとして返します。
\end{methoddesc}

\begin{methoddesc}{read}{}
次のセクションまでの全ての行を読みます。読んだ内容を単一の
(複数行にわたる) 文字列として返します。このメソッドには
size 引数をとらないので注意してください！
\end{methoddesc}

\begin{methoddesc}{seek}{pos\optional{, whence}}
ファイルを seek します。seek する際のインデクスは現在のセクションの
開始位置からの相対位置になります。\var{pis} および \var{whence} 引数
はファイルの seek における引数と同じように解釈されます。
\end{methoddesc}

\begin{methoddesc}{tell}{}
現在のセクションの先頭に対して相対的なファイル位置を返します。
\end{methoddesc}

\begin{methoddesc}{next}{}
次のセクションまで行を読み飛ばします (すなわち、セクション分割子
または終了マーカが消費されるまで行データを読みます)。
次のセクションがあった場合には真を、終了マーカが発見された場合
には偽を返します。最も最近スタックにプッシュされた境界パターンを
最有効化します。
\end{methoddesc}

\begin{methoddesc}{is_data}{str}
\var{str} がデータの場合に真を返し、セクション分割子の可能性がある
場合には偽を返します。このメソッドは行の先頭が (全ての MIME 境界が
持っている) \code{'-}\code{-'} 以外になっているかを調べるように
実装されていますが、導出クラスで上書きできるように宣言されています。

このテストは実際の境界テストにおいて高速性を保つために使われて
いるので注意してください; このテストが常に false を返す場合、
テストが失敗するのではなく、単に処理が遅くなるだけです。
\end{methoddesc}

\begin{methoddesc}{push}{str}
境界文字列をスタックにプッシュします。この境界文字列の修飾された
バージョンが入力行に見つかった場合、セクション分割子
または終了マーカであると解釈されます(どちらであるかは修飾に依存します。
\rfc{2045}を参照してください)。それ以降の全てのデータ読み出し
は、\method{pop()} を呼んで境界文字列を除去するか、\method{next()} 
を呼んで境界文字列を再有効化しないかぎり、ファイル終端を示す空文字列を
返します。

一つ以上の境界をプッシュすることは可能です。もっとも最近プッシュされた
境界に遭遇すると EOF が返ります; その他の境界に遭遇するとエラーが
送出されます。
\end{methoddesc}

\begin{methoddesc}{pop}{}
セクション境界をポップします。この境界はもはや EOF として解釈
されません。
\end{methoddesc}

\begin{methoddesc}{section_divider}{str}
境界をセクション分割子にします。標準では、このメソッドは
(全ての MIME 境界が持っている) \code{'-}\code{-'} を境界文字列の
先頭に追加しますが、これは導出クラスで上書きできるように宣言
されています。末尾の空白は無視されることから考えて、このメソッド
では LF や CR-LF を追加する必要はありません。
\end{methoddesc}

\begin{methoddesc}{end_marker}{str}
境界文字列を終了マーカ行にします。標準では、このメソッドは
(MIME マルチパートデータのメッセージ終了マーカのように) 
\code{'-}\code{-'} を境界文字列の先頭に追加し、かつ
\code{'-}\code{-'} を境界文字列の末尾に追加しますが、
これは導出クラスで上書きできるように宣言されています。
末尾の空白は無視されることから考えて、このメソッド
では LF や CR-LF を追加する必要はありません。
\end{methoddesc}

最後に、\class{MultiFile} インスタンスは二つの公開されたインスタンス
変数を持っています:

\begin{memberdesc}{level}
現在のパートにおける入れ子の深さです。
\end{memberdesc}

\begin{memberdesc}{last}
最後に見つかったファイル終了イベントがメッセージ終了マーカ
であった場合に真となります。
\end{memberdesc}


\subsection{\class{MultiFile} の例 \label{multifile-example}}
\sectionauthor{Skip Montanaro}{skip@mojam.com}

\begin{verbatim}
import mimetools
import multifile
import StringIO

def extract_mime_part_matching(stream, mimetype):
    """Return the first element in a multipart MIME message on stream
    matching mimetype."""

    msg = mimetools.Message(stream)
    msgtype = msg.gettype()
    params = msg.getplist()

    data = StringIO.StringIO()
    if msgtype[:10] == "multipart/":

        file = multifile.MultiFile(stream)
        file.push(msg.getparam("boundary"))
        while file.next():
            submsg = mimetools.Message(file)
            try:
                data = StringIO.StringIO()
                mimetools.decode(file, data, submsg.getencoding())
            except ValueError:
                continue
            if submsg.gettype() == mimetype:
                break
        file.pop()
    return data.getvalue()
\end{verbatim}

\chapter{字句解析\label{lexical}}

Python で書かれたプログラムは \emph{パーザ (parser)} に読み込まれます。
パーザへの入力は、\emph{字句解析器 (lexical analyzer)} によって生成
された一連の \emph{トークン (token)} からなります。この章では、字句解析器
がファイルをトークン列に分解する方法について解説します。
\index{lexical analysis}
\index{parser}
\index{token}

Python は 7-bit の \ASCII{} 文字セットをプログラムのテキストに
使います。
\versionadded[エンコード宣言を使って、文字列リテラルやコメントに
ASCII ではない文字セットが使われていることを明示できます。]{2.3}
以前のバージョンとの互換性のために、Python は 8-bit 文字が見つかっても
警告を出すだけにとどめます; こうした警告は、エンコーディングを明示
したり、バイナリデータの場合には文字ではなくエスケープシーケンス
を使うことで解決できます。


実行時の文字セットは、プログラムが接続されている I/O デバイスにもより
ますが、通常 \ASCII のサブセットです。

\strong{将来のバージョンとの互換性に関する注意:} 
8-bit 文字に対する文字セットを ISO Latin-1 (ラテン語系アルファベットを
用いるほとんどの西欧言語をカバーする\ASCII{} の上位セット) とみなし
たい気にもなるかもしれません。しかし、おそらく Unicode を編集できる
テキストエディタが将来一般的になるはずです。こうしたエディタでは
一般的に UTF-8 エンコードを使いますが、UTF-8 エンコードは \ASCII{}
の上位セットではあるものの、文字序数 (ordinal) 128-255 の扱いが
非常に異なります。この問題に関してはまだ合意が得られていませんが、
Latin-1 と UTF-8 のどちらかとみなすのは、たとえ現在の実装が Latin-1
びいきのように思えたとしても賢明とはいえません。これはソースコード
文字セットと実行時の文字セットのどちらにも該当します。


\section{行構造\label{line-structure}}

Python プログラムは多数の \emph{論理行 (logical lines)} に分割されます。
\index{line structure}


\subsection{論理行 (logical line)\label{logical}}

論理行の終端は、トークン NEWLINE で表されます。構文上許されている場合
(複合文: compound statement 中の実行文: statement) を除いて、実行文は
論理行間にまたがることはできません。
論理行は一行またはそれ以上の \emph{物理行(physical line)} からなり、
物理行の末尾には明示的または非明示的な \emph{行連結(line joining)} 
規則が続きます。
\index{logical line}
\index{physical line}
\index{line joining}
\index{NEWLINE token}


\subsection{物理行 (physical line)\label{physical}}

物理行とは、行終端コードで区切られた文字列のことです。
ソースコード内では、
各プラットフォームごとの標準の行終端コードを使用することができます。
\UNIX 形式では\ASCII{} LF (行送り: linefeed)文字、
Windows形式では\ASCII{} 配列の CR LF (復帰: return に続いて行送り) 、
Macintosh形式では\ASCII{} CR (復帰) 文字です。
これら全ての形式のコードは、
違うプラットフォームでも等しく使用することができます。

Pythonに埋め込む場合には、
標準のC言語の改行文字の変換規則
(\ASCII{} LFを表現した文字コード\code{\e n}が行終端となります)
に従って、
Python APIにソースコードを渡す必要があります。


\subsection{コメント\label{comments}}

コメントは文字列リテラル内に入っていないハッシュ文字 (\code{\#}) から
始まり、同じ物理行の末端で終わります。非明示的な行継続規則が適用されて
いない限り、コメントは論理行を終端させます。
コメントは構文上無視されます; コメントはトークンになりません。
\index{comment}
\index{hash character}


\subsection{エンコード宣言 (encoding declaration)\label{encodings}}
\index{source character set}
\index{encodings}

Python スクリプト中の最初の行か、二行目にあるコメントが正規表現
\regexp{coding[=:]\e s*([-\e w.]+)} にマッチする場合、コメントは
エンコード宣言 (encoding declaration) として処理されます;
表現に対する最初のマッチグループがソースコードファイルのエンコードを
指定します。エンコード宣言式として推奨する形式は、GNU Emacs が
認識できる形式

\begin{verbatim}
# -*- coding: <encoding-name> -*-
\end{verbatim}

または、Bram Moolenar による VIM が認識できる形式

\begin{verbatim}
# vim:fileencoding=<encoding-name>
\end{verbatim}

です。さらに、ファイルの先頭のバイト列が UTF-8 バイトオーダ記号
(\code{'\e xef\e xbb\e xbf'}) の場合、ファイルのエンコードは UTF-8
と宣言されているものとします (この機能は Microsoft の \program{notepad}
やその他のエディタでサポートされています)。

エンコードが宣言されている場合、Python はそのエンコード名を認識
できなければなりません。% XXX there should be a list of supported encodings.
宣言されたエンコードは全ての字句解析、特に文字列の終端を検出する際や
Unicode リテラルの内容を翻訳する上で用いられます。
文字列リテラルは文法的な解析を行うために Unicode に変換され、
解釈が行われる前に元のエンコードに戻されます。エンコード宣言は
宣言全体が一行に収まっていなければなりません。

\subsection{明示的な行継続\label{explicit-joining}}

二つまたはそれ以上の物理行を論理行としてつなげるためには、
バックスラッシュ文字 (\code{\e}) を使って以下のようにします:
物理行が文字列リテラルやコメント中の文字でないバックスラッシュで
終わっている場合、後続する行とつなげて一つの論理行を構成し、
バックスラッシュおよびバックスラッシュの後ろにある行末文字を
削除します。例えば:
\index{physical line}
\index{line joining}
\index{line continuation}
\index{backslash character}
%
\begin{verbatim}
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
        return 1
\end{verbatim}

となります。

バックスラッシュで終わる行にはコメントを入れることはできません。
また、バックスラッシュを使ってコメントを継続することはできません。
バックスラッシュが文字列リテラル中にある場合を除き、バックスラッシュの
後ろにトークンを継続することはできません (すなわち、物理行内の文字列
リテラル以外のトークンをバックスラッシュを使って分断することは
できません)。上記以外の場所では、文字列リテラル外にあるバックスラッシュ
はどこにあっても不正となります。


\subsection{非明示的な行継続\label{implicit-joining}}

丸括弧 (parentheses)、角括弧 (square bracket) 、および
波括弧 (curly brace) 内の式は、バックスラッシュを使わずに
一行以上の物理行に分割することができます。
例えば:

\begin{verbatim}
month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year
\end{verbatim}

非明示的に継続された行にはコメントを含めることができます。
継続行のインデントは重要ではありません。空の継続行を書くことが
できます。非明示的な継続行中には、NEWLINE トークンは存在しません。
非明示的な行の継続は、三重クオートされた文字列 (下記参照)
でも発生します; この場合には、コメントを含めることができません。


\subsection{空行 \label{blank-lines}}

\index{blank line}
スペース、タブ、フォームフィード、およびコメントのみを含む論理行は
無視されます (すなわち、NEWLINE トークンは生成されません)。
文を対話的に入力している際には、空行の扱いは行読み込み-評価-出力
(read-eval-print) ループの実装によって異なるかもしれません。
標準的な実装では、完全な空行でできた論理行 (すなわち、空白文字も
コメントも全く含まない空行) は、複数行からなる実行文の終端を示します。


\subsection{インデント\label{indentation}}

論理行の行頭にある、先頭の空白 (スペースおよびタブ) の連なりは、
その行のインデントレベルを計算するために使われます。インデントレベルは、
実行文のグループ化方法を決定するために用いられます。
\index{indentation}
\index{whitespace}
\index{leading whitespace}
\index{space}
\index{tab}
\index{grouping}
\index{statement grouping}

まず、タブは (左から右の方向に) 1 つから 8 つのスペースで置き換えられ、
置き換え後の文字列の終わりの位置までの文字数が 8 の倍数になるように
調整されます (\UNIX で使われている規則と同じになるよう意図されています)。
次に、空白文字でない最初の文字までのスペースの総数から、その行の
インデントを決定します。バックスラッシュを使ってインデントを複数の
物理行に分割することはできません; 最初のバックスラッシュまでの空白が
インデントを決定します。

\strong{プラットフォーム間の互換性に関する注意:} 
非 UNIX プラットフォームにおけるテキストエディタの性質上、一つの
ソースファイル内でタブとインデントを混在させて使うのは賢明では
ありません。また、プラットフォームによっては、最大インデントレベルを
明示的に制限しているかもしれません。

フォームフィード文字が行の先頭にあっても構いません; フォームフィード
文字は上のインデントレベル計算時には無視されます。フォームフィード
文字が先頭の空白中の他の場所にある場合、その影響は未定義です
(例えば、スペースの数を 0 にリセットするかもしれません)。


連続する行における各々のインデントレベルは、
INDENT および DEDENT トークンを生成するために使われます。
トークンの生成はスタックを用いて以下のように行われます。
\index{INDENT token}
\index{DEDENT token}

ファイル中の最初の行を読み出す前に、スタックにゼロが一つ積まれ
(push され) ます; このゼロは決して除去 (pop) されることはありません。
スタックの先頭に積まれてゆく数字は、常にスタックの末尾から先頭にかけて
厳密に増加するようになっています。各論理行の開始位置において、
その行のインデントレベル値がスタックの先頭の値と比較されます。値が
等しければ何もしません。インデントレベル値がスタック上の値よりも
大きければ、インデントレベル値はスタックに積まれ、INDENT トークンが
一つ生成されます。インデントレベル値がスタック上の値よりも小さい場合、
その値はスタック内のいずれかの値と\emph{等しくなければなりません} ;
スタック上のインデントレベル値よりも大きい値はすべて除去され、
値が一つ除去されるごとに DEDENT トークンが一つ生成されます。ファイルの
末尾では、スタックに残っているゼロより大きい値は全て除去され、
値が一つ除去されるごとに DEDENT トークンが一つ生成されます。

以下の例に正しく (しかし当惑させるように) インデントされた Python
コードの一部を示します:

\begin{verbatim}
def perm(l):
        # Compute the list of all permutations of l
    if len(l) <= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r
\end{verbatim}

以下の例は、様々なインデントエラーになります:

\begin{verbatim}
 def perm(l):                       # error: first line indented
for i in range(len(l)):             # error: not indented
    s = l[:i] + l[i+1:]
        p = perm(l[:i] + l[i+1:])   # error: unexpected indent
        for x in p:
                r.append(l[i:i+1] + x)
            return r                # error: inconsistent dedent
\end{verbatim}

(実際は、最初の 3 つのエラーはパーザによって検出されます; 最後の
エラーのみが字句解析器で見つかります --- \code{return r} の
インデントは、スタックから逐次除去されていくどのインデントレベル値とも
一致しません)


\subsection{トークン間の空白\label{whitespace}}

論理行の先頭や文字列の内部にある場合を除き、空白文字であるスペース、
タブ、およびフォームフィードは、トークンを分割するために自由に
利用することができます。二つのトークンを並べて書くと別のトークンと
してみなされてしまうような場合には、トークンの間に空白が必要と
なります (例えば、ab は一つのトークンですが、 a b は二つのトークンと
なります)。


\section{その他のトークン\label{other-tokens}}

NEWLINE、INDENT、および DEDENT の他、以下のトークンのカテゴリ:
\emph{識別子 (identifier)}、\emph{キーワード(keyword)}、\emph{リテラル}、
\emph{演算子 (operator)} 、\emph{デリミタ (delimiter)} が存在します。
空白文字 (上で述べた行終端文字以外) はトークンではありませんが、
トークンを区切る働きがあります。
トークンの解析にあいまいさが生じた場合、トークンは左から右に読んで
不正でないトークンを構築できる最長の文字列を含むように構築されます。


\section{識別子 (identifier) およびキーワード (keyword)\label{identifiers}}

識別子 (または \emph{名前 (name)}) は、以下の字句定義で記述されます:
\index{identifier}
\index{name}

\begin{productionlist}
  \production{identifier}
             {(\token{letter}|"_") (\token{letter} | \token{digit} | "_")*}
  \production{letter}
             {\token{lowercase} | \token{uppercase}}
  \production{lowercase}
             {"a"..."z"}
  \production{uppercase}
             {"A"..."Z"}
  \production{digit}
             {"0"..."9"}
\end{productionlist}

識別子の長さには制限がありません。大小文字は区別されます。


\subsection{キーワード (keyword)\label{keywords}}

以下の識別子は、予約語、または Python 言語における
\emph{キーワード (keyword)} として使われ、通常の識別子として
使うことはできません。キーワードは厳密に下記の通りに綴らなければ
なりません:%
\index{keyword}%
\index{reserved word}

\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try 
\end{verbatim}

% When adding keywords, use reswords.py for reformatting

\versionchanged[\constant{None} became a constant and is now
recognized by the compiler as a name for the built-in object
このバージョンから\constant{None}は定数になり、
組み込みオブジェクト\constant{None}の名前としてコンパイラに
認識されるようになりました。これは予約語ではありませんが、
これに他のオブジェクトを割り当てることはできません。]{2.4}

\versionchanged[\code{with_statement}機能をfuture文によって有効にしたときにのみ、
キーワード\keyword{as}と\keyword{with}は認識されます。
この機能はPython 2.6で正式に有効になる予定です。
詳しくは、~\ref{with}節を参照してください。
\keyword{as}と\keyword{with}を識別子として使用した場合は、
たとえfuture文で\code{with_statement}が有効になっていなかったとしても
常にワーニングが表示されます。]{2.6}


\subsection{予約済みの識別子種 (reserved classes of identifiers)\label{id-classes}}

ある種の (キーワードを除く) 識別子には、特殊な意味があります。
これらの識別子種は、先頭や末尾にあるアンダースコア文字のパターンで
区別されます:

\begin{description}

\item[\code{_*}]
この識別子は \samp{from \var{module} import *} で import されません。
対話インタプリタでは、最も最近行われた値評価の結果を記憶するために
特殊な識別子 \samp{_} が使われます; この識別子は \module{__builtin__} 
モジュール内に記憶されます。対話モードでない場合、\samp{_} には
特殊な意味はなく、定義されていません。~\ref{import} 節、
``\keyword{import} 文'' を参照してください。

\note{名前 \samp{_} は、しばしば国際化 (internationalization) と共に
用いられます; この慣習についての詳しい情報は、
\ulink{\module{gettext} module}{../lib/module-gettext.html} を
参照してください。}

\item[\code{__*__}]
システムで定義された (system-defined) 名前です。これらの名前は
インタプリタと (標準ライブラリを含む) 実装上で定義されています;
アプリケーション側では、この名前規約を使って別の名前を定義しようと
すべきではありません。この種の名前のうち、Python で定義されている
名前のセットは、将来のバージョンで拡張される可能性があります。
~\ref{specialnames} 節、``特殊なメソッド名'' を参照してください。

\item[\code{__*}]
クラスプライベート (class-private) な名前です。このカテゴリに属する
名前は、クラス定義のコンテキスト上で用いられた場合、基底クラスと
導出クラスの ``プライベートな'' 属性間で名前衝突が起こるのを防ぐために
書き直されます。
~\ref{atom-identifiers} 節、``識別子 (名前)'' を参照してください。

\end{description}


\section{リテラル (literal)\label{literals}}

リテラル (literal) とは、いくつかの組み込み型の定数を表記したものです。

\index{literal}
\index{constant}


\subsection{文字列リテラル\label{strings}}

文字列リテラルは以下の字句定義で記述されます:
\index{string literal}

\index{ASCII@\ASCII}
\begin{productionlist}
  \production{stringliteral}
             {[\token{stringprefix}](\token{shortstring} | \token{longstring})}
  \production{stringprefix}
             {"r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"}
  \production{shortstring}
             {"'" \token{shortstringitem}* "'"
              | '"' \token{shortstringitem}* '"'}
  \production{longstring}
             {"'''" \token{longstringitem}* "'''"}
  \productioncont{| '"""' \token{longstringitem}* '"""'}
  \production{shortstringitem}
             {\token{shortstringchar} | \token{escapeseq}}
  \production{longstringitem}
             {\token{longstringchar} | \token{escapeseq}}
  \production{shortstringchar}
             {<any source character except "\e" or newline or the quote>}
  \production{longstringchar}
             {<any source character except "\e">}
  \production{escapeseq}
             {"\e" <any ASCII character>}
\end{productionlist}

上記の生成規則で示されていない文法的な制限が一つあります。それは
文字列リテラルの \grammartoken{stringprefix} と残りの部分の間に
空白を入れてはならないということです。ソースコード文字セット
(source character set) はエンコード宣言で決まります．エンコード
宣言がない場合には \ASCII{} になります．\ref{encodings} 節を
参照してください．

\index{triple-quoted string}
\index{Unicode Consortium}
\index{string!Unicode}
より平易な説明: 文字列リテラルは、対応する一重引用符 (\code{'}) または
二重引用符 (\code{"}) で囲われます。また、対応する三連の一重引用符
や二重引用符で囲うこともできます 
(通常、\emph{三重クオート文字列: triple-quoted string} として
参照されます)。バックスラッシュ (\code{\e}) 文字を使って、
ある文字を例えば改行文字やバックスラッシュ自体、クオート文字といった
別の意味を持つようにエスケープすることができます。
文字列リテラルの前には、オプションとして \character{r} または \character{R}
一文字を接頭してもかまいません; このような文字列は \dfn{raw 文字列
(raw string)} と呼ばれ、バックスラッシュによるエスケープシーケンスの
解釈規則が異なります。\character{u} や \character{U} を接頭すると、
文字列は Unicode 文字列 (Unicode string) になります。Unicode 文字列は
Unicode コンソーシアムおよび ISO~10646 で定義されている Unicode 文字セット
を使います。Unicode 文字列では、文字セットに加えて、以下で説明するような
エスケープシーケンスを利用できます。二つの接頭文字を組み合わせることも
できます; この場合、\character{u} は \character{r} より前に出現しなくては
なりません。

三重クオート文字列中には、三連のエスケープされないクオート文字で
文字列を終端してしまわないかぎり、エスケープされていない改行やクオートを
書くことができます (さらに、それらはそのまま文字列中に残ります)。
(ここでいう ``クオート'' とは、文字列の囲みを開始するときに使った文字
を示し、\code{'} か \code{"} のいずれかです)。

\character{r} または \character{R} 接頭文字がつかないかぎり、
文字列中のエスケープシーケンスは標準 C で使われているのと同様の
法則にしたがって解釈されます。以下に Python で認識されるエスケープ
シーケンスを示します:
\index{physical line}
\index{escape sequence}
\index{Standard C}
\index{C}

\begin{tableiii}{l|l|c}{code}{エスケープシーケンス}{意味}{備考}
\lineiii{\e\var{newline}} {無視}{}
\lineiii{\e\e}	{バックスラッシュ (\code{\e})}{}
\lineiii{\e'}	{一重引用符 (\code{'})}{}
\lineiii{\e"}	{二重引用符 (\code{"})}{}
\lineiii{\e a}	{\ASCII{} 端末ベル (BEL)}{}
\lineiii{\e b}	{\ASCII{} バックスペース (BS)}{}
\lineiii{\e f}	{\ASCII{} フォームフィード (FF)}{}
\lineiii{\e n}	{\ASCII{} 行送り (LF)}{}
\lineiii{\e N\{\var{name}\}}
        {Unicode データベース中で名前 \var{name} を持つ文字 (Unicode のみ)}{}
\lineiii{\e r}	{\ASCII{} 復帰 (CR)}{}
\lineiii{\e t}	{\ASCII{} 水平タブ (TAB)}{}
\lineiii{\e u\var{xxxx}}
        {16-bit の 16 進数値 \var{xxxx} を持つ文字 (Unicode のみ)}{(1)}
\lineiii{\e U\var{xxxxxxxx}}
        {32-bit の 16 進数値 \var{xxxxxxxx} を持つ文字 (Unicode のみ)}{(2)}
\lineiii{\e v}	{\ASCII{} 水平タブ (VT)}{}
\lineiii{\e\var{ooo}} {8 進数値 \var{ooo} を持つ文字}{(3,5)}
\lineiii{\e x\var{hh}} {16 進数値 \var{hh} を持つ文字}{(4,5)}
\end{tableiii}
\index{ASCII@\ASCII}

\noindent
備考:

\begin{itemize}
\item[(1)]
サロゲートペアの断片を形成する個々のコード単位は、このエスケープ
シーケンスでエンコードすることができます。
\item[(2)]
Unicode 文字はすべてこの方法でエンコードできますが、
Python が 16-bit コード単位を扱うようにコンパイルされている
(デフォルトの設定です) 場合、基本多言語面 (Basic Multilingual Plane, BMP) 
外の文字はサロゲートペア (surrogate pair) を使ってエンコードする
ことになります。サロゲートペアの断片を形成する個々のコード単位は
このエスケープシーケンスを使ってエンコードすることができます。
\item[(3)]
標準 C と同じく、最大で 3 桁の 8 進数まで受理します。
\item[(4)]
標準 C とは違い、最大で 2 桁の 16 進数しか受理されません。
\item[(5)]
文字列リテラル中では， 16 進および 8 進エスケープはエスケープの
示すバイト文字になります．そのバイト文字がソース文字セットで
エンコードされている保証はありません．Unicode リテラル中では，
エスケープ文字はエスケープ文字の表現する値を持つ Unicode 文字に
なります．
\end{itemize}

\index{unrecognized escape sequence}
標準の C とは違い、認識されなかったエスケープシーケンスはそのまま
文字列中に残されます。すなわち。
\emph{バックスラッシュも文字列中に残ります。} (この挙動はデバッグの
際に便利です: エスケープシーケンスを誤入力した場合、その結果として
出力に失敗しているのが用意にわかります) テーブル中で 
``(Unicode のみ)'' と書かれたエスケープシーケンスは、非 Unicode
文字列リテラル中では認識されないエスケープシーケンスのカテゴリに
分類されるので注意してください。

接頭文字 \character{r} または \character{R} がある場合、バックスラッシュ
の後にくる文字はそのまま文字列中に入り、\emph{バックスラッシュは全て
文字列中に残されます}。例えば、文字列リテラル \code{r"\e n"} は二つの文字:
バックスラッシュと小文字の \character{n} からなる文字列を表すことに
なります。引用符はバックスラッシュでエスケープすることができますが、
バックスラッシュ自体も残ってしまいます; 例えば、\code{r"\e""} は不正でない
文字列リテラルで、バックスラッシュと二重引用符からなる文字列を表します; 
\code{r"\e"} は正しくない文字列リテラルです (raw 文字列を奇数個連なった
バックスラッシュで終わらせることはできません)。厳密にいえば、
(バックスラッシュが直後のクオート文字をエスケープしてしまうため) 
\emph{raw 文字列を単一のバックスラッシュで終わらせることはできない}
ということになります。また、バックスラッシュの直後に改行がきても、
行継続を意味する\emph{のではなく} 、それら二つの文字として解釈されるので
注意してください。

\character{r} および \character{R} 接頭文字を \character{u} や
\character{U} と合わせて使った場合、\code{\e uXXXX}および
\code{\e UXXXXXXXX} エスケープシーケンスは処理されますが、
\emph{その他のバックスラッシュは
すべて文字列中に残されます} 。例えば、文字列リテラル
\code{ur"\e{}u0062\e n"} は、3つの Unicode 文字: 
`LATIN SMALL LETTER B' (ラテン小文字 B)、`REVERSE SOLIDUS' (逆向き斜線)、
および `LATIN SMALL LETTER N' (ラテン小文字 N) を表します。
バックスラッシュの前にバックスラッシュをつけてエスケープすることは
できます; しかし、バックスラッシュは両方とも文字列中に残されます。
その結果、\code{\e uXXXX} エスケープシーケンスは、バックスラッシュが
奇数個連なっている場合にのみ認識されます。

\subsection{文字列リテラルの結合 (concatenation)\label{string-catenation}}

複数の文字列リテラルは、互いに異なる引用符を使っていても 
(空白文字で区切って) 隣接させることができ、その意味は各々の文字列を
結合したものと同じになります。したがって、\code{"hello" 'world'} は
\code{"helloworld"} と同じになります。この機能を使うと、長い文字列を
分離して、複数行にまたがらせる際に便利です。また、部分文字列ごとに
コメントを追加することもできます。例えば:

\begin{verbatim}
re.compile("[A-Za-z_]"       # letter or underscore
           "[A-Za-z0-9_]*"   # letter, digit or underscore
          )
\end{verbatim}

この機能は文法レベルで定義されていますが、スクリプトをコンパイルする
際の処理として実現されることに注意してください。実行時に文字列表現を
結合したければ、 `+' 演算子を使わなければなりません。また、リテラルの
結合においては、結合する各要素に異なる引用符形式を使える (raw 文字列
と三重引用符を混ぜることさえできます) ので注意してください。


\subsection{数値リテラル\label{numbers}}

数値リテラルは 4 種類あります: 整数 (plain integer)、長整数 (long
integer)、浮動小数点数 (floating point number)、そして虚数 (imaginary
number) です。複素数のためのリテラルはありません (複素数は実数と
虚数の和で作ることができます)。

\index{number}
\index{numeric literal}
\index{integer literal}
\index{plain integer literal}
\index{long integer literal}
\index{floating point literal}
\index{hexadecimal literal}
\index{octal literal}
\index{decimal literal}
\index{imaginary literal}
\index{complex!literal}

数値リテラルには符号が含まれていないことに注意してください; \code{-1}
のような句は、実際には単項演算子 (unary operator) `\code{-}' とリテラル
\code{1} を組み合わせたものです。


\subsection{整数および長整数リテラル\label{integers}}

整数および長整数リテラルは以下の字句定義で記述されます:

\begin{productionlist}
  \production{longinteger}
             {\token{integer} ("l" | "L")}
  \production{integer}
             {\token{decimalinteger} | \token{octinteger} | \token{hexinteger}}
  \production{decimalinteger}
             {\token{nonzerodigit} \token{digit}* | "0"}
  \production{octinteger}
             {"0" \token{octdigit}+}
  \production{hexinteger}
             {"0" ("x" | "X") \token{hexdigit}+}
  \production{nonzerodigit}
             {"1"..."9"}
  \production{octdigit}
             {"0"..."7"}
  \production{hexdigit}
             {\token{digit} | "a"..."f" | "A"..."F"}
\end{productionlist}

長整数を表す末尾の文字は小文字の \character{l} でも大文字の \character{L} 
でもかまいませんが、\character{l} は \character{1} に良く似ているので、
常に \character{L} を使うよう強く勧めます。

整数で表現できる最大の値よりも大きい整数のリテラル 
(例えば 32-bit 整数を使っている場合には 2147483647) は、
長整数として表現できる値であれば受理されます。
\footnote{バージョン 2.4 以前の Python では， 8 進および 16 進のリテラル
のうち，通常の整数型として表現可能な値より大きく，かつ符号無しの 32-bit
(32-bit 演算を使う計算機の場合) 整数で表現できる最大値，すなわち 
4294967296 よりも小さな数は，リテラルを符号無し整数として表現した値から
4294967296 を引いて得られる負の整数として扱っていました．}
値がメモリ上に収まるかどうかという問題を除けば、長整数リテラルには値域の
制限がありません。

整数リテラル (最初の行) と長整数リテラル (二行目および三行目) の例を
以下に示します:

\begin{verbatim}
7     2147483647                        0177
3L    79228162514264337593543950336L    0377L   0x100000000L
      79228162514264337593543950336             0xdeadbeef
\end{verbatim}


\subsection{浮動小数点数リテラル\label{floating}}

浮動小数点数リテラルは以下の字句定義で記述されます:

\begin{productionlist}
  \production{floatnumber}
             {\token{pointfloat} | \token{exponentfloat}}
  \production{pointfloat}
             {[\token{intpart}] \token{fraction} | \token{intpart} "."}
  \production{exponentfloat}
             {(\token{intpart} | \token{pointfloat})
              \token{exponent}}
  \production{intpart}
             {\token{digit}+}
  \production{fraction}
             {"." \token{digit}+}
  \production{exponent}
             {("e" | "E") ["+" | "-"] \token{digit}+}
\end{productionlist}

浮動小数点数における整数部と指数部は 8 進数のように見えることも
ありますが、10 を基数として解釈されるので注意してください。
例えば、\samp{077e010} は正しい表記であり、\samp{77e10} と同じ数を
表します。
浮動小数点数リテラルの取りうる値の範囲は実装に依存します。
浮動小数点数リテラルの例をいくつか示します:

\begin{verbatim}
3.14    10.    .001    1e100    3.14e-10    0e0
\end{verbatim}

数値リテラルには符号が含まれていないことに注意してください; \code{-1}
のような句は、実際には単項演算子 (unary operator) `\code{-}' とリテラル
\code{1} を組み合わせたものです。


\subsection{虚数 (imaginary) リテラル\label{imaginary}}

虚数リテラルは以下のような字句定義で記述されます:

\begin{productionlist}
  \production{imagnumber}{(\token{floatnumber} | \token{intpart}) ("j" | "J")}
\end{productionlist}

虚数リテラルは、実数部が 0.0 の複素数を表します。複素数は二つ組の
浮動小数点型の数値で表され、それぞれの数値は浮動小数点型と同じ定義域の
範囲を持ちます。実数部がゼロでない浮動小数点を生成するには、\code{(3+4j)}
のように虚数リテラルに浮動小数点数を加算します。以下に虚数リテラルの
例をいくつか示します:

\begin{verbatim}
3.14j   10.j    10j     .001j   1e100j  3.14e-10j 
\end{verbatim}


\section{演算子 (operator)\label{operators}}

以下のトークンは演算子です:
\index{operators}

\begin{verbatim}
+       -       *       **      /       //      %
<<      >>      &       |       ^       ~
<       >       <=      >=      ==      !=      <>
\end{verbatim}

比較演算子 \code{<>} と \code{!=} は、同じ演算子について別の書き方をした
ものです。書き方としては \code{!=} を推奨します; \code{<>} は時代遅れの
書き方です。


\section{デリミタ (delimiter)\label{delimiters}}

以下のトークンは文法上のデリミタとして働きます:
\index{delimiters}

\begin{verbatim}
(       )       [       ]       {       }      @
,       :       .       `       =       ;
+=      -=      *=      /=      //=     %=
&=      |=      ^=      >>=     <<=     **=
\end{verbatim}

浮動小数点数や虚数リテラル中にピリオドがあってもかまいません。
ピリオド三つの列はスライス表記における省略符号 (ellipsis) として
特別な意味を持っています。リスト後半の累算代入演算子 (augmented
assignment operator) は、字句的にはデリミタとして振舞いますが、
演算も行います。

以下の印字可能 \ASCII{} 文字は、他のトークンの一部として特殊な意味を
持っていたり、字句解析器にとって重要な意味を持っています:

\begin{verbatim}
'       "       #       \
\end{verbatim}

以下の印字可能 \ASCII{} 文字は、Python では使われていません。これらの
文字が文字列リテラルやコメントの外にある場合、無条件にエラーとなります:
\index{ASCII@\ASCII}

\begin{verbatim}
$       ?
\end{verbatim}

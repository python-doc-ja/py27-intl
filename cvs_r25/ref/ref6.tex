\chapter{単純文 (simple statement) \label{simple}}
\indexii{simple}{statement}

単純文とは、単一の論理行内に収められる文です。
単一の行内には、複数の単純文をセミコロンで区切って入れることが
できます。単純文の構文は以下の通りです:

\begin{productionlist}
  \production{simple_stmt}{\token{expression_stmt}}
  \productioncont{| \token{assert_stmt}}
  \productioncont{| \token{assignment_stmt}}
  \productioncont{| \token{augmented_assignment_stmt}}
  \productioncont{| \token{pass_stmt}}
  \productioncont{| \token{del_stmt}}
  \productioncont{| \token{print_stmt}}
  \productioncont{| \token{return_stmt}}
  \productioncont{| \token{yield_stmt}}
  \productioncont{| \token{raise_stmt}}
  \productioncont{| \token{break_stmt}}
  \productioncont{| \token{continue_stmt}}
  \productioncont{| \token{import_stmt}}
  \productioncont{| \token{global_stmt}}
  \productioncont{| \token{exec_stmt}}
\end{productionlist}


\section{式文 (expression statement) \label{exprstmts}}
\indexii{expression}{statement}

式文は、 (主に対話的な使い方では) 値を計算して出力するために
使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない
関数のことです; Python では、プロシジャは値 \code{None} を返します)
を呼び出すために使います。その他の使い方でも式文を使うことができ
ますし、有用なこともあります。式文の構文は以下の通りです:

\begin{productionlist}
  \production{expression_stmt}
             {\token{expression_list}}
\end{productionlist}

式文は式のリスト (単一の式のこともあります) を値評価します。
\indexii{expression}{list}

対話モードでは、値が \code{None} でない場合、値を組み込み関数
\function{repr()}\bifuncindex{repr} で文字列に変換して、
その結果のみからなる一行を標準出力に書き出します (~\ref{print} 節参照)。
(\code{None} になる式文の値は書き出されないので、プロシジャ呼び出しを
行っても出力は得られません。)
\ttindex{None}
\indexii{string}{conversion}
\index{output}
\indexii{standard}{output}
\indexii{writing}{values}
\indexii{procedure}{call}


\section{Assert 文 (assert statement) \label{assert}}

Assert 文\stindex{assert} は、プログラム内にデバッグ用アサーション
(debugging assertion) を仕掛けるための便利な方法です:

\begin{productionlist}
  \production{assert_stmt}
             {"assert" \token{expression} ["," \token{expression}]}
\end{productionlist}

単純な形式 \samp{assert expression} は、

\begin{verbatim}
if __debug__:
   if not expression: raise AssertionError
\end{verbatim}

と等価です。拡張形式 \samp{assert expression1, expression2} は、

\begin{verbatim}
if __debug__:
   if not expression1: raise AssertionError, expression2
\end{verbatim}

と等価です。

上記の等価関係は、 \code{__debug__}\ttindex{__debug__} と
\exception{AssertionError}\exindex{AssertionError} が、同名の組み込み
変数を参照しているという前提の上に成り立っています。現在の実装では、
組み込み変数 \code{__debug__} は通常の状況では \code{True} 
であり、最適化がリクエストされた場合（コマンドラインオプション -O）は
\code{False} です。現状のコード生成器は、コンパイル時に最適化が要求されて
いると assert 文に対するコードを全く出力しません。
実行に失敗した式のソースコードをエラーメッセージ内に入れる必要は
ありません; メッセージはスタックトレース内で表示されます。

\code{__debug__} への代入は不正な操作です。組み込み変数の値は、
インタプリタが開始するときに決定されます。


\section{代入文 (assignment statement) \label{assignment}}

代入文\indexii{assignment}{statement} は、名前を値に (再) 束縛したり、
変更可能なオブジェクトの属性や要素を変更したりするために使われます:
\indexii{binding}{name}
\indexii{rebinding}{name}
\obindex{mutable}
\indexii{attribute}{assignment}

\begin{productionlist}
  \production{assignment_stmt}
             {(\token{target_list} "=")+ \token{expression_list}}
  \production{target_list}
             {\token{target} ("," \token{target})* [","]}
  \production{target}
             {\token{identifier}}
  \productioncont{| "(" \token{target_list} ")"}
  \productioncont{| "[" \token{target_list} "]"}
  \productioncont{| \token{attributeref}}
  \productioncont{| \token{subscription}}
  \productioncont{| \token{slicing}}
\end{productionlist}

(末尾の三つのシンボルの構文については ~\ref{primaries} 節を
参照してください。)

代入文は式のリスト (これは単一の式でも、
カンマで区切られた式リストでもよく、後者はタプルになることを
思い出してください) を評価し、得られた単一の結果オブジェクトを
ターゲット (target) のリストに対して左から右へと代入してゆきます。
\indexii{expression}{list}

代入はターゲット (リスト) の形式に従って再帰的に行われます。
ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス)
の一部である場合、この変更可能なオブジェクトは最終的に代入を
実行して、その代入が有効な操作であるか判断しなければなりません。
代入が不可能な場合には例外を発行することもできます。型ごとに
みられる規則や、送出される例外は、そのオブジェクト型定義
で与えられています (~\ref{types} 節を参照してください).
\index{target}
\indexii{target}{list}

ターゲットリストへのオブジェクトの代入は、以下のようにして再帰的に
定義されています。
\indexiii{target}{list}{assignment}

\begin{itemize}
\item
ターゲットリストが単一のターゲットからなる場合: オブジェクトはその
ターゲットに代入されます。

\item
ターゲットリストが、カンマで区切られた複数のターゲットからなる
リストの場合: オブジェクトはターゲットリスト中のターゲット数と
同じ数の要素からなるシーケンスでなければならず、その各要素は左から
右へと対応するターゲットに代入されます。(これは Python 1.5
で緩和された規則です; 以前のバージョンでは、代入するオブジェクトは
タプルでなければなりませんでした。文字列もシーケンスなので、今では
\samp{a, b = "xy"} のような代入は文字列が正しい長さを持つ限り
正規の操作になります。)

\end{itemize}

単一のターゲットへの単一のオブジェクトの代入は、以下のようにして
再帰的に定義されています。

\begin{itemize} % nested

\item
ターゲットが識別子 (名前) の場合:

\begin{itemize}

\item
名前が現在のコードブロック内の \keyword{global} 文に書かれて
いない場合: 名前は現在のローカル名前空間内のオブジェクトに
束縛されます。
\stindex{global}

\item
それ以外の場合: 名前は現在のグローバル名前空間内のオブジェクトに
束縛されます。

\end{itemize} % nested

名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。
再束縛によって、以前その名前に束縛されていたオブジェクトの
参照カウント (reference count) がゼロになった場合、オブジェクトは
解放 (deallocate) され、デストラクタ 
(destructor\index{destructor}) が (存在すれば) 呼び出されます。

\item
ターゲットが丸括弧や角括弧で囲われたターゲットリストの場合:
オブジェクトはターゲットリスト中のターゲット数と
同じ数の要素からなるシーケンスでなければならず、その各要素は左から
右へと対応するターゲットに代入されます。

\item
ターゲットが属性参照の場合: 参照されている一次語の式
が値評価されます。値は代入可能な属性を伴うオブジェクトでなければ
なりません; そうでなければ、 \exception{TypeError} が送出されます。
次に、このオブジェクトに対して、被代入オブジェクトを指定した属性
に代入してよいか問い合わせます; 代入を実行できない場合、
例外 (通常は \exception{AttributeError} ですが、必然ではありません)
を送出します。
\indexii{attribute}{assignment}

\item
ターゲットが添字表記の場合: 参照されている一次語の式
が値評価されます。まず、値は変更可能な (リストのような) シーケンスオブジェクト
か、 (辞書のような) マップオブジェクトでなければなりません。
次に、添字表記の表す式が値評価されます。
\indexii{subscription}{assignment}
\obindex{mutable}

一次語が変更可能な (リストのような) シーケンスオブジェクトの場合、
まず添字は整数でなければなりません。添字が負数の場合、シーケンスの
長さが加算されます。添字は最終的に、シーケンスの長さよりも小さな
非負の整数でなくてはなりません。次に、添字をインデクスに
持つ要素に非代入オブジェクトを代入してよいか、シーケンスに問い合わせ
ます。範囲を超えたインデクスに対しては\exception{IndexError} 
が送出されます (添字指定されたシーケンスに代入を行っても、
リスト要素の新たな追加はできません)。
\obindex{sequence}
\obindex{list}

一次語が (辞書のような) マップオブジェクトの場合、まず添字は
マップのキー型と互換性のある型でなくてはなりません。
次に、添字を被代入オブジェクトに関連付けるようなキー/データ
の対を生成するようマップオブジェクトに問い合わせます。
この操作では、既存のキー/値の対を同じキーと別の値で置き換えても
よく、(同じ値を持つキーが存在しない場合) 新たなキー/値の対を挿入しても
かまいません。
\obindex{mapping}
\obindex{dictionary}

\item
ターゲットがスライスの場合: 参照されている一次語の式
が値評価されます。まず、値は変更可能な (リストのような) シーケンスオブジェクト
でなければなりません。被代入オブジェクトは同じ型を持ったシーケンスオブジェクト
でなければなりません。次に、スライスの下境界と上境界を示す式があれば
評価されます; デフォルト値はそれぞれゼロとシーケンスの長さです。
上下境界は整数にならなければなりません。いずれかの境界が負数に
なった場合、シーケンスの長さが加算されます。最終的に、境界は
ゼロからシーケンスの長さまでの内包になるようにクリップされます。
最後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに
問い合わせます。オブジェクトで許されている限り、スライスの長さは
被代入シーケンスの長さと異なっていてよく、この場合にはターゲットシーケンスの
長さが変更されます。
\indexii{slicing}{assignment}

\end{itemize}
        
(現在の実装では、ターゲットの構文は式の構文と同じであるとみなされて
おり、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを
伴って拒否されます。)

警告: 代入の定義では、左辺値と右辺値がオーバラップするような代入
(例えば、\samp{a, b = b, a} を行うと、二つの変数を入れ替えます) を
定義しても `安全 (safe)' に代入できますが、代入対象となる
変数群 \emph{の間で} オーバラップがある場合は安全ではありません！
例えば、以下のプログラムは \samp{[0, 2]} を出力してしまいます:

\begin{verbatim}
x = [0, 1]
i = 0
i, x[i] = 1, 2
print x
\end{verbatim}


\subsection{累算代入文 (augmented assignment statement) \label{augassign}}

累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:
\indexii{augmented}{assignment}
\index{statement!assignment, augmented}

\begin{productionlist}
  \production{augmented_assignment_stmt}
             {\token{target} \token{augop} \token{expression_list}}
  \production{augop}
             {"+=" | "-=" | "*=" | "/=" | "\%=" | "**="}
  % The empty groups below prevent conversion to guillemets.
  \productioncont{| ">{}>=" | "<{}<=" | "\&=" | "\textasciicircum=" | "|="}
\end{productionlist}

% JJJ: この一文はおそらく間違ってここに挿入されています
% (最後の 3 つのシンボル定義については、~\ref{primaries} 節を参照
% してください。)

累算代入文は、ターゲット (通常の代入文と違って、アンパックは
起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算
代入型の二項演算を行い、結果をもとのターゲットに代入します。
ターゲットは一度しか評価されません。

\code{x += 1} のような累算代入式は、\code{x = x + 1} のように書き換えて
ほぼ同様の動作にできますが、厳密に等価にはなりません。累算代入の
方では、\code{x} は一度しか評価されません。また、実際の処理として、
可能ならば \emph{インプレース (in-place)} 演算が実行されます。
これは、代入時に新たなオブジェクトを生成してターゲットに代入するの
ではなく、以前のオブジェクトの内容を変更するということです。

累算代入文で行われる代入は、タプルへの代入や、一文中に複数の
ターゲットが存在する場合を除き、通常の代入と同じように扱われます。
同様に、累算代入で行われる二項演算は、場合によって
\emph{インプレース演算} が行われることを除き、通常の二項演算
と同じです。

属性参照のターゲットの場合、代入前の初期値は \method{getattr()} で
取り出され、演算結果は \method{setattr()} で代入されます。
二つのメソッドが同じ変数を参照するという必然性はないので注意してください。
例えば:

\begin{verbatim}
class A:
    x = 3    # class variable
a = A()
a.x += 1     # writes a.x as 4 leaving A.x as 3
\end{verbatim}

のように、\method{getattr()} がクラス変数を参照していても、
\method{setattr()} はインスタンス変数への書き込みを行ってしまいます。

\section{\keyword{pass} 文\label{pass}}
\stindex{pass}

\begin{productionlist}
  \production{pass_stmt}
             {"pass"}
\end{productionlist}

\keyword{pass} はヌル操作 (null operation) です --- \keyword{pass}
が実行されても、何も起きません。\keyword{pass} は、例えば:
\indexii{null}{operation}

\begin{verbatim}
def f(arg): pass    # a function that does nothing (yet)

class C: pass       # a class with no methods (yet)
\end{verbatim}

のように、構文法的には文が必要だが、コードとしては何も実行したく
ない場合のプレースホルダとして有用です。

\section{\keyword{del} 文 \label{del}}
\stindex{del}

\begin{productionlist}
  \production{del_stmt}
             {"del" \token{target_list}}
\end{productionlist}

オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で
再帰的に定義されています。ここでは完全な詳細を記述するよりも
いくつかのヒントを述べるにとどめます。
\indexii{deletion}{target}
\indexiii{deletion}{target}{list}

ターゲットリストに対する削除は、各々のターゲットを左から右へと
順に再帰的に削除します。

名前に対して削除を行うと、ローカルまたはグローバル名前空間での
その名前の束縛を解除します。どちらの名前空間かは、名前が同じコード
ブロック内の \keyword{global} 文で宣言されているかどうかによります。
名前が未束縛 (unbound) であるばあい、\exception{NameError} 例外
が送出されます。
\stindex{global}
\indexii{unbinding}{name}

ネストしたブロック中で自由変数\indexii{free}{variable} になっている
ローカル名前空間上の名前に対する削除は不正な操作になります

属性参照、添字表記、およびスライスの削除操作は、対象となる一次語
オブジェクトに渡されます; スライスの削除は一般的には適切な
型の空のスライスを代入するのと等価です (が、この仕様自体も
スライスされるオブジェクトで決定されています)。
\indexii{attribute}{deletion}


\section{\keyword{print} 文 \label{print}}
\stindex{print}

\begin{productionlist}
  \production{print_stmt}
             {"print" ( \optional{\token{expression} ("," \token{expression})* \optional{","}}}
  \productioncont{| ">>" \token{expression}
                  \optional{("," \token{expression})+ \optional{","}} )}
\end{productionlist}

\keyword{print} は、式を逐次的に評価し、得られたオブジェクトを
標準出力に書き出します。オブジェクトが文字列でなければ、まず文字列
変換規則を使って文字列に変換され、次いで (得られた文字列か、オリジナル
の文字列が) 書き出されます。出力系の現在の書き出し位置が行頭にある
と考えられる場合を除き、各オブジェクトの出力前にスペースが一つ出力
されます。行頭にある場合とは、(1) 標準出力にまだ何も書き出されて
いない場合、(2) 標準出力に最後に書き出された文字が \character{\e n}
である、または (3) 標準出力に対する最後の書き出し操作が 
\keyword{print} 文によるものではない場合、です。(こうした理由から、
場合によっては空文字を標準出力に書き出すと便利なことがあります。)
\note{組み込みのファイルオブジェクトでない、ファイルオブジェクト
に似た動作をするオブジェクトでは、組み込みのファイルオブジェクト
が持つ上記の性質を適切にエミュレートしていないことがあるため、
当てにしないほうがよいでしょう。}
\index{output}
\indexii{writing}{values}

\keyword{print} 文がカンマで終了していない限り、末尾には文字
\character{\e n} が書き出されます。この仕様は、文に予約語
\keyword{print} がある場合のみの動作です。
\indexii{trailing}{comma}
\indexii{newline}{suppression}

標準出力は、組み込みモジュール \module{sys} 内で \code{stdout} 
という名前のファイルオブジェクトとして定義されています。
該当するオブジェクトが存在しないか、オブジェクトに \method{write()}
メソッドがない場合、\exception{RuntimeError}
例外が送出されます。.
\indexii{standard}{output}
\refbimodindex{sys}
\withsubitem{(in module sys)}{\ttindex{stdout}}
\exindex{RuntimeError}

\keyword{print} には、上で説明した構文の第二形式で定義されている
拡張形式\index{extended print statement} があります。
この形式は、``山形 \keyword{print} 表記 (\keyword{print} chevron)''
と呼ばれます。この形式では、\code{>>} の直後にくる最初の
式の値評価結果は ``ファイル類似 (file-like)'' なオブジェクト、とりわけ
上で述べたように \method{write()} メソッドを持つオブジェクトで
なければなりません。この拡張形式では、ファイルオブジェクトを指定する
式よりも後ろの式が、指定されたファイルオブジェクトに出力されます。
最初の式の値評価結果が \code{None} になった場合、 \code{sys.stdout} 
が出力ファイルとして使われます。

\section{\keyword{return} 文 \label{return}}
\stindex{return}

\begin{productionlist}
  \production{return_stmt}
             {"return" [\token{expression_list}]}
\end{productionlist}

\keyword{return} は、関数定義内で構文法的にネストして現れますが、
ネストしたクラス定義内には現れません。
\indexii{function}{definition}
\indexii{class}{definition}

式リストがある場合、リストが値評価されます。それ以外の場合は
\code{None} で置き換えられます。

\keyword{return} を使うと、式リスト (または \code{None}) 
を戻り値として、現在の関数呼び出しから抜け出します。

\keyword{return} によって、\keyword{finally} 節をともなう \keyword{try} 
文の外に処理が引き渡されると、実際に関数から抜ける前に 
\keyword{finally} 節が実行されます。
\kwindex{finally}

ジェネレータ関数の場合には、\keyword{return} 文の中に
\grammartoken{expression_list} を入れることはできません。
ジェネレータ関数の処理コンテキストでは、単体の \keyword{return} 
はジェネレータ処理を終了し \exception{StopIteration} を送出させる
ことを示します。

\section{\keyword{yield} 文 \label{yield}}
\stindex{yield}

\begin{productionlist}
  \production{yield_stmt}
             {"yield" \token{expression_list}}
\end{productionlist}

\index{generator!function}
\index{generator!iterator}
\index{function!generator}
\exindex{StopIteration}

\keyword{yield} 文は、ジェネレータ関数 (generator function) を
定義するときだけ使われ、かつジェネレータ関数の本体の中でだけ
用いられます。
関数定義中で \keyword{yield} 文を使うだけで、関数定義は通常の関数
でなくジェネレータ関数になります。

ジェネレータ関数が呼び出されると、ジェネレータイテレータ
(generator iterator)、一般的にはジェネレータ (generator) を
返します。ジェネレータ関数の本体は、ジェネレータの
\method{next()} が例外を発行するまで繰り返し呼び出して実行します。

\keyword{yield} 文が実行されると、現在のジェネレータの状態は
凍結 (freeze) され、\grammartoken{expression_list} の値が \method{next()} 
の呼び出し側に返されます。ここでの ``凍結'' は、ローカルな変数への
束縛、命令ポインタ (instruction pointer)、および内部実行スタック
(internal evaluation stack) を含む、全てのローカルな状態が保存される
ことを意味します: すなわち、必要な情報を保存しておき、次に
\method{next()} が呼び出された際に、関数が \keyword{yield} 文をあたかも
もう一つの外部呼出しであるかのように処理できるようにします。

Python バージョン 2.5 では、\keyword{yield} 文が 
\keyword{try} ... \ \keyword{finally} 構造における 
\keyword{try} 節で許されるようになりました。ジェネレータが終了（finalized）される
（参照カウントがゼロになるか、ガベージコレクションされる) までに再開されなければ、
ジェネレータ-イテレータの \method{close()} メソッドが呼ばれ、
留保されている \keyword{finally} 節が実行できるようになります。

\begin{notice}
Python 2.2 では、\code{generators} 機能が有効になっている場合にのみ
\keyword{yield} 文を使えます。Python 2.3 では、常に有効になっています。
\code{__future__} import 文を使うと、この機能を有効にできます:

\begin{verbatim}
from __future__ import generators
\end{verbatim}
\end{notice}


\begin{seealso}
  \seepep{0255}{単純なジェネレータ}
         {Python へのジェネレータと \keyword{yield} 文の導入提案}

  \seepep{0342}{改善されたジェネレータによるコルーチン (Coroutine)}
         {その他のジェネレータの改善と共に、 \keyword{yield} が
          \keyword{try} ... \keyword{finally} ブロックの中に存在することを
          可能にするための提案}
\end{seealso}


\section{\keyword{raise} 文 \label{raise}}
\stindex{raise}

\begin{productionlist}
  \production{raise_stmt}
             {"raise" [\token{expression} ["," \token{expression}
              ["," \token{expression}]]]}
\end{productionlist}

式を伴わない場合、\keyword{raise} は現在のスコープで最終的に有効に
なっている例外を再送出します。そのような例外が現在のスコープで
アクティブでない場合、\exception{TypeError} 例外が送出されて、
これがエラーであることを示します (IDLE で実行した場合は、
代わりに exception{Queue.Empty} 例外を送出します)。
\index{exception}
\indexii{raising}{exception}

それ以外の場合、\keyword{raise} は式を値評価して、三つのオブジェクトを
取得します。このとき、\code{None} を省略された式の値として使います。
最初の二つのオブジェクトは、例外の \emph{型 (type)} と
例外の \emph{値 (value)} を決定するために用いられます。

最初のオブジェクトがインスタンスである場合、例外の型はインスタンス
のクラスになり、インスタンス自体が例外の値になります。このとき
第二のオブジェクトは \code{None} でなければなりません。

最初のオブジェクトがクラスの場合、例外の型になります。
第二のオブジェクトは、例外の値を決めるために使われます:
第二のオブジェクトがインスタンスならば、そのインスタンスが
例外の値になります。第二のオブジェクトがタプルの場合、
クラスのコンストラクタに対する引数リストとして使われます;
\code{None} なら、空の引数リストとして扱われ、それ以外の型
ならコンストラクタに対する単一の引数として扱われます。
このようにしてコンストラクタを呼び出して生成したインスタンス
が例外の値になります。

第三のオブジェクトが存在し、かつ \code{None} でなければ、
オブジェクトはトレースバック \obindex{traceback} オブジェクト
でなければなりません (~\ref{traceback} 節参照)。また、
例外が発生した場所は現在の処理位置に置き換えられます。
第三のオブジェクトが存在し、オブジェクトがトレースバック
オブジェクトでも \code{None} でもなければ、\exception{TypeError} 
例外が送出されます。\keyword{raise} の三連式型は、\keyword{except}
節から透過的に例外を再送出するのに便利ですが、再送出すべき
例外が現在のスコープで発生した最も新しいアクティブな例外で
ある場合には、式なしの \keyword{raise} を使うよう推奨します。

例外に関する追加情報は ~\ref{exceptions} 節にあります。また、
例外処理に関する情報は ~\ref{try} 節にあります。


\section{\keyword{break} 文 \label{break}}
\stindex{break}

\begin{productionlist}
  \production{break_stmt}
             {"break"}
\end{productionlist}

\keyword{break} 文は \keyword{for} ループや \keyword{while} ループ内の
ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義
には現れません。
\stindex{for}
\stindex{while}
\indexii{loop}{statement}

\keyword{break} 文は、文を囲う最も内側のループを終了させ、
ループにオプションの \keyword{else} 節がある場合には
 \keyword{else} 節に飛びます。
\kwindex{else}

\keyword{for} ループを \keyword{break} によって終了すると、
ループ制御ターゲットはその時の値を保持します。
\indexii{loop control}{target}

\keyword{break} が \keyword{finally} 節を伴う \keyword{try} 文の
外側に処理を渡す際には、ループを実際に抜ける前にその\keyword{finally} 
節が実行されます。
\kwindex{finally}


\section{\keyword{continue} 文 \label{continue}}
\stindex{continue}

\begin{productionlist}
  \production{continue_stmt}
             {"continue"}
\end{productionlist}

\keyword{continue} 文は \keyword{for} ループや \keyword{while} ループ内の
ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、
\keyword{finally} 文の中には現れません。\footnote{\keyword{except} 節や
 \keyword{else} 節中に置くことはできます。\keyword{try} 文に置けない
という制限は、実装側の不精によるもので、そのうち改善されることでしょう。}

\keyword{continue} 文は、文を囲う最も内側のループの次の周期に
処理を継続します。
\stindex{for}
\stindex{while}
\indexii{loop}{statement}
\kwindex{finally}


\section{\keyword{import} 文 \label{import}}
\stindex{import}
\index{module!importing}
\indexii{name}{binding}
\kwindex{from}

\begin{productionlist}
  \production{import_stmt}
             {"import" \token{module} ["as" \token{name}]
                ( "," \token{module} ["as" \token{name}] )*}
  \productioncont{| "from" \token{module} "import" \token{identifier}
                    ["as" \token{name}]}
  \productioncont{  ( "," \token{identifier} ["as" \token{name}] )*}
  \productioncont{| "from" \token{module} "import" "(" \token{identifier}
                    ["as" \token{name}]}
  \productioncont{  ( "," \token{identifier} ["as" \token{name}] )* [","] ")"}
  \productioncont{| "from" \token{module} "import" "*"}
  \production{module}
             {(\token{identifier} ".")* \token{identifier}}
\end{productionlist}

import 文は、(1) モジュールを探し、必要なら初期化 (initialize) する;
(\keyword{import} 文のあるスコープにおける) ローカルな名前空間で
名前を定義する、の二つの段階を踏んで初期化されます。
第一形式 (\keyword{from} のない形式) は、上記の段階をリスト中にある
各識別子に対して繰り返し実行していきます。
\keyword{from} のある形式では、(1) を一度だけ行い、次いで (2) を
繰り返し実行します。

組み込みモジュールや拡張モジュールの ``初期化'' は、ここでは
初期化関数の呼び出しを意味します。モジュールは初期化を行うために
かならず初期化関数を提供しなければなりません
(リファレンス実装では、関数名はモジュール名の前に ``init'' を
つけたものになっています);
Python で書かれたモジュールの ``初期化'' は、モジュール本体の
実行を意味します。

Python 処理系は、すでに初期化済みのモジュールや、初期化中のモジュール
をモジュール名でインデクス化したテーブルを維持しています。  
このテーブルは \code{sys.modules} からアクセスできます。
モジュール名がこのテーブル内にあるなら、段階 (1) は完了しています。
そうでなければ、処理系はモジュール定義の検索を開始します。モジュール
が見つかった場合、モジュールを読み込み (load) ます。モジュール検索や
読み込みプロセスの詳細は、実装やプラットフォームに依存します。
一般的には、ある名前のモジュールを検索する際、まず同名の
``組み込み (built-in)'' モジュールを探し、次に \code{sys.path}
で列挙されている場所を探します。
\withsubitem{(in module sys)}{\ttindex{modules}}
\ttindex{sys.modules}
\indexii{module}{name}
\indexii{built-in}{module}
\indexii{user-defined}{module}
\refbimodindex{sys}
\indexii{filename}{extension}
\indexiii{module}{search}{path}

組み込みモジュールが見つかった場合\indexii{module}{initialization} 、
組み込みの初期化コードが実行され、段階 (1) を完結します。
合致するファイルが見つからなかった場合、
\exception{ImportError}\exindex{ImportError} が送出されます。
\index{code block}
ファイルが見つかった場合、ファイルを構文解析して実行可能な
コードブロックにします。構文エラーが起きた場合、
\exception{SyntaxError}\exindex{SyntaxError} が送出されます。
それ以外の場合、まず指定された名前をもつ空のモジュールを作成し、
モジュールテーブルに挿入します。次に、このモジュールの実行コンテキスト
下でコードブロックを実行します。実行中に例外が発生すると、段階 (1)
を終了 (terminate) します。

段階 (1) が例外を送出することなく完了したなら、段階 (2) を開始
します。

\keyword{import} 文の第一形式は、ローカルな名前空間に置かれた
モジュール名をモジュールオブジェクトに束縛し、import すべき
次の識別子があればその処理に移ります。モジュール名の後ろに
\keyword{as} がある場合、\keyword{as} の後ろの名前はモジュールの
ローカルな名前として使われます。

\keyword{from} 形式は、モジュール名の束縛を行いません:
\keyword{from} 形式では、段階 (1) で見つかったモジュール内から、
識別子リストの各名前を順に検索し、見つかったオブジェクトを識別子の
名前でローカルな名前空間において束縛します。
\keyword{import} の第一形式と同じように、"\keyword{as} localname"
で別名を与えることができます。指定された名前が見つからない場合、
\exception{ImportError} が送出されます。識別子のリストを星印
(\character{*}) で置き換えると、モジュールで公開されている名前
(public name) 全てを \keyword{import} 文のある場所のローカルな
名前空間に束縛します。。。
\indexii{name}{binding}
\exindex{ImportError}

モジュールで \emph{公開されている名前 (public names)} は、
モジュールの名前空間内にある \code{__all__} という名前の変数
を調べて決定します; \code{__all__} が定義されている場合、
\code{__all__} はモジュールで定義されていたり、import されている
ような名前の文字列からなるシーケンスでなければなりません。
\code{__all__} 内にある名前は、全て公開された名前であり、
実在するものとみなされます。
\code{__all__} が定義されていない場合、モジュールの名前空間に
見つかった名前で、アンダースコア文字 (\character{_}) で始まっていない
全ての名前が公開された名前になります。
\code{__all__} には、公開されている API 全てを入れなければなりません。
\code{__all__} には、(モジュール内で import されて使われている
ライブラリモジュールのように) API を構成しない要素を意に反して
公開してしまうのを避けるという意図があります。
\withsubitem{(optional module attribute)}{\ttindex{__all__}}

\samp{*} を使った \keyword{from} 形式は、モジュールのスコープ内
だけに作用します。関数内でワイルドカードの import 文 ---
\samp{import *} --- を使い、関数が自由変数を伴うネストされたブロック
であったり、ブロックを含んでいる場合、コンパイラは
\exception{SyntaxError} を送出します。

\kwindex{from}
\stindex{from}

\strong{階層的なモジュール名:}\indexiii{hierarchical}{module}{names}
モジュール名に一つまたはそれ以上のドットが入っている場合、
モジュール検索パスは違った扱われ方をします。最後のドットまでの
各識別子からなる列は、``パッケージ (package)'' \index{packages}
を見つけるために使われます; 次に、パッケージ内から各識別子が
検索されます。パッケージとは、一般には \code{sys.path} 上のディレクトリ
のサブディレクトリで、\file{__init__.py}.\ttindex{__init__.py}
ファイルを持つものです。
%
[XXX この説明については、ここでは今のところこれ以上詳しく書けません;
詳細や、パッケージ内モジュールの検索がどのように行われるかは、
\url{http://www.python.org/doc/essays/packages.html} を参照
してください]

どのモジュールがロードされるべきかを動的に決めたいアプリケーションの
ために、組み込み関数 \function{__import__()} が提供されています;
詳細は、\citetitle[../lib/lib.html]{Python ライブラリリファレンス} の
\ulink{組み込み関数}{../lib/built-in-funcs.html} を参照してください。
\bifuncindex{__import__}

\subsection{future 文 (future statement) \label{future}}

\dfn{future 文}\indexii{future}{statement} は、
将来の特定の Python のリリースで利用可能になるような構文や意味付け
を使って、特定のモジュールをコンパイルさせるための、コンパイラに
対する指示句 (directive) です。
future 文は、言語仕様に非互換性がもたらされるような、将来の Python 
のバージョンに容易に移行できるよう意図されています。
future 文によって、新たな機能が標準化されたリリースが
出される前に、その機能をモジュール単位で使えるようにします。

\begin{productionlist}[*]
  \production{future_statement}
             {"from" "__future__" "import" feature ["as" name] ("," feature ["as" name])*}
  \productioncont{| "from" "__future__" "import" "(" feature ["as" name] ("," feature ["as" name])* [","] ")"}
  \production{feature}{identifier}
  \production{name}{identifier}
\end{productionlist}

future 文は、モジュールの先頭周辺に書かなければなりません。
future 文の前に書いてよい内容は:

\begin{itemize}

\item the module docstring (if any),
\item comments,
\item blank lines, and
\item other future statements.

\end{itemize}

です。

Python 2.3 が feature 文で新たに認識するようになった機能は、
\samp{generators}、\samp{division}、および \samp{nested_scopes}
です。 \samp{generators} および \samp{nested_scopes} は
Python 2.3 では常に有効になっているので、冗長な機能名といえます。

future 文は、コンパイル時に特別なやり方で認識され、扱われます:
言語の中核をなす構文構成 (construct) に対する意味付けが変更されて
いる場合、変更部分はしばしば異なるコードを生成することで実現
されています。新たな機能によって、(新たな予約語のような)
互換性のない新たな構文が取り入れられることさえあります。
この場合、コンパイラはモジュールを別のやりかたで解析する必要が
あるかもしれません。こうしたコード生成に関する決定は、
実行時まで先延ばしすることはできません。

これまでの全てのリリースにおいて、コンパイラはどの機能が定義済み
かを知っており、future 文に未知の機能が含まれている場合には
コンパイル時エラーを送出します。

future 文の実行時における直接的な意味付けは、import 文と同じです。
標準モジュール \module{__future__} があり、これについては後で述べます。
\module{__future__} は、future 文が実行される際に通常の方法で import 
されます。

future 文の実行時における特別な意味付けは、future 文で有効化される
特定の機能によって変わります。

以下の文:

\begin{verbatim}
import __future__ [as name]
\end{verbatim}

には、何ら特殊な意味はないので注意してください。

これは future 文ではありません; この文は通常の import 文であり、
その他の特殊な意味付けや構文的な制限はありません。

future 文の入ったモジュール \module{M} 内で使われている
\keyword{exec} 文、組み込み関数 \function{compile()} や \function{execfile()}
によってコンパイルされるコードは、デフォルトの設定では、
future 文に関係する新たな構文や意味付けを使うようになっています。
Python 2.2 からは、この仕様を \function{compile()} のオプション引数
で制御できるようになりました --- 詳細は 
\citetitle[../lib/built-in-funcs.html]{Python ライブラリリファレンス} で
この関数に関するドキュメントを参照してください。

対話的インタプリタのプロンプトでタイプ入力した future 文は、
その後のインタプリタセッション中で有効になります。インタプリタ
を \programopt{-i} オプションで起動して実行すべきスクリプト名を
渡し、スクリプト中に future 文を入れておくと、新たな機能は
スクリプトが実行された後に開始する対話セッションで有効になります。

\section{\keyword{global} 文 \label{global}}
\stindex{global}

\begin{productionlist}
  \production{global_stmt}
             {"global" \token{identifier} ("," \token{identifier})*}
\end{productionlist}

\keyword{global} 文は、現在のコードブロック全体で維持される宣言文
です。\keyword{global} 文は、列挙した識別子をグローバル変数として
解釈するよう指定することを意味します。
\keyword{global} を使わずにグローバル変数に代入を行うことは
不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずに
グローバル変数を参照することができます。
\indexiii{global}{name}{binding}

\keyword{global} 文で列挙する名前は、同じコードブロック中で、
プログラムテキスト上 \keyword{global} 文より前に使っては
なりません。

\keyword{global} 文で列挙する名前は、\keyword{for} ループの
ループ制御ターゲットや、\keyword{class} 定義、関数定義、
\keyword{import} 文内で仮引数として使ってはなりません。

(現在の実装では、後ろ二つの制限については強制していませんが、
プログラムでこの緩和された仕様を乱用すべきではありません。
将来の実装では、この制限を強制したり、暗黙のうちにプログラム
の意味付けを変更したりする可能性があります。)

\strong{プログラマのための注意点:}
\keyword{global} はパーザに対する指示句 (directive) です。
この指示句は、\keyword{global} 文と同時に読み込まれたコード
に対してのみ適用されます。特に、\keyword{exec} 文内に入っている
\keyword{global} 文は、\keyword{exec} 文を \emph{含んでいる}
コードブロック内に効果を及ぼすことはなく、\keyword{exec} 文内に
含まれているコードは、\keyword{exec} 文を含むコード内での
\keyword{global} 文に影響を受けません。同様のことが、関数
\function{eval()}、 \function{execfile()} 、および
 \function{compile()} にも当てはまります。
\stindex{exec}
\bifuncindex{eval}
\bifuncindex{execfile}
\bifuncindex{compile}


\section{\keyword{exec} 文 \label{exec}}
\stindex{exec}

\begin{productionlist}
  \production{exec_stmt}
             {"exec" \token{expression}
              ["in" \token{expression} ["," \token{expression}]]}
\end{productionlist}

この文は、Python コードの動的な実行をサポートします。
最初の式の値評価結果は文字列か、開かれたファイルオブジェクトか、
コードオブジェクトでなければなりません。文字列の場合、
一連の Python 実行文として解析し、(構文エラーが生じない限り)
実行します。開かれたファイルであれば、ファイルを \EOF{}
まで読んで解析し、実行します。コードオブジェクトなら、単にこれを実行します。全ての
場合で、実行されたコードはファイル入力として有効であることが
期待されます (セクション~\ref{file-input}、''ファイル入力''を参照)。
\keyword{return} と \keyword{yield} 文は、\keyword{exec} 文に
渡されたコードの文脈中においても関数定義の外では使われない点に
注意してください。


いずれの場合でも、オプションの部分が省略されると、コードは
現在のスコープ内で実行されます。\keyword{in} の後ろに一つだけ
式を指定する場合、その式は辞書でなくてはならず、
グローバル変数とローカル変数の両方に使われます。
これらはそれぞれグローバル変数とローカル変数として使われます。
\var{locals} を指定する場合は何らかのマップ型オブジェクトに
せねばなりません．
\versionchanged[以前は\var{locals} は辞書でなければなりませんでした]{2.4}

\keyword{exec} の副作用として実行されるコードで設定された変数名に
対応する名前の他に、追加のキーを辞書に追加することがあります。
例えば、現在の実装では、組み込みモジュール \module{__builtin__} 
の辞書に対する参照を、\code{__builtins__} (!) というキーで追加
することがあります。
\ttindex{__builtins__}
\refbimodindex{__builtin__}

\strong{プログラマのためのヒント:}
式の動的な評価は、組み込み関数 \function{eval()} でサポートされています
組み込み関数 \function{globals()} および \function{locals()} は、
それぞれ現在のグローバル辞書とローカル辞書を返すので、
\keyword{exec} に渡して使うと便利です。
\bifuncindex{eval}
\bifuncindex{globals}
\bifuncindex{locals}

  


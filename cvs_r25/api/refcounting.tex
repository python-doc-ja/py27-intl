\chapter{参照カウント \label{countingRefs}}


この節のマクロはPythonオブジェクトの参照カウントを管理するために使われます。


\begin{cfuncdesc}{void}{Py_INCREF}{PyObject *o}
  オブジェクト\var{o}に対する参照カウントを一つ増やします。オブジェクトが
  \NULL であってはいけません。それが\NULL ではないと確信が持てないならば、
  \cfunction{Py_XINCREF()}を使ってください。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_XINCREF}{PyObject *o}
  オブジェクト\var{o}に対する参照カウントを一つ増やします。オブジェクトが
  \NULL であってもよく、その場合マクロは何の影響も与えません。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_DECREF}{PyObject *o}
  オブジェクト\var{o}に対する参照カウントを一つ減らします。オブジェクトが
  \NULL であってはいけません。それが\NULL ではないと確信が持てないならば、
  \cfunction{Py_XDECREF()}を使ってください。参照カウントがゼロになったら、
  オブジェクトの型のメモリ解放関数(\NULL であってはならない)が呼ばれます。

  \warning{(例えば\method{__del__()}メソッドをもつクラスインスタンスが
  メモリ解放されたときに)メモリ解放関数は任意のPythonコードを呼び出すことが
  できます。このようなコードでは例外は伝播しませんが、実行されたコードは
  すべてのPythonグローバル変数に自由にアクセスできます。
  これが意味するのは、\cfunction{Py_DECREF()}が呼び出されるより前では、
  グローバル変数から到達可能などんなオブジェクトも一貫した状態に
  あるべきであるということです。
  例えば、リストからオブジェクトを削除するコードは削除するオブジェクト
  への参照を一時変数にコピーし、リストデータ構造を更新し、それから
  一時変数に対して\cfunction{Py_DECREF()}を呼び出すべきです。}
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_XDECREF}{PyObject *o}
  オブジェクト\var{o}への参照カウントを一つ減らします。オブジェクトは
  \NULL でもかまいませんが、その場合マクロは何の影響も与えません。それ以外の
  場合、結果は\cfunction{Py_DECREF()}と同じです。また、注意すべきことも
  同じです。
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_CLEAR}{PyObject *o}
\var{o} の参照カウントを減らします．オブジェクトは \NULL でもよく，
その場合このマクロは何も行いません．オブジェクトが \NULL でなければ，
引数を \NULL にした\cfunction{Py_DECREF()} と同じ効果をもたらします．
このマクロは一時変数を使って，参照カウントをデクリメントする前に
引数を \NULL にセットしてくれるので，\cfunction{Py_DECREF()} に
使うときの警告を気にしなくてすみます．

ガベージコレクション中に追跡される可能性のある変数の参照デクリメントを
行うには，このマクロを使うのがよいでしょう．

\versionadded{2.4}
\end{cfuncdesc}

以下の関数:
\cfunction{Py_IncRef(PyObject *o)}, \cfunction{Py_DecRef(PyObject *o)}.
は，実行時の動的な Python 埋め込みで使われる関数です．
これらの関数はそれぞれ\cfunction{Py_XINCREF()} および
\cfunction{Py_XDECREF()} をエクスポートしただけです．


以下の関数やマクロ: 
\cfunction{_Py_Dealloc()}, \cfunction{_Py_ForgetReference()},
\cfunction{_Py_NewReference()}
は，インタプリタのコアの内部においてのみ使用するためのものです。
また、グローバル変数\cdata{_Py_RefTotal} も同様です。

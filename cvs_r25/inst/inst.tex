\documentclass{howtojp}
\usepackage{distutils}

% TODO:
%   Fill in XXX comments

\title{Python モジュールのインストール}

% The audience for this document includes people who don't know anything 
% about Python and aren't about to learn the language just in order to
% install and maintain it for their users, i.e. system administrators.
% Thus, I have to be sure to explain the basics at some point:
% sys.path and PYTHONPATH at least.  Should probably give pointers to
% other docs on "import site", PYTHONSTARTUP, PYTHONHOME, etc.
% 
% Finally, it might be useful to include all the material from my "Care
% and Feeding of a Python Installation" talk in here somewhere.  Yow!

\input{boilerplatejp}

\author{Greg Ward\\
日本語訳: Python ドキュメント翻訳プロジェクト}
\authoraddress{
	\strong{Python Software Foundation}\\
	Email: \email{distutils-sig@python.org}
}

\makeindex

\begin{document}

\maketitle

\begin{abstract}
\noindent
このドキュメントでは、 Python モジュール配布ユーティリティ
(Python Distribution Utilities, ``Distutils'') について、 
エンドユーザの視点に立ち、サードパーティ製のモジュールや
拡張モジュールの構築やインストールによって標準の Python に
機能を追加する方法について述べます。
\end{abstract}

%\begin{abstract}
%\noindent
%Abstract this!
%\end{abstract}


% The ugly "%begin{latexonly}" pseudo-environment suppresses the table
% of contents for HTML generation.
%
%begin{latexonly}
\tableofcontents
%end{latexonly}


\section{はじめに}
\label{intro}

Python の広範な標準ライブラリは、プログラミングにおける多くの
要求をカバーしていますが、時には何らかの新たな機能をサードパーティ製
モジュールの形で追加する必要に迫られます。
自分がプログラムを書くときのサポートとして必要な場合もあるし、
自分が使いたいアプリケーションがたまたま Python で書かれていて、
そのサポートとして必要な場合もあるでしょう。

以前は、すでにインストール済みの Python に対して、サードパーティ製
モジュールを追加するためのサポートはほとんどありませんでした。
しかしPython 配布ユーティリティ (Python Distribution Utilities, 
略して Distutils) が Python 2.0 から取り入れられ、状況は変わりました。

このドキュメントが主要な対象としているのは、サードパーティモジュール
をインストールする必要がある人たち: 単に何らかの Python アプリケーション
を稼動させたいだけのエンドユーザやシステム管理者、そしてすでに
Python プログラマであって、新たな道具を自分のツールキットに加えたい
と思っている人たちです。このドキュメントを読むために、 Python に
ついて知っておく必要はありません; インストールしたモジュールを
調べるために Python の対話モードにちょっとだけ手を出す必要が
ありますが、それだけです。自作の Python モジュールを他人が使える
ようにするために配布する方法を探しているのなら、
\citetitle[../dist/dist.html]{Python モジュールの配布} マニュアルを
参照してください。


\subsection{もっとも簡単な場合: ありふれたインストール作業}
\label{trivial-install}

最も楽なのは、インストールしたいモジュール配布物の特殊なバージョンを
インストールしたいプラットフォーム向けに誰かがすでに用意してくれていて、
他のアプリケーションと同じようにインストールするだけであるような場合です。
例えば Windows ユーザ向けには実行可能形式のインストーラ、
RPM ベースの Linux システム (Red Hat, SuSE, Mandrake その他多数) 
向けには RPM パッケージ、 Debian ベースの Linux システム向けには 
Debian パッケージといった具合に、モジュール開発者はビルド済み
配布物を作成しているかもしれません。

このような場合、自分のプラットフォームに合ったインストーラをダウンロード
して、実行可能形式なら実行し、RPM なら \code{rpm --install} するといった、
分かりきった作業をするだけです。
Python を起動したり、 setup スクリプトを実行する必要はなく、
何もコンパイルする必要はありません --- 説明書きを読む必要すら
全くないかもしれません (とはいえ、説明書きを読むのはよいことですが)。

もちろん、いつもこう簡単とは限りません。自分のプラットフォーム向けの
お手軽なインストーラがないモジュール配布物に興味を持つこともあるでしょう。
そんな場合には、モジュールの作者やメンテナがリリースしている
ソース配布物から作業をはじめねばなりません。
ソース配布物からのインストールは、モジュールが標準的な方法でパッケージ
化されている限りさほど大変ではありません。このドキュメントの大部分は、
標準的なソース配布物からのビルドとインストールに関するものです。

\subsection{新しい標準: Distutils}
\label{new-standard}

モジュールのソースコード配布物をダウンロードしたら、配布物が
標準のやり方、すなわち Distutils のやり方に従ってパッケージされて
配布されているかどうかすぐに分かります。Distutils の場合、まず配布物の
名前とバージョン番号が、例えば \file{foo-1.0.tar.gz} や
 \file{widget-0.9.7.zip} のように、ダウンロードされたアーカイブファイルの
名前にはっきりと反映されます。次に、アーカイブは同様の名前の
ディレクトリ、例えば \file{foo-1.0} や \file{widget-0.9.7} に展開されます。
さらに、配布物には setup スクリプト \file{setup.py} が入っています。
また、\file{README.txt} 場合によっては \file{README} という名前の
ファイルも入っていて、そこには、モジュール配布物の構築とインストールは
簡単で、

\begin{verbatim}
python setup.py install
\end{verbatim}
%
とするだけだ、という説明が書かれているはずです。

上記の全てが当てはまるなら、ダウンロードしたものをビルドして
インストールする方法はすでに知っていることになります: 上記のコマンドを
実行するだけです。
非標準の方法でインストールを行ったり、ビルドプロセスをカスタマイズ
行いたいのでない限り、このマニュアルは必要ありません。
別の言葉で言えば、上のコマンドこそが、このマニュアルから習得すべき
全てということになります。


\section{標準的なビルド・インストール作業}
\label{standard-install}

\ref{new-standard} 節で述べたよいうに、 Distutils を使ったモジュール
配布物のビルドとインストールは、通常は単純なコマンド:

\begin{verbatim}
python setup.py install
\end{verbatim}
%
で行います。

\UNIX では、このコマンドをシェルプロンプトで行います; Windows では、
コマンドプロンプトウィンドウ (``DOS ボックス'') を開いて、そこで
行います; Mac OS X の場合、\command{Terminal} ウィンドウを開いて
シェルプロンプトを出してください。


\subsection{プラットフォームによる違い}
\label{platform-variations}

setup コマンドは常に配布物ルートディレクトリ、すなわちモジュールの
ソース配布物を展開した際のトップレベルのサブディレクトリ内で
実行しなければなりません。例えば、あるモジュールのソース配布物
\file{foo-1.0.tar.gz} を \UNIX{} システム上にダウンロードしたなら、
通常は以下の操作を行います:

\begin{verbatim}
gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
cd foo-1.0
python setup.py install
\end{verbatim}
%
Windows では、おそらく \file{foo-1.0.zip} をダウンロードしている
でしょう。アーカイブファイルを \file{C:\textbackslash{}Temp} に
ダウンロードしたのなら、(WinZip のような) グラフィカルユーザ
インタフェースつきのアーカイブ操作ソフトや、 (\program{unzip} や
\program{pkunzip} のような) コマンドラインツールを使って
アーカイブを展開します。次に、コマンドプロンプトウィンドウ
 (``DOS ボックス'') を開いて、以下を実行します:

\begin{verbatim}
cd c:\Temp\foo-1.0
python setup.py install
\end{verbatim}
%
% Mac OS 9 では、 \file{setup.py} スクリプトをダブルクリックします。
% ダイアログが表示されるので、ダイアログで \command{install} コマンドを
% 選択します。次に、 \command{run} ボタンを押すと、配布物をインストール
% します。ダイアログは動的に生成されるので、現在作業している配布物固有の
% コマンドやオプションがリスト表示されます。

\subsection{ビルド作業とインストール作業を分割する}
\label{splitting-up}

\code{setup.py install} を実行すると、一度の実行で全てのモジュールを
ビルドしてインストールします。段階的に作業をしたい場合 --- ビルド
プロセスをカスタマイズしたり、作業がうまくいかない場合に特に便利
です --- には、setup スクリプトに一度に一つづつ作業を行わせるよう
にできます。この機能は、ビルドとインストールを異なるユーザで
行う場合にも便利です --- 例えば、モジュール配布物をビルドしておいて
システム管理者に渡して (または、自分でスーパユーザになって) 、
インストールしたくなるかもしれません.

最初のステップでは全てをビルドしておき、次のステップで
全てをインストールするには、 setup スクリプトを二度起動します:

\begin{verbatim}
python setup.py build
python setup.py install
\end{verbatim}
%
この作業を行ってみれば、\command{install} コマンドを実行すると
まず \command{build} コマンドを実行し、さらに  --- この場合には --- 
\file{build} ディレクトリの中が全て最新の状態になっているので、
\command{build} は何も行わなくてよいと判断していることが
わかるでしょう。

インターネットからダウンロードしたモジュールをインストールしたい
だけなら、上のように作業を分割する機能は必要ないかもしれませんが、
この機能はより進んだ使い方をする際にはとても便利です。
自作の Python モジュールや拡張モジュールを配布することになれば、
個々の Distutils コマンドを自分で何度も実行することになるでしょう。


\subsection{ビルドの仕組み}
\label{how-build-works}

上で示唆したように、 \command{build} コマンドは、インストールすべき
ファイルを \emph{ビルドディレクトリ (build directory)} に置く働きが
あります。デフォルトでは、ビルドディレクトリは配布物ルート下の 
\file{build} になります; システムの処理速度に強いこだわりがあったり、
ソースツリーに指一本触れたくないのなら、\longprogramopt{build-base} 
オプションを使ってビルドディレクトリを変更できます。例えば:

\begin{verbatim}
python setup.py build --build-base=/tmp/pybuild/foo-1.0
\end{verbatim}
%
(あるいは、システム全体向け、あるいは個人用の Distutils 設定ファイルに
ディレクティブを書いて、永続的に設定を変えられます; ~\ref{config-files}
節を参照してください。)  通常は必要ない作業です。

ビルドツリーのデフォルトのレイアウトは以下のようになっています:

\begin{verbatim}
--- build/ --- lib/
または
--- build/ --- lib.<plat>/
               temp.<plat>/
\end{verbatim}
%
\code{<plat>} は、現在の OS/ハードウェアプラットフォームと
Python のバージョンを記述する短い文字列に展開されます。
第一の \file{lib} ディレクトリだけの形式は、 ``pure モジュール配布物''
--- すなわち、pure Python モジュールだけの入ったモジュール配布物 ---
の場合に使われます。モジュール配布物に何らかの拡張モジュール
(C/\Cpp{} で書かれたモジュール) が入っている場合、第二の \code{<plat>}
付きディレクトリが二つある形式が使われます。この場合、 
\file{temp.\filevar{plat}} ディレクトリには、コンパイル/リンク
過程で生成され、実際にはインストールされない一時ファイルが収められます。
どちらの場合にも、\file{lib} (または \file{lib.\filevar{plat}}) 
ディレクトリには、最終的にインストールされることになる全ての Python 
モジュール (pure Python モジュールおよび拡張モジュール) が入ります。

今後、 Python スクリプト、ドキュメント、バイナリ実行可能形式、
その他 Python モジュールやアプリケーションのインストール作業に
必要なディレクトリが追加されるかもしれません。


\subsection{インストールの仕組み}
\label{how-install-works}

\command{build} コマンドを実行した後 (明示的に実行した場合も、
\command{install} コマンドが代わりに実行してくれた場合も) は、
\command{install} コマンドの仕事は比較的単純なもの: \file{build/lib}
(または \file{build/lib.\filevar{plat}}) の下にあるもの全ての
指定したインストールディレクトリへのコピー、になります。

インストールディレクトリを選ばなかった場合 --- すなわち、
\code{setup.py install} を実行しただけの場合 --- には、\command{install}
コマンドはサードパーティ製 Python モジュールを置くための標準の場所に
インストールを行います。この場所は、プラットフォームや、Python 自体を
どのようにビルド/インストールしたかで変わります。 \UNIX{} (と、\UNIX{}
をベースとしたMac OS X)
では、インストールしようとするモジュール配布物が pure Python なのか、
拡張モジュールを含む (``非 pure'') のかによっても異なります:
\begin{tableiv}{l|l|l|c}{textrm}%
  {プラットフォーム}{標準のインストール場所}{デフォルト値}{注記}
  \lineiv{\UNIX{} (pure)}
          {\filenq{\filevar{prefix}/lib/python\shortversion/site-packages}}
          {\filenq{/usr/local/lib/python\shortversion/site-packages}}
          {(1)}
  \lineiv{\UNIX{} (非 pure)}
          {\filenq{\filevar{exec-prefix}/lib/python\shortversion/site-packages}}
          {\filenq{/usr/local/lib/python\shortversion/site-packages}}
          {(1)}
  \lineiv{Windows}
          {\filenq{\filevar{prefix}}}
          {\filenq{C:\textbackslash{}Python}}
          {(2)}
\end{tableiv}

\noindent 注記:
\begin{description}
\item[(1)] ほとんどの Linux ディストリビューションには、システムの
標準インストール物として Python が入っているので、 Linux では普通、
\filevar{prefix} や \filevar{exec-prefix} はどちらも \file{/usr} 
になります。 Linux (または \UNIX ライクなシステム) 上で自分で Python 
をビルドした場合、デフォルトの \filevar{prefix} および
\filevar{exec-prefix} は \file{/usr/local} になります。
\item[(2)] Windows での Python のデフォルトインストールディレクトリは、
Python 1.6a1、 1.5.2、およびそれ以前のバージョンでは
\file{C:\textbackslash{}Program Files\textbackslash{}Python}
です。
\end{description}

\filevar{prefix} および \filevar{exec-prefix} は、 Python がインストール
されているディレクトリと、実行時にライブラリを探しにいく場所を表します。
これらのディレクトリは、Windows では常に同じで、 \UNIX と Mac OS X でも
ほぼ常に同じです。自分の Python がどんな \filevar{prefix} や
\filevar{exec-prefix} を使っているかは、Python を対話モードで起動して、
単純なコマンドをいくつか入力すればわかります。
Windows では、\menuselection{スタート \sub (すべての) プログラム \sub 
Python \shortversion \sub Python (command line)} を選びます。
Mac OS 9 では、 \file{PythonInterpreter} を起動します。
インタプリタを起動すると、プロンプトに Python コードを入力
できます。例えば、作者の使っている Linux システムで、三つの
Python 文を以下のように入力すると、出力から作者のシステムの
\filevar{prefix} と \filevar{exec-prefix} を得られます:

\begin{verbatim}
Python 2.4 (#26, Aug  7 2004, 17:19:02) 
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> sys.prefix
'/usr'
>>> sys.exec_prefix
'/usr'
\end{verbatim}

モジュールを標準の場所にインストールしたくない場合や、標準の場所に
インストールするためのファイル権限を持っていない場合、 ~\ref{alt-install}
節にある、別の場所へのインストール方法の説明を読んでください。
インストール先のディレクトリを大幅にカスタマイズしければ、
~\ref{custom-install} 節のカスタムインストールに関する説明を読んでください。


% This rather nasty macro is used to generate the tables that describe
% each installation scheme.  It's nasty because it takes two arguments
% for each "slot" in an installation scheme, there will soon be more
% than five of these slots, and TeX has a limit of 10 arguments to a
% macro.  Uh-oh.

\newcommand{\installscheme}[8]
  {\begin{tableiii}{l|l|l}{textrm}
          {ファイルの種類}
          {インストール先ディレクトリ}
          {オーバライドするためのオプション}
     \lineiii{pure モジュール配布物}
             {\filevar{#1}\filenq{#2}}
             {\longprogramopt{install-purelib}}
     \lineiii{非 pure モジュール配布物}
             {\filevar{#3}\filenq{#4}}
             {\longprogramopt{install-platlib}}
     \lineiii{スクリプト}
             {\filevar{#5}\filenq{#6}}
             {\longprogramopt{install-scripts}}
     \lineiii{データ}
             {\filevar{#7}\filenq{#8}}
             {\longprogramopt{install-data}}
   \end{tableiii}}


\section{別の場所へのインストール}
\label{alt-install}

しばしば、サードパーティ製 Python モジュールをインストールするための
標準の場所以外にモジュールをインストールしなければならなかったり、
単にそうしたくなるときがあります。例えば\UNIX{} システムでは、標準のサード
パーティ製モジュールディレクトリに対する書き込み権限を持っていないかも
しれません。または、あるモジュールを、ローカルで使っている Python に
標準のモジュールの一部として組み込む前にテストしてみたいと思う
かもしれません。既存の配布物をアップグレードする際には特にそうでしょう:
実際にアップグレードする前に、既存のスクリプトの基本となる部分が
新たなバージョンでも動作するか確認したいはずです。

Distutils の \command{install} コマンドは、別の場所へ配布物をインストール
する作業を単純で苦労のない作業にするように設計されています。
基本的なアイデアは、インストール先のベースディレクトリを指定しておき、
\command{install} コマンドがそのベースディレクトリ下にファイル群を
インストールするための一連のディレクトリ (\emph{インストールスキーム
: installation scheme}) を作成するというものです。
詳細はプラットフォームによって異なるので、以下の節から自分の
プラットフォームに当てはまるものを読んでください。


\subsection{別の場所へのインストール: home スキーム}
\label{alt-install-prefix}


``home スキーム'' の背後にある考え方は、Python モジュールを
個人用のモジュール置き場でビルドし、維持するというものです。
このスキームの名前は \UNIX の「ホーム」ディレクトリの概念から
とりました。というのも、 \UNIX のユーザにとって、自分のホーム
ディレクトリを\file{/usr/} や \file{/usr/local/} のようにレイアウト
するのはよくあることだからです。とはいえ、このスキームはどの
オペレーティングシステムのユーザでも使えます。
新たなモジュールのインストールは単純で、

\begin{verbatim}
python setup.py install --home=<dir>
\end{verbatim}
%
のようにします。このとき、\longprogramopt{home} オプションを使って
ディレクトリを指定します。面倒臭がりの人は、単にチルダ
(\code{\textasciitilde}) をタイプするだけでかまいません; 
\command{install} コマンドがチルダをホームディレクトリに
展開してくれます:

\begin{verbatim}
python setup.py install --home=~
\end{verbatim}
%
\longprogramopt{home} オプションは、インストールのベースディレクトリ
を指定します。ファイルはインストールベース下の以下のディレクトリに
保存されます:
\installscheme{home}{/lib/python}
              {home}{/lib/python}
              {home}{/bin}
              {home}{/share}


\versionchanged[\longprogramopt{home} は \UNIX でしかサポートされて
いませんでした]{2.4}


\subsection{別の場所へのインストール: \UNIX{} (prefix スキーム)}
\label{alt-install-home}

あるインストール済みの Python を使ってモジュールのビルド/インストール
を (例えば setup スクリプトを実行して) 行いたいけれども、
別のインストール済みの Python のサードパーティ製モジュール置き場
(あるいは、そう見えるようなディレクトリ構造) に、ビルドされた
モジュールをインストールしたい場合には、``prefix スキーム'' が
便利です。そんな作業はまったくありえそうにない、と思うなら、
確かにその通りです --- ``home スキーム'' を先に説明したのも
そのためです。とはいえ、prefix スキームが有用なケースは少なくとも
二つあります。

まず、多くの Linux ディストリビューションは、 Python を \file{/usr/local}
ではなく \file{/usr} に置いていることを考えてください。この場合は、
Python はローカルの計算機ごとのアドオン (add-on) ではなく、``システム''
の一部となっているので、\file{/usr} に置くのは全く正当なことです。
しかしながら、 Python モジュールをソースコードからインストール
していると、モジュールを \file{/usr/lib/python2.\filevar{X}}
ではなく \file{/usr/local/lib/python2.\filevar{X}} に置きたいと
思うかもしれません。これを行うには

\begin{verbatim}
/usr/bin/python setup.py install --prefix=/usr/local
\end{verbatim}
%
と指定します。

もう一つありえるのは、ネットワークファイルシステムにおいて、
遠隔のディレクトリに対する読み出しと書き込みの際に違う名前を使う
場合です。
例えば、 \file{/usr/local/bin/python} でアクセスするような Python 
インタプリタは、 \file{/usr/local/lib/python2.\filevar{X}} から
モジュールを探すでしょうが、モジュールは別の場所、例えば
\file{/mnt/\filevar{@server}/export/lib/python2.\filevar{X}} に
インストールしなければならないかもしれません。この場合には、

\begin{verbatim}
/usr/local/bin/python setup.py install --prefix=/mnt/@server/export
\end{verbatim}
%
のようにします。

どちらの場合も、\longprogramopt{prefix} オプションでインストール
ベースディレクトリを決め、 \longprogramopt{exec-prefix} で
プラットフォーム固有のファイル置き場名として使う、
プラットフォーム固有インストールベースディレクトリを決めます。
(プラットフォーム固有のファイルとは、現状では単に非 pure モジュール
配布物のことを意味しますが、 C ライブラリやバイナリ実行可能形式など
に拡張されるかもしれません。) \longprogramopt{exec-prefix} 
が指定されていなければ、デフォルトの \longprogramopt{prefix}
になります。ファイルは以下のようにインストールされます:

\installscheme{prefix}{/lib/python2.\filevar{X}/site-packages}
              {exec-prefix}{/lib/python2.\filevar{X}/site-packages}
              {prefix}{/bin}
              {prefix}{/share}

\longprogramopt{prefix} や \longprogramopt{exec-prefix} が実際に
他のインストール済み Python の場所を指している必要はありません;
上に挙げたディレクトリがまだ存在しなければ、インストール時に
作成されます。

ちなみに、prefix スキームが重要な本当の理由は、単に標準の \UNIX{} 
インストールが prefix スキームを使っているからです。ただし、
そのときには、 \longprogramopt{prefix} や \longprogramopt{exec-prefix} 
は Python 自体が \code{sys.prefix} や \code{sys.exec\_prefix} を使って
決めます。というわけで、読者は prefix スキームを決して使うことは
あるまいと思っているかもしれませんが、\code{python setup.py install} 
をオプションを何もつけずに実行していれば、常に prefix スキームを
使っていることになるのです。

拡張モジュールを別のインストール済み Python にインストールしても、
拡張モジュールのビルド方法による影響を受けることはありません:
特に、拡張モジュールをコンパイルする際には、
setup スクリプトを実行する際に使う Python インタプリタと一緒に
インストールされている Python ヘッダファイル (\file{Python.h} 
とその仲間たち) を使います。
上で述べてきたやり方でインストールされた拡張モジュールを実行する
インタプリタと、インタプリタをビルドする際に用いた別のインタプリタ
との互換性を保証するのはユーザの責任です。

これを行うには、二つのインタプリタが同じバージョンの Python  (ビルドが違って
いたり、同じビルドのコピーということもあり得ます) であるかどうかを
確かめます。(もちろん、\longprogramopt{prefix} や 
\longprogramopt{exec-prefix} が別のインストール済み Python の場所すら
指していなければどうにもなりません。)


\subsection{別の場所へのインストール (prefix を使う方法): Windows}
\label{alt-install-windows}

Windows はユーザのホームディレクトリという概念がなく、
Windows 環境下で標準的にインストールされた Python は \UNIX よりも
単純な構成をしているので、 Windows で追加のパッケージを別の場所に入れる
場合には、伝統的に \longprogramopt{prefix} が使われてきました。

\begin{verbatim}
python setup.py install --prefix="\Temp\Python"
\end{verbatim}
%
とすると、モジュールを現在のドライブの
\file{\textbackslash{}Temp\textbackslash{}Python} ディレクトリに
インストールします

インストールベースディレクトリは、 \longprogramopt{prefix} オプション
だけで決まります; \longprogramopt{exec-prefix} オプションは、Windows
ではサポートされていません。ファイルは以下のような構成でインストール
されます:
\installscheme{prefix}{}
              {prefix}{}
              {prefix}{\textbackslash{}Scripts}
              {prefix}{\textbackslash{}Data}


\section{カスタムのインストール}
\label{custom-install}

たまに、 \ref{alt-install} 節で述べたような別の場所へのインストール
スキームが、自分のやりたいインストール方法と違うことがあります。
もしかすると、同じベースディレクトリ下にあるディレクトリのうち、
一つか二つだけをいじりたかったり、インストールスキームを完全に
再定義したいと思うかもしれません。どちらの場合にせよ、こうした操作では
\emph{カスタムのインストールスキーム} を作成することになります。

別の場所へのインストールスキームに関するこれまでの説明で、
``オーバライドするためのオプション'' というコラムにお気づきかも
しれません。このオプションは、カスタムのインストールスキームを
定義するための手段です。各オーバライドオプションには、
相対パスを指定しても、絶対パスを指定しても、インストールベース
ディレクトリのいずれかを明示的に指定してもかまいません。
(インストールベースディレクトリは二種類あり、それら二つは通常は
同じディレクトリです --- \UNIX{} の ``prefix スキーム'' を使っていて、
\longprogramopt{prefix} と \longprogramopt{exec-prefix} オプションを
使っているときだけ異なります。)

例えば、 \UNIX 環境でモジュール配布物をホームディレクトリにインストール
したい --- とはいえ、スクリプトは \file{\textasciitilde/bin} ではなく
\file{\textasciitilde/scripts} に置きたい --- とします。
ご想像の通り、スクリプトを置くディレクトリは、
\longprogramopt{install-scripts} オプションで上書きできます;
この場合は相対パスで指定もでき、インストールベースディレクトリ
(この場合にはホームディレクトリ) からの相対パスとして解釈されます:

\begin{verbatim}
python setup.py install --home=~ --install-scripts=scripts
\end{verbatim}
%
\UNIX{} 環境での例をもう一つ紹介します: インストール済みの Python が、
\file{/usr/local/python} を prefix にしてビルドされ、インストール
されていて、標準のインストールスクリプトは \file{/usr/local/python/bin}
に入るようになっているとします。 \file{/usr/local/bin} に入るように
したければ、絶対パスを \longprogramopt{install-scripts} オプションに
与えて上書きすることになるでしょう:

\begin{verbatim}
python setup.py install --install-scripts=/usr/local/bin
\end{verbatim}
%
(この操作を行うと、 ``prefix スキーム'' を使ったインストールに
なり、 prefix は Python インタプリタがインストールされている場所
--- この場合には \file{/usr/local/python} になります。)

Windows 用の Python を管理しているのなら、サードパーティ製モジュール
を \filevar{prefix} そのものの下ではなく、 \filevar{prefix} の下
にあるサブディレクトリに置きたいと考えるかもしれません。
この作業は、インストールディレクトリのカスタマイズとほぼ同じくらい
簡単です --- 覚えておかねばならないのは、モジュールには二つのタイプ、
pure モジュールと非 pure モジュール (非 pure モジュール配布物内の
モジュール) があるということです。例えば以下のようにします:

\begin{verbatim}
python setup.py install --install-purelib=Site --install-platlib=Site
\end{verbatim}

指定したインストール先ディレクトリは、\filevar{prefix} からの相対です。
もちろん、\filevar{prefix} を \file{.pth} ファイルに入れるなどして、
これらのディレクトリが Python のモジュール検索パス内に入るように
しなければなりません。 Python のモジュール検索パスを修正する方法は、
~\ref{search-path} 節を参照してください。

インストールスキーム全体を定義したいのなら、全てのインストール
ディレクトリオプションを指定しなければなりません。この作業には、
相対パスを使った指定を勧めます; 例えば、全ての Python モジュール
関連ファイルをホームディレクトリ下の \file{python} ディレクトリの
下に置き、そのホームディレクトリをマウントしている各プラットフォーム
ごとに別のディレクトリを置きたければ、以下のようにインストールスキーム
を定義します:

\begin{verbatim}
python setup.py install --home=~ \
                        --install-purelib=python/lib \
                        --install-platlib=python/lib.$PLAT \
                        --install-scripts=python/scripts
                        --install-data=python/data
\end{verbatim}
% $ % -- bow to font-lock
%
また、以下のようにも指定できます:

\begin{verbatim}
python setup.py install --home=~/python \
                        --install-purelib=lib \
                        --install-platlib='lib.$PLAT' \
                        --install-scripts=scripts
                        --install-data=data
\end{verbatim}
% $ % -- bow to font-lock
%
\code{\$PLAT} は、(必ずしも) 環境変数ではありません --- 
この表記は、 Distutils がコマンドラインオプションの解釈と同じやり方
で展開します。設定ファイルを解釈する際と同じです。

言うまでもないことですが、毎回新たなモジュール配布物をインストールする
度にインストールスキーム全体の指定を行っていては面倒です。そこで、
オプションは Distutils 設定ファイル (\ref{config-files} 参照) にも
指定できます:

\begin{verbatim}
[install]
install-base=$HOME
install-purelib=python/lib
install-platlib=python/lib.$PLAT
install-scripts=python/scripts
install-data=python/data
\end{verbatim}
%
あるいは、以下のようにも指定できます:

\begin{verbatim}
[install]
install-base=$HOME/python
install-purelib=lib
install-platlib=lib.$PLAT
install-scripts=scripts
install-data=data
\end{verbatim}
%
これら二つは、 setup スクリプトを異なるインストールベースディレクトリ
から実行した場合には同じには \emph{ならない} ので注意してください。
例えば、

\begin{verbatim}
python setup.py --install-base=/tmp
\end{verbatim}
%
とすると、最初の書き方では pure モジュールが\filevar{/tmp/python/lib} 
に入り、二番目の書き方では \filevar{/tmp/lib} に入ります。(二番目の
ケースでは、インストールベースを \file{/tmp/python} に指定しようと
考えるでしょう。)

読者は、設定ファイル例で、入力値に \code{\$HOME} や \code{\$PLAT} を
使っていることに気づいているかもしれませんね。これらは Distutils の
設定変数で、環境変数を彷彿とさせます。実際、この表記が使える
プラットフォーム上では、設定ファイル中に環境変数を入れられますが、
Distutils は他にも、例えば \code{\$PLAT} のようにおそらくユーザの
環境中にないような変数をいくつか持っています。(そしてもちろん、
Mac OS 9 のような環境変数のないシステムでは、設定ファイル中で
使える変数は Distutils が提供しているものだけです。)

% XXX need some Windows examples---when would custom
% installation schemes be needed on those platforms?


% XXX I'm not sure where this section should go.
\subsection{Python サーチパスの変更}
\label{search-path}

Python インタプリタが \keyword{import} 文を実行するとき、
インタプリタは Python コードや拡張モジュールをモジュール検索パス
中から探します。検索パスのデフォルト値は、インタプリタをビルドする
際に Python のバイナリ内に設定されます。検索パスは、
\module{sys} を import して、 \code{sys.path} を出力すれば
わかります。

\begin{verbatim}
$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type ``help'', ``copyright'', ``credits'' or ``license'' for more information.
>>> import sys
>>> sys.path
['', '/usr/local/lib/python2.3', '/usr/local/lib/python2.3/plat-linux2', 
 '/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/python2.3/lib-dynload', 
 '/usr/local/lib/python2.3/site-packages']
>>>
\end{verbatim} % $ <-- bow to font-lock
%
\code{sys.path} 内の空文字列は、現在の作業ディレクトリを表します。

ローカルでインストールされるパッケージは、\file{.../site-packages/}
ディレクトリに入るのが決まりですが、ユーザはどこか任意のディレクトリに
Python モジュールをインストールしたいと思うかもしれません。
例えば、自分のサイトでは、 web サーバに関連する全てのソフトウェア
を \file{/www} に置くという決まりがあるかもしれません。そこで、
アドオンの Python モジュールが \file{/www/python} 置かれることに
なると、モジュールを import するためにはディレクトリを \code{sys.path}
に追加せねばなりません。ディレクトリを検索パスに追加するには、いくつか
の異なる方法が存在します。

最も手軽な方法は、パス設定ファイルをすでに Python の検索パスに
含まれるディレクトリ、通常は \file{.../site-packages/} ディレクトリ
に置くというものです。パス設定ファイルは拡張子が \file{.pth} で、
ファイルには \code{sys.path} に追加するパスを一行に一つづつ
記述しなければなりません。
(新たなパスは今の \code{sys.path} の後ろに追加されるので、追加された
ディレクトリ内にあるモジュールが標準のモジュールセットを上書き
することはありません。つまり、このメカニズムを使って、標準モジュール
に対する修正版のインストールはできないということです。)

パスは絶対パスでも相対パスでもよく、相対パスの場合には \file{.pth}
ファイルのあるパスからの相対になります。検索パスにディレクトリが追加
されると、今度はそのディレクトリに対して \file{.pth} ファイルを
検索します。詳しくは
\citetitle[http://www.python.org/dev/doc/devel/lib/module-site.html]
{\module{site} モジュールのドキュメント} を読んでください。

やや便利さには欠けますが、Python の標準ライブラリ中にある 
\file{site.py} ファイルを編集することでも、\code{sys.path} を変更
できます。\file{site.py} は、 \programopt{-S} スイッチを与えて
抑制しないかぎり、Python インタプリタが実行される際に自動的に import 
されます。ただし、設定するには、単に\file{site.py} を編集して、例えば
以下のような二行を加えます:

\begin{verbatim}
import sys
sys.path.append('/www/python/')
\end{verbatim}
%
しかしながら、(例えば 2.2 から 2.2.2 にアップグレードするときのように)
同じメジャーバージョンの Python を再インストールすると、
\file{site.py} は手持ちのバージョンで上書きされてしまいます。
ファイルが変更されていることを覚えておき、インストールを行う前に
コピーを忘れずとっておかねばなりません。

また、\code{sys.path} を修正できる二つの環境変数があります。
\envvar{PYTHONHOME} を使うと、インストールされている Python の
プレフィクスを別の値に設定できます。
例えば、 \envvar{PYTHONHOME} を \samp{/www/python} に設定すると、
検索パスは 
\code{['', '/www/python/lib/python\shortversion/', '/www/python/lib/python\shortversion/plat-linux2', ...]} といった具合になります。

\envvar{PYTHONPATH} を使うと、\code{sys.path} の先頭に一連の
パスを追加できます。例えば、\envvar{PYTHONPATH} を
\samp{/www/python:/opt/py} に設定すると、検索パスは
\code{['/www/python', '/opt/py']} から始まります。 
(\code{sys.path} にディレクトリを追加するには、そのディレクトリが
実在しなければなりません; \module{site} は実在しないディレクトリを
除去します。)

最後に、 \code{sys.path} はただの普通の Python のリストなので、
どんな Python アプリケーションもエントリを追加したり除去したりと
いった修正を行えます。


\section{Distutils 設定ファイル}
\label{config-files}

上で述べたように、 Distutils 設定ファイルを使えば、任意の 
Distutils オプションに対して個人的な設定やサイト全体の設定を
記録できます。すなわち、任意のコマンドの任意のオプションを
二つか三つ (プラットフォームによって異なります) の
設定ファイルに保存でき、コマンドラインを解釈する前にオプションを
問い合わせさせるようにできます。
つまり、設定ファイルはデフォルトの値を上書きし、さらにコマンドライン
上で与えた値が設定ファイルの内容を上書きするわけです。
さらに、複数の設定ファイルが適用されると、``先に'' 適用された
ファイルに指定されていた値は ``後に'' 適用されたファイル内の
値で上書きされます。


\subsection{設定ファイルの場所と名前}
\label{config-filenames}

設定ファイルの名前と場所は、非常にわずかですがプラットフォーム間で
異なります。\UNIX{} と Mac OS X では、三種類の設定ファイルは以下のようになります
(処理される順に並んでいます):
\begin{tableiii}{l|l|c}{textrm}
  {設定ファイルのタイプ}{場所とファイル名}{注記}
  \lineiii{system}{\filenq{\filevar{prefix}/lib/python\filevar{ver}/distutils/distutils.cfg}}{(1)}
  \lineiii{personal}{\filenq{\$HOME/.pydistutils.cfg}}{(2)}
  \lineiii{local}{\filenq{setup.cfg}}{(3)}
\end{tableiii}

Windows では設定ファイルは以下のようになります:
\begin{tableiii}{l|l|c}{textrm}
  {設定ファイルのタイプ}{場所とファイル名}{注記}
  \lineiii{system}{\filenq{\filevar{prefix}\textbackslash{}Lib\textbackslash{}distutils\textbackslash{}distutils.cfg}}{(4)}
  \lineiii{personal}{\filenq{\%HOME\%\textbackslash{}pydistutils.cfg}}{(5)}
  \lineiii{local}{\filenq{setup.cfg}}{(3)}
\end{tableiii}

\noindent 注記:
\begin{description}
\item[(1)] 厳密に言えば、システム全体向けの設定ファイルは、 Distutils
がインストールされているディレクトリになります; \UNIX の Python 1.6 
以降では、表の通りの場所になります。 Python 1.5.2 では、 Distutils は
通常 \file{\filevar{prefix}/lib/python1.5/site-packages/distutils}
にインストールされるため、 Python 1.5.2 では設定ファイルをそこに
置かなければなりません。
\item[(2)] \UNIX では、環境変数 \envvar{HOME} が定義されていない場合、
標準モジュール \ulink{\module{pwd}}{../lib/module-pwd.html} の
\function{getpwuid()} 関数を使ってユーザのホームディレクトリを決定します。
\item[(3)] 現在のディレクトリ (通常は setup スクリプトがある場所) です。
\item[(4)] (注記 (1) も参照してください)  Python 1.6 およびそれ以降の
バージョンでは、 Python のデフォルトの ``インストールプレフィクス''
は \file{C:\textbackslash{}Python} なので、システム設定ファイルは通常
\file{C:\textbackslash{}Python\textbackslash{}Lib\textbackslash{}distutils\textbackslash{}distutils.cfg} になります。Python 1.5.2 ではデフォルトの
プレフィクスは \file{C:\textbackslash{}Program~Files\textbackslash{}Python}
であり、Distutils は標準ライブラリの一部ではありません --- 従って、
システム設定ファイルは、 Windows 用の標準の Python 1.5.2 では
  \file{C:\textbackslash{}Program~Files\textbackslash{}Python\textbackslash{}distutils\textbackslash{}distutils.cfg} になります。
\item[(5)] Windows では、環境変数 \envvar{HOME} が設定されていない場合、
個人用の設定ファイルはどこにもなく、使われることもありません。
(言い換えれば、 Windows での Distutils はホームディレクトリが
どこにあるか一切推測しようとしないということです。)
\end{description}


\subsection{設定ファイルの構文}
\label{config-syntax}

Distutils 設定ファイルは、全て同じ構文をしています。
設定ファイルはセクションでグループ分けされています。
各 Distutils コマンドごとにセクションがあり、それに加えて
全てのコマンドに影響するグローバルオプションを設定するための
\code{global} セクションがあります。各セクションには
\code{option=value} の形で、一行あたり一つのオプションを指定します。

例えば、以下は全てのコマンドに対してデフォルトでメッセージを出さない
よう強制するための完全な設定ファイルです:

\begin{verbatim}
[global]
verbose=0
\end{verbatim}
%
この内容のファイルがシステム全体用の設定ファイルとしてインストール
されていれば、そのシステムの全てのユーザによる全ての Python モジュール
配布物に対する処理に影響します。ファイルが (個人用の設定をサポート
しているシステムで) 個人用の設定ファイルとしてインストールされていれば、
そのユーザが処理するモジュール配布物にのみ影響します。
この内容を特定のモジュール配布物の \file{setup.cfg} として使えば、
その配布物だけに影響します。

以下のようにして、デフォルトの ``ビルドベース'' ディレクトリを
オーバライドしたり、\command{build*} コマンドが常に強制的にリビルドを
行うようにもできます:

\begin{verbatim}
[build]
build-base=blib
force=1
\end{verbatim}
%
この設定は、コマンドライン引数の

\begin{verbatim}
python setup.py build --build-base=blib --force
\end{verbatim}
%
に対応します。ただし、後者ではコマンドライン上で \command{build} 
コマンドを含めて、そのコマンドを実行するよう意味しているところが
違います。
特定のコマンドに対するオプションを設定ファイルに含めると、
このような関連付けの必要はなくなります;
あるコマンドが実行されると、そのコマンドに対するオプションが適用
されます。
(また、設定ファイル内からオプションを取得するような他のコマンドを
実行した場合、それらのコマンドもまた設定ファイル内の対応するオプション
の値を使います。)

あるコマンドに対するオプションの完全なリストは、
例えば以下のように、\longprogramopt{help} を使って調べます:

\begin{verbatim}
python setup.py build --help
\end{verbatim}
%
グローバルオプションの完全なリストを得るには、コマンドを指定せずに
\longprogramopt{help} オプションを使います:

\begin{verbatim}
python setup.py --help
\end{verbatim}
%
``Python モジュールの配布'' マニュアルの、
``リファレンスマニュアル'' の節も参照してください。

\section{拡張モジュールのビルド: 小技と豆知識}
\label{building-ext}

Distutils は、可能なときにはいつでも、 \file{setup.py} スクリプトを
実行する Python インタプリタが提供する設定情報を使おうとします。
例えば、拡張モジュールをコンパイルする際には、コンパイラやリンカの
フラグには Python をコンパイルした際と同じものが使われます。
通常、この設定はうまくいきますが、状況が複雑になると不適切な
設定になることもあります。この節では、通常の Distutils の動作を
オーバライドする方法について議論します。

\subsection{コンパイラ/リンカのフラグをいじるには}
\label{tweak-flags}

C や \Cpp{} で書かれた Python 拡張をコンパイルする際、しばしば
特定のライブラリを使ったり、特定の種類のオブジェクトコードを
生成したりする上で、コンパイラやリンカに与えるフラグをカスタマイズ
する必要があります。ある拡張モジュールが自分のプラットフォームでは
テストされていなかったり、クロスコンパイルを行わねばならない
場合にはこれが当てはまります。

最も一般的なケースでは、拡張モジュールの作者はすでに
拡張モジュールのコンパイルが複雑になることを見越していて、
\file{Setup} ファイルを提供して編集できるようにしています。
\file{Setup} ファイルの編集は、モジュール配布物に多くの個別の拡張
モジュールがあったり、コンパイラに拡張モジュールをコンパイルさせる
ために細かくフラグをセットする必要があるような場合にのみ行うことに
なるでしょう。

\file{Setup} ファイルが存在する場合、ビルドするべき拡張モジュールの
リストを得るために解釈されます。\file{Setup} ファイルの各行には
単一のモジュールを書きます。各行は以下のような構造をとります:

\begin{alltt}
\var{module} ... [\var{sourcefile} ...] [\var{cpparg} ...] [\var{library} ...]
\end{alltt}
%
次に、各フィールドについて見てみましょう。

\begin{itemize}

\item \var{module} はビルドする拡張モジュールの名前で、Python の
識別子名として有効でなければなりません。モジュールの名前変更は、
このフィールドを変えるだけではできない (ソースコードの編集も必要です) 
ので、このフィールドに手を加えるべきではありません。

\item \var{sourcefile} は、少なくともファイル名から何の言語で書かれて
いるかがわかるようになっているソースコードファイル名です。
\file{.c} で終わるファイルは C で書かれているとみなされ、
\file{.C}、\file{.cc}、および \file{.c++} で終わるファイルは
\Cpp{} で書かれているとみなされます。\file{.m} や \file{.mm} で
終わるファイルは Objective C で書かれているとみなされます。

\item \var{cpparg} は C プリプロセッサへの引数で、
\programopt{-I}、 \programopt{-D}、\programopt{-U} または \programopt{-C}
のいずれかから始まる文字列です。

\item \var{library} は \file{.a} で終わるか、
\programopt{-l} または \programopt{-L} のいずれかから始まる文字列です。
\end{itemize}

特定のプラットフォームにおいて、プラットフォーム上の特殊なライブラリ
が必要な場合、 \file{Setup} ファイルを編集して
\code{python setup.py build} を実行すればライブラリを追加できます。
例えば、以下の行

\begin{verbatim}
foo foomodule.c
\end{verbatim}
%
で定義されたモジュールを、自分のプラットフォーム上の数学ライブラリ
\file{libm.a} とリンクしなければならない場合、\file{Setup} 内の
行に \programopt{-lm} を追加するだけです:

\begin{verbatim}
foo foomodule.c -lm
\end{verbatim}
%
コンパイラやリンカ向けの任意のスイッチオプションは、
\programopt{-Xcompiler} \var{arg} や
\programopt{-Xlinker} \var{arg} オプションで与えます:

\begin{verbatim}
foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm
\end{verbatim}
%
\programopt{-Xcompiler} および \programopt{-Xlinker} の後にくる
オプションは、それぞれ適切なコマンドラインに追加されます。
従って、上の例では、コンパイラには \programopt{-o32} オプションが
渡され、リンカには \programopt{-shared} が渡されます。
コンパイラオプションに引数が必要な場合、複数の \programopt{-Xcompiler} 
オプションを与えます; 例えば、 \code{-x c++} を渡すには、
\file{Setup} ファイルには \code{-Xcompiler -x -Xcompiler c++}
を渡さねばなりません。

コンパイラフラグは、環境変数 \envvar{CFLAGS} の設定でも与えられます。
\envvar{CFLAGS} が設定されていれば、\file{Setup} ファイル内で指定
されているコンパイラフラグに \envvar{CFLAGS} の内容が追加されます。


\subsection{Windows で非 Microsoft コンパイラを使ってビルドするには\label{non-ms-compilers}}
\sectionauthor{Rene Liebscher}{R.Liebscher@gmx.de}

\subsubsection{Borland \Cpp}

この小節では、 Borland \Cpp{} コンパイラのバージョン 5.5 で
Distutils を使うために必要な手順について述べています。
%Should we mention that users have to create cfg-files for the compiler?
%see also http://community.borland.com/article/0,1410,21205,00.html 

まず、 Borland のオブジェクトファイル形式 (OMF)
は、Python 公式サイトや ActiveState の Web サイトからダウンロード
できるバージョンの Python が使っている形式とは違うことを知って
おかねばなりません (Python は通常、 Microsoft Visual \Cpp{} でビルド
されています。Microsoft Visual \Cpp{} は COFF をオブジェクトファイル
形式に使います。)
このため、以下のようにして、 Python のライブラリ \file{python25.lib} 
を Borland の形式に変換する必要があります:

\begin{verbatim}
coff2omf python25.lib python25_bcpp.lib
\end{verbatim}
%
\file{coff2omf} プログラムは、 Borland コンパイラに付属しています。
\file{python25.lib} は Python インストールディレクトリの \file{Libs} 
ディレクトリ内にあります。拡張モジュールで他のライブラリ (zlib, ...)
を使っている場合、それらのライブラリも変換しなければなりません。

変換されたファイルは、通常のライブラリと同じディレクトリに置かねば
なりません。

さて、 Distutils は異なる名前を持つこれらのライブラリをどのように
扱うのでしょうか? 拡張モジュールで (例えば \file{foo} という名の)
ライブラリが必要な場合、 Distutils はまず \file{_bcpp} が後ろに
付いたライブラリ (例えば \file{foo_bcpp.lib}) が見つかるかどうか
調べ、あればそのライブラリを使います。該当するライブラリがなければ、
デフォルトの名前 (\file{foo.lib}) を使います\footnote{
つまり、全ての既存の COFF ライブラリを同名の OMF ライブラリに
置き換えてもかまわないということです}。

Borland \Cpp{} を使って Distutils に拡張モジュールをコンパイル
させるには、以下のように入力します:

\begin{verbatim}
python setup.py build --compiler=bcpp
\end{verbatim}

Borland \Cpp{} コンパイラをデフォルトにしたいなら、自分用、または
システム全体向けに、 Distutils の設定ファイルを書くことを検討した
方がよいでしょう (~\ref{config-files} 節を参照してください)。

\begin{seealso}
  \seetitle[http://www.borland.com/bcppbuilder/freecompiler/]
    {\Cpp{}Builder Compiler}
    {Borland によるフリーの \Cpp{} コンパイラに関する情報で、
コンパイラのダウンロードページへのリンクもあります。}

  \seetitle[http://www.cyberus.ca/\%7eg_will/pyExtenDL.shtml]
    {Creating Python Extensions Using Borland's Free Compiler}
    {Borland 製のフリーのコマンドライン \Cpp{} を使って Python を
ビルドする方法について述べたドキュメントです。}
\end{seealso}


\subsubsection{GNU C / Cygwin / MinGW}

この手引きは2.4.1 以降のPython と 3.0.0 (binutils-2.13.90-20030111-1)
以上の MinGW でのみ有効です。

この節では、 Cygwin や MinGW \footnote{詳しくは
\url{http://sources.redhat.com/cygwin/} や
\url{http://www.mingw.org/} を参照してください}
配布物中の GNU C/\Cpp{} コンパイラ
で Distutils を使うために必要な手順について述べます。
Cygwin 向けにビルドされている Python インタプリタを使っているなら、
以下の手順をとらなくても Distutils はまったく問題なく動作します。

上記のコンパイラは、いくつかの特殊なライブラリを必要とします。
この作業は Borland の \Cpp{} よりもやや複雑です。というのは、
ライブラリを変換するためのプログラムが存在しないからです。
% I don't understand what the next line means. --amk
% (inclusive the references on data structures.)
 
まず、 Python DLL が公開している全てのシンボルからなるリストを
作成しなければなりません。 (この作業むけのプログラムは、
\url{http://starship.python.net/crew/kernr/mingw32/Notes.html}
にあります。そのページで PExports 0.42h を探してください。)

\begin{verbatim}
pexports python25.dll >python25.def
\end{verbatim}
%
これで、上で得られた情報をもとに、 gcc 用の import ライブラリを作成
できます。

インストールされた \file{python25.dll}の位置はインストールオプションと、
Windowsのバージョンと言語に依存します。''自分だけのため''のインストー
ルの場合には、インストールディレクトリのルートに配置されます。
共有インストールの場合にはシステムディレクトリに配置されます。
 
\begin{verbatim}
dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a
\end{verbatim}
%
出来上がったライブラリは、 \file{python25.lib} と同じディレクトリ
(Python インストールディレクトリの \file{libs} ディレクトリに
なるはずです) に置かなければなりません。 

拡張モジュールが他のライブラリ (zlib, ... ) を必要とする場合、
それらのライブラリも変換しなければなりません。
変換されたファイルは、それぞれ通常のライブラリが置かれているのと
同じディレクトリに置かねばなりません。

Cygwin を使って Distutils に拡張モジュールをコンパイルさせるには、

\begin{verbatim}
python setup.py build --compiler=cygwin
\end{verbatim}
%
のように入力します。また、非 cygwin モードの Cygwin \footnote{
このモードでは \POSIX{} エミュレーションを利用できませんが、
\file{cygwin1.dll} も必要なくなります。} や MinGW では、
 
\begin{verbatim}
python setup.py build --compiler=mingw32
\end{verbatim}
%
のように入力します。

上記のオプションやコンパイラをデフォルトにしたいなら、自分用、または
システム全体向けに、 Distutils の設定ファイルを書くことを検討した
方がよいでしょう (~\ref{config-files} 節を参照してください)。

\begin{seealso}
  \seetitle[http://www.zope.org/Members/als/tips/win32_mingw_modules]
    {Building Python modules on MS Windows platform with MinGW}
    {MinGW 環境で必要なライブラリのビルドに関する情報があります。}

  \seeurl{http://pyopengl.sourceforge.net/ftp/win32-stuff/}
    {Cygwin/MinGW および Borland 形式に変換済みの import ライブラリと、
Distutils がビルド済みの Python の場所を特定するために必要なレジストリ
エントリを作成するためのスクリプトがあります。}
\end{seealso}

\section{日本語訳について}
\input{jptranslation}

\end{document}

--- r262/tutorial/introduction.rst	2009-04-06 06:21:05.082173000 +0900
+++ r266/tutorial/introduction.rst	2010-03-22 04:34:26.632505000 +0900
@@ -129,39 +129,37 @@
 
    >>> a=3.0+4.0j
    >>> float(a)
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: can't convert complex to float; use abs(z)
    >>> a.real
    3.0
    >>> a.imag
    4.0
    >>> abs(a)  # sqrt(a.real**2 + a.imag**2)
    5.0
-   >>>
 
 In interactive mode, the last printed expression is assigned to the variable
 ``_``.  This means that when you are using Python as a desk calculator, it is
 somewhat easier to continue calculations, for example::
 
    >>> tax = 12.5 / 100
    >>> price = 100.50
    >>> price * tax
    12.5625
    >>> price + _
    113.0625
    >>> round(_, 2)
    113.06
-   >>>
 
 This variable should be treated as read-only by the user.  Don't explicitly
 assign a value to it --- you would create an independent local variable with the
 same name masking the built-in variable with its magic behavior.
 
 
 .. _tut-strings:
 
 Strings
 -------
 
 Besides numbers, Python can also manipulate strings, which can be expressed in
@@ -184,56 +182,62 @@
 be used, with a backslash as the last character on the line indicating that the
 next line is a logical continuation of the line::
 
    hello = "This is a rather long string containing\n\
    several lines of text just as you would do in C.\n\
        Note that whitespace at the beginning of the line is\
     significant."
 
    print hello
 
 Note that newlines still need to be embedded in the string using ``\n``; the
 newline following the trailing backslash is discarded.  This example would print
-the following::
+the following:
+
+.. code-block:: text
 
    This is a rather long string containing
    several lines of text just as you would do in C.
        Note that whitespace at the beginning of the line is significant.
 
 Or, strings can be surrounded in a pair of matching triple-quotes: ``"""`` or
 ``'''``.  End of lines do not need to be escaped when using triple-quotes, but
 they will be included in the string. ::
 
    print """
    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
    """
 
-produces the following output::
+produces the following output:
+
+.. code-block:: text
 
    Usage: thingy [OPTIONS]
         -h                        Display this usage message
         -H hostname               Hostname to connect to
 
 If we make the string literal a "raw" string, ``\n`` sequences are not converted
 to newlines, but the backslash at the end of the line, and the newline character
 in the source, are both included in the string as data.  Thus, the example::
 
    hello = r"This is a rather long string containing\n\
    several lines of text much as you would do in C."
 
    print hello
 
-would print::
+would print:
+
+.. code-block:: text
 
    This is a rather long string containing\n\
    several lines of text much as you would do in C.
 
 The interpreter prints the result of string operations in the same way as they
 are typed for input: inside quotes, and with quotes and other funny characters
 escaped by backslashes, to show the precise value.  The string is enclosed in
 double quotes if the string contains a single quote and no double quotes, else
 it's enclosed in single quotes.  (The :keyword:`print` statement, described
 later, can be used to write strings without quotes or escapes.)
 
 Strings can be concatenated (glued together) with the ``+`` operator, and
@@ -276,29 +280,29 @@
 
    >>> word[:2]    # The first two characters
    'He'
    >>> word[2:]    # Everything except the first two characters
    'lpA'
 
 Unlike a C string, Python strings cannot be changed.  Assigning to an indexed
 position in the string results in an error::
 
    >>> word[0] = 'x'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
-   TypeError: object doesn't support item assignment
+   TypeError: object does not support item assignment
    >>> word[:1] = 'Splat'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
-   TypeError: object doesn't support slice assignment
+   TypeError: object does not support slice assignment
 
 However, creating a new string with the combined content is easy and efficient::
 
    >>> 'x' + word[1:]
    'xelpA'
    >>> 'Splat' + word[4]
    'SplatA'
 
 Here's a useful invariant of slice operations: ``s[:i] + s[i:]`` equals ``s``.
 ::
 
    >>> word[:2] + word[2:]
@@ -510,24 +514,30 @@
    'spam'
    >>> a[3]
    1234
    >>> a[-2]
    100
    >>> a[1:-1]
    ['eggs', 100]
    >>> a[:2] + ['bacon', 2*2]
    ['spam', 'eggs', 'bacon', 4]
    >>> 3*a[:3] + ['Boo!']
    ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']
 
+All slice operations return a new list containing the requested elements.  This
+means that the following slice returns a shallow copy of the list *a*::
+
+   >>> a[:]
+   ['spam', 'eggs', 100, 1234]
+
 Unlike strings, which are *immutable*, it is possible to change individual
 elements of a list::
 
    >>> a
    ['spam', 'eggs', 100, 1234]
    >>> a[2] = a[2] + 23
    >>> a
    ['spam', 'eggs', 123, 1234]
 
 Assignment to slices is also possible, and this can even change the size of the
 list or clear it entirely::
 

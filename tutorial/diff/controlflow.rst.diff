--- r262/tutorial/controlflow.rst	2009-01-04 06:55:17.853888000 +0900
+++ r266/tutorial/controlflow.rst	2009-11-24 01:39:46.597661000 +0900
@@ -185,31 +185,31 @@
 
 .. _tut-functions:
 
 Defining Functions
 ==================
 
 We can create a function that writes the Fibonacci series to an arbitrary
 boundary::
 
    >>> def fib(n):    # write Fibonacci series up to n
    ...     """Print a Fibonacci series up to n."""
    ...     a, b = 0, 1
-   ...     while b < n:
-   ...         print b,
+   ...     while a < n:
+   ...         print a,
    ...         a, b = b, a+b
    ...
    >>> # Now call the function we just defined:
    ... fib(2000)
-   1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
+   0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
 
 .. index::
    single: documentation strings
    single: docstrings
    single: strings, documentation
 
 The keyword :keyword:`def` introduces a function *definition*.  It must be
 followed by the function name and the parenthesized list of formal parameters.
 The statements that form the body of the function start at the next line, and
 must be indented.
 
 The first statement of the function body can optionally be a string literal;
@@ -235,100 +235,109 @@
 local symbol table is created for that call.
 
 A function definition introduces the function name in the current symbol table.
 The value of the function name has a type that is recognized by the interpreter
 as a user-defined function.  This value can be assigned to another name which
 can then also be used as a function.  This serves as a general renaming
 mechanism::
 
    >>> fib
    <function fib at 10042ed0>
    >>> f = fib
    >>> f(100)
-   1 1 2 3 5 8 13 21 34 55 89
+   0 1 1 2 3 5 8 13 21 34 55 89
 
 Coming from other languages, you might object that ``fib`` is not a function but
 a procedure since it doesn't return a value.  In fact, even functions without a
 :keyword:`return` statement do return a value, albeit a rather boring one.  This
 value is called ``None`` (it's a built-in name).  Writing the value ``None`` is
 normally suppressed by the interpreter if it would be the only value written.
 You can see it if you really want to using :keyword:`print`::
 
    >>> fib(0)
    >>> print fib(0)
    None
 
 It is simple to write a function that returns a list of the numbers of the
 Fibonacci series, instead of printing it::
 
    >>> def fib2(n): # return Fibonacci series up to n
    ...     """Return a list containing the Fibonacci series up to n."""
    ...     result = []
    ...     a, b = 0, 1
-   ...     while b < n:
-   ...         result.append(b)    # see below
+   ...     while a < n:
+   ...         result.append(a)    # see below
    ...         a, b = b, a+b
    ...     return result
    ...
    >>> f100 = fib2(100)    # call it
    >>> f100                # write the result
-   [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
+   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
 
 This example, as usual, demonstrates some new Python features:
 
 * The :keyword:`return` statement returns with a value from a function.
   :keyword:`return` without an expression argument returns ``None``. Falling off
   the end of a function also returns ``None``.
 
-* The statement ``result.append(b)`` calls a *method* of the list object
+* The statement ``result.append(a)`` calls a *method* of the list object
   ``result``.  A method is a function that 'belongs' to an object and is named
   ``obj.methodname``, where ``obj`` is some object (this may be an expression),
   and ``methodname`` is the name of a method that is defined by the object's type.
   Different types define different methods.  Methods of different types may have
   the same name without causing ambiguity.  (It is possible to define your own
-  object types and methods, using *classes*, as discussed later in this tutorial.)
+  object types and methods, using *classes*, see :ref:`tut-classes`)
   The method :meth:`append` shown in the example is defined for list objects; it
   adds a new element at the end of the list.  In this example it is equivalent to
-  ``result = result + [b]``, but more efficient.
+  ``result = result + [a]``, but more efficient.
 
 
 .. _tut-defining:
 
 More on Defining Functions
 ==========================
 
 It is also possible to define functions with a variable number of arguments.
 There are three forms, which can be combined.
 
 
 .. _tut-defaultargs:
 
 Default Argument Values
 -----------------------
 
 The most useful form is to specify a default value for one or more arguments.
 This creates a function that can be called with fewer arguments than it is
 defined to allow.  For example::
 
    def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
        while True:
            ok = raw_input(prompt)
-           if ok in ('y', 'ye', 'yes'): return True
-           if ok in ('n', 'no', 'nop', 'nope'): return False
+           if ok in ('y', 'ye', 'yes'):
+               return True
+           if ok in ('n', 'no', 'nop', 'nope'):
+               return False
            retries = retries - 1
-           if retries < 0: raise IOError, 'refusenik user'
+           if retries < 0:
+               raise IOError('refusenik user')
            print complaint
 
-This function can be called either like this: ``ask_ok('Do you really want to
-quit?')`` or like this: ``ask_ok('OK to overwrite the file?', 2)``.
+This function can be called in several ways:
+
+* giving only the mandatory argument:
+  ``ask_ok('Do you really want to quit?')``
+* giving one of the optional arguments:
+  ``ask_ok('OK to overwrite the file?', 2)``
+* or even giving all arguments:
+  ``ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')``
 
 This example also introduces the :keyword:`in` keyword. This tests whether or
 not a sequence contains a certain value.
 
 The default values are evaluated at the point of function definition in the
 *defining* scope, so that ::
 
    i = 5
 
    def f(arg=i):
        print arg
 

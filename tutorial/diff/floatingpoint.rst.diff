--- r262/tutorial/floatingpoint.rst	2008-05-26 09:54:22.113301000 +0900
+++ r266/tutorial/floatingpoint.rst	2009-10-27 22:28:11.423643000 +0900
@@ -56,41 +56,41 @@
 
 On most machines today, that is what you'll see if you enter 0.1 at a Python
 prompt.  You may not, though, because the number of bits used by the hardware to
 store floating-point values can vary across machines, and Python only prints a
 decimal approximation to the true decimal value of the binary approximation
 stored by the machine.  On most machines, if Python were to print the true
 decimal value of the binary approximation stored for 0.1, it would have to
 display ::
 
    >>> 0.1
    0.1000000000000000055511151231257827021181583404541015625
 
-instead!  The Python prompt uses the builtin :func:`repr` function to obtain a
+instead!  The Python prompt uses the built-in :func:`repr` function to obtain a
 string version of everything it displays.  For floats, ``repr(float)`` rounds
 the true decimal value to 17 significant digits, giving ::
 
    0.10000000000000001
 
 ``repr(float)`` produces 17 significant digits because it turns out that's
 enough (on most machines) so that ``eval(repr(x)) == x`` exactly for all finite
 floats *x*, but rounding to 16 digits is not enough to make that true.
 
 Note that this is in the very nature of binary floating-point: this is not a bug
 in Python, and it is not a bug in your code either.  You'll see the same kind of
 thing in all languages that support your hardware's floating-point arithmetic
 (although some languages may not *display* the difference by default, or in all
 output modes).
 
-Python's builtin :func:`str` function produces only 12 significant digits, and
+Python's built-in :func:`str` function produces only 12 significant digits, and
 you may wish to use that instead.  It's unusual for ``eval(str(x))`` to
 reproduce *x*, but the output may be more pleasant to look at::
 
    >>> print str(0.1)
    0.1
 
 It's important to realize that this is, in a real sense, an illusion: the value
 in the machine is not exactly 1/10, you're simply rounding the *display* of the
 true machine value.
 
 Other surprises follow from this one.  For example, after seeing ::
 
@@ -148,25 +148,25 @@
 :dfn:`Representation error` refers to the fact that some (most, actually)
 decimal fractions cannot be represented exactly as binary (base 2) fractions.
 This is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many
 others) often won't display the exact decimal number you expect::
 
    >>> 0.1
    0.10000000000000001
 
 Why is that?  1/10 is not exactly representable as a binary fraction. Almost all
 machines today (November 2000) use IEEE-754 floating point arithmetic, and
 almost all platforms map Python floats to IEEE-754 "double precision".  754
 doubles contain 53 bits of precision, so on input the computer strives to
-convert 0.1 to the closest fraction it can of the form *J*/2\*\**N* where *J* is
+convert 0.1 to the closest fraction it can of the form *J*/2**\ *N* where *J* is
 an integer containing exactly 53 bits.  Rewriting ::
 
    1 / 10 ~= J / (2**N)
 
 as ::
 
    J ~= 2**N / 10
 
 and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< 2**53``),
 the best value for *N* is 56::
 
    >>> 2**52

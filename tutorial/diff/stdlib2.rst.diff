--- r262/tutorial/stdlib2.rst	2009-01-04 06:55:17.853888000 +0900
+++ r266/tutorial/stdlib2.rst	2009-12-20 07:59:01.003699000 +0900
@@ -52,26 +52,26 @@
 
 The :mod:`locale` module accesses a database of culture specific data formats.
 The grouping attribute of locale's format function provides a direct way of
 formatting numbers with group separators::
 
    >>> import locale
    >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
    'English_United States.1252'
    >>> conv = locale.localeconv()          # get a mapping of conventions
    >>> x = 1234567.8
    >>> locale.format("%d", x, grouping=True)
    '1,234,567'
-   >>> locale.format("%s%.*f", (conv['currency_symbol'],
-   ...               conv['frac_digits'], x), grouping=True)
+   >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
+   ...                      conv['frac_digits'], x), grouping=True)
    '$1,234,567.80'
 
 
 .. _tut-templating:
 
 Templating
 ==========
 
 The :mod:`string` module includes a versatile :class:`Template` class with a
 simplified syntax suitable for editing by end-users.  This allows users to
 customize their applications without having to alter the application.
 
@@ -280,25 +280,25 @@
 
 Tools for Working with Lists
 ============================
 
 Many data structure needs can be met with the built-in list type. However,
 sometimes there is a need for alternative implementations with different
 performance trade-offs.
 
 The :mod:`array` module provides an :class:`array()` object that is like a list
 that stores only homogeneous data and stores it more compactly.  The following
 example shows an array of numbers stored as two byte unsigned binary numbers
 (typecode ``"H"``) rather than the usual 16 bytes per entry for regular lists of
-python int objects::
+Python int objects::
 
    >>> from array import array
    >>> a = array('H', [4000, 10, 700, 22222])
    >>> sum(a)
    26932
    >>> a[1:3]
    array('H', [10, 700])
 
 The :mod:`collections` module provides a :class:`deque()` object that is like a
 list with faster appends and pops from the left side but slower lookups in the
 middle. These objects are well suited for implementing queues and breadth first
 tree searches::
@@ -338,54 +338,57 @@
    >>> heappush(data, -5)                 # add a new entry
    >>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
    [-5, 0, 1]
 
 
 .. _tut-decimal-fp:
 
 Decimal Floating Point Arithmetic
 =================================
 
 The :mod:`decimal` module offers a :class:`Decimal` datatype for decimal
 floating point arithmetic.  Compared to the built-in :class:`float`
-implementation of binary floating point, the new class is especially helpful for
-financial applications and other uses which require exact decimal
-representation, control over precision, control over rounding to meet legal or
-regulatory requirements, tracking of significant decimal places, or for
-applications where the user expects the results to match calculations done by
-hand.
+implementation of binary floating point, the class is especially helpful for
+
+* financial applications and other uses which require exact decimal
+  representation,
+* control over precision,
+* control over rounding to meet legal or regulatory requirements,
+* tracking of significant decimal places, or
+* applications where the user expects the results to match calculations done by
+  hand.
 
 For example, calculating a 5% tax on a 70 cent phone charge gives different
 results in decimal floating point and binary floating point. The difference
 becomes significant if the results are rounded to the nearest cent::
 
    >>> from decimal import *
    >>> Decimal('0.70') * Decimal('1.05')
-   Decimal("0.7350")
+   Decimal('0.7350')
    >>> .70 * 1.05
    0.73499999999999999
 
 The :class:`Decimal` result keeps a trailing zero, automatically inferring four
 place significance from multiplicands with two place significance.  Decimal
 reproduces mathematics as done by hand and avoids issues that can arise when
 binary floating point cannot exactly represent decimal quantities.
 
 Exact representation enables the :class:`Decimal` class to perform modulo
 calculations and equality tests that are unsuitable for binary floating point::
 
    >>> Decimal('1.00') % Decimal('.10')
-   Decimal("0.00")
+   Decimal('0.00')
    >>> 1.00 % 0.10
    0.09999999999999995
 
    >>> sum([Decimal('0.1')]*10) == Decimal('1.0')
    True
    >>> sum([0.1]*10) == 1.0
    False
 
 The :mod:`decimal` module provides arithmetic with as much precision as needed::
 
    >>> getcontext().prec = 36
    >>> Decimal(1) / Decimal(7)
-   Decimal("0.142857142857142857142857142857142857")
+   Decimal('0.142857142857142857142857142857142857')
 
 

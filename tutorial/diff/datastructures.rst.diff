--- r262/tutorial/datastructures.rst	2009-04-06 06:21:05.082173000 +0900
+++ r266/tutorial/datastructures.rst	2010-03-31 16:39:45.690732000 +0900
@@ -129,39 +129,43 @@
    5
    >>> stack
    [3, 4]
 
 
 .. _tut-lists-as-queues:
 
 Using Lists as Queues
 ---------------------
 
 .. sectionauthor:: Ka-Ping Yee <ping@lfw.org>
 
+It is also possible to use a list as a queue, where the first element added is
+the first element retrieved ("first-in, first-out"); however, lists are not
+efficient for this purpose.  While appends and pops from the end of list are
+fast, doing inserts or pops from the beginning of a list is slow (because all
+of the other elements have to be shifted by one).
 
-You can also use a list conveniently as a queue, where the first element added
-is the first element retrieved ("first-in, first-out").  To add an item to the
-back of the queue, use :meth:`append`.  To retrieve an item from the front of
-the queue, use :meth:`pop` with ``0`` as the index.  For example::
+To implement a queue, use :class:`collections.deque` which was designed to
+have fast appends and pops from both ends.  For example::
 
-   >>> queue = ["Eric", "John", "Michael"]
+   >>> from collections import deque
+   >>> queue = deque(["Eric", "John", "Michael"])
    >>> queue.append("Terry")           # Terry arrives
    >>> queue.append("Graham")          # Graham arrives
-   >>> queue.pop(0)
+   >>> queue.popleft()                 # The first to arrive now leaves
    'Eric'
-   >>> queue.pop(0)
+   >>> queue.popleft()                 # The second to arrive now leaves
    'John'
-   >>> queue
-   ['Michael', 'Terry', 'Graham']
+   >>> queue                           # Remaining queue in order of arrival
+   deque(['Michael', 'Terry', 'Graham'])
 
 
 .. _tut-functional:
 
 Functional Programming Tools
 ----------------------------
 
 There are three built-in functions that are very useful when used with lists:
 :func:`filter`, :func:`map`, and :func:`reduce`.
 
 ``filter(function, sequence)`` returns a sequence consisting of those items from
 the sequence for which ``function(item)`` is true. If *sequence* is a
@@ -299,25 +303,25 @@
 Special care has to be taken for the *nested* list comprehension:
 
     To avoid apprehension when nesting list comprehensions, read from right to
     left.
 
 A more verbose version of this snippet shows the flow explicitly::
 
     for i in [0, 1, 2]:
         for row in mat:
             print row[i],
         print
 
-In real world, you should prefer builtin functions to complex flow statements.
+In real world, you should prefer built-in functions to complex flow statements.
 The :func:`zip` function would do a great job for this use case::
 
     >>> zip(*mat)
     [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
 
 See :ref:`tut-unpacking-arguments` for details on the asterisk in this line.
 
 .. _tut-del:
 
 The :keyword:`del` statement
 ============================
 

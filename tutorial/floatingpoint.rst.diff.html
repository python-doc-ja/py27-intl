<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>tutorial/floatingpoint.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -48,74 +48,82 @@</span>
 
    0.0001100110011001100110011001100110011001100110011...
 
<span class="gd">-Stop at any finite number of bits, and you get an approximation.  This is why</span>
<span class="gd">-you see things like::</span>
<span class="gi">+Stop at any finite number of bits, and you get an approximation.</span>
 
<span class="gd">-   &gt;&gt;&gt; 0.1</span>
<span class="gd">-   0.10000000000000001</span>
<span class="gi">+On a typical machine running Python, there are 53 bits of precision available</span>
<span class="gi">+for a Python float, so the value stored internally when you enter the decimal</span>
<span class="gi">+number ``0.1`` is the binary fraction ::</span>
 
<span class="gd">-On most machines today, that is what you&#39;ll see if you enter 0.1 at a Python</span>
<span class="gd">-prompt.  You may not, though, because the number of bits used by the hardware to</span>
<span class="gd">-store floating-point values can vary across machines, and Python only prints a</span>
<span class="gd">-decimal approximation to the true decimal value of the binary approximation</span>
<span class="gd">-stored by the machine.  On most machines, if Python were to print the true</span>
<span class="gd">-decimal value of the binary approximation stored for 0.1, it would have to</span>
<span class="gd">-display ::</span>
<span class="gi">+   0.00011001100110011001100110011001100110011001100110011010</span>
<span class="gi">+</span>
<span class="gi">+which is close to, but not exactly equal to, 1/10.</span>
<span class="gi">+</span>
<span class="gi">+It&#39;s easy to forget that the stored value is an approximation to the original</span>
<span class="gi">+decimal fraction, because of the way that floats are displayed at the</span>
<span class="gi">+interpreter prompt.  Python only prints a decimal approximation to the true</span>
<span class="gi">+decimal value of the binary approximation stored by the machine.  If Python</span>
<span class="gi">+were to print the true decimal value of the binary approximation stored for</span>
<span class="gi">+0.1, it would have to display ::</span>
 
    &gt;&gt;&gt; 0.1
    0.1000000000000000055511151231257827021181583404541015625
 
<span class="gd">-instead!  The Python prompt uses the built-in :func:`repr` function to obtain a</span>
<span class="gd">-string version of everything it displays.  For floats, ``repr(float)`` rounds</span>
<span class="gd">-the true decimal value to 17 significant digits, giving ::</span>
<span class="gi">+That is more digits than most people find useful, so Python keeps the number</span>
<span class="gi">+of digits manageable by displaying a rounded value instead ::</span>
 
<span class="gd">-   0.10000000000000001</span>
<span class="gd">-</span>
<span class="gd">-``repr(float)`` produces 17 significant digits because it turns out that&#39;s</span>
<span class="gd">-enough (on most machines) so that ``eval(repr(x)) == x`` exactly for all finite</span>
<span class="gd">-floats *x*, but rounding to 16 digits is not enough to make that true.</span>
<span class="gd">-</span>
<span class="gd">-Note that this is in the very nature of binary floating-point: this is not a bug</span>
<span class="gd">-in Python, and it is not a bug in your code either.  You&#39;ll see the same kind of</span>
<span class="gd">-thing in all languages that support your hardware&#39;s floating-point arithmetic</span>
<span class="gd">-(although some languages may not *display* the difference by default, or in all</span>
<span class="gd">-output modes).</span>
<span class="gd">-</span>
<span class="gd">-Python&#39;s built-in :func:`str` function produces only 12 significant digits, and</span>
<span class="gd">-you may wish to use that instead.  It&#39;s unusual for ``eval(str(x))`` to</span>
<span class="gd">-reproduce *x*, but the output may be more pleasant to look at::</span>
<span class="gd">-</span>
<span class="gd">-   &gt;&gt;&gt; print str(0.1)</span>
<span class="gi">+   &gt;&gt;&gt; 0.1</span>
    0.1
 
 It&#39;s important to realize that this is, in a real sense, an illusion: the value
 in the machine is not exactly 1/10, you&#39;re simply rounding the *display* of the
<span class="gd">-true machine value.</span>
<span class="gi">+true machine value.  This fact becomes apparent as soon as you try to do</span>
<span class="gi">+arithmetic with these values ::</span>
 
<span class="gd">-Other surprises follow from this one.  For example, after seeing ::</span>
<span class="gi">+   &gt;&gt;&gt; 0.1 + 0.2</span>
<span class="gi">+   0.30000000000000004</span>
 
<span class="gd">-   &gt;&gt;&gt; 0.1</span>
<span class="gd">-   0.10000000000000001</span>
<span class="gi">+Note that this is in the very nature of binary floating-point: this is not a</span>
<span class="gi">+bug in Python, and it is not a bug in your code either.  You&#39;ll see the same</span>
<span class="gi">+kind of thing in all languages that support your hardware&#39;s floating-point</span>
<span class="gi">+arithmetic (although some languages may not *display* the difference by</span>
<span class="gi">+default, or in all output modes).</span>
 
<span class="gd">-you may be tempted to use the :func:`round` function to chop it back to the</span>
<span class="gd">-single digit you expect.  But that makes no difference::</span>
<span class="gi">+Other surprises follow from this one.  For example, if you try to round the</span>
<span class="gi">+value 2.675 to two decimal places, you get this ::</span>
 
<span class="gd">-   &gt;&gt;&gt; round(0.1, 1)</span>
<span class="gd">-   0.10000000000000001</span>
<span class="gi">+   &gt;&gt;&gt; round(2.675, 2)</span>
<span class="gi">+   2.67</span>
 
<span class="gd">-The problem is that the binary floating-point value stored for &quot;0.1&quot; was already</span>
<span class="gd">-the best possible binary approximation to 1/10, so trying to round it again</span>
<span class="gd">-can&#39;t make it better:  it was already as good as it gets.</span>
<span class="gi">+The documentation for the built-in :func:`round` function says that it rounds</span>
<span class="gi">+to the nearest value, rounding ties away from zero.  Since the decimal fraction</span>
<span class="gi">+2.675 is exactly halfway between 2.67 and 2.68, you might expect the result</span>
<span class="gi">+here to be (a binary approximation to) 2.68.  It&#39;s not, because when the</span>
<span class="gi">+decimal string ``2.675`` is converted to a binary floating-point number, it&#39;s</span>
<span class="gi">+again replaced with a binary approximation, whose exact value is ::</span>
 
<span class="gd">-Another consequence is that since 0.1 is not exactly 1/10, summing ten values of</span>
<span class="gd">-0.1 may not yield exactly 1.0, either::</span>
<span class="gi">+   2.67499999999999982236431605997495353221893310546875</span>
<span class="gi">+</span>
<span class="gi">+Since this approximation is slightly closer to 2.67 than to 2.68, it&#39;s rounded</span>
<span class="gi">+down.</span>
<span class="gi">+</span>
<span class="gi">+If you&#39;re in a situation where you care which way your decimal halfway-cases</span>
<span class="gi">+are rounded, you should consider using the :mod:`decimal` module.</span>
<span class="gi">+Incidentally, the :mod:`decimal` module also provides a nice way to &quot;see&quot; the</span>
<span class="gi">+exact value that&#39;s stored in any particular Python float ::</span>
<span class="gi">+</span>
<span class="gi">+   &gt;&gt;&gt; from decimal import Decimal</span>
<span class="gi">+   &gt;&gt;&gt; Decimal(2.675)</span>
<span class="gi">+   Decimal(&#39;2.67499999999999982236431605997495353221893310546875&#39;)</span>
<span class="gi">+</span>
<span class="gi">+Another consequence is that since 0.1 is not exactly 1/10, summing ten values</span>
<span class="gi">+of 0.1 may not yield exactly 1.0, either::</span>
 
    &gt;&gt;&gt; sum = 0.0
    &gt;&gt;&gt; for i in range(10):
    ...     sum += 0.1
    ...
    &gt;&gt;&gt; sum
<span class="gd">-   0.99999999999999989</span>
<span class="gi">+   0.9999999999999999</span>
 
 Binary floating-point arithmetic holds many surprises like this.  The problem
 with &quot;0.1&quot; is explained in precise detail below, in the &quot;Representation Error&quot;
<span class="gu">@@ -131,9 +139,9 @@</span>
 
 While pathological cases do exist, for most casual use of floating-point
 arithmetic you&#39;ll see the result you expect in the end if you simply round the
<span class="gd">-display of your final results to the number of decimal digits you expect.</span>
<span class="gd">-:func:`str` usually suffices, and for finer control see the :meth:`str.format`</span>
<span class="gd">-method&#39;s format specifiers in :ref:`formatstrings`.</span>
<span class="gi">+display of your final results to the number of decimal digits you expect.  For</span>
<span class="gi">+fine control over how a float is displayed see the :meth:`str.format` method&#39;s</span>
<span class="gi">+format specifiers in :ref:`formatstrings`.</span>
 
 
 .. _tut-fp-error:
<span class="gu">@@ -141,24 +149,24 @@</span>
 Representation Error
 ====================
 
<span class="gd">-This section explains the &quot;0.1&quot; example in detail, and shows how you can perform</span>
<span class="gd">-an exact analysis of cases like this yourself.  Basic familiarity with binary</span>
<span class="gd">-floating-point representation is assumed.</span>
<span class="gi">+This section explains the &quot;0.1&quot; example in detail, and shows how you can</span>
<span class="gi">+perform an exact analysis of cases like this yourself.  Basic familiarity with</span>
<span class="gi">+binary floating-point representation is assumed.</span>
 
 :dfn:`Representation error` refers to the fact that some (most, actually)
 decimal fractions cannot be represented exactly as binary (base 2) fractions.
 This is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many
 others) often won&#39;t display the exact decimal number you expect::
 
<span class="gd">-   &gt;&gt;&gt; 0.1</span>
<span class="gd">-   0.10000000000000001</span>
<span class="gi">+   &gt;&gt;&gt; 0.1 + 0.2</span>
<span class="gi">+   0.30000000000000004</span>
 
<span class="gd">-Why is that?  1/10 is not exactly representable as a binary fraction. Almost all</span>
<span class="gd">-machines today (November 2000) use IEEE-754 floating point arithmetic, and</span>
<span class="gd">-almost all platforms map Python floats to IEEE-754 &quot;double precision&quot;.  754</span>
<span class="gd">-doubles contain 53 bits of precision, so on input the computer strives to</span>
<span class="gd">-convert 0.1 to the closest fraction it can of the form *J*/2**\ *N* where *J* is</span>
<span class="gd">-an integer containing exactly 53 bits.  Rewriting ::</span>
<span class="gi">+Why is that?  1/10 and 2/10 are not exactly representable as a binary</span>
<span class="gi">+fraction. Almost all machines today (July 2010) use IEEE-754 floating point</span>
<span class="gi">+arithmetic, and almost all platforms map Python floats to IEEE-754 &quot;double</span>
<span class="gi">+precision&quot;.  754 doubles contain 53 bits of precision, so on input the computer</span>
<span class="gi">+strives to convert 0.1 to the closest fraction it can of the form *J*/2**\ *N*</span>
<span class="gi">+where *J* is an integer containing exactly 53 bits.  Rewriting ::</span>
 
    1 / 10 ~= J / (2**N)
 
<span class="gu">@@ -170,24 +178,24 @@</span>
 the best value for *N* is 56::
 
    &gt;&gt;&gt; 2**52
<span class="gd">-   4503599627370496L</span>
<span class="gi">+   4503599627370496</span>
    &gt;&gt;&gt; 2**53
<span class="gd">-   9007199254740992L</span>
<span class="gi">+   9007199254740992</span>
    &gt;&gt;&gt; 2**56/10
<span class="gd">-   7205759403792793L</span>
<span class="gi">+   7205759403792793</span>
 
<span class="gd">-That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  The</span>
<span class="gd">-best possible value for *J* is then that quotient rounded::</span>
<span class="gi">+That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.</span>
<span class="gi">+The best possible value for *J* is then that quotient rounded::</span>
 
    &gt;&gt;&gt; q, r = divmod(2**56, 10)
    &gt;&gt;&gt; r
<span class="gd">-   6L</span>
<span class="gi">+   6</span>
 
 Since the remainder is more than half of 10, the best approximation is obtained
 by rounding up::
 
    &gt;&gt;&gt; q+1
<span class="gd">-   7205759403792794L</span>
<span class="gi">+   7205759403792794</span>
 
 Therefore the best possible approximation to 1/10 in 754 double precision is
 that over 2\*\*56, or ::
<span class="gu">@@ -195,8 +203,8 @@</span>
    7205759403792794 / 72057594037927936
 
 Note that since we rounded up, this is actually a little bit larger than 1/10;
<span class="gd">-if we had not rounded up, the quotient would have been a little bit smaller than</span>
<span class="gd">-1/10.  But in no case can it be *exactly* 1/10!</span>
<span class="gi">+if we had not rounded up, the quotient would have been a little bit smaller</span>
<span class="gi">+than 1/10.  But in no case can it be *exactly* 1/10!</span>
 
 So the computer never &quot;sees&quot; 1/10:  what it sees is the exact fraction given
 above, the best 754 double approximation it can get::
<span class="gu">@@ -207,13 +215,12 @@</span>
 If we multiply that fraction by 10\*\*30, we can see the (truncated) value of
 its 30 most significant decimal digits::
 
<span class="gd">-   &gt;&gt;&gt; 7205759403792794 * 10**30 / 2**56</span>
<span class="gi">+   &gt;&gt;&gt; 7205759403792794 * 10**30 // 2**56</span>
    100000000000000005551115123125L
 
 meaning that the exact number stored in the computer is approximately equal to
<span class="gd">-the decimal value 0.100000000000000005551115123125.  Rounding that to 17</span>
<span class="gd">-significant digits gives the 0.10000000000000001 that Python displays (well,</span>
<span class="gd">-will display on any 754-conforming platform that does best-possible input and</span>
<span class="gd">-output conversions in its C library --- yours may not!).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+the decimal value 0.100000000000000005551115123125.  In versions prior to</span>
<span class="gi">+Python 2.7 and Python 3.1, Python rounded this value to 17 significant digits,</span>
<span class="gi">+giving &#39;0.10000000000000001&#39;.  In current versions, Python displays a value</span>
<span class="gi">+based on the shortest decimal fraction that rounds correctly back to the true</span>
<span class="gi">+binary value, resulting simply in &#39;0.1&#39;.</span>
</pre></div>

</body>
</html>
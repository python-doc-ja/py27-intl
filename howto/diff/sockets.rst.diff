--- r262/howto/sockets.rst	2009-01-04 06:55:17.853888000 +0900
+++ r266/howto/sockets.rst	2009-10-27 23:19:50.039185000 +0900
@@ -195,35 +195,33 @@
                    socket.AF_INET, socket.SOCK_STREAM)
            else:
                self.sock = sock
 
        def connect(self, host, port):
            self.sock.connect((host, port))
 
        def mysend(self, msg):
            totalsent = 0
            while totalsent < MSGLEN:
                sent = self.sock.send(msg[totalsent:])
                if sent == 0:
-                   raise RuntimeError, \
-                       "socket connection broken"
+                   raise RuntimeError("socket connection broken")
                totalsent = totalsent + sent
 
        def myreceive(self):
            msg = ''
            while len(msg) < MSGLEN:
                chunk = self.sock.recv(MSGLEN-len(msg))
                if chunk == '':
-                   raise RuntimeError, \
-                       "socket connection broken"
+                   raise RuntimeError("socket connection broken")
                msg = msg + chunk
            return msg
 
 The sending code here is usable for almost any messaging scheme - in Python you
 send strings, and you can use ``len()`` to determine its length (even if it has
 embedded ``\0`` characters). It's mostly the receiving code that gets more
 complex. (And in C, it's not much worse, except you can't use ``strlen`` if the
 message has embedded ``\0``\ s.)
 
 The easiest enhancement is to make the first character of the message an
 indicator of message type, and have the type determine the length. Now you have
 two ``recv``\ s - the first to get (at least) that first character so you can

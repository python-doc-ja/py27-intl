--- r262/howto/functional.rst	2009-01-04 06:55:17.853888000 +0900
+++ r266/howto/functional.rst	2010-04-05 21:55:05.908767000 +0900
@@ -326,25 +326,25 @@
 
 Generator expressions and list comprehensions
 =============================================
 
 Two common operations on an iterator's output are 1) performing some operation
 for every element, 2) selecting a subset of elements that meet some condition.
 For example, given a list of strings, you might want to strip off trailing
 whitespace from each line or extract all the strings containing a given
 substring.
 
 List comprehensions and generator expressions (short form: "listcomps" and
 "genexps") are a concise notation for such operations, borrowed from the
-functional programming language Haskell (http://www.haskell.org).  You can strip
+functional programming language Haskell (http://www.haskell.org/).  You can strip
 all the whitespace from a stream of strings with the following code::
 
     line_list = ['  line 1\n', 'line 2  \n', ...]
 
     # Generator expression -- returns iterator
     stripped_iter = (line.strip() for line in line_list)
 
     # List comprehension -- returns list
     stripped_list = [line.strip() for line in line_list]
 
 You can select only certain elements by adding an ``"if"`` condition::
 
@@ -463,25 +463,25 @@
 When you call a generator function, it doesn't return a single value; instead it
 returns a generator object that supports the iterator protocol.  On executing
 the ``yield`` expression, the generator outputs the value of ``i``, similar to a
 ``return`` statement.  The big difference between ``yield`` and a ``return``
 statement is that on reaching a ``yield`` the generator's state of execution is
 suspended and local variables are preserved.  On the next call to the
 generator's ``.next()`` method, the function will resume executing.
 
 Here's a sample usage of the ``generate_ints()`` generator:
 
     >>> gen = generate_ints(3)
     >>> gen
-    <generator object at ...>
+    <generator object generate_ints at ...>
     >>> gen.next()
     0
     >>> gen.next()
     1
     >>> gen.next()
     2
     >>> gen.next()
     Traceback (most recent call last):
       File "stdin", line 1, in ?
       File "stdin", line 2, in generate_ints
     StopIteration
 

--- r262/howto/regex.rst	2009-04-06 09:24:29.561602000 +0900
+++ r266/howto/regex.rst	2009-10-27 23:19:50.039185000 +0900
@@ -248,32 +248,32 @@
 Using Regular Expressions
 =========================
 
 Now that we've looked at some simple regular expressions, how do we actually use
 them in Python?  The :mod:`re` module provides an interface to the regular
 expression engine, allowing you to compile REs into objects and then perform
 matches with them.
 
 
 Compiling Regular Expressions
 -----------------------------
 
-Regular expressions are compiled into :class:`RegexObject` instances, which have
+Regular expressions are compiled into pattern objects, which have
 methods for various operations such as searching for pattern matches or
 performing string substitutions. ::
 
    >>> import re
    >>> p = re.compile('ab*')
    >>> print p
-   <re.RegexObject instance at 80b4150>
+   <_sre.SRE_Pattern object at 80b4150>
 
 :func:`re.compile` also accepts an optional *flags* argument, used to enable
 various special features and syntax variations.  We'll go over the available
 settings later, but for now a single example will do::
 
    >>> p = re.compile('ab*', re.IGNORECASE)
 
 The RE is passed to :func:`re.compile` as a string.  REs are handled as strings
 because regular expressions aren't part of the core Python language, and no
 special syntax was created for expressing them.  (There are applications that
 don't need REs at all, so there's no need to bloat the language specification by
 including them.) Instead, the :mod:`re` module is simply a C extension module
@@ -327,25 +327,25 @@
 | ``"ab*"``         | ``r"ab*"``       |
 +-------------------+------------------+
 | ``"\\\\section"`` | ``r"\\section"`` |
 +-------------------+------------------+
 | ``"\\w+\\s+\\1"`` | ``r"\w+\s+\1"``  |
 +-------------------+------------------+
 
 
 Performing Matches
 ------------------
 
 Once you have an object representing a compiled regular expression, what do you
-do with it?  :class:`RegexObject` instances have several methods and attributes.
+do with it?  Pattern objects have several methods and attributes.
 Only the most significant ones will be covered here; consult the :mod:`re` docs
 for a complete listing.
 
 +------------------+-----------------------------------------------+
 | Method/Attribute | Purpose                                       |
 +==================+===============================================+
 | ``match()``      | Determine if the RE matches at the beginning  |
 |                  | of the string.                                |
 +------------------+-----------------------------------------------+
 | ``search()``     | Scan through a string, looking for any        |
 |                  | location where this RE matches.               |
 +------------------+-----------------------------------------------+
@@ -418,90 +418,90 @@
 
    >>> m.group()
    'tempo'
    >>> m.start(), m.end()
    (0, 5)
    >>> m.span()
    (0, 5)
 
 :meth:`group` returns the substring that was matched by the RE.  :meth:`start`
 and :meth:`end` return the starting and ending index of the match. :meth:`span`
 returns both start and end indexes in a single tuple.  Since the :meth:`match`
 method only checks if the RE matches at the start of a string, :meth:`start`
-will always be zero.  However, the :meth:`search` method of :class:`RegexObject`
-instances scans through the string, so  the match may not start at zero in that
+will always be zero.  However, the :meth:`search` method of patterns
+scans through the string, so  the match may not start at zero in that
 case. ::
 
    >>> print p.match('::: message')
    None
    >>> m = p.search('::: message') ; print m
    <re.MatchObject instance at 80c9650>
    >>> m.group()
    'message'
    >>> m.span()
    (4, 11)
 
 In actual programs, the most common style is to store the :class:`MatchObject`
 in a variable, and then check if it was ``None``.  This usually looks like::
 
    p = re.compile( ... )
    m = p.match( 'string goes here' )
    if m:
        print 'Match found: ', m.group()
    else:
        print 'No match'
 
-Two :class:`RegexObject` methods return all of the matches for a pattern.
+Two pattern methods return all of the matches for a pattern.
 :meth:`findall` returns a list of matching strings::
 
    >>> p = re.compile('\d+')
    >>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
    ['12', '11', '10']
 
 :meth:`findall` has to create the entire list before it can be returned as the
 result.  The :meth:`finditer` method returns a sequence of :class:`MatchObject`
 instances as an :term:`iterator`. [#]_ ::
 
    >>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
    >>> iterator
    <callable-iterator object at 0x401833ac>
    >>> for match in iterator:
    ...     print match.span()
    ...
    (0, 2)
    (22, 24)
    (29, 31)
 
 
 Module-Level Functions
 ----------------------
 
-You don't have to create a :class:`RegexObject` and call its methods; the
+You don't have to create a pattern object and call its methods; the
 :mod:`re` module also provides top-level functions called :func:`match`,
 :func:`search`, :func:`findall`, :func:`sub`, and so forth.  These functions
-take the same arguments as the corresponding :class:`RegexObject` method, with
+take the same arguments as the corresponding pattern method, with
 the RE string added as the first argument, and still return either ``None`` or a
 :class:`MatchObject` instance. ::
 
    >>> print re.match(r'From\s+', 'Fromage amk')
    None
    >>> re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998')
    <re.MatchObject instance at 80c5978>
 
-Under the hood, these functions simply produce a :class:`RegexObject` for you
+Under the hood, these functions simply create a pattern object for you
 and call the appropriate method on it.  They also store the compiled object in a
 cache, so future calls using the same RE are faster.
 
 Should you use these module-level functions, or should you get the
-:class:`RegexObject` and call its methods yourself?  That choice depends on how
+pattern and call its methods yourself?  That choice depends on how
 frequently the RE will be used, and on your personal coding style.  If the RE is
 being used at only one point in the code, then the module functions are probably
 more convenient.  If a program contains a lot of regular expressions, or re-uses
 the same ones in several locations, then it might be worthwhile to collect all
 the definitions in one place, in a section of code that compiles all the REs
 ahead of time.  To take an example from the standard library, here's an extract
 from :file:`xmllib.py`::
 
    ref = re.compile( ... )
    entityref = re.compile( ... )
    charref = re.compile( ... )
    starttagopen = re.compile( ... )
@@ -1021,45 +1021,45 @@
 Excluding another filename extension is now easy; simply add it as an
 alternative inside the assertion.  The following pattern excludes filenames that
 end in either ``bat`` or ``exe``:
 
 ``.*[.](?!bat$|exe$).*$``
 
 
 Modifying Strings
 =================
 
 Up to this point, we've simply performed searches against a static string.
 Regular expressions are also commonly used to modify strings in various ways,
-using the following :class:`RegexObject` methods:
+using the following pattern methods:
 
 +------------------+-----------------------------------------------+
 | Method/Attribute | Purpose                                       |
 +==================+===============================================+
 | ``split()``      | Split the string into a list, splitting it    |
 |                  | wherever the RE matches                       |
 +------------------+-----------------------------------------------+
 | ``sub()``        | Find all substrings where the RE matches, and |
 |                  | replace them with a different string          |
 +------------------+-----------------------------------------------+
 | ``subn()``       | Does the same thing as :meth:`sub`,  but      |
 |                  | returns the new string and the number of      |
 |                  | replacements                                  |
 +------------------+-----------------------------------------------+
 
 
 Splitting Strings
 -----------------
 
-The :meth:`split` method of a :class:`RegexObject` splits a string apart
+The :meth:`split` method of a pattern splits a string apart
 wherever the RE matches, returning a list of the pieces. It's similar to the
 :meth:`split` method of strings but provides much more generality in the
 delimiters that you can split by; :meth:`split` only supports splitting by
 whitespace or by a fixed string.  As you'd expect, there's a module-level
 :func:`re.split` function, too.
 
 
 .. method:: .split(string [, maxsplit=0])
    :noindex:
 
    Split *string* by the matches of the regular expression.  If capturing
    parentheses are used in the RE, then their contents will also be returned as
@@ -1186,28 +1186,28 @@
 hexadecimal::
 
    >>> def hexrepl( match ):
    ...     "Return the hex string for a decimal number"
    ...     value = int( match.group() )
    ...     return hex(value)
    ...
    >>> p = re.compile(r'\d+')
    >>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
    'Call 0xffd2 for printing, 0xc000 for user code.'
 
 When using the module-level :func:`re.sub` function, the pattern is passed as
-the first argument.  The pattern may be a string or a :class:`RegexObject`; if
+the first argument.  The pattern may be provided as an object or as a string; if
 you need to specify regular expression flags, you must either use a
-:class:`RegexObject` as the first parameter, or use embedded modifiers in the
-pattern, e.g.  ``sub("(?i)b+", "x", "bbbb BBBB")`` returns ``'x x'``.
+pattern object as the first parameter, or use embedded modifiers in the
+pattern string, e.g. ``sub("(?i)b+", "x", "bbbb BBBB")`` returns ``'x x'``.
 
 
 Common Problems
 ===============
 
 Regular expressions are a powerful tool for some applications, but in some ways
 their behaviour isn't intuitive and at times they don't behave the way you may
 expect them to.  This section will point out some of the most common pitfalls.
 
 
 Use String Methods
 ------------------

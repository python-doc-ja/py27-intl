@@ -287,25 +287,25 @@
          def f(self, x):
               return x
 
     >>> d = D()
     >>> D.__dict__['f'] # Stored internally as a function
     <function f at 0x00C45070>
     >>> D.f             # Get from a class becomes an unbound method
     <unbound method D.f>
     >>> d.f             # Get from an instance becomes a bound method
     <bound method D.f of <__main__.D object at 0x00B18C90>>
 
 The output suggests that bound and unbound methods are two different types.
-While they could have been implemented that way, the actual C implemention of
+While they could have been implemented that way, the actual C implementation of
 :ctype:`PyMethod_Type` in
 `Objects/classobject.c <http://svn.python.org/view/python/trunk/Objects/classobject.c?view=markup>`_
 is a single object with two different representations depending on whether the
 :attr:`im_self` field is set or is *NULL* (the C equivalent of *None*).
 
 Likewise, the effects of calling a method object depend on the :attr:`im_self`
 field. If set (meaning bound), the original function (stored in the
 :attr:`im_func` field) is called as expected with the first argument set to the
 instance.  If unbound, all of the arguments are passed unchanged to the original
 function. The actual C implementation of :func:`instancemethod_call()` is only
 slightly more complex in that it includes some type checking.
 

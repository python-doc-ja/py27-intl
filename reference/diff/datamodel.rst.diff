--- r262/reference/datamodel.rst	2009-04-06 06:48:06.719229000 +0900
+++ r266/reference/datamodel.rst	2010-05-19 23:04:44.117518000 +0900
@@ -47,31 +47,34 @@
 object's mutability is determined by its type; for instance, numbers, strings
 and tuples are immutable, while dictionaries and lists are mutable.
 
 .. index::
    single: garbage collection
    single: reference counting
    single: unreachable object
 
 Objects are never explicitly destroyed; however, when they become unreachable
 they may be garbage-collected.  An implementation is allowed to postpone garbage
 collection or omit it altogether --- it is a matter of implementation quality
 how garbage collection is implemented, as long as no objects are collected that
-are still reachable.  (Implementation note: CPython currently uses a
-reference-counting scheme with (optional) delayed detection of cyclically linked
-garbage, which collects most objects as soon as they become unreachable, but is
-not guaranteed to collect garbage containing circular references.  See the
-documentation of the :mod:`gc` module for information on controlling the
-collection of cyclic garbage.  Other implementations act differently and CPython
-may change.)
+are still reachable.
+
+.. impl-detail::
+
+   CPython currently uses a reference-counting scheme with (optional) delayed
+   detection of cyclically linked garbage, which collects most objects as soon
+   as they become unreachable, but is not guaranteed to collect garbage
+   containing circular references.  See the documentation of the :mod:`gc`
+   module for information on controlling the collection of cyclic garbage.
+   Other implementations act differently and CPython may change.
 
 Note that the use of the implementation's tracing or debugging facilities may
 keep objects alive that would normally be collectable. Also note that catching
 an exception with a ':keyword:`try`...\ :keyword:`except`' statement may keep
 objects alive.
 
 Some objects contain references to "external" resources such as open files or
 windows.  It is understood that these resources are freed when the object is
 garbage-collected, but since garbage collection is not guaranteed to happen,
 such objects also provide an explicit way to release the external resource,
 usually a :meth:`close` method. Programs are strongly recommended to explicitly
 close such objects.  The ':keyword:`try`...\ :keyword:`finally`' statement
@@ -351,33 +354,41 @@
          object: mutable sequence
          object: mutable
          pair: assignment; statement
          single: delete
          statement: del
          single: subscription
          single: slicing
 
       Mutable sequences can be changed after they are created.  The subscription and
       slicing notations can be used as the target of assignment and :keyword:`del`
       (delete) statements.
 
-      There is currently a single intrinsic mutable sequence type:
+      There are currently two intrinsic mutable sequence types:
 
       Lists
          .. index:: object: list
 
          The items of a list are arbitrary Python objects.  Lists are formed by placing a
          comma-separated list of expressions in square brackets. (Note that there are no
          special cases needed to form lists of length 0 or 1.)
 
+      Byte Arrays
+         .. index:: bytearray
+
+         A bytearray object is a mutable array. They are created by the built-in
+         :func:`bytearray` constructor.  Aside from being mutable (and hence
+         unhashable), byte arrays otherwise provide the same interface and
+         functionality as immutable bytes objects.
+
       .. index:: module: array
 
       The extension module :mod:`array` provides an additional example of a mutable
       sequence type.
 
 Set types
    .. index::
       builtin: len
       object: set type
 
    These represent unordered, finite sets of unique, immutable objects. As such,
    they cannot be indexed by any subscript. However, they can be iterated over, and
@@ -942,24 +953,26 @@
       in :attr:`co_flags` to indicate whether a code object was compiled with a
       particular feature enabled: bit ``0x2000`` is set if the function was compiled
       with future division enabled; bits ``0x10`` and ``0x1000`` were used in earlier
       versions of Python.
 
       Other bits in :attr:`co_flags` are reserved for internal use.
 
       .. index:: single: documentation string
 
       If a code object represents a function, the first item in :attr:`co_consts` is
       the documentation string of the function, or ``None`` if undefined.
 
+   .. _frame-objects:
+
    Frame objects
       .. index:: object: frame
 
       Frame objects represent execution frames.  They may occur in traceback objects
       (see below).
 
       .. index::
          single: f_back (frame attribute)
          single: f_code (frame attribute)
          single: f_globals (frame attribute)
          single: f_locals (frame attribute)
          single: f_lasti (frame attribute)
@@ -1330,24 +1343,27 @@
    operators will behave as expected.  See the paragraph on :meth:`__hash__` for
    some important notes on creating :term:`hashable` objects which support
    custom comparison operations and are usable as dictionary keys.
 
    There are no swapped-argument versions of these methods (to be used when the
    left argument does not support the operation but the right argument does);
    rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection,
    :meth:`__le__` and :meth:`__ge__` are each other's reflection, and
    :meth:`__eq__` and :meth:`__ne__` are their own reflection.
 
    Arguments to rich comparison methods are never coerced.
 
+   To automatically generate ordering operations from a single root operation,
+   see the `Total Ordering recipe in the ASPN cookbook
+   <http://code.activestate.com/recipes/576529/>`_\.
 
 .. method:: object.__cmp__(self, other)
 
    .. index::
       builtin: cmp
       single: comparisons
 
    Called by comparison operations if rich comparison (see above) is not
    defined.  Should return a negative integer if ``self < other``, zero if
    ``self == other``, a positive integer if ``self > other``.  If no
    :meth:`__cmp__`, :meth:`__eq__` or :meth:`__ne__` operation is defined, class
    instances are compared by object identity ("address").  See also the
@@ -1417,25 +1433,25 @@
    Called to implement truth value testing and the built-in operation ``bool()``;
    should return ``False`` or ``True``, or their integer equivalents ``0`` or
    ``1``.  When this method is not defined, :meth:`__len__` is called, if it is
    defined, and the object is considered true if its result is nonzero.
    If a class defines neither :meth:`__len__` nor :meth:`__nonzero__`, all its
    instances are considered true.
 
 
 .. method:: object.__unicode__(self)
 
    .. index:: builtin: unicode
 
-   Called to implement :func:`unicode` builtin; should return a Unicode object.
+   Called to implement :func:`unicode` built-in; should return a Unicode object.
    When this method is not defined, string conversion is attempted, and the result
    of string conversion is converted to Unicode using the system default encoding.
 
 
 .. _attribute-access:
 
 Customizing attribute access
 ----------------------------
 
 The following methods can be defined to customize the meaning of attribute
 access (use of, assignment to, or deletion of ``x.name``) for class instances.
 
@@ -1496,25 +1512,25 @@
    Called unconditionally to implement attribute accesses for instances of the
    class. If the class also defines :meth:`__getattr__`, the latter will not be
    called unless :meth:`__getattribute__` either calls it explicitly or raises an
    :exc:`AttributeError`. This method should return the (computed) attribute value
    or raise an :exc:`AttributeError` exception. In order to avoid infinite
    recursion in this method, its implementation should always call the base class
    method with the same name to access any attributes it needs, for example,
    ``object.__getattribute__(self, name)``.
 
    .. note::
 
       This method may still be bypassed when looking up special methods as the
-      result of implicit invocation via language syntax or builtin functions.
+      result of implicit invocation via language syntax or built-in functions.
       See :ref:`new-style-special-lookup`.
 
 
 .. _descriptors:
 
 Implementing Descriptors
 ^^^^^^^^^^^^^^^^^^^^^^^^
 
 The following methods only apply when an instance of the class containing the
 method (a so-called *descriptor* class) appears in the class dictionary of
 another new-style class, known as the *owner* class. In the examples below, "the
 attribute" refers to the attribute whose name is the key of the property in the
@@ -1578,29 +1594,35 @@
 
 Class Binding
    If binding to a new-style class, ``A.x`` is transformed into the call:
    ``A.__dict__['x'].__get__(None, A)``.
 
 Super Binding
    If ``a`` is an instance of :class:`super`, then the binding ``super(B,
    obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A``
    immediately preceding ``B`` and then invokes the descriptor with the call:
    ``A.__dict__['m'].__get__(obj, A)``.
 
 For instance bindings, the precedence of descriptor invocation depends on the
-which descriptor methods are defined.  Normally, data descriptors define both
-:meth:`__get__` and :meth:`__set__`, while non-data descriptors have just the
-:meth:`__get__` method.  Data descriptors always override a redefinition in an
+which descriptor methods are defined.  A descriptor can define any combination
+of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If it does not
+define :meth:`__get__`, then accessing the attribute will return the descriptor
+object itself unless there is a value in the object's instance dictionary.  If
+the descriptor defines :meth:`__set__` and/or :meth:`__delete__`, it is a data
+descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
+descriptors define both :meth:`__get__` and :meth:`__set__`, while non-data
+descriptors have just the :meth:`__get__` method.  Data descriptors with
+:meth:`__set__` and :meth:`__get__` defined always override a redefinition in an
 instance dictionary.  In contrast, non-data descriptors can be overridden by
-instances. [#]_
+instances.
 
 Python methods (including :func:`staticmethod` and :func:`classmethod`) are
 implemented as non-data descriptors.  Accordingly, instances can redefine and
 override methods.  This allows individual instances to acquire behaviors that
 differ from other instances of the same class.
 
 The :func:`property` function is implemented as a data descriptor. Accordingly,
 instances cannot override the behavior of a property.
 
 
 .. _slots:
 
@@ -1650,33 +1672,33 @@
   *__slots__* declaration.
 
   .. versionchanged:: 2.3
      Previously, adding ``'__weakref__'`` to the *__slots__* declaration would not
      enable support for weak references.
 
 * *__slots__* are implemented at the class level by creating descriptors
   (:ref:`descriptors`) for each variable name.  As a result, class attributes
   cannot be used to set default values for instance variables defined by
   *__slots__*; otherwise, the class attribute would overwrite the descriptor
   assignment.
 
+* The action of a *__slots__* declaration is limited to the class where it is
+  defined.  As a result, subclasses will have a *__dict__* unless they also define
+  *__slots__* (which must only contain names of any *additional* slots).
+
 * If a class defines a slot also defined in a base class, the instance variable
   defined by the base class slot is inaccessible (except by retrieving its
   descriptor directly from the base class). This renders the meaning of the
   program undefined.  In the future, a check may be added to prevent this.
 
-* The action of a *__slots__* declaration is limited to the class where it is
-  defined.  As a result, subclasses will have a *__dict__* unless they also define
-  *__slots__*.
-
 * Nonempty *__slots__* does not work for classes derived from "variable-length"
   built-in types such as :class:`long`, :class:`str` and :class:`tuple`.
 
 * Any non-string iterable may be assigned to *__slots__*. Mappings may also be
   used; however, in the future, special meaning may be assigned to the values
   corresponding to each key.
 
 * *__class__* assignment works only if both classes have the same *__slots__*.
 
   .. versionchanged:: 2.6
      Previously, *__class__* assignment raised an error if either new or old class
      had *__slots__*.
@@ -1732,24 +1754,66 @@
   looks for a *__class__* attribute first and if not found, uses its type).
 
 * Otherwise, if a global variable named __metaclass__ exists, it is used.
 
 * Otherwise, the old-style, classic metaclass (types.ClassType) is used.
 
 The potential uses for metaclasses are boundless. Some ideas that have been
 explored including logging, interface checking, automatic delegation, automatic
 property creation, proxies, frameworks, and automatic resource
 locking/synchronization.
 
 
+Customizing instance and subclass checks
+----------------------------------------
+
+.. versionadded:: 2.6
+
+The following methods are used to override the default behavior of the
+:func:`isinstance` and :func:`issubclass` built-in functions.
+
+In particular, the metaclass :class:`abc.ABCMeta` implements these methods in
+order to allow the addition of Abstract Base Classes (ABCs) as "virtual base
+classes" to any class or type (including built-in types), and including to other
+ABCs.
+
+.. method:: class.__instancecheck__(self, instance)
+
+   Return true if *instance* should be considered a (direct or indirect)
+   instance of *class*. If defined, called to implement ``isinstance(instance,
+   class)``.
+
+
+.. method:: class.__subclasscheck__(self, subclass)
+
+   Return true if *subclass* should be considered a (direct or indirect)
+   subclass of *class*.  If defined, called to implement ``issubclass(subclass,
+   class)``.
+
+
+Note that these methods are looked up on the type (metaclass) of a class.  They
+cannot be defined as class methods in the actual class.  This is consistent with
+the lookup of special methods that are called on instances, only that in this
+case the instance is itself a class.
+
+.. seealso::
+
+   :pep:`3119` - Introducing Abstract Base Classes
+      Includes the specification for customizing :func:`isinstance` and
+      :func:`issubclass` behavior through :meth:`__instancecheck__` and
+      :meth:`__subclasscheck__`, with motivation for this functionality in the
+      context of adding Abstract Base Classes (see the :mod:`abc` module) to the
+      language.
+
+
 .. _callable-types:
 
 Emulating callable objects
 --------------------------
 
 
 .. method:: object.__call__(self[, args...])
 
    .. index:: pair: call; instance
 
    Called when the instance is "called" as a function; if this method is defined,
    ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, arg2, ...)``.
@@ -1845,48 +1909,52 @@
 
    This method is called when an iterator is required for a container. This method
    should return a new iterator object that can iterate over all the objects in the
    container.  For mappings, it should iterate over the keys of the container, and
    should also be made available as the method :meth:`iterkeys`.
 
    Iterator objects also need to implement this method; they are required to return
    themselves.  For more information on iterator objects, see :ref:`typeiter`.
 
 
 .. method:: object.__reversed__(self)
 
-   Called (if present) by the :func:`reversed` builtin to implement
+   Called (if present) by the :func:`reversed` built-in to implement
    reverse iteration.  It should return a new iterator object that iterates
    over all the objects in the container in reverse order.
 
-   If the :meth:`__reversed__` method is not provided, the
-   :func:`reversed` builtin will fall back to using the sequence protocol
-   (:meth:`__len__` and :meth:`__getitem__`).  Objects should normally
-   only provide :meth:`__reversed__` if they do not support the sequence
-   protocol and an efficient implementation of reverse iteration is possible.
+   If the :meth:`__reversed__` method is not provided, the :func:`reversed`
+   built-in will fall back to using the sequence protocol (:meth:`__len__` and
+   :meth:`__getitem__`).  Objects that support the sequence protocol should
+   only provide :meth:`__reversed__` if they can provide an implementation
+   that is more efficient than the one provided by :func:`reversed`.
 
    .. versionadded:: 2.6
 
 
 The membership test operators (:keyword:`in` and :keyword:`not in`) are normally
 implemented as an iteration through a sequence.  However, container objects can
 supply the following special method with a more efficient implementation, which
 also does not require the object be a sequence.
 
-
 .. method:: object.__contains__(self, item)
 
-   Called to implement membership test operators.  Should return true if *item* is
-   in *self*, false otherwise.  For mapping objects, this should consider the keys
-   of the mapping rather than the values or the key-item pairs.
+   Called to implement membership test operators.  Should return true if *item*
+   is in *self*, false otherwise.  For mapping objects, this should consider the
+   keys of the mapping rather than the values or the key-item pairs.
+
+   For objects that don't define :meth:`__contains__`, the membership test first
+   tries iteration via :meth:`__iter__`, then the old sequence iteration
+   protocol via :meth:`__getitem__`, see :ref:`this section in the language
+   reference <membership-test-details>`.
 
 
 .. _sequence-methods:
 
 Additional methods for emulation of sequence types
 --------------------------------------------------
 
 The following optional methods can be defined to further emulate sequence
 objects.  Immutable sequences methods should at most only define
 :meth:`__getslice__`; mutable sequences might define all three methods.
 
 
@@ -2405,23 +2473,16 @@
 provides significant scope for speed optimisations within the
 interpreter, at the cost of some flexibility in the handling of
 special methods (the special method *must* be set on the class
 object itself in order to be consistently invoked by the interpreter).
 
 
 .. rubric:: Footnotes
 
 .. [#] It *is* possible in some cases to change an object's type, under certain
    controlled conditions. It generally isn't a good idea though, since it can
    lead to some very strange behaviour if it is handled incorrectly.
 
-.. [#] A descriptor can define any combination of :meth:`__get__`,
-   :meth:`__set__` and :meth:`__delete__`.  If it does not define :meth:`__get__`,
-   then accessing the attribute even on an instance will return the descriptor
-   object itself.  If the descriptor defines :meth:`__set__` and/or
-   :meth:`__delete__`, it is a data descriptor; if it defines neither, it is a
-   non-data descriptor.
-
 .. [#] For operands of the same type, it is assumed that if the non-reflected method
    (such as :meth:`__add__`) fails the operation is not supported, which is why the
    reflected method is not called.
 

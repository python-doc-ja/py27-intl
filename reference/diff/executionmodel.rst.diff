--- rest25/reference/executionmodel.rst	2008-12-19 16:58:05.000000000 +0900
+++ rest262/reference/executionmodel.rst	2009-04-07 00:06:52.000000000 +0900
@@ -43,25 +43,31 @@
 
 A code block is executed in an :dfn:`execution frame`.  A frame contains some
 administrative information (used for debugging) and determines where and how
 execution continues after the code block's execution has completed.
 
 .. index:: single: scope
 
 A :dfn:`scope` defines the visibility of a name within a block.  If a local
 variable is defined in a block, its scope includes that block.  If the
 definition occurs in a function block, the scope extends to any blocks contained
 within the defining one, unless a contained block introduces a different binding
 for the name.  The scope of names defined in a class block is limited to the
-class block; it does not extend to the code blocks of methods.
+class block; it does not extend to the code blocks of methods -- this includes
+generator expressions since they are implemented using a function scope.  This
+means that the following will fail::
+
+   class A:
+       a = 42
+       b = list(a + i for i in range(10))
 
 .. index:: single: environment
 
 When a name is used in a code block, it is resolved using the nearest enclosing
 scope.  The set of all such scopes visible to a code block is called the block's
 :dfn:`environment`.
 
 .. index:: pair: free; variable
 
 If a name is bound in a block, it is a local variable of that block. If a name
 is bound at the module level, it is a global variable.  (The variables of the
 module code block are local and global.)  If a variable is used in a code block
@@ -72,27 +78,28 @@
    single: UnboundLocalError
 
 When a name is not found at all, a :exc:`NameError` exception is raised.  If the
 name refers to a local variable that has not been bound, a
 :exc:`UnboundLocalError` exception is raised.  :exc:`UnboundLocalError` is a
 subclass of :exc:`NameError`.
 
 .. index:: statement: from
 
 The following constructs bind names: formal parameters to functions,
 :keyword:`import` statements, class and function definitions (these bind the
 class or function name in the defining block), and targets that are identifiers
-if occurring in an assignment, :keyword:`for` loop header, or in the second
-position of an :keyword:`except` clause header.  The :keyword:`import` statement
-of the form "``from ...import *``" binds all names defined in the imported
+if occurring in an assignment, :keyword:`for` loop header, in the second
+position of an :keyword:`except` clause header or after :keyword:`as` in a
+:keyword:`with` statement.  The :keyword:`import` statement
+of the form ``from ... import *`` binds all names defined in the imported
 module, except those beginning with an underscore.  This form may only be used
 at the module level.
 
 A target occurring in a :keyword:`del` statement is also considered bound for
 this purpose (though the actual semantics are to unbind the name).  It is
 illegal to unbind a name that is referenced by an enclosing scope; the compiler
 will report a :exc:`SyntaxError`.
 
 Each assignment or import statement occurs within a block defined by a class or
 function definition or at the module level (the top-level code block).
 
 If a name binding operation occurs anywhere within a code block, all uses of the
@@ -188,56 +195,51 @@
    single: errors
    single: error handling
 
 Exceptions are a means of breaking out of the normal flow of control of a code
 block in order to handle errors or other exceptional conditions.  An exception
 is *raised* at the point where the error is detected; it may be *handled* by the
 surrounding code block or by any code block that directly or indirectly invoked
 the code block where the error occurred.
 
 The Python interpreter raises an exception when it detects a run-time error
 (such as division by zero).  A Python program can also explicitly raise an
 exception with the :keyword:`raise` statement. Exception handlers are specified
-with the :keyword:`try` ... :keyword:`except` statement.  The :keyword:`try` ...
-:keyword:`finally` statement specifies cleanup code which does not handle the
-exception, but is executed whether an exception occurred or not in the preceding
-code.
+with the :keyword:`try` ... :keyword:`except` statement.  The :keyword:`finally`
+clause of such a statement can be used to specify cleanup code which does not
+handle the exception, but is executed whether an exception occurred or not in
+the preceding code.
 
 .. index:: single: termination model
 
 Python uses the "termination" model of error handling: an exception handler can
 find out what happened and continue execution at an outer level, but it cannot
-repair the cause of the error and retry the failing operation (except by re-
-entering the offending piece of code from the top).
+repair the cause of the error and retry the failing operation (except by
+re-entering the offending piece of code from the top).
 
 .. index:: single: SystemExit (built-in exception)
 
 When an exception is not handled at all, the interpreter terminates execution of
 the program, or returns to its interactive main loop.  In either case, it prints
 a stack backtrace, except when the exception is  :exc:`SystemExit`.
 
 Exceptions are identified by class instances.  The :keyword:`except` clause is
 selected depending on the class of the instance: it must reference the class of
 the instance or a base class thereof.  The instance can be received by the
 handler and can carry additional information about the exceptional condition.
 
 Exceptions can also be identified by strings, in which case the
 :keyword:`except` clause is selected by object identity.  An arbitrary value can
 be raised along with the identifying string which can be passed to the handler.
 
-.. deprecated:: 2.5
-   String exceptions should not be used in new code. They will not be supported in
-   a future version of Python.  Old code should be rewritten to use class
-   exceptions instead.
-
 .. warning::
 
    Messages to exceptions are not part of the Python API.  Their contents may
    change from one version of Python to the next without warning and should not be
    relied on by code which will run under multiple versions of the interpreter.
 
 See also the description of the :keyword:`try` statement in section :ref:`try`
 and :keyword:`raise` statement in section :ref:`raise`.
 
 .. rubric:: Footnotes
 
 .. [#] This limitation occurs because the code that is executed by these operations is

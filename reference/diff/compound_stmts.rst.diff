--- r262/reference/compound_stmts.rst	2008-10-17 06:44:19.650648000 +0900
+++ r266/reference/compound_stmts.rst	2009-04-29 03:23:28.138007000 +0900
@@ -1,13 +1,12 @@
-
 .. _compound:
 
 *******************
 Compound statements
 *******************
 
 .. index:: pair: compound; statement
 
 Compound statements contain (groups of) other statements; they affect or control
 the execution of those other statements in some way.  In general, compound
 statements span multiple lines, although in simple incarnations a whole compound
 statement may be contained in one line.
@@ -170,46 +169,44 @@
 the next item assigned to it.
 
 .. index::
    builtin: range
    pair: Pascal; language
 
 The target list is not deleted when the loop is finished, but if the sequence is
 empty, it will not have been assigned to at all by the loop.  Hint: the built-in
 function :func:`range` returns a sequence of integers suitable to emulate the
 effect of Pascal's ``for i := a to b do``; e.g., ``range(3)`` returns the list
 ``[0, 1, 2]``.
 
-.. warning::
+.. note::
 
    .. index::
       single: loop; over mutable sequence
       single: mutable sequence; loop over
 
    There is a subtlety when the sequence is being modified by the loop (this can
    only occur for mutable sequences, i.e. lists). An internal counter is used to
    keep track of which item is used next, and this is incremented on each
    iteration.  When this counter has reached the length of the sequence the loop
    terminates.  This means that if the suite deletes the current (or a previous)
    item from the sequence, the next item will be skipped (since it gets the index
    of the current item which has already been treated).  Likewise, if the suite
    inserts an item in the sequence before the current item, the current item will
    be treated again the next time through the loop. This can lead to nasty bugs
    that can be avoided by making a temporary copy using a slice of the whole
-   sequence, e.g.,
-
-::
+   sequence, e.g., ::
 
-   for x in a[:]:
-       if x < 0: a.remove(x)
+      for x in a[:]:
+          if x < 0: a.remove(x)
 
 
 .. _try:
 .. _except:
 .. _finally:
 
 The :keyword:`try` statement
 ============================
 
 .. index::
    statement: try
    keyword: except

=== modified file 'Doc/c-api/unicode.rst'
--- Doc/c-api/unicode.rst	2008-01-19 22:08:21 +0000
+++ Doc/c-api/unicode.rst	2010-11-17 12:18:12 +0000
@@ -11,11 +11,12 @@
 ^^^^^^^^^^^^^^^
 
 
+Unicode Type
+""""""""""""
+
 These are the basic Unicode object types used for the Unicode implementation in
 Python:
 
-.. % --- Unicode Type -------------------------------------------------------
-
 
 .. ctype:: Py_UNICODE
 
@@ -71,12 +72,20 @@
    Return the size of the object.  *o* has to be a :ctype:`PyUnicodeObject` (not
    checked).
 
+   .. versionchanged:: 2.5
+      This function returned an :ctype:`int` type. This might require changes
+      in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: Py_ssize_t PyUnicode_GET_DATA_SIZE(PyObject *o)
 
    Return the size of the object's internal buffer in bytes.  *o* has to be a
    :ctype:`PyUnicodeObject` (not checked).
 
+   .. versionchanged:: 2.5
+      This function returned an :ctype:`int` type. This might require changes
+      in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: Py_UNICODE* PyUnicode_AS_UNICODE(PyObject *o)
 
@@ -89,12 +98,21 @@
    Return a pointer to the internal buffer of the object. *o* has to be a
    :ctype:`PyUnicodeObject` (not checked).
 
+
+.. cfunction:: int PyUnicode_ClearFreeList()
+
+   Clear the free list. Return the total number of freed items.
+
+   .. versionadded:: 2.6
+
+
+Unicode Character Properties
+""""""""""""""""""""""""""""
+
 Unicode provides many different character properties. The most often needed ones
 are available through these macros which are mapped to C functions depending on
 the Python configuration.
 
-.. % --- Unicode character properties ---------------------------------------
-
 
 .. cfunction:: int Py_UNICODE_ISSPACE(Py_UNICODE ch)
 
@@ -180,11 +198,13 @@
    Return the character *ch* converted to a double. Return ``-1.0`` if this is not
    possible.  This macro does not raise exceptions.
 
+
+Plain Py_UNICODE
+""""""""""""""""
+
 To create Unicode objects and access their basic sequence properties, use these
 APIs:
 
-.. % --- Plain Py_UNICODE ---------------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)
 
@@ -195,6 +215,10 @@
    Therefore, modification of the resulting Unicode object is only allowed when *u*
    is *NULL*.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: Py_UNICODE* PyUnicode_AsUnicode(PyObject *unicode)
 
@@ -206,6 +230,10 @@
 
    Return the length of the Unicode object.
 
+   .. versionchanged:: 2.5
+      This function returned an :ctype:`int` type. This might require changes
+      in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
 
@@ -234,14 +262,21 @@
 Support is optimized if Python's own :ctype:`Py_UNICODE` type is identical to
 the system's :ctype:`wchar_t`.
 
-.. % --- wchar_t support for platforms which support it ---------------------
-
+
+wchar_t Support
+"""""""""""""""
+
+wchar_t support for platforms which support it:
 
 .. cfunction:: PyObject* PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
 
    Create a Unicode object from the :ctype:`wchar_t` buffer *w* of the given size.
    Return *NULL* on failure.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: Py_ssize_t PyUnicode_AsWideChar(PyUnicodeObject *unicode, wchar_t *w, Py_ssize_t size)
 
@@ -253,18 +288,23 @@
    to make sure that the :ctype:`wchar_t` string is 0-terminated in case this is
    required by the application.
 
+   .. versionchanged:: 2.5
+      This function returned an :ctype:`int` type and used an :ctype:`int`
+      type for *size*. This might require changes in your code for properly
+      supporting 64-bit systems.
+
 
 .. _builtincodecs:
 
 Built-in Codecs
 ^^^^^^^^^^^^^^^
 
-Python provides a set of builtin codecs which are written in C for speed. All of
+Python provides a set of built-in codecs which are written in C for speed. All of
 these codecs are directly usable via the following functions.
 
 Many of the following APIs take two arguments encoding and errors. These
 parameters encoding and errors have the same semantics as the ones of the
-builtin unicode() Unicode object constructor.
+built-in :func:`unicode` Unicode object constructor.
 
 Setting encoding to *NULL* causes the default encoding to be used which is
 ASCII.  The file system calls should use :cdata:`Py_FileSystemDefaultEncoding`
@@ -274,24 +314,30 @@
 
 Error handling is set by errors which may also be set to *NULL* meaning to use
 the default handling defined for the codec.  Default error handling for all
-builtin codecs is "strict" (:exc:`ValueError` is raised).
+built-in codecs is "strict" (:exc:`ValueError` is raised).
 
 The codecs all use a similar interface.  Only deviation from the following
 generic ones are documented for simplicity.
 
+
+Generic Codecs
+""""""""""""""
+
 These are the generic codec APIs:
 
-.. % --- Generic Codecs -----------------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
 
    Create a Unicode object by decoding *size* bytes of the encoded string *s*.
    *encoding* and *errors* have the same meaning as the parameters of the same name
-   in the :func:`unicode` builtin function.  The codec to be used is looked up
+   in the :func:`unicode` built-in function.  The codec to be used is looked up
    using the Python codec registry.  Return *NULL* if an exception was raised by
    the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_Encode(const Py_UNICODE *s, Py_ssize_t size, const char *encoding, const char *errors)
 
@@ -301,6 +347,10 @@
    looked up using the Python codec registry.  Return *NULL* if an exception was
    raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
 
@@ -310,16 +360,22 @@
    the Python codec registry. Return *NULL* if an exception was raised by the
    codec.
 
+
+UTF-8 Codecs
+""""""""""""
+
 These are the UTF-8 codec APIs:
 
-.. % --- UTF-8 Codecs -------------------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeUTF8(const char *s, Py_ssize_t size, const char *errors)
 
    Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string
    *s*. Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_DecodeUTF8Stateful(const char *s, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)
 
@@ -330,12 +386,20 @@
 
    .. versionadded:: 2.4
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeUTF8(const Py_UNICODE *s, Py_ssize_t size, const char *errors)
 
    Encode the :ctype:`Py_UNICODE` buffer of the given size using UTF-8 and return a
    Python string object.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsUTF8String(PyObject *unicode)
 
@@ -343,10 +407,12 @@
    object.  Error handling is "strict".  Return *NULL* if an exception was raised
    by the codec.
 
+
+UTF-32 Codecs
+"""""""""""""
+
 These are the UTF-32 codec APIs:
 
-.. % --- UTF-32 Codecs ------------------------------------------------------ */
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeUTF32(const char *s, Py_ssize_t size, const char *errors, int *byteorder)
 
@@ -361,10 +427,13 @@
       *byteorder == 0:  native order
       *byteorder == 1:  big endian
 
-   and then switches if the first four bytes of the input data are a byte order mark
-   (BOM) and the specified byte order is native order.  This BOM is not copied into
-   the resulting Unicode string.  After completion, *\*byteorder* is set to the
-   current byte order at the end of input data.
+   If ``*byteorder`` is zero, and the first four bytes of the input data are a
+   byte order mark (BOM), the decoder switches to this byte order and the BOM is
+   not copied into the resulting Unicode string.  If ``*byteorder`` is ``-1`` or
+   ``1``, any byte order mark is copied to the output.
+
+   After completion, *\*byteorder* is set to the current byte order at the end
+   of input data.
 
    In a narrow build codepoints outside the BMP will be decoded as surrogate pairs.
 
@@ -389,8 +458,7 @@
 .. cfunction:: PyObject* PyUnicode_EncodeUTF32(const Py_UNICODE *s, Py_ssize_t size, const char *errors, int byteorder)
 
    Return a Python bytes object holding the UTF-32 encoded value of the Unicode
-   data in *s*.  If *byteorder* is not ``0``, output is written according to the
-   following byte order::
+   data in *s*.  Output is written according to the following byte order::
 
       byteorder == -1: little endian
       byteorder == 0:  native byte order (writes a BOM mark)
@@ -416,10 +484,11 @@
    .. versionadded:: 2.6
 
 
+UTF-16 Codecs
+"""""""""""""
+
 These are the UTF-16 codec APIs:
 
-.. % --- UTF-16 Codecs ------------------------------------------------------ */
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors, int *byteorder)
 
@@ -434,15 +503,23 @@
       *byteorder == 0:  native order
       *byteorder == 1:  big endian
 
-   and then switches if the first two bytes of the input data are a byte order mark
-   (BOM) and the specified byte order is native order.  This BOM is not copied into
-   the resulting Unicode string.  After completion, *\*byteorder* is set to the
-   current byte order at the.
+   If ``*byteorder`` is zero, and the first two bytes of the input data are a
+   byte order mark (BOM), the decoder switches to this byte order and the BOM is
+   not copied into the resulting Unicode string.  If ``*byteorder`` is ``-1`` or
+   ``1``, any byte order mark is copied to the output (where it will result in
+   either a ``\ufeff`` or a ``\ufffe`` character).
+
+   After completion, *\*byteorder* is set to the current byte order at the end
+   of input data.
 
    If *byteorder* is *NULL*, the codec starts in native order mode.
 
    Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_DecodeUTF16Stateful(const char *s, Py_ssize_t size, const char *errors, int *byteorder, Py_ssize_t *consumed)
 
@@ -454,12 +531,16 @@
 
    .. versionadded:: 2.4
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size* and an :ctype:`int *`
+      type for *consumed*. This might require changes in your code for
+      properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeUTF16(const Py_UNICODE *s, Py_ssize_t size, const char *errors, int byteorder)
 
    Return a Python string object holding the UTF-16 encoded value of the Unicode
-   data in *s*.  If *byteorder* is not ``0``, output is written according to the
-   following byte order::
+   data in *s*.  Output is written according to the following byte order::
 
       byteorder == -1: little endian
       byteorder == 0:  native byte order (writes a BOM mark)
@@ -474,6 +555,10 @@
 
    Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsUTF16String(PyObject *unicode)
 
@@ -481,16 +566,54 @@
    string always starts with a BOM mark.  Error handling is "strict".  Return
    *NULL* if an exception was raised by the codec.
 
+
+UTF-7 Codecs
+""""""""""""
+
+These are the UTF-7 codec APIs:
+
+
+.. cfunction:: PyObject* PyUnicode_DecodeUTF7(const char *s, Py_ssize_t size, const char *errors)
+
+   Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string
+   *s*.  Return *NULL* if an exception was raised by the codec.
+
+
+.. cfunction:: PyObject* PyUnicode_DecodeUTF8Stateful(const char *s, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)
+
+   If *consumed* is *NULL*, behave like :cfunc:`PyUnicode_DecodeUTF7`.  If
+   *consumed* is not *NULL*, trailing incomplete UTF-7 base-64 sections will not
+   be treated as an error.  Those bytes will not be decoded and the number of
+   bytes that have been decoded will be stored in *consumed*.
+
+
+.. cfunction:: PyObject* PyUnicode_EncodeUTF7(const Py_UNICODE *s, Py_ssize_t size, int base64SetO, int base64WhiteSpace, const char *errors)
+
+   Encode the :ctype:`Py_UNICODE` buffer of the given size using UTF-7 and
+   return a Python bytes object.  Return *NULL* if an exception was raised by
+   the codec.
+
+   If *base64SetO* is nonzero, "Set O" (punctuation that has no otherwise
+   special meaning) will be encoded in base-64.  If *base64WhiteSpace* is
+   nonzero, whitespace will be encoded in base-64.  Both are set to zero for the
+   Python "utf-7" codec.
+
+
+Unicode-Escape Codecs
+"""""""""""""""""""""
+
 These are the "Unicode Escape" codec APIs:
 
-.. % --- Unicode-Escape Codecs ----------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeUnicodeEscape(const char *s, Py_ssize_t size, const char *errors)
 
    Create a Unicode object by decoding *size* bytes of the Unicode-Escape encoded
    string *s*.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeUnicodeEscape(const Py_UNICODE *s, Py_ssize_t size)
 
@@ -498,6 +621,10 @@
    return a Python string object.  Return *NULL* if an exception was raised by the
    codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
 
@@ -505,16 +632,22 @@
    string object.  Error handling is "strict". Return *NULL* if an exception was
    raised by the codec.
 
+
+Raw-Unicode-Escape Codecs
+"""""""""""""""""""""""""
+
 These are the "Raw Unicode Escape" codec APIs:
 
-.. % --- Raw-Unicode-Escape Codecs ------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeRawUnicodeEscape(const char *s, Py_ssize_t size, const char *errors)
 
    Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape
    encoded string *s*.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeRawUnicodeEscape(const Py_UNICODE *s, Py_ssize_t size, const char *errors)
 
@@ -522,6 +655,10 @@
    and return a Python string object.  Return *NULL* if an exception was raised by
    the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
 
@@ -529,23 +666,33 @@
    Python string object. Error handling is "strict". Return *NULL* if an exception
    was raised by the codec.
 
+
+Latin-1 Codecs
+""""""""""""""
+
 These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 Unicode
 ordinals and only these are accepted by the codecs during encoding.
 
-.. % --- Latin-1 Codecs -----------------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeLatin1(const char *s, Py_ssize_t size, const char *errors)
 
    Create a Unicode object by decoding *size* bytes of the Latin-1 encoded string
    *s*.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeLatin1(const Py_UNICODE *s, Py_ssize_t size, const char *errors)
 
    Encode the :ctype:`Py_UNICODE` buffer of the given size using Latin-1 and return
    a Python string object.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsLatin1String(PyObject *unicode)
 
@@ -553,23 +700,33 @@
    object.  Error handling is "strict".  Return *NULL* if an exception was raised
    by the codec.
 
+
+ASCII Codecs
+""""""""""""
+
 These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All other
 codes generate errors.
 
-.. % --- ASCII Codecs -------------------------------------------------------
-
 
 .. cfunction:: PyObject* PyUnicode_DecodeASCII(const char *s, Py_ssize_t size, const char *errors)
 
    Create a Unicode object by decoding *size* bytes of the ASCII encoded string
    *s*.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeASCII(const Py_UNICODE *s, Py_ssize_t size, const char *errors)
 
    Encode the :ctype:`Py_UNICODE` buffer of the given size using ASCII and return a
    Python string object.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsASCIIString(PyObject *unicode)
 
@@ -577,10 +734,12 @@
    object.  Error handling is "strict".  Return *NULL* if an exception was raised
    by the codec.
 
+
+Character Map Codecs
+""""""""""""""""""""
+
 These are the mapping codec APIs:
 
-.. % --- Character Map Codecs -----------------------------------------------
-
 This codec is special in that it can be used to implement many different codecs
 (and this is in fact what was done to obtain most of the standard codecs
 included in the :mod:`encodings` package). The codec uses mapping to encode and
@@ -615,6 +774,10 @@
    .. versionchanged:: 2.4
       Allowed unicode string as mapping argument.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_EncodeCharmap(const Py_UNICODE *s, Py_ssize_t size, PyObject *mapping, const char *errors)
 
@@ -622,6 +785,10 @@
    *mapping* object and return a Python string object. Return *NULL* if an
    exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
 
@@ -645,12 +812,18 @@
    and sequences work well.  Unmapped character ordinals (ones which cause a
    :exc:`LookupError`) are left untouched and are copied as-is.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 These are the MBCS codec APIs. They are currently only available on Windows and
 use the Win32 MBCS converters to implement the conversions.  Note that MBCS (or
 DBCS) is a class of encodings, not just one.  The target encoding is defined by
 the user settings on the machine running the codec.
 
-.. % --- MBCS codecs for Windows --------------------------------------------
+
+MBCS codecs for Windows
+"""""""""""""""""""""""
 
 
 .. cfunction:: PyObject* PyUnicode_DecodeMBCS(const char *s, Py_ssize_t size, const char *errors)
@@ -658,6 +831,10 @@
    Create a Unicode object by decoding *size* bytes of the MBCS encoded string *s*.
    Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_DecodeMBCSStateful(const char *s, int size, const char *errors, int *consumed)
 
@@ -674,6 +851,10 @@
    Encode the :ctype:`Py_UNICODE` buffer of the given size using MBCS and return a
    Python string object.  Return *NULL* if an exception was raised by the codec.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *size*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_AsMBCSString(PyObject *unicode)
 
@@ -681,8 +862,9 @@
    object.  Error handling is "strict".  Return *NULL* if an exception was raised
    by the codec.
 
-.. % --- Methods & Slots ----------------------------------------------------
 
+Methods & Slots
+"""""""""""""""
 
 .. _unicodemethodsandslots:
 
@@ -708,6 +890,10 @@
    separator.  At most *maxsplit* splits will be done.  If negative, no limit is
    set.  Separators are not included in the resulting list.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *maxsplit*. This might require
+      changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_Splitlines(PyObject *s, int keepend)
 
@@ -744,6 +930,11 @@
    (*direction* == -1 means to do a prefix match, *direction* == 1 a suffix match),
    0 otherwise. Return ``-1`` if an error occurred.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *start* and *end*. This
+      might require changes in your code for properly supporting 64-bit
+      systems.
+
 
 .. cfunction:: Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
 
@@ -753,12 +944,22 @@
    ``-1`` indicates that no match was found, and ``-2`` indicates that an error
    occurred and an exception has been set.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *start* and *end*. This
+      might require changes in your code for properly supporting 64-bit
+      systems.
+
 
 .. cfunction:: Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
 
    Return the number of non-overlapping occurrences of *substr* in
    ``str[start:end]``.  Return ``-1`` if an error occurred.
 
+   .. versionchanged:: 2.5
+      This function returned an :ctype:`int` type and used an :ctype:`int`
+      type for *start* and *end*. This might require changes in your code for
+      properly supporting 64-bit systems.
+
 
 .. cfunction:: PyObject* PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
 
@@ -766,6 +967,10 @@
    return the resulting Unicode object. *maxcount* == -1 means replace all
    occurrences.
 
+   .. versionchanged:: 2.5
+      This function used an :ctype:`int` type for *maxcount*. This might
+      require changes in your code for properly supporting 64-bit systems.
+
 
 .. cfunction:: int PyUnicode_Compare(PyObject *left, PyObject *right)
 


--- r262/c-api/typeobj.rst	2009-04-06 06:48:06.719229000 +0900
+++ r266/c-api/typeobj.rst	2010-03-22 04:29:04.684594000 +0900
@@ -55,24 +55,28 @@
 
 
 .. cmember:: Py_ssize_t PyObject.ob_refcnt
 
    This is the type object's reference count, initialized to ``1`` by the
    ``PyObject_HEAD_INIT`` macro.  Note that for statically allocated type objects,
    the type's instances (objects whose :attr:`ob_type` points back to the type) do
    *not* count as references.  But for dynamically allocated type objects, the
    instances *do* count as references.
 
    This field is not inherited by subtypes.
 
+   .. versionchanged:: 2.5
+      This field used to be an :ctype:`int` type. This might require changes
+      in your code for properly supporting 64-bit systems.
+
 
 .. cmember:: PyTypeObject* PyObject.ob_type
 
    This is the type's type, in other words its metatype.  It is initialized by the
    argument to the ``PyObject_HEAD_INIT`` macro, and its value should normally be
    ``&PyType_Type``.  However, for dynamically loadable extension modules that must
    be usable on Windows (at least), the compiler complains that this is not a valid
    initializer.  Therefore, the convention is to pass *NULL* to the
    ``PyObject_HEAD_INIT`` macro and to initialize this field explicitly at the
    start of the module's initialization function, before doing anything else.  This
    is typically done like this::
 
@@ -176,25 +180,25 @@
    :cfunc:`Py_XDECREF` macros when the new reference count is zero.  At this point,
    the instance is still in existence, but there are no references to it.  The
    destructor function should free all references which the instance owns, free all
    memory buffers owned by the instance (using the freeing function corresponding
    to the allocation function used to allocate the buffer), and finally (as its
    last action) call the type's :attr:`tp_free` function.  If the type is not
    subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), it is
    permissible to call the object deallocator directly instead of via
    :attr:`tp_free`.  The object deallocator should be the one used to allocate the
    instance; this is normally :cfunc:`PyObject_Del` if the instance was allocated
    using :cfunc:`PyObject_New` or :cfunc:`PyObject_VarNew`, or
    :cfunc:`PyObject_GC_Del` if the instance was allocated using
-   :cfunc:`PyObject_GC_New` or :cfunc:`PyObject_GC_VarNew`.
+   :cfunc:`PyObject_GC_New` or :cfunc:`PyObject_GC_NewVar`.
 
    This field is inherited by subtypes.
 
 
 .. cmember:: printfunc PyTypeObject.tp_print
 
    An optional pointer to the instance print function.
 
    The print function is only called when the instance is printed to a *real* file;
    when it is printed to a pseudo-file (like a :class:`StringIO` instance), the
    instance's :attr:`tp_repr` or :attr:`tp_str` function is called to convert it to
    a string.  These are also called when the type's :attr:`tp_print` field is
@@ -1147,24 +1151,25 @@
 .. ctype:: PyNumberMethods
 
    This structure holds pointers to the functions which an object uses to
    implement the number protocol.  Almost every function below is used by the
    function of similar name documented in the :ref:`number` section.
 
    Here is the structure definition::
 
        typedef struct {
             binaryfunc nb_add;
             binaryfunc nb_subtract;
             binaryfunc nb_multiply;
+            binaryfunc nb_divide;
             binaryfunc nb_remainder;
             binaryfunc nb_divmod;
             ternaryfunc nb_power;
             unaryfunc nb_negative;
             unaryfunc nb_positive;
             unaryfunc nb_absolute;
             inquiry nb_nonzero;       /* Used by PyObject_IsTrue */
             unaryfunc nb_invert;
             binaryfunc nb_lshift;
             binaryfunc nb_rshift;
             binaryfunc nb_and;
             binaryfunc nb_xor;

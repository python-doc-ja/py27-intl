<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>c-api/init.rst</title>
<style type="text/css">
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<div class="highlight"><pre><span class="gu">@@ -1,22 +1,26 @@</span>
 .. highlightlang:: c
 
 
 .. _initialization:
 
 *****************************************
 Initialization, Finalization, and Threads
 *****************************************
 
 
<span class="gi">+Initializing and finalizing the interpreter</span>
<span class="gi">+===========================================</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. cfunction:: void Py_Initialize()
 
    .. index::
       single: Py_SetProgramName()
       single: PyEval_InitThreads()
       single: PyEval_ReleaseLock()
       single: PyEval_AcquireLock()
       single: modules (in module sys)
       single: path (in module sys)
       module: __builtin__
       module: __main__
       module: sys
<span class="gu">@@ -74,103 +78,26 @@</span>
    **Bugs and caveats:** The destruction of modules and objects in modules is done
    in random order; this may cause destructors (:meth:`__del__` methods) to fail
    when they depend on other objects (even functions) or modules.  Dynamically
    loaded extension modules loaded by Python are not unloaded.  Small amounts of
    memory allocated by the Python interpreter may not be freed (if you find a leak,
    please report it).  Memory tied up in circular references between objects is not
    freed.  Some memory allocated by extension modules may not be freed.  Some
    extensions may not work properly if their initialization routine is called more
    than once; this can happen if an application calls :cfunc:`Py_Initialize` and
    :cfunc:`Py_Finalize` more than once.
 
 
<span class="gd">-.. cfunction:: PyThreadState* Py_NewInterpreter()</span>
<span class="gd">-</span>
<span class="gd">-   .. index::</span>
<span class="gd">-      module: __builtin__</span>
<span class="gd">-      module: __main__</span>
<span class="gd">-      module: sys</span>
<span class="gd">-      single: stdout (in module sys)</span>
<span class="gd">-      single: stderr (in module sys)</span>
<span class="gd">-      single: stdin (in module sys)</span>
<span class="gd">-</span>
<span class="gd">-   Create a new sub-interpreter.  This is an (almost) totally separate environment</span>
<span class="gd">-   for the execution of Python code.  In particular, the new interpreter has</span>
<span class="gd">-   separate, independent versions of all imported modules, including the</span>
<span class="gd">-   fundamental modules :mod:`__builtin__`, :mod:`__main__` and :mod:`sys`.  The</span>
<span class="gd">-   table of loaded modules (``sys.modules``) and the module search path</span>
<span class="gd">-   (``sys.path``) are also separate.  The new environment has no ``sys.argv``</span>
<span class="gd">-   variable.  It has new standard I/O stream file objects ``sys.stdin``,</span>
<span class="gd">-   ``sys.stdout`` and ``sys.stderr`` (however these refer to the same underlying</span>
<span class="gd">-   :ctype:`FILE` structures in the C library).</span>
<span class="gd">-</span>
<span class="gd">-   The return value points to the first thread state created in the new</span>
<span class="gd">-   sub-interpreter.  This thread state is made in the current thread state.</span>
<span class="gd">-   Note that no actual thread is created; see the discussion of thread states</span>
<span class="gd">-   below.  If creation of the new interpreter is unsuccessful, *NULL* is</span>
<span class="gd">-   returned; no exception is set since the exception state is stored in the</span>
<span class="gd">-   current thread state and there may not be a current thread state.  (Like all</span>
<span class="gd">-   other Python/C API functions, the global interpreter lock must be held before</span>
<span class="gd">-   calling this function and is still held when it returns; however, unlike most</span>
<span class="gd">-   other Python/C API functions, there needn&#39;t be a current thread state on</span>
<span class="gd">-   entry.)</span>
<span class="gd">-</span>
<span class="gd">-   .. index::</span>
<span class="gd">-      single: Py_Finalize()</span>
<span class="gd">-      single: Py_Initialize()</span>
<span class="gd">-</span>
<span class="gd">-   Extension modules are shared between (sub-)interpreters as follows: the first</span>
<span class="gd">-   time a particular extension is imported, it is initialized normally, and a</span>
<span class="gd">-   (shallow) copy of its module&#39;s dictionary is squirreled away.  When the same</span>
<span class="gd">-   extension is imported by another (sub-)interpreter, a new module is initialized</span>
<span class="gd">-   and filled with the contents of this copy; the extension&#39;s ``init`` function is</span>
<span class="gd">-   not called.  Note that this is different from what happens when an extension is</span>
<span class="gd">-   imported after the interpreter has been completely re-initialized by calling</span>
<span class="gd">-   :cfunc:`Py_Finalize` and :cfunc:`Py_Initialize`; in that case, the extension&#39;s</span>
<span class="gd">-   ``initmodule`` function *is* called again.</span>
<span class="gd">-</span>
<span class="gd">-   .. index:: single: close() (in module os)</span>
<span class="gd">-</span>
<span class="gd">-   **Bugs and caveats:** Because sub-interpreters (and the main interpreter) are</span>
<span class="gd">-   part of the same process, the insulation between them isn&#39;t perfect --- for</span>
<span class="gd">-   example, using low-level file operations like  :func:`os.close` they can</span>
<span class="gd">-   (accidentally or maliciously) affect each other&#39;s open files.  Because of the</span>
<span class="gd">-   way extensions are shared between (sub-)interpreters, some extensions may not</span>
<span class="gd">-   work properly; this is especially likely when the extension makes use of</span>
<span class="gd">-   (static) global variables, or when the extension manipulates its module&#39;s</span>
<span class="gd">-   dictionary after its initialization.  It is possible to insert objects created</span>
<span class="gd">-   in one sub-interpreter into a namespace of another sub-interpreter; this should</span>
<span class="gd">-   be done with great care to avoid sharing user-defined functions, methods,</span>
<span class="gd">-   instances or classes between sub-interpreters, since import operations executed</span>
<span class="gd">-   by such objects may affect the wrong (sub-)interpreter&#39;s dictionary of loaded</span>
<span class="gd">-   modules.  (XXX This is a hard-to-fix bug that will be addressed in a future</span>
<span class="gd">-   release.)</span>
<span class="gd">-</span>
<span class="gd">-   Also note that the use of this functionality is incompatible with extension</span>
<span class="gd">-   modules such as PyObjC and ctypes that use the :cfunc:`PyGILState_\*` APIs (and</span>
<span class="gd">-   this is inherent in the way the :cfunc:`PyGILState_\*` functions work).  Simple</span>
<span class="gd">-   things may work, but confusing behavior will always be near.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void Py_EndInterpreter(PyThreadState *tstate)</span>
<span class="gd">-</span>
<span class="gd">-   .. index:: single: Py_Finalize()</span>
<span class="gd">-</span>
<span class="gd">-   Destroy the (sub-)interpreter represented by the given thread state. The given</span>
<span class="gd">-   thread state must be the current thread state.  See the discussion of thread</span>
<span class="gd">-   states below.  When the call returns, the current thread state is *NULL*.  All</span>
<span class="gd">-   thread states associated with this interpreter are destroyed.  (The global</span>
<span class="gd">-   interpreter lock must be held before calling this function and is still held</span>
<span class="gd">-   when it returns.)  :cfunc:`Py_Finalize` will destroy all sub-interpreters that</span>
<span class="gd">-   haven&#39;t been explicitly destroyed at that point.</span>
<span class="gi">+Process-wide parameters</span>
<span class="gi">+=======================</span>
 
 
 .. cfunction:: void Py_SetProgramName(char *name)
 
    .. index::
       single: Py_Initialize()
       single: main()
       single: Py_GetPath()
 
    This function should be called before :cfunc:`Py_Initialize` is called for
    the first time, if it is called at all.  It tells the interpreter the value
    of the ``argv[0]`` argument to the :cfunc:`main` function of the program.
<span class="gu">@@ -377,198 +304,200 @@</span>
       :cfunc:`PySys_SetArgv`, for example using::
 
          PyRun_SimpleString(&quot;import sys; sys.path.pop(0)\n&quot;);
 
    .. versionadded:: 2.6.6
 
    .. XXX impl. doesn&#39;t seem consistent in allowing 0/NULL for the params;
       check w/ Guido.
 
 
 .. cfunction:: void PySys_SetArgv(int argc, char **argv)
 
<span class="gd">-   This function works like :cfunc:`PySys_SetArgv` with *updatepath* set to 1.</span>
<span class="gi">+   This function works like :cfunc:`PySys_SetArgvEx` with *updatepath* set to 1.</span>
 
 
 .. cfunction:: void Py_SetPythonHome(char *home)
 
    Set the default &quot;home&quot; directory, that is, the location of the standard
<span class="gd">-   Python libraries.  The libraries are searched in</span>
<span class="gd">-   :file:`{home}/lib/python{version}` and :file:`{home}/lib/python{version}`.</span>
<span class="gi">+   Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the</span>
<span class="gi">+   argument string.</span>
<span class="gi">+</span>
    The argument should point to a zero-terminated character string in static
    storage whose contents will not change for the duration of the program&#39;s
    execution.  No code in the Python interpreter will change the contents of
    this storage.
 
 
 .. cfunction:: char* Py_GetPythonHome()
 
    Return the default &quot;home&quot;, that is, the value set by a previous call to
    :cfunc:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME`
    environment variable if it is set.
 
 
 .. _threads:
 
 Thread State and the Global Interpreter Lock
 ============================================
 
 .. index::
<span class="gi">+   single: GIL</span>
    single: global interpreter lock
    single: interpreter lock
    single: lock, interpreter
 
<span class="gd">-The Python interpreter is not fully thread safe.  In order to support</span>
<span class="gd">-multi-threaded Python programs, there&#39;s a global lock, called the :dfn:`global</span>
<span class="gd">-interpreter lock` or :dfn:`GIL`, that must be held by the current thread before</span>
<span class="gi">+The Python interpreter is not fully thread-safe.  In order to support</span>
<span class="gi">+multi-threaded Python programs, there&#39;s a global lock, called the :term:`global</span>
<span class="gi">+interpreter lock` or :term:`GIL`, that must be held by the current thread before</span>
 it can safely access Python objects. Without the lock, even the simplest
 operations could cause problems in a multi-threaded program: for example, when
 two threads simultaneously increment the reference count of the same object, the
 reference count could end up being incremented only once instead of twice.
 
 .. index:: single: setcheckinterval() (in module sys)
 
<span class="gd">-Therefore, the rule exists that only the thread that has acquired the global</span>
<span class="gd">-interpreter lock may operate on Python objects or call Python/C API functions.</span>
<span class="gd">-In order to support multi-threaded Python programs, the interpreter regularly</span>
<span class="gd">-releases and reacquires the lock --- by default, every 100 bytecode instructions</span>
<span class="gd">-(this can be changed with  :func:`sys.setcheckinterval`).  The lock is also</span>
<span class="gd">-released and reacquired around potentially blocking I/O operations like reading</span>
<span class="gd">-or writing a file, so that other threads can run while the thread that requests</span>
<span class="gd">-the I/O is waiting for the I/O operation to complete.</span>
<span class="gi">+Therefore, the rule exists that only the thread that has acquired the</span>
<span class="gi">+:term:`GIL` may operate on Python objects or call Python/C API functions.</span>
<span class="gi">+In order to emulate concurrency of execution, the interpreter regularly</span>
<span class="gi">+tries to switch threads (see :func:`sys.setcheckinterval`).  The lock is also</span>
<span class="gi">+released around potentially blocking I/O operations like reading or writing</span>
<span class="gi">+a file, so that other Python threads can run in the meantime.</span>
 
 .. index::
    single: PyThreadState
    single: PyThreadState
 
<span class="gd">-The Python interpreter needs to keep some bookkeeping information separate per</span>
<span class="gd">-thread --- for this it uses a data structure called :ctype:`PyThreadState`.</span>
<span class="gd">-There&#39;s one global variable, however: the pointer to the current</span>
<span class="gd">-:ctype:`PyThreadState` structure.  Before the addition of :dfn:`thread-local</span>
<span class="gd">-storage` (:dfn:`TLS`) the current thread state had to be manipulated</span>
<span class="gd">-explicitly.</span>
<span class="gi">+The Python interpreter keeps some thread-specific bookkeeping information</span>
<span class="gi">+inside a data structure called :ctype:`PyThreadState`.  There&#39;s also one</span>
<span class="gi">+global variable pointing to the current :ctype:`PyThreadState`: it can</span>
<span class="gi">+be retrieved using :cfunc:`PyThreadState_Get`.</span>
 
<span class="gd">-This is easy enough in most cases.  Most code manipulating the global</span>
<span class="gd">-interpreter lock has the following simple structure::</span>
<span class="gi">+Releasing the GIL from extension code</span>
<span class="gi">+-------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+Most extension code manipulating the :term:`GIL` has the following simple</span>
<span class="gi">+structure::</span>
 
    Save the thread state in a local variable.
    Release the global interpreter lock.
<span class="gd">-   ...Do some blocking I/O operation...</span>
<span class="gi">+   ... Do some blocking I/O operation ...</span>
    Reacquire the global interpreter lock.
    Restore the thread state from the local variable.
 
 This is so common that a pair of macros exists to simplify it::
 
    Py_BEGIN_ALLOW_THREADS
<span class="gd">-   ...Do some blocking I/O operation...</span>
<span class="gi">+   ... Do some blocking I/O operation ...</span>
    Py_END_ALLOW_THREADS
 
 .. index::
    single: Py_BEGIN_ALLOW_THREADS
    single: Py_END_ALLOW_THREADS
 
 The :cmacro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a
 hidden local variable; the :cmacro:`Py_END_ALLOW_THREADS` macro closes the
<span class="gd">-block.  Another advantage of using these two macros is that when Python is</span>
<span class="gd">-compiled without thread support, they are defined empty, thus saving the thread</span>
<span class="gd">-state and GIL manipulations.</span>
<span class="gi">+block.  These two macros are still available when Python is compiled without</span>
<span class="gi">+thread support (they simply have an empty expansion).</span>
 
 When thread support is enabled, the block above expands to the following code::
 
    PyThreadState *_save;
 
    _save = PyEval_SaveThread();
    ...Do some blocking I/O operation...
    PyEval_RestoreThread(_save);
 
<span class="gd">-Using even lower level primitives, we can get roughly the same effect as</span>
<span class="gd">-follows::</span>
<span class="gd">-</span>
<span class="gd">-   PyThreadState *_save;</span>
<span class="gd">-</span>
<span class="gd">-   _save = PyThreadState_Swap(NULL);</span>
<span class="gd">-   PyEval_ReleaseLock();</span>
<span class="gd">-   ...Do some blocking I/O operation...</span>
<span class="gd">-   PyEval_AcquireLock();</span>
<span class="gd">-   PyThreadState_Swap(_save);</span>
<span class="gd">-</span>
 .. index::
    single: PyEval_RestoreThread()
<span class="gd">-   single: errno</span>
    single: PyEval_SaveThread()
<span class="gd">-   single: PyEval_ReleaseLock()</span>
<span class="gd">-   single: PyEval_AcquireLock()</span>
 
<span class="gd">-There are some subtle differences; in particular, :cfunc:`PyEval_RestoreThread`</span>
<span class="gd">-saves and restores the value of the  global variable :cdata:`errno`, since the</span>
<span class="gd">-lock manipulation does not guarantee that :cdata:`errno` is left alone.  Also,</span>
<span class="gd">-when thread support is disabled, :cfunc:`PyEval_SaveThread` and</span>
<span class="gd">-:cfunc:`PyEval_RestoreThread` don&#39;t manipulate the GIL; in this case,</span>
<span class="gd">-:cfunc:`PyEval_ReleaseLock` and :cfunc:`PyEval_AcquireLock` are not available.</span>
<span class="gd">-This is done so that dynamically loaded extensions compiled with thread support</span>
<span class="gd">-enabled can be loaded by an interpreter that was compiled with disabled thread</span>
<span class="gd">-support.</span>
<span class="gi">+Here is how these functions work: the global interpreter lock is used to protect the pointer to the</span>
<span class="gi">+current thread state.  When releasing the lock and saving the thread state,</span>
<span class="gi">+the current thread state pointer must be retrieved before the lock is released</span>
<span class="gi">+(since another thread could immediately acquire the lock and store its own thread</span>
<span class="gi">+state in the global variable). Conversely, when acquiring the lock and restoring</span>
<span class="gi">+the thread state, the lock must be acquired before storing the thread state</span>
<span class="gi">+pointer.</span>
 
<span class="gd">-The global interpreter lock is used to protect the pointer to the current thread</span>
<span class="gd">-state.  When releasing the lock and saving the thread state, the current thread</span>
<span class="gd">-state pointer must be retrieved before the lock is released (since another</span>
<span class="gd">-thread could immediately acquire the lock and store its own thread state in the</span>
<span class="gd">-global variable). Conversely, when acquiring the lock and restoring the thread</span>
<span class="gd">-state, the lock must be acquired before storing the thread state pointer.</span>
<span class="gi">+.. note::</span>
<span class="gi">+   Calling system I/O functions is the most common use case for releasing</span>
<span class="gi">+   the GIL, but it can also be useful before calling long-running computations</span>
<span class="gi">+   which don&#39;t need access to Python objects, such as compression or</span>
<span class="gi">+   cryptographic functions operating over memory buffers.  For example, the</span>
<span class="gi">+   standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when</span>
<span class="gi">+   compressing or hashing data.</span>
 
<span class="gd">-It is important to note that when threads are created from C, they don&#39;t have</span>
<span class="gd">-the global interpreter lock, nor is there a thread state data structure for</span>
<span class="gd">-them.  Such threads must bootstrap themselves into existence, by first</span>
<span class="gd">-creating a thread state data structure, then acquiring the lock, and finally</span>
<span class="gd">-storing their thread state pointer, before they can start using the Python/C</span>
<span class="gd">-API.  When they are done, they should reset the thread state pointer, release</span>
<span class="gd">-the lock, and finally free their thread state data structure.</span>
<span class="gi">+Non-Python created threads</span>
<span class="gi">+--------------------------</span>
 
<span class="gd">-Beginning with version 2.3, threads can now take advantage of the</span>
<span class="gd">-:cfunc:`PyGILState_\*` functions to do all of the above automatically.  The</span>
<span class="gd">-typical idiom for calling into Python from a C thread is now::</span>
<span class="gi">+When threads are created using the dedicated Python APIs (such as the</span>
<span class="gi">+:mod:`threading` module), a thread state is automatically associated to them</span>
<span class="gi">+and the code showed above is therefore correct.  However, when threads are</span>
<span class="gi">+created from C (for example by a third-party library with its own thread</span>
<span class="gi">+management), they don&#39;t hold the GIL, nor is there a thread state structure</span>
<span class="gi">+for them.</span>
<span class="gi">+</span>
<span class="gi">+If you need to call Python code from these threads (often this will be part</span>
<span class="gi">+of a callback API provided by the aforementioned third-party library),</span>
<span class="gi">+you must first register these threads with the interpreter by</span>
<span class="gi">+creating a thread state data structure, then acquiring the GIL, and finally</span>
<span class="gi">+storing their thread state pointer, before you can start using the Python/C</span>
<span class="gi">+API.  When you are done, you should reset the thread state pointer, release</span>
<span class="gi">+the GIL, and finally free the thread state data structure.</span>
<span class="gi">+</span>
<span class="gi">+The :cfunc:`PyGILState_Ensure` and :cfunc:`PyGILState_Release` functions do</span>
<span class="gi">+all of the above automatically.  The typical idiom for calling into Python</span>
<span class="gi">+from a C thread is::</span>
 
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
 
<span class="gd">-   /* Perform Python actions here.  */</span>
<span class="gi">+   /* Perform Python actions here. */</span>
    result = CallSomeFunction();
<span class="gd">-   /* evaluate result */</span>
<span class="gi">+   /* evaluate result or handle exception */</span>
 
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
 
 Note that the :cfunc:`PyGILState_\*` functions assume there is only one global
<span class="gd">-interpreter (created automatically by :cfunc:`Py_Initialize`).  Python still</span>
<span class="gi">+interpreter (created automatically by :cfunc:`Py_Initialize`).  Python</span>
 supports the creation of additional interpreters (using
 :cfunc:`Py_NewInterpreter`), but mixing multiple interpreters and the
 :cfunc:`PyGILState_\*` API is unsupported.
 
 Another important thing to note about threads is their behaviour in the face
 of the C :cfunc:`fork` call. On most systems with :cfunc:`fork`, after a
 process forks only the thread that issued the fork will exist. That also
 means any locks held by other threads will never be released. Python solves
 this for :func:`os.fork` by acquiring the locks it uses internally before
 the fork, and releasing them afterwards. In addition, it resets any
 :ref:`lock-objects` in the child. When extending or embedding Python, there
 is no way to inform Python of additional (non-Python) locks that need to be
 acquired before or reset after a fork. OS facilities such as
<span class="gd">-:cfunc:`posix_atfork` would need to be used to accomplish the same thing.</span>
<span class="gi">+:cfunc:`pthread_atfork` would need to be used to accomplish the same thing.</span>
 Additionally, when extending or embedding Python, calling :cfunc:`fork`
 directly rather than through :func:`os.fork` (and returning to or calling
 into Python) may result in a deadlock by one of Python&#39;s internal locks
 being held by a thread that is defunct after the fork.
 :cfunc:`PyOS_AfterFork` tries to reset the necessary locks, but is not
 always able to.
 
<span class="gi">+</span>
<span class="gi">+High-level API</span>
<span class="gi">+--------------</span>
<span class="gi">+</span>
<span class="gi">+These are the most commonly used types and functions when writing C extension</span>
<span class="gi">+code, or when embedding the Python interpreter:</span>
<span class="gi">+</span>
 .. ctype:: PyInterpreterState
 
    This data structure represents the state shared by a number of cooperating
    threads.  Threads belonging to the same interpreter share their module
    administration and a few other internal items. There are no public members in
    this structure.
 
    Threads belonging to different interpreters initially share nothing, except
    process state like available memory, open file descriptors and such.  The global
    interpreter lock is also shared by all threads, regardless of to which
    interpreter they belong.
 
<span class="gu">@@ -592,262 +521,426 @@</span>
    main thread before creating a second thread or engaging in any other thread
    operations such as :cfunc:`PyEval_ReleaseLock` or
    ``PyEval_ReleaseThread(tstate)``. It is not needed before calling
    :cfunc:`PyEval_SaveThread` or :cfunc:`PyEval_RestoreThread`.
 
    .. index:: single: Py_Initialize()
 
    This is a no-op when called for a second time.  It is safe to call this function
    before calling :cfunc:`Py_Initialize`.
 
    .. index:: module: thread
 
<span class="gd">-   When only the main thread exists, no GIL operations are needed. This is a</span>
<span class="gd">-   common situation (most Python programs do not use threads), and the lock</span>
<span class="gd">-   operations slow the interpreter down a bit. Therefore, the lock is not</span>
<span class="gd">-   created initially.  This situation is equivalent to having acquired the lock:</span>
<span class="gd">-   when there is only a single thread, all object accesses are safe.  Therefore,</span>
<span class="gd">-   when this function initializes the global interpreter lock, it also acquires</span>
<span class="gd">-   it.  Before the Python :mod:`thread` module creates a new thread, knowing</span>
<span class="gd">-   that either it has the lock or the lock hasn&#39;t been created yet, it calls</span>
<span class="gd">-   :cfunc:`PyEval_InitThreads`.  When this call returns, it is guaranteed that</span>
<span class="gd">-   the lock has been created and that the calling thread has acquired it.</span>
<span class="gi">+   .. note::</span>
<span class="gi">+      When only the main thread exists, no GIL operations are needed. This is a</span>
<span class="gi">+      common situation (most Python programs do not use threads), and the lock</span>
<span class="gi">+      operations slow the interpreter down a bit. Therefore, the lock is not</span>
<span class="gi">+      created initially.  This situation is equivalent to having acquired the lock:</span>
<span class="gi">+      when there is only a single thread, all object accesses are safe.  Therefore,</span>
<span class="gi">+      when this function initializes the global interpreter lock, it also acquires</span>
<span class="gi">+      it.  Before the Python :mod:`_thread` module creates a new thread, knowing</span>
<span class="gi">+      that either it has the lock or the lock hasn&#39;t been created yet, it calls</span>
<span class="gi">+      :cfunc:`PyEval_InitThreads`.  When this call returns, it is guaranteed that</span>
<span class="gi">+      the lock has been created and that the calling thread has acquired it.</span>
 
<span class="gd">-   It is **not** safe to call this function when it is unknown which thread (if</span>
<span class="gd">-   any) currently has the global interpreter lock.</span>
<span class="gi">+      It is **not** safe to call this function when it is unknown which thread (if</span>
<span class="gi">+      any) currently has the global interpreter lock.</span>
 
<span class="gd">-   This function is not available when thread support is disabled at compile time.</span>
<span class="gi">+      This function is not available when thread support is disabled at compile time.</span>
 
 
 .. cfunction:: int PyEval_ThreadsInitialized()
 
    Returns a non-zero value if :cfunc:`PyEval_InitThreads` has been called.  This
    function can be called without holding the GIL, and therefore can be used to
    avoid calls to the locking API when running single-threaded.  This function is
    not available when thread support is disabled at compile time.
 
    .. versionadded:: 2.4
 
 
<span class="gd">-.. cfunction:: void PyEval_AcquireLock()</span>
<span class="gd">-</span>
<span class="gd">-   Acquire the global interpreter lock.  The lock must have been created earlier.</span>
<span class="gd">-   If this thread already has the lock, a deadlock ensues.  This function is not</span>
<span class="gd">-   available when thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyEval_ReleaseLock()</span>
<span class="gd">-</span>
<span class="gd">-   Release the global interpreter lock.  The lock must have been created earlier.</span>
<span class="gd">-   This function is not available when thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyEval_AcquireThread(PyThreadState *tstate)</span>
<span class="gd">-</span>
<span class="gd">-   Acquire the global interpreter lock and set the current thread state to</span>
<span class="gd">-   *tstate*, which should not be *NULL*.  The lock must have been created earlier.</span>
<span class="gd">-   If this thread already has the lock, deadlock ensues.  This function is not</span>
<span class="gd">-   available when thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyEval_ReleaseThread(PyThreadState *tstate)</span>
<span class="gd">-</span>
<span class="gd">-   Reset the current thread state to *NULL* and release the global interpreter</span>
<span class="gd">-   lock.  The lock must have been created earlier and must be held by the current</span>
<span class="gd">-   thread.  The *tstate* argument, which must not be *NULL*, is only used to check</span>
<span class="gd">-   that it represents the current thread state --- if it isn&#39;t, a fatal error is</span>
<span class="gd">-   reported. This function is not available when thread support is disabled at</span>
<span class="gd">-   compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
 .. cfunction:: PyThreadState* PyEval_SaveThread()
 
    Release the global interpreter lock (if it has been created and thread
    support is enabled) and reset the thread state to *NULL*, returning the
    previous thread state (which is not *NULL*).  If the lock has been created,
    the current thread must have acquired it.  (This function is available even
    when thread support is disabled at compile time.)
 
 
 .. cfunction:: void PyEval_RestoreThread(PyThreadState *tstate)
 
    Acquire the global interpreter lock (if it has been created and thread
    support is enabled) and set the thread state to *tstate*, which must not be
    *NULL*.  If the lock has been created, the current thread must not have
    acquired it, otherwise deadlock ensues.  (This function is available even
    when thread support is disabled at compile time.)
 
 
<span class="gi">+.. cfunction:: PyThreadState* PyThreadState_Get()</span>
<span class="gi">+</span>
<span class="gi">+   Return the current thread state.  The global interpreter lock must be held.</span>
<span class="gi">+   When the current thread state is *NULL*, this issues a fatal error (so that</span>
<span class="gi">+   the caller needn&#39;t check for *NULL*).</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: PyThreadState* PyThreadState_Swap(PyThreadState *tstate)</span>
<span class="gi">+</span>
<span class="gi">+   Swap the current thread state with the thread state given by the argument</span>
<span class="gi">+   *tstate*, which may be *NULL*.  The global interpreter lock must be held</span>
<span class="gi">+   and is not released.</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. cfunction:: void PyEval_ReInitThreads()
 
    This function is called from :cfunc:`PyOS_AfterFork` to ensure that newly
    created child processes don&#39;t hold locks referring to threads which
    are not running in the child process.
 
 
<span class="gd">-The following macros are normally used without a trailing semicolon; look for</span>
<span class="gd">-example usage in the Python source distribution.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cmacro:: Py_BEGIN_ALLOW_THREADS</span>
<span class="gd">-</span>
<span class="gd">-   This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();``.</span>
<span class="gd">-   Note that it contains an opening brace; it must be matched with a following</span>
<span class="gd">-   :cmacro:`Py_END_ALLOW_THREADS` macro.  See above for further discussion of this</span>
<span class="gd">-   macro.  It is a no-op when thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cmacro:: Py_END_ALLOW_THREADS</span>
<span class="gd">-</span>
<span class="gd">-   This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it contains</span>
<span class="gd">-   a closing brace; it must be matched with an earlier</span>
<span class="gd">-   :cmacro:`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of</span>
<span class="gd">-   this macro.  It is a no-op when thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cmacro:: Py_BLOCK_THREADS</span>
<span class="gd">-</span>
<span class="gd">-   This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to</span>
<span class="gd">-   :cmacro:`Py_END_ALLOW_THREADS` without the closing brace.  It is a no-op when</span>
<span class="gd">-   thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cmacro:: Py_UNBLOCK_THREADS</span>
<span class="gd">-</span>
<span class="gd">-   This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to</span>
<span class="gd">-   :cmacro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable</span>
<span class="gd">-   declaration.  It is a no-op when thread support is disabled at compile time.</span>
<span class="gd">-</span>
<span class="gd">-All of the following functions are only available when thread support is enabled</span>
<span class="gd">-at compile time, and must be called only when the global interpreter lock has</span>
<span class="gd">-been created.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: PyInterpreterState* PyInterpreterState_New()</span>
<span class="gd">-</span>
<span class="gd">-   Create a new interpreter state object.  The global interpreter lock need not</span>
<span class="gd">-   be held, but may be held if it is necessary to serialize calls to this</span>
<span class="gd">-   function.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyInterpreterState_Clear(PyInterpreterState *interp)</span>
<span class="gd">-</span>
<span class="gd">-   Reset all information in an interpreter state object.  The global interpreter</span>
<span class="gd">-   lock must be held.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyInterpreterState_Delete(PyInterpreterState *interp)</span>
<span class="gd">-</span>
<span class="gd">-   Destroy an interpreter state object.  The global interpreter lock need not be</span>
<span class="gd">-   held.  The interpreter state must have been reset with a previous call to</span>
<span class="gd">-   :cfunc:`PyInterpreterState_Clear`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: PyThreadState* PyThreadState_New(PyInterpreterState *interp)</span>
<span class="gd">-</span>
<span class="gd">-   Create a new thread state object belonging to the given interpreter object.</span>
<span class="gd">-   The global interpreter lock need not be held, but may be held if it is</span>
<span class="gd">-   necessary to serialize calls to this function.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyThreadState_Clear(PyThreadState *tstate)</span>
<span class="gd">-</span>
<span class="gd">-   Reset all information in a thread state object.  The global interpreter lock</span>
<span class="gd">-   must be held.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: void PyThreadState_Delete(PyThreadState *tstate)</span>
<span class="gd">-</span>
<span class="gd">-   Destroy a thread state object.  The global interpreter lock need not be held.</span>
<span class="gd">-   The thread state must have been reset with a previous call to</span>
<span class="gd">-   :cfunc:`PyThreadState_Clear`.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: PyThreadState* PyThreadState_Get()</span>
<span class="gd">-</span>
<span class="gd">-   Return the current thread state.  The global interpreter lock must be held.</span>
<span class="gd">-   When the current thread state is *NULL*, this issues a fatal error (so that</span>
<span class="gd">-   the caller needn&#39;t check for *NULL*).</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: PyThreadState* PyThreadState_Swap(PyThreadState *tstate)</span>
<span class="gd">-</span>
<span class="gd">-   Swap the current thread state with the thread state given by the argument</span>
<span class="gd">-   *tstate*, which may be *NULL*.  The global interpreter lock must be held.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: PyObject* PyThreadState_GetDict()</span>
<span class="gd">-</span>
<span class="gd">-   Return a dictionary in which extensions can store thread-specific state</span>
<span class="gd">-   information.  Each extension should use a unique key to use to store state in</span>
<span class="gd">-   the dictionary.  It is okay to call this function when no current thread state</span>
<span class="gd">-   is available. If this function returns *NULL*, no exception has been raised and</span>
<span class="gd">-   the caller should assume no current thread state is available.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionchanged:: 2.3</span>
<span class="gd">-      Previously this could only be called when a current thread is active, and *NULL*</span>
<span class="gd">-      meant that an exception was raised.</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-.. cfunction:: int PyThreadState_SetAsyncExc(long id, PyObject *exc)</span>
<span class="gd">-</span>
<span class="gd">-   Asynchronously raise an exception in a thread. The *id* argument is the thread</span>
<span class="gd">-   id of the target thread; *exc* is the exception object to be raised. This</span>
<span class="gd">-   function does not steal any references to *exc*. To prevent naive misuse, you</span>
<span class="gd">-   must write your own C extension to call this.  Must be called with the GIL held.</span>
<span class="gd">-   Returns the number of thread states modified; this is normally one, but will be</span>
<span class="gd">-   zero if the thread id isn&#39;t found.  If *exc* is :const:`NULL`, the pending</span>
<span class="gd">-   exception (if any) for the thread is cleared. This raises no exceptions.</span>
<span class="gd">-</span>
<span class="gd">-   .. versionadded:: 2.3</span>
<span class="gd">-</span>
<span class="gi">+The following functions use thread-local storage, and are not compatible</span>
<span class="gi">+with sub-interpreters:</span>
 
 .. cfunction:: PyGILState_STATE PyGILState_Ensure()
 
    Ensure that the current thread is ready to call the Python C API regardless
    of the current state of Python, or of the global interpreter lock. This may
    be called as many times as desired by a thread as long as each call is
    matched with a call to :cfunc:`PyGILState_Release`. In general, other
    thread-related APIs may be used between :cfunc:`PyGILState_Ensure` and
    :cfunc:`PyGILState_Release` calls as long as the thread state is restored to
    its previous state before the Release().  For example, normal usage of the
    :cmacro:`Py_BEGIN_ALLOW_THREADS` and :cmacro:`Py_END_ALLOW_THREADS` macros is
    acceptable.
 
    The return value is an opaque &quot;handle&quot; to the thread state when
    :cfunc:`PyGILState_Ensure` was called, and must be passed to
    :cfunc:`PyGILState_Release` to ensure Python is left in the same state. Even
    though recursive calls are allowed, these handles *cannot* be shared - each
    unique call to :cfunc:`PyGILState_Ensure` must save the handle for its call
    to :cfunc:`PyGILState_Release`.
 
<span class="gd">-   When the function returns, the current thread will hold the GIL. Failure is a</span>
<span class="gd">-   fatal error.</span>
<span class="gi">+   When the function returns, the current thread will hold the GIL and be able</span>
<span class="gi">+   to call arbitrary Python code.  Failure is a fatal error.</span>
 
    .. versionadded:: 2.3
 
 
 .. cfunction:: void PyGILState_Release(PyGILState_STATE)
 
    Release any resources previously acquired.  After this call, Python&#39;s state will
    be the same as it was prior to the corresponding :cfunc:`PyGILState_Ensure` call
    (but generally this state will be unknown to the caller, hence the use of the
<span class="gd">-   GILState API.)</span>
<span class="gi">+   GILState API).</span>
 
    Every call to :cfunc:`PyGILState_Ensure` must be matched by a call to
    :cfunc:`PyGILState_Release` on the same thread.
 
    .. versionadded:: 2.3
 
 
<span class="gi">+The following macros are normally used without a trailing semicolon; look for</span>
<span class="gi">+example usage in the Python source distribution.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cmacro:: Py_BEGIN_ALLOW_THREADS</span>
<span class="gi">+</span>
<span class="gi">+   This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();``.</span>
<span class="gi">+   Note that it contains an opening brace; it must be matched with a following</span>
<span class="gi">+   :cmacro:`Py_END_ALLOW_THREADS` macro.  See above for further discussion of this</span>
<span class="gi">+   macro.  It is a no-op when thread support is disabled at compile time.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cmacro:: Py_END_ALLOW_THREADS</span>
<span class="gi">+</span>
<span class="gi">+   This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it contains</span>
<span class="gi">+   a closing brace; it must be matched with an earlier</span>
<span class="gi">+   :cmacro:`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of</span>
<span class="gi">+   this macro.  It is a no-op when thread support is disabled at compile time.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cmacro:: Py_BLOCK_THREADS</span>
<span class="gi">+</span>
<span class="gi">+   This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to</span>
<span class="gi">+   :cmacro:`Py_END_ALLOW_THREADS` without the closing brace.  It is a no-op when</span>
<span class="gi">+   thread support is disabled at compile time.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cmacro:: Py_UNBLOCK_THREADS</span>
<span class="gi">+</span>
<span class="gi">+   This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to</span>
<span class="gi">+   :cmacro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable</span>
<span class="gi">+   declaration.  It is a no-op when thread support is disabled at compile time.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Low-level API</span>
<span class="gi">+-------------</span>
<span class="gi">+</span>
<span class="gi">+All of the following functions are only available when thread support is enabled</span>
<span class="gi">+at compile time, and must be called only when the global interpreter lock has</span>
<span class="gi">+been created.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: PyInterpreterState* PyInterpreterState_New()</span>
<span class="gi">+</span>
<span class="gi">+   Create a new interpreter state object.  The global interpreter lock need not</span>
<span class="gi">+   be held, but may be held if it is necessary to serialize calls to this</span>
<span class="gi">+   function.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyInterpreterState_Clear(PyInterpreterState *interp)</span>
<span class="gi">+</span>
<span class="gi">+   Reset all information in an interpreter state object.  The global interpreter</span>
<span class="gi">+   lock must be held.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyInterpreterState_Delete(PyInterpreterState *interp)</span>
<span class="gi">+</span>
<span class="gi">+   Destroy an interpreter state object.  The global interpreter lock need not be</span>
<span class="gi">+   held.  The interpreter state must have been reset with a previous call to</span>
<span class="gi">+   :cfunc:`PyInterpreterState_Clear`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: PyThreadState* PyThreadState_New(PyInterpreterState *interp)</span>
<span class="gi">+</span>
<span class="gi">+   Create a new thread state object belonging to the given interpreter object.</span>
<span class="gi">+   The global interpreter lock need not be held, but may be held if it is</span>
<span class="gi">+   necessary to serialize calls to this function.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyThreadState_Clear(PyThreadState *tstate)</span>
<span class="gi">+</span>
<span class="gi">+   Reset all information in a thread state object.  The global interpreter lock</span>
<span class="gi">+   must be held.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyThreadState_Delete(PyThreadState *tstate)</span>
<span class="gi">+</span>
<span class="gi">+   Destroy a thread state object.  The global interpreter lock need not be held.</span>
<span class="gi">+   The thread state must have been reset with a previous call to</span>
<span class="gi">+   :cfunc:`PyThreadState_Clear`.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: PyObject* PyThreadState_GetDict()</span>
<span class="gi">+</span>
<span class="gi">+   Return a dictionary in which extensions can store thread-specific state</span>
<span class="gi">+   information.  Each extension should use a unique key to use to store state in</span>
<span class="gi">+   the dictionary.  It is okay to call this function when no current thread state</span>
<span class="gi">+   is available. If this function returns *NULL*, no exception has been raised and</span>
<span class="gi">+   the caller should assume no current thread state is available.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionchanged:: 2.3</span>
<span class="gi">+      Previously this could only be called when a current thread is active, and *NULL*</span>
<span class="gi">+      meant that an exception was raised.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: int PyThreadState_SetAsyncExc(long id, PyObject *exc)</span>
<span class="gi">+</span>
<span class="gi">+   Asynchronously raise an exception in a thread. The *id* argument is the thread</span>
<span class="gi">+   id of the target thread; *exc* is the exception object to be raised. This</span>
<span class="gi">+   function does not steal any references to *exc*. To prevent naive misuse, you</span>
<span class="gi">+   must write your own C extension to call this.  Must be called with the GIL held.</span>
<span class="gi">+   Returns the number of thread states modified; this is normally one, but will be</span>
<span class="gi">+   zero if the thread id isn&#39;t found.  If *exc* is :const:`NULL`, the pending</span>
<span class="gi">+   exception (if any) for the thread is cleared. This raises no exceptions.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.3</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyEval_AcquireThread(PyThreadState *tstate)</span>
<span class="gi">+</span>
<span class="gi">+   Acquire the global interpreter lock and set the current thread state to</span>
<span class="gi">+   *tstate*, which should not be *NULL*.  The lock must have been created earlier.</span>
<span class="gi">+   If this thread already has the lock, deadlock ensues.</span>
<span class="gi">+</span>
<span class="gi">+   :cfunc:`PyEval_RestoreThread` is a higher-level function which is always</span>
<span class="gi">+   available (even when thread support isn&#39;t enabled or when threads have</span>
<span class="gi">+   not been initialized).</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyEval_ReleaseThread(PyThreadState *tstate)</span>
<span class="gi">+</span>
<span class="gi">+   Reset the current thread state to *NULL* and release the global interpreter</span>
<span class="gi">+   lock.  The lock must have been created earlier and must be held by the current</span>
<span class="gi">+   thread.  The *tstate* argument, which must not be *NULL*, is only used to check</span>
<span class="gi">+   that it represents the current thread state --- if it isn&#39;t, a fatal error is</span>
<span class="gi">+   reported.</span>
<span class="gi">+</span>
<span class="gi">+   :cfunc:`PyEval_SaveThread` is a higher-level function which is always</span>
<span class="gi">+   available (even when thread support isn&#39;t enabled or when threads have</span>
<span class="gi">+   not been initialized).</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyEval_AcquireLock()</span>
<span class="gi">+</span>
<span class="gi">+   Acquire the global interpreter lock.  The lock must have been created earlier.</span>
<span class="gi">+   If this thread already has the lock, a deadlock ensues.</span>
<span class="gi">+</span>
<span class="gi">+   .. warning::</span>
<span class="gi">+      This function does not change the current thread state.  Please use</span>
<span class="gi">+      :cfunc:`PyEval_RestoreThread` or :cfunc:`PyEval_AcquireThread`</span>
<span class="gi">+      instead.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void PyEval_ReleaseLock()</span>
<span class="gi">+</span>
<span class="gi">+   Release the global interpreter lock.  The lock must have been created earlier.</span>
<span class="gi">+</span>
<span class="gi">+   .. warning::</span>
<span class="gi">+      This function does not change the current thread state.  Please use</span>
<span class="gi">+      :cfunc:`PyEval_SaveThread` or :cfunc:`PyEval_ReleaseThread`</span>
<span class="gi">+      instead.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Sub-interpreter support</span>
<span class="gi">+=======================</span>
<span class="gi">+</span>
<span class="gi">+While in most uses, you will only embed a single Python interpreter, there</span>
<span class="gi">+are cases where you need to create several independent interpreters in the</span>
<span class="gi">+same process and perhaps even in the same thread.  Sub-interpreters allow</span>
<span class="gi">+you to do that.  You can switch between sub-interpreters using the</span>
<span class="gi">+:cfunc:`PyThreadState_Swap` function.  You can create and destroy them</span>
<span class="gi">+using the following functions:</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: PyThreadState* Py_NewInterpreter()</span>
<span class="gi">+</span>
<span class="gi">+   .. index::</span>
<span class="gi">+      module: builtins</span>
<span class="gi">+      module: __main__</span>
<span class="gi">+      module: sys</span>
<span class="gi">+      single: stdout (in module sys)</span>
<span class="gi">+      single: stderr (in module sys)</span>
<span class="gi">+      single: stdin (in module sys)</span>
<span class="gi">+</span>
<span class="gi">+   Create a new sub-interpreter.  This is an (almost) totally separate environment</span>
<span class="gi">+   for the execution of Python code.  In particular, the new interpreter has</span>
<span class="gi">+   separate, independent versions of all imported modules, including the</span>
<span class="gi">+   fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`.  The</span>
<span class="gi">+   table of loaded modules (``sys.modules``) and the module search path</span>
<span class="gi">+   (``sys.path``) are also separate.  The new environment has no ``sys.argv``</span>
<span class="gi">+   variable.  It has new standard I/O stream file objects ``sys.stdin``,</span>
<span class="gi">+   ``sys.stdout`` and ``sys.stderr`` (however these refer to the same underlying</span>
<span class="gi">+   file descriptors).</span>
<span class="gi">+</span>
<span class="gi">+   The return value points to the first thread state created in the new</span>
<span class="gi">+   sub-interpreter.  This thread state is made in the current thread state.</span>
<span class="gi">+   Note that no actual thread is created; see the discussion of thread states</span>
<span class="gi">+   below.  If creation of the new interpreter is unsuccessful, *NULL* is</span>
<span class="gi">+   returned; no exception is set since the exception state is stored in the</span>
<span class="gi">+   current thread state and there may not be a current thread state.  (Like all</span>
<span class="gi">+   other Python/C API functions, the global interpreter lock must be held before</span>
<span class="gi">+   calling this function and is still held when it returns; however, unlike most</span>
<span class="gi">+   other Python/C API functions, there needn&#39;t be a current thread state on</span>
<span class="gi">+   entry.)</span>
<span class="gi">+</span>
<span class="gi">+   .. index::</span>
<span class="gi">+      single: Py_Finalize()</span>
<span class="gi">+      single: Py_Initialize()</span>
<span class="gi">+</span>
<span class="gi">+   Extension modules are shared between (sub-)interpreters as follows: the first</span>
<span class="gi">+   time a particular extension is imported, it is initialized normally, and a</span>
<span class="gi">+   (shallow) copy of its module&#39;s dictionary is squirreled away.  When the same</span>
<span class="gi">+   extension is imported by another (sub-)interpreter, a new module is initialized</span>
<span class="gi">+   and filled with the contents of this copy; the extension&#39;s ``init`` function is</span>
<span class="gi">+   not called.  Note that this is different from what happens when an extension is</span>
<span class="gi">+   imported after the interpreter has been completely re-initialized by calling</span>
<span class="gi">+   :cfunc:`Py_Finalize` and :cfunc:`Py_Initialize`; in that case, the extension&#39;s</span>
<span class="gi">+   ``initmodule`` function *is* called again.</span>
<span class="gi">+</span>
<span class="gi">+   .. index:: single: close() (in module os)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: void Py_EndInterpreter(PyThreadState *tstate)</span>
<span class="gi">+</span>
<span class="gi">+   .. index:: single: Py_Finalize()</span>
<span class="gi">+</span>
<span class="gi">+   Destroy the (sub-)interpreter represented by the given thread state. The given</span>
<span class="gi">+   thread state must be the current thread state.  See the discussion of thread</span>
<span class="gi">+   states below.  When the call returns, the current thread state is *NULL*.  All</span>
<span class="gi">+   thread states associated with this interpreter are destroyed.  (The global</span>
<span class="gi">+   interpreter lock must be held before calling this function and is still held</span>
<span class="gi">+   when it returns.)  :cfunc:`Py_Finalize` will destroy all sub-interpreters that</span>
<span class="gi">+   haven&#39;t been explicitly destroyed at that point.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Bugs and caveats</span>
<span class="gi">+----------------</span>
<span class="gi">+</span>
<span class="gi">+Because sub-interpreters (and the main interpreter) are part of the same</span>
<span class="gi">+process, the insulation between them isn&#39;t perfect --- for example, using</span>
<span class="gi">+low-level file operations like  :func:`os.close` they can</span>
<span class="gi">+(accidentally or maliciously) affect each other&#39;s open files.  Because of the</span>
<span class="gi">+way extensions are shared between (sub-)interpreters, some extensions may not</span>
<span class="gi">+work properly; this is especially likely when the extension makes use of</span>
<span class="gi">+(static) global variables, or when the extension manipulates its module&#39;s</span>
<span class="gi">+dictionary after its initialization.  It is possible to insert objects created</span>
<span class="gi">+in one sub-interpreter into a namespace of another sub-interpreter; this should</span>
<span class="gi">+be done with great care to avoid sharing user-defined functions, methods,</span>
<span class="gi">+instances or classes between sub-interpreters, since import operations executed</span>
<span class="gi">+by such objects may affect the wrong (sub-)interpreter&#39;s dictionary of loaded</span>
<span class="gi">+modules.</span>
<span class="gi">+</span>
<span class="gi">+Also note that combining this functionality with :cfunc:`PyGILState_\*` APIs</span>
<span class="gi">+is delicate, because these APIs assume a bijection between Python thread states</span>
<span class="gi">+and OS-level threads, an assumption broken by the presence of sub-interpreters.</span>
<span class="gi">+It is highly recommended that you don&#39;t switch sub-interpreters between a pair</span>
<span class="gi">+of matching :cfunc:`PyGILState_Ensure` and :cfunc:`PyGILState_Release` calls.</span>
<span class="gi">+Furthermore, extensions (such as :mod:`ctypes`) using these APIs to allow calling</span>
<span class="gi">+of Python code from non-Python created threads will probably be broken when using</span>
<span class="gi">+sub-interpreters.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Asynchronous Notifications</span>
<span class="gi">+==========================</span>
<span class="gi">+</span>
<span class="gi">+A mechanism is provided to make asynchronous notifications to the main</span>
<span class="gi">+interpreter thread.  These notifications take the form of a function</span>
<span class="gi">+pointer and a void argument.</span>
<span class="gi">+</span>
<span class="gi">+.. index:: single: setcheckinterval() (in module sys)</span>
<span class="gi">+</span>
<span class="gi">+Every check interval, when the global interpreter lock is released and</span>
<span class="gi">+reacquired, Python will also call any such provided functions.  This can be used</span>
<span class="gi">+for example by asynchronous IO handlers.  The notification can be scheduled from</span>
<span class="gi">+a worker thread and the actual call than made at the earliest convenience by the</span>
<span class="gi">+main thread where it has possession of the global interpreter lock and can</span>
<span class="gi">+perform any Python API calls.</span>
<span class="gi">+</span>
<span class="gi">+.. cfunction:: int Py_AddPendingCall(int (*func)(void *), void *arg)</span>
<span class="gi">+</span>
<span class="gi">+   .. index:: single: Py_AddPendingCall()</span>
<span class="gi">+</span>
<span class="gi">+   Post a notification to the Python main thread.  If successful, *func* will be</span>
<span class="gi">+   called with the argument *arg* at the earliest convenience.  *func* will be</span>
<span class="gi">+   called having the global interpreter lock held and can thus use the full</span>
<span class="gi">+   Python API and can take any action such as setting object attributes to</span>
<span class="gi">+   signal IO completion.  It must return 0 on success, or -1 signalling an</span>
<span class="gi">+   exception.  The notification function won&#39;t be interrupted to perform another</span>
<span class="gi">+   asynchronous notification recursively, but it can still be interrupted to</span>
<span class="gi">+   switch threads if the global interpreter lock is released, for example, if it</span>
<span class="gi">+   calls back into Python code.</span>
<span class="gi">+</span>
<span class="gi">+   This function returns 0 on success in which case the notification has been</span>
<span class="gi">+   scheduled.  Otherwise, for example if the notification buffer is full, it</span>
<span class="gi">+   returns -1 without setting any exception.</span>
<span class="gi">+</span>
<span class="gi">+   This function can be called on any thread, be it a Python thread or some</span>
<span class="gi">+   other system thread.  If it is a Python thread, it doesn&#39;t matter if it holds</span>
<span class="gi">+   the global interpreter lock or not.</span>
<span class="gi">+</span>
<span class="gi">+   .. versionadded:: 2.7</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+</span>
 .. _profiling:
 
 Profiling and Tracing
 =====================
 
 .. sectionauthor:: Fred L. Drake, Jr. &lt;fdrake@acm.org&gt;
 
 
 The Python interpreter provides some low-level support for attaching profiling
 and execution tracing facilities.  These are used for profiling, debugging, and
 coverage analysis tools.
 
<span class="gu">@@ -872,31 +965,32 @@</span>
    :const:`PyTrace_C_RETURN`, and *arg* depends on the value of *what*:
 
    +------------------------------+--------------------------------------+
    | Value of *what*              | Meaning of *arg*                     |
    +==============================+======================================+
    | :const:`PyTrace_CALL`        | Always *NULL*.                       |
    +------------------------------+--------------------------------------+
    | :const:`PyTrace_EXCEPTION`   | Exception information as returned by |
    |                              | :func:`sys.exc_info`.                |
    +------------------------------+--------------------------------------+
    | :const:`PyTrace_LINE`        | Always *NULL*.                       |
    +------------------------------+--------------------------------------+
<span class="gd">-   | :const:`PyTrace_RETURN`      | Value being returned to the caller.  |</span>
<span class="gi">+   | :const:`PyTrace_RETURN`      | Value being returned to the caller,  |</span>
<span class="gi">+   |                              | or *NULL* if caused by an exception. |</span>
    +------------------------------+--------------------------------------+
<span class="gd">-   | :const:`PyTrace_C_CALL`      | Name of function being called.       |</span>
<span class="gi">+   | :const:`PyTrace_C_CALL`      | Function object being called.        |</span>
    +------------------------------+--------------------------------------+
<span class="gd">-   | :const:`PyTrace_C_EXCEPTION` | Always *NULL*.                       |</span>
<span class="gi">+   | :const:`PyTrace_C_EXCEPTION` | Function object being called.        |</span>
    +------------------------------+--------------------------------------+
<span class="gd">-   | :const:`PyTrace_C_RETURN`    | Always *NULL*.                       |</span>
<span class="gi">+   | :const:`PyTrace_C_RETURN`    | Function object being called.        |</span>
    +------------------------------+--------------------------------------+
 
 
 .. cvar:: int PyTrace_CALL
 
    The value of the *what* parameter to a :ctype:`Py_tracefunc` function when a new
    call to a function or method is being reported, or a new entry into a generator.
    Note that the creation of the iterator for a generator function is not reported
    as there is no control transfer to the Python bytecode in the corresponding
    frame.
 
 
<span class="gu">@@ -923,25 +1017,25 @@</span>
    call is returning without propagating an exception.
 
 
 .. cvar:: int PyTrace_C_CALL
 
    The value for the *what* parameter to :ctype:`Py_tracefunc` functions when a C
    function is about to be called.
 
 
 .. cvar:: int PyTrace_C_EXCEPTION
 
    The value for the *what* parameter to :ctype:`Py_tracefunc` functions when a C
<span class="gd">-   function has thrown an exception.</span>
<span class="gi">+   function has raised an exception.</span>
 
 
 .. cvar:: int PyTrace_C_RETURN
 
    The value for the *what* parameter to :ctype:`Py_tracefunc` functions when a C
    function has returned.
 
 
 .. cfunction:: void PyEval_SetProfile(Py_tracefunc func, PyObject *obj)
 
    Set the profiler function to *func*.  The *obj* parameter is passed to the
    function as its first parameter, and may be any Python object, or *NULL*.  If
</pre></div>

</body>
</html>
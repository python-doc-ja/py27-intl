--- r262/extending/extending.rst	2009-04-06 06:11:43.798160000 +0900
+++ r266/extending/extending.rst	2010-08-03 06:45:43.685855000 +0900
@@ -11,24 +11,31 @@
 program in C.  Such :dfn:`extension modules` can do two things that can't be
 done directly in Python: they can implement new built-in object types, and they
 can call C library functions and system calls.
 
 To support extensions, the Python API (Application Programmers Interface)
 defines a set of functions, macros and variables that provide access to most
 aspects of the Python run-time system.  The Python API is incorporated in a C
 source file by including the header ``"Python.h"``.
 
 The compilation of an extension module depends on its intended use as well as on
 your system setup; details are given in later chapters.
 
+Do note that if your use case is calling C library functions or system calls,
+you should consider using the :mod:`ctypes` module rather than writing custom
+C code. Not only does :mod:`ctypes` let you write Python code to interface
+with C code, but it is more portable between implementations of Python than
+writing and compiling an extension module which typically ties you to CPython.
+
+
 
 .. _extending-simpleexample:
 
 A Simple Example
 ================
 
 Let's create an extension module called ``spam`` (the favorite food of Monty
 Python fans...) and let's say we want to create a Python interface to the C
 library function :cfunc:`system`. [#]_ This function takes a null-terminated
 character string as argument and returns an integer.  We want this function to
 be callable from Python as follows::
 
@@ -38,25 +45,25 @@
 Begin by creating a file :file:`spammodule.c`.  (Historically, if a module is
 called ``spam``, the C file containing its implementation is called
 :file:`spammodule.c`; if the module name is very long, like ``spammify``, the
 module name can be just :file:`spammify.c`.)
 
 The first line of our file can be::
 
    #include <Python.h>
 
 which pulls in the Python API (you can add a comment describing the purpose of
 the module and a copyright notice if you like).
 
-.. warning::
+.. note::
 
    Since Python may define some pre-processor definitions which affect the standard
    headers on some systems, you *must* include :file:`Python.h` before any standard
    headers are included.
 
 All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py`` or
 ``PY``, except those defined in standard header files. For convenience, and
 since they are used extensively by the Python interpreter, ``"Python.h"``
 includes a few standard header files: ``<stdio.h>``, ``<string.h>``,
 ``<errno.h>``, and ``<stdlib.h>``.  If the latter header file does not exist on
 your system, it declares the functions :cfunc:`malloc`, :cfunc:`free` and
 :cfunc:`realloc` directly.
@@ -212,27 +219,46 @@
 Note that the Python name for the exception object is :exc:`spam.error`.  The
 :cfunc:`PyErr_NewException` function may create a class with the base class
 being :exc:`Exception` (unless another class is passed in instead of *NULL*),
 described in :ref:`bltin-exceptions`.
 
 Note also that the :cdata:`SpamError` variable retains a reference to the newly
 created exception class; this is intentional!  Since the exception could be
 removed from the module by external code, an owned reference to the class is
 needed to ensure that it will not be discarded, causing :cdata:`SpamError` to
 become a dangling pointer. Should it become a dangling pointer, C code which
 raises the exception could cause a core dump or other unintended side effects.
 
-We discuss the use of PyMODINIT_FUNC as a function return type later in this
+We discuss the use of ``PyMODINIT_FUNC`` as a function return type later in this
 sample.
 
+The :exc:`spam.error` exception can be raised in your extension module using a
+call to :cfunc:`PyErr_SetString` as shown below::
+
+   static PyObject *
+   spam_system(PyObject *self, PyObject *args)
+   {
+       const char *command;
+       int sts;
+
+       if (!PyArg_ParseTuple(args, "s", &command))
+           return NULL;
+       sts = system(command);
+       if (sts < 0) {
+           PyErr_SetString(SpamError, "System command failed");
+           return NULL;
+       }
+       return PyLong_FromLong(sts);
+   }
+
 
 .. _backtoexample:
 
 Back to the Example
 ===================
 
 Going back to our example function, you should now be able to understand this
 statement::
 
    if (!PyArg_ParseTuple(args, "s", &command))
        return NULL;
 
@@ -1210,34 +1236,41 @@
    #else
    /* This section is used in modules that use spammodule's API */
 
    static void **PySpam_API;
 
    #define PySpam_System \
     (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])
 
    /* Return -1 and set exception on error, 0 on success. */
    static int
    import_spam(void)
    {
-       PyObject *module = PyImport_ImportModule("spam");
+       PyObject *c_api_object;
+       PyObject *module;
 
-       if (module != NULL) {
-           PyObject *c_api_object = PyObject_GetAttrString(module, "_C_API");
-           if (c_api_object == NULL)
-               return -1;
-           if (PyCObject_Check(c_api_object))
-               PySpam_API = (void **)PyCObject_AsVoidPtr(c_api_object);
-           Py_DECREF(c_api_object);
+       module = PyImport_ImportModule("spam");
+       if (module == NULL)
+           return -1;
+
+       c_api_object = PyObject_GetAttrString(module, "_C_API");
+       if (c_api_object == NULL) {
+           Py_DECREF(module);
+           return -1;
        }
+       if (PyCObject_Check(c_api_object))
+           PySpam_API = (void **)PyCObject_AsVoidPtr(c_api_object);
+
+       Py_DECREF(c_api_object);
+       Py_DECREF(module);
        return 0;
    }
 
    #endif
 
    #ifdef __cplusplus
    }
    #endif
 
    #endif /* !defined(Py_SPAMMODULE_H) */
 
 All that a client module must do in order to have access to the function

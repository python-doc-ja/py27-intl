--- rest25/tutorial/floatingpoint.rst	2008-10-21 04:57:14.392617154 +0900
+++ rest26/tutorial/floatingpoint.rst	2008-10-21 05:03:04.694844417 +0900
@@ -123,27 +123,26 @@
 for a more complete account of other common surprises.
 
 As that says near the end, "there are no easy answers."  Still, don't be unduly
 wary of floating-point!  The errors in Python float operations are inherited
 from the floating-point hardware, and on most machines are on the order of no
 more than 1 part in 2\*\*53 per operation.  That's more than adequate for most
 tasks, but you do need to keep in mind that it's not decimal arithmetic, and
 that every float operation can suffer a new rounding error.
 
 While pathological cases do exist, for most casual use of floating-point
 arithmetic you'll see the result you expect in the end if you simply round the
 display of your final results to the number of decimal digits you expect.
-:func:`str` usually suffices, and for finer control see the discussion of
-Python's ``%`` format operator: the ``%g``, ``%f`` and ``%e`` format codes
-supply flexible and easy ways to round float results for display.
+:func:`str` usually suffices, and for finer control see the :meth:`str.format`
+method's format specifiers in :ref:`formatstrings`.
 
 
 .. _tut-fp-error:
 
 Representation Error
 ====================
 
 This section explains the "0.1" example in detail, and shows how you can perform
 an exact analysis of cases like this yourself.  Basic familiarity with binary
 floating-point representation is assumed.
 
 :dfn:`Representation error` refers to the fact that some (most, actually)

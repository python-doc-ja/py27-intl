--- rest25/library/pdb.rst	2008-10-21 04:57:02.435072404 +0900
+++ rest26/library/pdb.rst	2008-10-21 05:03:04.821175592 +0900
@@ -1,18 +1,17 @@
 
 .. _debugger:
 
-*******************
-The Python Debugger
-*******************
+:mod:`pdb` --- The Python Debugger
+==================================
 
 .. module:: pdb
    :synopsis: The Python debugger for interactive interpreters.
 
 
 .. index:: single: debugging
 
 The module :mod:`pdb` defines an interactive source code debugger for Python
 programs.  It supports setting (conditional) breakpoints and single stepping at
 the source line level, inspection of stack frames, source code listing, and
 evaluation of arbitrary Python code in the context of any stack frame.  It also
 supports post-mortem debugging and can be called under program control.
@@ -99,27 +98,30 @@
    Call the *function* (a function or method object, not a string) with the given
    arguments.  When :func:`runcall` returns, it returns whatever the function call
    returned.  The debugger prompt appears as soon as the function is entered.
 
 
 .. function:: set_trace()
 
    Enter the debugger at the calling stack frame.  This is useful to hard-code a
    breakpoint at a given point in a program, even if the code is not otherwise
    being debugged (e.g. when an assertion fails).
 
 
-.. function:: post_mortem(traceback)
+.. function:: post_mortem([traceback])
 
-   Enter post-mortem debugging of the given *traceback* object.
+   Enter post-mortem debugging of the given *traceback* object.  If no 
+   *traceback* is given, it uses the one of the exception that is currently
+   being handled (an exception must be being handled if the default is to be
+   used).
 
 
 .. function:: pm()
 
    Enter post-mortem debugging of the traceback found in ``sys.last_traceback``.
 
 
 .. _debugger-commands:
 
 Debugger Commands
 =================
 
@@ -170,40 +172,40 @@
    command.
 
 w(here)
    Print a stack trace, with the most recent frame at the bottom.  An arrow
    indicates the current frame, which determines the context of most commands.
 
 d(own)
    Move the current frame one level down in the stack trace (to a newer frame).
 
 u(p)
    Move the current frame one level up in the stack trace (to an older frame).
 
-b(reak) [[*filename*:]*lineno*``|``*function*[, *condition*]]
+b(reak) [[*filename*:]\ *lineno* | *function*\ [, *condition*]]
    With a *lineno* argument, set a break there in the current file.  With a
    *function* argument, set a break at the first executable statement within that
    function. The line number may be prefixed with a filename and a colon, to
    specify a breakpoint in another file (probably one that hasn't been loaded yet).
    The file is searched on ``sys.path``. Note that each breakpoint is assigned a
    number to which all the other breakpoint commands refer.
 
    If a second argument is present, it is an expression which must evaluate to true
    before the breakpoint is honored.
 
    Without argument, list all breaks, including for each breakpoint, the number of
    times that breakpoint has been hit, the current ignore count, and the associated
    condition if any.
 
-tbreak [[*filename*:]*lineno*``|``*function*[, *condition*]]
+tbreak [[*filename*:]\ *lineno* | *function*\ [, *condition*]]
    Temporary breakpoint, which is removed automatically when it is first hit.  The
    arguments are the same as break.
 
 cl(ear) [*bpnumber* [*bpnumber ...*]]
    With a space separated list of breakpoint numbers, clear those breakpoints.
    Without argument, clear all breaks (but first ask confirmation).
 
 disable [*bpnumber* [*bpnumber ...*]]
    Disables the breakpoints given as a space separated list of breakpoint numbers.
    Disabling a breakpoint means it cannot cause the program to stop execution, but
    unlike clearing a breakpoint, it remains in the list of breakpoints and can be
    (re-)enabled.
@@ -235,61 +237,67 @@
 
    To remove all commands from a breakpoint, type commands and follow it
    immediately with  end; that is, give no commands.
 
    With no *bpnumber* argument, commands refers to the last breakpoint set.
 
    You can use breakpoint commands to start your program up again. Simply use the
    continue command, or step, or any other command that resumes execution.
 
    Specifying any command resuming execution (currently continue, step, next,
    return, jump, quit and their abbreviations) terminates the command list (as if
    that command was immediately followed by end). This is because any time you
-   resume execution (even with a simple next or step), you may encounterÂ· another
+   resume execution (even with a simple next or step), you may encounter another
    breakpoint--which could have its own command list, leading to ambiguities about
    which list to execute.
 
    If you use the 'silent' command in the command list, the usual message about
    stopping at a breakpoint is not printed.  This may be desirable for breakpoints
    that are to print a specific message and then continue.  If none of the other
    commands print anything, you see no sign that the breakpoint was reached.
 
    .. versionadded:: 2.5
 
 s(tep)
    Execute the current line, stop at the first possible occasion (either in a
    function that is called or on the next line in the current function).
 
 n(ext)
    Continue execution until the next line in the current function is reached or it
    returns.  (The difference between ``next`` and ``step`` is that ``step`` stops
    inside a called function, while ``next`` executes called functions at (nearly)
    full speed, only stopping at the next line in the current function.)
 
+unt(il)
+   Continue execution until the line with the the line number greater than the
+   current one is reached or when returning from current frame.
+
+   .. versionadded:: 2.6
+
 r(eturn)
    Continue execution until the current function returns.
 
 c(ont(inue))
    Continue execution, only stop when a breakpoint is encountered.
 
 j(ump) *lineno*
    Set the next line that will be executed.  Only available in the bottom-most
    frame.  This lets you jump back and execute code again, or jump forward to skip
    code that you don't want to run.
 
    It should be noted that not all jumps are allowed --- for instance it is not
    possible to jump into the middle of a :keyword:`for` loop or out of a
    :keyword:`finally` clause.
 
-l(ist) [*first*[, *last*]]
+l(ist) [*first*\ [, *last*]]
    List source code for the current file.  Without arguments, list 11 lines around
    the current line or continue the previous listing.  With one argument, list 11
    lines around at that line.  With two arguments, list the given range; if the
    second argument is less than the first, it is interpreted as a count.
 
 a(rgs)
    Print the argument list of the current function.
 
 p *expression*
    Evaluate the *expression* in the current context and print its value.
 
    .. note::
@@ -316,33 +324,40 @@
 
    As an example, here are two useful aliases (especially when placed in the
    :file:`.pdbrc` file)::
 
       #Print instance variables (usage "pi classInst")
       alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
       #Print instance variables in self
       alias ps pi self
 
 unalias *name*
    Deletes the specified alias.
 
-[!]*statement*
+[!]\ *statement*
    Execute the (one-line) *statement* in the context of the current stack frame.
    The exclamation point can be omitted unless the first word of the statement
    resembles a debugger command. To set a global variable, you can prefix the
    assignment command with a ``global`` command on the same line, e.g.::
 
       (Pdb) global list_options; list_options = ['-l']
       (Pdb)
 
+run [*args* ...]
+   Restart the debugged python program. If an argument is supplied, it is split
+   with "shlex" and the result is used as the new sys.argv. History, breakpoints,
+   actions and debugger options are preserved. "restart" is an alias for "run".
+
+   .. versionadded:: 2.6
+
 q(uit)
    Quit from the debugger. The program being executed is aborted.
 
 
 .. _debugger-hooks:
 
 How It Works
 ============
 
 Some changes were made to the interpreter:
 
 * ``sys.settrace(func)`` sets the global trace function
@@ -390,15 +405,14 @@
    A C function is about to be called.  This may be an extension function or a
    builtin.  *arg* is the C function object.
 
 ``'c_return'``
    A C function has returned. *arg* is ``None``.
 
 ``'c_exception'``
    A C function has thrown an exception.  *arg* is ``None``.
 
 Note that as an exception is propagated down the chain of callers, an
 ``'exception'`` event is generated at each level.
 
-For more information on code and frame objects, refer to the Python Reference
-Manual (XXX reference: ../ref/ref.html).
+For more information on code and frame objects, refer to :ref:`types`.
 
